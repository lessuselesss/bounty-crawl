{
  "result": {
    "data": {
      "json": {
        "items": [
          {
            "id": "PX4#21902",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "PX4",
              "id": "generated-PX4",
              "name": "PX4",
              "description": "",
              "members": [],
              "display_name": "PX4",
              "created_at": "2026-01-24T11:30:38.196Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/PX4?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "PX4",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-24T11:30:38.196Z",
            "created_at": "2026-01-24T11:30:38.196Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-PX4#21902",
              "status": "open",
              "type": "issue",
              "number": 21902,
              "title": "Support EKF2_GPS_POS_* for Multiple GPS",
              "source": {
                "data": {
                  "id": "source-PX4#21902",
                  "user": {
                    "login": "AlexKlimaj",
                    "id": 2019539,
                    "node_id": "MDQ6VXNlcjIwMTk1Mzk=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/2019539?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/AlexKlimaj",
                    "html_url": "https://github.com/AlexKlimaj",
                    "followers_url": "https://api.github.com/users/AlexKlimaj/followers",
                    "following_url": "https://api.github.com/users/AlexKlimaj/following{/other_user}",
                    "gists_url": "https://api.github.com/users/AlexKlimaj/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/AlexKlimaj/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/AlexKlimaj/subscriptions",
                    "organizations_url": "https://api.github.com/users/AlexKlimaj/orgs",
                    "repos_url": "https://api.github.com/users/AlexKlimaj/repos",
                    "events_url": "https://api.github.com/users/AlexKlimaj/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/AlexKlimaj/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Support EKF2_GPS_POS_* for Multiple GPS",
                  "body": "### Describe problem solved by the proposed feature\n\nCurrently the EKF2_GPS_POS_* params only apply to vehicle_gps when it gets used in the EKF.\n\n### Describe your preferred solution\n\nI propose we move these params to an offset in the GPS driver.\n\n### Describe possible alternatives\n\nDo we need these offsets at all?\n\n### Additional context\n\n_No response_",
                  "html_url": "https://github.com/PX4/PX4-Autopilot/issues/21902"
                },
                "type": "github"
              },
              "hash": "PX4/PX4-Autopilot#21902",
              "body": "### Describe problem solved by the proposed feature\n\nCurrently the EKF2_GPS_POS_* params only apply to vehicle_gps when it gets used in the EKF.\n\n### Describe your preferred solution\n\nI propose we move these params to an offset in the GPS driver.\n\n### Describe possible alternatives\n\nDo we need these offsets at all?\n\n### Additional context\n\n_No response_",
              "url": "https://github.com/PX4/PX4-Autopilot/issues/21902",
              "tech": [],
              "repo_name": "PX4-Autopilot",
              "repo_owner": "PX4",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "PX4#19970",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "PX4",
              "id": "generated-PX4",
              "name": "PX4",
              "description": "",
              "members": [],
              "display_name": "PX4",
              "created_at": "2026-01-24T11:30:38.381Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/PX4?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "PX4",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-24T11:30:38.381Z",
            "created_at": "2026-01-24T11:30:38.381Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-PX4#19970",
              "status": "open",
              "type": "issue",
              "number": 19970,
              "title": "[Project Tracker] Sensor configuration display UI",
              "source": {
                "data": {
                  "id": "source-PX4#19970",
                  "user": {
                    "login": "junwoo091400",
                    "id": 23277211,
                    "node_id": "MDQ6VXNlcjIzMjc3MjEx",
                    "avatar_url": "https://avatars.githubusercontent.com/u/23277211?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/junwoo091400",
                    "html_url": "https://github.com/junwoo091400",
                    "followers_url": "https://api.github.com/users/junwoo091400/followers",
                    "following_url": "https://api.github.com/users/junwoo091400/following{/other_user}",
                    "gists_url": "https://api.github.com/users/junwoo091400/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/junwoo091400/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/junwoo091400/subscriptions",
                    "organizations_url": "https://api.github.com/users/junwoo091400/orgs",
                    "repos_url": "https://api.github.com/users/junwoo091400/repos",
                    "events_url": "https://api.github.com/users/junwoo091400/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/junwoo091400/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "[Project Tracker] Sensor configuration display UI",
                  "body": "## Describe problem solved by the proposed feature\r\nCurrently it is hard to figure out which sensors are connected where, with which configuration and which priority (e.g. `CAL_MAG0_PRIO`) in a single view. For example during my [boat project](https://discuss.px4.io/t/rc-speed-boat-with-px4-episode-1-using-px4-to-control-the-boat/28429#things-that-are-still-ambiguous-to-me-22) build, I wasn't sure if I needed to set the priority of magnetometer manually or not.\r\n\r\nThis is also quite related to the calibration pain addressed in the issue #19459. What can we do to improve user experience for setting up the sensors? If so, which part should be addressed and how?\r\n\r\nWhat could be great (in my opinion) could be something like this in QGC (it won't be a literal text output like this, but just for giving some idea):\r\n\r\n```\r\n<mag-type> | <mag-orientation> | <mag-priority> | <mag-protocol?> # First mag sensor\r\n<mag-type> | <mag-orientation> | <mag-priority> | <mag-protocol?> # One for the second mag\r\n<baro-type> |              | <baro-priority> | <baro-protocol>\r\n<gyro-type> | <gyro-orientation> | <gyro-priority> | <gyro-protocol>\r\n```\r\n\r\nBut I am also not sure what others expectation / needs are, so any feedback would be appreciated!\r\n\r\n## Describe your preferred solution\r\n* @davids5 pointed out that transferring device tree information over to QGC could be a solution. Could you elaborate on that?\r\n* @dagar pointed out that having a unified view in general would be good. Could you let me know if a view I suggested above is similar to what you have imagined?\r\n",
                  "html_url": "https://github.com/PX4/PX4-Autopilot/issues/19970"
                },
                "type": "github"
              },
              "hash": "PX4/PX4-Autopilot#19970",
              "body": "## Describe problem solved by the proposed feature\r\nCurrently it is hard to figure out which sensors are connected where, with which configuration and which priority (e.g. `CAL_MAG0_PRIO`) in a single view. For example during my [boat project](https://discuss.px4.io/t/rc-speed-boat-with-px4-episode-1-using-px4-to-control-the-boat/28429#things-that-are-still-ambiguous-to-me-22) build, I wasn't sure if I needed to set the priority of magnetometer manually or not.\r\n\r\nThis is also quite related to the calibration pain addressed in the issue #19459. What can we do to improve user experience for setting up the sensors? If so, which part should be addressed and how?\r\n\r\nWhat could be great (in my opinion) could be something like this in QGC (it won't be a literal text output like this, but just for giving some idea):\r\n\r\n```\r\n<mag-type> | <mag-orientation> | <mag-priority> | <mag-protocol?> # First mag sensor\r\n<mag-type> | <mag-orientation> | <mag-priority> | <mag-protocol?> # One for the second mag\r\n<baro-type> |              | <baro-priority> | <baro-protocol>\r\n<gyro-type> | <gyro-orientation> | <gyro-priority> | <gyro-protocol>\r\n```\r\n\r\nBut I am also not sure what others expectation / needs are, so any feedback would be appreciated!\r\n\r\n## Describe your preferred solution\r\n* @davids5 pointed out that transferring device tree information over to QGC could be a solution. Could you elaborate on that?\r\n* @dagar pointed out that having a unified view in general would be good. Could you let me know if a view I suggested above is similar to what you have imagined?\r\n",
              "url": "https://github.com/PX4/PX4-Autopilot/issues/19970",
              "tech": [],
              "repo_name": "PX4-Autopilot",
              "repo_owner": "PX4",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "outerbase#59",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "outerbase",
              "id": "generated-outerbase",
              "name": "Outerbase",
              "description": "",
              "members": [],
              "display_name": "Outerbase",
              "created_at": "2026-01-24T11:30:38.196Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/outerbase?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "outerbase",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-24T11:30:38.196Z",
            "created_at": "2026-01-24T11:30:38.196Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-outerbase#59",
              "status": "open",
              "type": "issue",
              "number": 59,
              "title": "Database dumps do not work on large databases",
              "source": {
                "data": {
                  "id": "source-outerbase#59",
                  "user": {
                    "login": "Brayden",
                    "id": 1066085,
                    "node_id": "MDQ6VXNlcjEwNjYwODU=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1066085?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/Brayden",
                    "html_url": "https://github.com/Brayden",
                    "followers_url": "https://api.github.com/users/Brayden/followers",
                    "following_url": "https://api.github.com/users/Brayden/following{/other_user}",
                    "gists_url": "https://api.github.com/users/Brayden/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/Brayden/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/Brayden/subscriptions",
                    "organizations_url": "https://api.github.com/users/Brayden/orgs",
                    "repos_url": "https://api.github.com/users/Brayden/repos",
                    "events_url": "https://api.github.com/users/Brayden/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/Brayden/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Database dumps do not work on large databases",
                  "body": "**Describe the bug**\nIf you try to use any of the database dump endpoints such as SQL, CSV or JSON the data is loaded into memory and then created as a dump file. To support any size database we should investigate enhancements to allow any sized database to be exported. Currently the size limitations are 1GB for Durable Objects with 10GB in the future. Operate under the assumption that we might be attempting to dump a 10GB database into a `.sql` file.\n\nAnother consideration to make is because Durable Objects execute synchronous operations we may need to allow for \"breathing intervals\". An example might be we allow our export operation to run for 5 seconds, and take 5 seconds off if other requests are in a queue, then it can pick up again. The goal here would be to prevent locking the database for long periods of time.\n\nBut then poses the questions: \n1. How do we continue operations that need more than 30 seconds to work?\n2. Where is the data stored as it's being created? (R2, S3, something else)?\n3. How do we deliver that dump information to the user after its completed?\n\n**To Reproduce**\nSteps to reproduce the behavior:\n\n1. Hit the `/export/dump` endpoint on a large database\n2. Will eventually fail when the 30 second request response time window closes\n\nRun the following command in Terminal (replace the URL with yours) and if your operation exceeds 30 seconds you should see a failed network response instead of a dump file.\n```\ncurl --location 'https://starbasedb.YOUR-ID-HERE.workers.dev/export/dump' \\\n--header 'Authorization: Bearer ABC123' \\\n--output database_dump.sql\n```\n\nIf you can't create a large enough test database feel free to add code in to `sleep` for 29 seconds before proceeding with the `/export/dump` functional code and should also see the failure.\n\n**Expected behavior**\nAs a user I would expect any and all of the specified data to be dumped out without an error and without partial results. Where it ends up for the user to access if the operation takes more than 30 seconds is up for discussion. Ideally if shorter than 30 seconds it could be returned as our cURL above works today (downloads the file from the response of the origin request), but perhaps after the timeout it continues on uploads it to a destination source to access afterwards?\n\n**Proposed Solution:**\n1. For backups require an R2 binding\n2. Have a `.sql` file that gets created in R2 with the filename like `dump_20240101-170000.sql` where it represents `2024-01-01 17:00:00`\n3. Create the file and continuously append new chunks to it until reaching the end\n4. May need to utilize a DO alarm to continue the work after X time if a timeout occurs & mark where it currently is in the process in internal memory so it can pick up and continue.\n5. Provide a callback URL when the operation is finally completed so users can create custom logic to notify them (e.g. Email, Slack, etc)",
                  "html_url": "https://github.com/outerbase/starbasedb/issues/59"
                },
                "type": "github"
              },
              "hash": "outerbase/starbasedb#59",
              "body": "**Describe the bug**\nIf you try to use any of the database dump endpoints such as SQL, CSV or JSON the data is loaded into memory and then created as a dump file. To support any size database we should investigate enhancements to allow any sized database to be exported. Currently the size limitations are 1GB for Durable Objects with 10GB in the future. Operate under the assumption that we might be attempting to dump a 10GB database into a `.sql` file.\n\nAnother consideration to make is because Durable Objects execute synchronous operations we may need to allow for \"breathing intervals\". An example might be we allow our export operation to run for 5 seconds, and take 5 seconds off if other requests are in a queue, then it can pick up again. The goal here would be to prevent locking the database for long periods of time.\n\nBut then poses the questions: \n1. How do we continue operations that need more than 30 seconds to work?\n2. Where is the data stored as it's being created? (R2, S3, something else)?\n3. How do we deliver that dump information to the user after its completed?\n\n**To Reproduce**\nSteps to reproduce the behavior:\n\n1. Hit the `/export/dump` endpoint on a large database\n2. Will eventually fail when the 30 second request response time window closes\n\nRun the following command in Terminal (replace the URL with yours) and if your operation exceeds 30 seconds you should see a failed network response instead of a dump file.\n```\ncurl --location 'https://starbasedb.YOUR-ID-HERE.workers.dev/export/dump' \\\n--header 'Authorization: Bearer ABC123' \\\n--output database_dump.sql\n```\n\nIf you can't create a large enough test database feel free to add code in to `sleep` for 29 seconds before proceeding with the `/export/dump` functional code and should also see the failure.\n\n**Expected behavior**\nAs a user I would expect any and all of the specified data to be dumped out without an error and without partial results. Where it ends up for the user to access if the operation takes more than 30 seconds is up for discussion. Ideally if shorter than 30 seconds it could be returned as our cURL above works today (downloads the file from the response of the origin request), but perhaps after the timeout it continues on uploads it to a destination source to access afterwards?\n\n**Proposed Solution:**\n1. For backups require an R2 binding\n2. Have a `.sql` file that gets created in R2 with the filename like `dump_20240101-170000.sql` where it represents `2024-01-01 17:00:00`\n3. Create the file and continuously append new chunks to it until reaching the end\n4. May need to utilize a DO alarm to continue the work after X time if a timeout occurs & mark where it currently is in the process in internal memory so it can pick up and continue.\n5. Provide a callback URL when the operation is finally completed so users can create custom logic to notify them (e.g. Email, Slack, etc)",
              "url": "https://github.com/outerbase/starbasedb/issues/59",
              "tech": [],
              "repo_name": "starbasedb",
              "repo_owner": "outerbase",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "outerbase#72",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "outerbase",
              "id": "generated-outerbase",
              "name": "Outerbase",
              "description": "",
              "members": [],
              "display_name": "Outerbase",
              "created_at": "2026-01-24T11:30:38.381Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/outerbase?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "outerbase",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-24T11:30:38.381Z",
            "created_at": "2026-01-24T11:30:38.381Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-outerbase#72",
              "status": "open",
              "type": "issue",
              "number": 72,
              "title": "Replicate data from external source to internal source with a Plugin",
              "source": {
                "data": {
                  "id": "source-outerbase#72",
                  "user": {
                    "login": "Brayden",
                    "id": 1066085,
                    "node_id": "MDQ6VXNlcjEwNjYwODU=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1066085?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/Brayden",
                    "html_url": "https://github.com/Brayden",
                    "followers_url": "https://api.github.com/users/Brayden/followers",
                    "following_url": "https://api.github.com/users/Brayden/following{/other_user}",
                    "gists_url": "https://api.github.com/users/Brayden/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/Brayden/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/Brayden/subscriptions",
                    "organizations_url": "https://api.github.com/users/Brayden/orgs",
                    "repos_url": "https://api.github.com/users/Brayden/repos",
                    "events_url": "https://api.github.com/users/Brayden/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/Brayden/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Replicate data from external source to internal source with a Plugin",
                  "body": "**Is your feature request related to a problem? Please describe.**\nStarbaseDB instances support by default an internal database (SQLite offered by the Durable Object) as well as an optional external data source. External data sources can be powered in one of two ways, both by providing values in the `wrangler.toml` file of the project.\n\n- Outerbase API Key\n- Connection details of the database\n\n<img width=\"481\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/485d4b88-a7f8-432d-9f29-d3239a6e6577\" />\n\n**Describe the solution you'd like**\nWhat would be beneficial for some use cases is the ability to bring in an external data source (e.g. a Postgres on Supabase) and have a pull mechanism where data can be brought into the internal DO SQLite so that the instance serves as a close-to-edge replica that can be queried alternatively to querying the Supabase Postgres instance.\n\n**Describe alternatives you've considered**\n- Considering the pull vs push mechanism. A pull mechanism seems to be a better global solution where a push mechanism would be required to live elsewhere on a per provider basis.\n\n**Additional context**\n- Might be beneficial for users to be able to define in the plugin what intervals data should be pulled at\n- Might be beneficial to allow users to define which tables should have data pulled into it (perhaps not all tables need replicated)\n- Likely need a way to know for each table what the last queried items were so you can do append-only type polling for new data. Does a user need to define a column to base this on (e.g. `id` or `created_at` columns perhaps)?\n",
                  "html_url": "https://github.com/outerbase/starbasedb/issues/72"
                },
                "type": "github"
              },
              "hash": "outerbase/starbasedb#72",
              "body": "**Is your feature request related to a problem? Please describe.**\nStarbaseDB instances support by default an internal database (SQLite offered by the Durable Object) as well as an optional external data source. External data sources can be powered in one of two ways, both by providing values in the `wrangler.toml` file of the project.\n\n- Outerbase API Key\n- Connection details of the database\n\n<img width=\"481\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/485d4b88-a7f8-432d-9f29-d3239a6e6577\" />\n\n**Describe the solution you'd like**\nWhat would be beneficial for some use cases is the ability to bring in an external data source (e.g. a Postgres on Supabase) and have a pull mechanism where data can be brought into the internal DO SQLite so that the instance serves as a close-to-edge replica that can be queried alternatively to querying the Supabase Postgres instance.\n\n**Describe alternatives you've considered**\n- Considering the pull vs push mechanism. A pull mechanism seems to be a better global solution where a push mechanism would be required to live elsewhere on a per provider basis.\n\n**Additional context**\n- Might be beneficial for users to be able to define in the plugin what intervals data should be pulled at\n- Might be beneficial to allow users to define which tables should have data pulled into it (perhaps not all tables need replicated)\n- Likely need a way to know for each table what the last queried items were so you can do append-only type polling for new data. Does a user need to define a column to base this on (e.g. `id` or `created_at` columns perhaps)?\n",
              "url": "https://github.com/outerbase/starbasedb/issues/72",
              "tech": [],
              "repo_name": "starbasedb",
              "repo_owner": "outerbase",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "Mudlet#8030",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "Mudlet",
              "id": "generated-Mudlet",
              "name": "Mudlet",
              "description": "",
              "members": [],
              "display_name": "Mudlet",
              "created_at": "2026-01-24T11:30:38.097Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/Mudlet?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "Mudlet",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-24T11:30:38.097Z",
            "created_at": "2026-01-24T11:30:38.097Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-Mudlet#8030",
              "status": "open",
              "type": "issue",
              "number": 8030,
              "title": "Split Mudlet up into `libmudlet` and a Qt front-end",
              "source": {
                "data": {
                  "id": "source-Mudlet#8030",
                  "user": {
                    "login": "vadi2",
                    "id": 110988,
                    "node_id": "MDQ6VXNlcjExMDk4OA==",
                    "avatar_url": "https://avatars.githubusercontent.com/u/110988?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/vadi2",
                    "html_url": "https://github.com/vadi2",
                    "followers_url": "https://api.github.com/users/vadi2/followers",
                    "following_url": "https://api.github.com/users/vadi2/following{/other_user}",
                    "gists_url": "https://api.github.com/users/vadi2/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/vadi2/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/vadi2/subscriptions",
                    "organizations_url": "https://api.github.com/users/vadi2/orgs",
                    "repos_url": "https://api.github.com/users/vadi2/repos",
                    "events_url": "https://api.github.com/users/vadi2/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/vadi2/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Split Mudlet up into `libmudlet` and a Qt front-end",
                  "body": "#### Description of requested feature:\nMudlet is a Qt Widgets based application, which works great for Linux/macOS/Windows, but not so great for running natively on Android or iPhone, which are popular feature requests.\n\nAkin to how VLC is split into libVLC and various front-ends, split Mudlet out into libmudlet (providing all of core functionality) and a Qt Widget frontend that makes use of all of the core functionality.\n\n**Prior to taking this issue up**, open a new github issue here and in there, provide (1) plan for how the library/frontend split will work on an architectural level, and (2) a plan for the migration strategy, since once mega PR will not work for this.\n\n#### Reasons for adding feature:\n\n1. allowing Mudlet to eventually have a mobile-native version\n\n#### Expected result of feature\nlibmudlet may use Qt Core classes (QObject, QTimer, QThread, QSettings, etc.) but must not depend on Qt Widgets, Qt GUI, or any UI-related Qt modules.\n\n Mudlet's functionality pre and post-split should be 100% the same, nothing should be lost in the transition:\n -  All existing automated tests must pass, plus:\n  - All menu items and dialogs function identically\n  - All Lua API functions return identical results\n  - All protocol features work (GMCP, MXP, etc.)\n  - All file formats (profiles, packages) remain compatible\n\nPerformance of the network/text display stack as well as the trigger engine should be comparable as well (no more than 10% lost). Measured in:\n\n  - Text display: X lines/second in main console (can be measured using [stressinator](https://packages.mudlet.org/packages#pkg-Stressinator))\n  - Network: Y MB/s processing throughput (needs to be measured)\n  - Memory: no more than 10% increase in base memory usage\n\n####\n\n",
                  "html_url": "https://github.com/Mudlet/Mudlet/issues/8030"
                },
                "type": "github"
              },
              "hash": "Mudlet/Mudlet#8030",
              "body": "#### Description of requested feature:\nMudlet is a Qt Widgets based application, which works great for Linux/macOS/Windows, but not so great for running natively on Android or iPhone, which are popular feature requests.\n\nAkin to how VLC is split into libVLC and various front-ends, split Mudlet out into libmudlet (providing all of core functionality) and a Qt Widget frontend that makes use of all of the core functionality.\n\n**Prior to taking this issue up**, open a new github issue here and in there, provide (1) plan for how the library/frontend split will work on an architectural level, and (2) a plan for the migration strategy, since once mega PR will not work for this.\n\n#### Reasons for adding feature:\n\n1. allowing Mudlet to eventually have a mobile-native version\n\n#### Expected result of feature\nlibmudlet may use Qt Core classes (QObject, QTimer, QThread, QSettings, etc.) but must not depend on Qt Widgets, Qt GUI, or any UI-related Qt modules.\n\n Mudlet's functionality pre and post-split should be 100% the same, nothing should be lost in the transition:\n -  All existing automated tests must pass, plus:\n  - All menu items and dialogs function identically\n  - All Lua API functions return identical results\n  - All protocol features work (GMCP, MXP, etc.)\n  - All file formats (profiles, packages) remain compatible\n\nPerformance of the network/text display stack as well as the trigger engine should be comparable as well (no more than 10% lost). Measured in:\n\n  - Text display: X lines/second in main console (can be measured using [stressinator](https://packages.mudlet.org/packages#pkg-Stressinator))\n  - Network: Y MB/s processing throughput (needs to be measured)\n  - Memory: no more than 10% increase in base memory usage\n\n####\n\n",
              "url": "https://github.com/Mudlet/Mudlet/issues/8030",
              "tech": [],
              "repo_name": "Mudlet",
              "repo_owner": "Mudlet",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "Mudlet#3172",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "Mudlet",
              "id": "generated-Mudlet",
              "name": "Mudlet",
              "description": "",
              "members": [],
              "display_name": "Mudlet",
              "created_at": "2026-01-24T11:30:38.293Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/Mudlet?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "Mudlet",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-24T11:30:38.293Z",
            "created_at": "2026-01-24T11:30:38.293Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-Mudlet#3172",
              "status": "open",
              "type": "issue",
              "number": 3172,
              "title": "generic mapper: add video walkthrough on how to set it up",
              "source": {
                "data": {
                  "id": "source-Mudlet#3172",
                  "user": {
                    "login": "vadi2",
                    "id": 110988,
                    "node_id": "MDQ6VXNlcjExMDk4OA==",
                    "avatar_url": "https://avatars.githubusercontent.com/u/110988?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/vadi2",
                    "html_url": "https://github.com/vadi2",
                    "followers_url": "https://api.github.com/users/vadi2/followers",
                    "following_url": "https://api.github.com/users/vadi2/following{/other_user}",
                    "gists_url": "https://api.github.com/users/vadi2/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/vadi2/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/vadi2/subscriptions",
                    "organizations_url": "https://api.github.com/users/vadi2/orgs",
                    "repos_url": "https://api.github.com/users/vadi2/repos",
                    "events_url": "https://api.github.com/users/vadi2/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/vadi2/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "generic mapper: add video walkthrough on how to set it up",
                  "body": "#### Brief summary of issue / Description of requested feature:\r\nIt's been requested a few times, and it would be really handy to link people to a video explanation of how the generic mapper script should be setup.\r\n\r\n#### Steps to reproduce the issue / Reasons for adding feature:\r\n\r\n1. \r\n2. \r\n3. \r\n\r\n#### Error output / Expected result of feature\r\n\r\n\r\n#### Extra information, such as Mudlet version, operating system and ideas for how to solve / implement:\r\n",
                  "html_url": "https://github.com/Mudlet/Mudlet/issues/3172"
                },
                "type": "github"
              },
              "hash": "Mudlet/Mudlet#3172",
              "body": "#### Brief summary of issue / Description of requested feature:\r\nIt's been requested a few times, and it would be really handy to link people to a video explanation of how the generic mapper script should be setup.\r\n\r\n#### Steps to reproduce the issue / Reasons for adding feature:\r\n\r\n1. \r\n2. \r\n3. \r\n\r\n#### Error output / Expected result of feature\r\n\r\n\r\n#### Extra information, such as Mudlet version, operating system and ideas for how to solve / implement:\r\n",
              "url": "https://github.com/Mudlet/Mudlet/issues/3172",
              "tech": [],
              "repo_name": "Mudlet",
              "repo_owner": "Mudlet",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "Mudlet#689",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "Mudlet",
              "id": "generated-Mudlet",
              "name": "Mudlet",
              "description": "",
              "members": [],
              "display_name": "Mudlet",
              "created_at": "2026-01-24T11:30:38.523Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/Mudlet?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "Mudlet",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-24T11:30:38.523Z",
            "created_at": "2026-01-24T11:30:38.523Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-Mudlet#689",
              "status": "open",
              "type": "issue",
              "number": 689,
              "title": "Support telnet:// links",
              "source": {
                "data": {
                  "id": "source-Mudlet#689",
                  "user": {
                    "login": "vadi2",
                    "id": 110988,
                    "node_id": "MDQ6VXNlcjExMDk4OA==",
                    "avatar_url": "https://avatars.githubusercontent.com/u/110988?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/vadi2",
                    "html_url": "https://github.com/vadi2",
                    "followers_url": "https://api.github.com/users/vadi2/followers",
                    "following_url": "https://api.github.com/users/vadi2/following{/other_user}",
                    "gists_url": "https://api.github.com/users/vadi2/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/vadi2/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/vadi2/subscriptions",
                    "organizations_url": "https://api.github.com/users/vadi2/orgs",
                    "repos_url": "https://api.github.com/users/vadi2/repos",
                    "events_url": "https://api.github.com/users/vadi2/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/vadi2/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Support telnet:// links",
                  "body": "Idea: MUDs should be able to provide an easy to use link with their connection info to spawn Mudlet and get it to connect to their game. Similar to apt://, steam:// and so forth links.\r\n\r\nI think Mudlet should support those types of links - it'd be a lot more convenient for players to try out new MUDs if they only have to click on a link, instead of copying the server and port, going to Mudlet, making a new profile and so on.\r\n\r\nAs for the naming of the link, we could either go with a custom one: mudlet:// or - use an already standard one (telnet://), which would be much better as some websites use it already (http://dmud.thebbs.org/lotflink.htm) and it would be compatible with other MUDs clients.\r\n\r\nI believe the latter option is better.\r\n\r\nTelnet links seem to work in the format of: telnet://<server>[:<optional port #>], see https://tools.ietf.org/html/rfc4248 for the actual spec.\r\n\r\nThe logic for this could be the following:\r\n\r\nWhen Mudlet is spawned via the telnet link, check to see if any profile(s) server matches server field of the link. If multiple profiles do, auto-load the latest profile used. If one matches, load that profile. If not profiles match...\r\n\r\nCreate a new profile with the given server and port data, and the profiles name will be the servers name as well. Auto-load this newly created profile.\r\n\r\n\r\nI think these cases sound plausible. There'll an issue with peoples already made profile using the server name vs IP address directly as webmasters might, but that's not something that could be easily avoided.\r\n\r\nLaunchpad Details: [#LP1187243](https://bugs.launchpad.net/bugs/1187243) Vadim Peretokin - 2013-06-04 04:47:05 +0000",
                  "html_url": "https://github.com/Mudlet/Mudlet/issues/689"
                },
                "type": "github"
              },
              "hash": "Mudlet/Mudlet#689",
              "body": "Idea: MUDs should be able to provide an easy to use link with their connection info to spawn Mudlet and get it to connect to their game. Similar to apt://, steam:// and so forth links.\r\n\r\nI think Mudlet should support those types of links - it'd be a lot more convenient for players to try out new MUDs if they only have to click on a link, instead of copying the server and port, going to Mudlet, making a new profile and so on.\r\n\r\nAs for the naming of the link, we could either go with a custom one: mudlet:// or - use an already standard one (telnet://), which would be much better as some websites use it already (http://dmud.thebbs.org/lotflink.htm) and it would be compatible with other MUDs clients.\r\n\r\nI believe the latter option is better.\r\n\r\nTelnet links seem to work in the format of: telnet://<server>[:<optional port #>], see https://tools.ietf.org/html/rfc4248 for the actual spec.\r\n\r\nThe logic for this could be the following:\r\n\r\nWhen Mudlet is spawned via the telnet link, check to see if any profile(s) server matches server field of the link. If multiple profiles do, auto-load the latest profile used. If one matches, load that profile. If not profiles match...\r\n\r\nCreate a new profile with the given server and port data, and the profiles name will be the servers name as well. Auto-load this newly created profile.\r\n\r\n\r\nI think these cases sound plausible. There'll an issue with peoples already made profile using the server name vs IP address directly as webmasters might, but that's not something that could be easily avoided.\r\n\r\nLaunchpad Details: [#LP1187243](https://bugs.launchpad.net/bugs/1187243) Vadim Peretokin - 2013-06-04 04:47:05 +0000",
              "url": "https://github.com/Mudlet/Mudlet/issues/689",
              "tech": [],
              "repo_name": "Mudlet",
              "repo_owner": "Mudlet",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "Mudlet#5310",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "Mudlet",
              "id": "generated-Mudlet",
              "name": "Mudlet",
              "description": "",
              "members": [],
              "display_name": "Mudlet",
              "created_at": "2026-01-24T11:30:38.691Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/Mudlet?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "Mudlet",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-24T11:30:38.691Z",
            "created_at": "2026-01-24T11:30:38.691Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-Mudlet#5310",
              "status": "open",
              "type": "issue",
              "number": 5310,
              "title": "Autocomplete steals window focus, prevents further typing",
              "source": {
                "data": {
                  "id": "source-Mudlet#5310",
                  "user": {
                    "login": "Matthew-Marsh",
                    "id": 79426017,
                    "node_id": "MDQ6VXNlcjc5NDI2MDE3",
                    "avatar_url": "https://avatars.githubusercontent.com/u/79426017?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/Matthew-Marsh",
                    "html_url": "https://github.com/Matthew-Marsh",
                    "followers_url": "https://api.github.com/users/Matthew-Marsh/followers",
                    "following_url": "https://api.github.com/users/Matthew-Marsh/following{/other_user}",
                    "gists_url": "https://api.github.com/users/Matthew-Marsh/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/Matthew-Marsh/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/Matthew-Marsh/subscriptions",
                    "organizations_url": "https://api.github.com/users/Matthew-Marsh/orgs",
                    "repos_url": "https://api.github.com/users/Matthew-Marsh/repos",
                    "events_url": "https://api.github.com/users/Matthew-Marsh/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/Matthew-Marsh/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Autocomplete steals window focus, prevents further typing",
                  "body": "#### Brief summary of issue / Description of requested feature:\r\n\r\nOccasionally encountering an issue where autocomplete pops up and prevents typing. Need to esc to remove the autocomplete, but will pop up again with another relevant letter.\r\n\r\n#### Steps to reproduce the issue / Reasons for adding feature:\r\n\r\n1.  Unknown to why it begins.\r\n2.  Typing a letter that has a corresponding lua command in the autocomplete. \r\n\r\n#### Error output / Expected result of feature\r\n\r\nExpected result: Being able to continue typing outside of autocomplete.\r\n\r\n#### Extra information, such as Mudlet version, operating system and ideas for how to solve / implement:\r\n\r\nMudlet version: 4.11.2\r\nWindows 10 Home\r\nVideo recording: https://youtu.be/qJF0h2MDWzg\r\n",
                  "html_url": "https://github.com/Mudlet/Mudlet/issues/5310"
                },
                "type": "github"
              },
              "hash": "Mudlet/Mudlet#5310",
              "body": "#### Brief summary of issue / Description of requested feature:\r\n\r\nOccasionally encountering an issue where autocomplete pops up and prevents typing. Need to esc to remove the autocomplete, but will pop up again with another relevant letter.\r\n\r\n#### Steps to reproduce the issue / Reasons for adding feature:\r\n\r\n1.  Unknown to why it begins.\r\n2.  Typing a letter that has a corresponding lua command in the autocomplete. \r\n\r\n#### Error output / Expected result of feature\r\n\r\nExpected result: Being able to continue typing outside of autocomplete.\r\n\r\n#### Extra information, such as Mudlet version, operating system and ideas for how to solve / implement:\r\n\r\nMudlet version: 4.11.2\r\nWindows 10 Home\r\nVideo recording: https://youtu.be/qJF0h2MDWzg\r\n",
              "url": "https://github.com/Mudlet/Mudlet/issues/5310",
              "tech": [],
              "repo_name": "Mudlet",
              "repo_owner": "Mudlet",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "ZIO#802",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "ZIO",
              "id": "generated-ZIO",
              "name": "ZIO",
              "description": "",
              "members": [],
              "display_name": "ZIO",
              "created_at": "2026-01-24T11:31:18.261Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/ZIO?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "zio",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-24T11:31:18.261Z",
            "created_at": "2026-01-24T11:31:18.261Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-ZIO#802",
              "status": "open",
              "type": "issue",
              "number": 802,
              "title": "Enhance toString of core data types",
              "source": {
                "data": {
                  "id": "source-ZIO#802",
                  "user": {
                    "login": "jdegoes",
                    "id": 156745,
                    "node_id": "MDQ6VXNlcjE1Njc0NQ==",
                    "avatar_url": "https://avatars.githubusercontent.com/u/156745?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/jdegoes",
                    "html_url": "https://github.com/jdegoes",
                    "followers_url": "https://api.github.com/users/jdegoes/followers",
                    "following_url": "https://api.github.com/users/jdegoes/following{/other_user}",
                    "gists_url": "https://api.github.com/users/jdegoes/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/jdegoes/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/jdegoes/subscriptions",
                    "organizations_url": "https://api.github.com/users/jdegoes/orgs",
                    "repos_url": "https://api.github.com/users/jdegoes/repos",
                    "events_url": "https://api.github.com/users/jdegoes/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/jdegoes/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Enhance toString of core data types",
                  "body": "# Implement custom toString for schema types\n\n## Summary\n\nAdd custom `toString` implementations across the zio-blocks schema library to provide human-readable, debugger-friendly representations. Each type's format should draw from established prior art and match existing project conventions where applicable.\n\n## Motivation\n\nCurrently, many types use default case class `toString`, which produces verbose, hard-to-read output that makes debugging difficult. For example:\n\n```\nTypeName(Namespace(List(scala, collection, immutable)),List,List(TypeName(Namespace(List(scala)),Int,List())))\n```\n\nShould instead be:\n\n```\nscala.collection.immutable.List[scala.Int]\n```\n\nAll output should be **beautiful and human-readable**, using proper indentation and line breaks where appropriate.\n\n---\n\n## Specifications\n\n### 1. TypeName[A]\n\n**Format:** Valid Scala type syntax\n\n**Examples:**\n```\nscala.Int\nscala.Option[scala.String]\nscala.collection.immutable.List[scala.Int]\nscala.collection.immutable.Map[scala.String, scala.Int]\ncom.example.Person\n```\n\n**Rationale:** Immediately recognizable, copy-pasteable into Scala code.\n\n---\n\n### 2. DynamicOptic\n\n**Format:** Match the path interpolator (`p\"...\"`) syntax exactly.\n\n**Examples:**\n```\n.name\n.address.street\n.name<Some>\n.users[0]\n.users[0,2,5]\n.items[*]\n.config{\"host\"}\n.ports{80}\n.lookup{*}\n.ports{*:}\n```\n\n**Node Mapping:**\n\n| Node | Syntax |\n|------|--------|\n| Field(name) | `.name` |\n| Case(name) | `<Name>` |\n| AtIndex(n) | `[n]` |\n| AtIndices(ns) | `[n1,n2,n3]` |\n| AtMapKey(k) | `{\"key\"}` or `{42}` or `{true}` |\n| AtMapKeys(ks) | `{\"k1\", \"k2\"}` |\n| Elements | `[*]` |\n| MapKeys | `{*:}` |\n| MapValues | `{*}` |\n| Wrapped | `.~` |\n\n**Rationale:** Users can copy debug output directly into `p\"...\"` strings.\n\n---\n\n### 3. Optic Types (Lens, Prism, Optional, Traversal)\n\n**Format:** Match the `$` macro syntax\n\n**Examples:**\n```\nLens(_.name)\nLens(_.address.street)\nPrism(_.when[Some].value)\nOptional(_.result.when[Success].data)\nTraversal(_.users.each.email)\n```\n\n**Rationale:** Shows the Scala code you'd write with the `$` macro.\n\n---\n\n### 4. Reflect[F, A] Types\n\n**Format:** Fully recursive inline expansion. Every type is expanded to its leaves (primitives or deferred references). No external references - the entire structure is self-contained.\n\n#### Reflect.Primitive\n\nPrimitives are leaf nodes, rendered as their type name:\n```\nString\nInt\nBoolean\njava.time.Instant\n```\n\n#### Reflect.Record\n\nRecords show all fields with their fully-expanded types:\n```\nrecord Person {\n  name: String\n  age: Int\n  address: record Address {\n    street: String\n    city: String\n    zip: String\n  }\n}\n```\n\n#### Reflect.Variant\n\nVariants show all cases with their fully-expanded payloads:\n```\nvariant Option[Int] {\n  | None\n  | Some(value: Int)\n}\n\nvariant PaymentMethod {\n  | Cash\n  | CreditCard(\n      number: String,\n      expiry: String,\n      cvv: String\n    )\n  | BankTransfer(\n      account: record BankAccount {\n        routing: String\n        number: String\n      }\n    )\n}\n```\n\n#### Reflect.Sequence\n\nSequences show the collection type with fully-expanded element type:\n```\nsequence List[String]\n\nsequence Vector[\n  record OrderItem {\n    product: String\n    quantity: Int\n    price: BigDecimal\n  }\n]\n```\n\n#### Reflect.Map\n\nMaps show the map type with fully-expanded key and value types:\n```\nmap Map[String, Int]\n\nmap Map[\n  String,\n  record Config {\n    value: String\n    enabled: Boolean\n  }\n]\n```\n\n#### Reflect.Deferred\n\nDeferred types are shown as references (not expanded) to prevent infinite recursion:\n```\ndeferred => Person\n```\n\n#### Reflect.Wrapper\n\nWrappers show the fully-expanded underlying type:\n```\nwrapper UserId(String)\n\nwrapper ValidatedEmail(\n  record EmailParts {\n    local: String\n    domain: String\n  }\n)\n\nwrapper OrderId(\n  wrapper UUID(String)\n)\n```\n\n#### Complex Nested Example\n\nA fully-expanded real-world schema:\n```\nrecord Order {\n  id: wrapper OrderId(String)\n  customer: record Customer {\n    name: String\n    email: wrapper Email(String)\n    address: record Address {\n      street: String\n      city: String\n      country: String\n    }\n  }\n  items: sequence Vector[\n    record OrderItem {\n      product: String\n      quantity: Int\n      price: BigDecimal\n    }\n  ]\n  status: variant OrderStatus {\n    | Pending\n    | Shipped(trackingNumber: String)\n    | Delivered(deliveredAt: java.time.Instant)\n    | Cancelled(reason: String)\n  }\n  metadata: map Map[String, String]\n  previousOrder: deferred => Order\n}\n```\n\n#### Recursive Types\n\nTypes that reference themselves use `deferred` to break the cycle:\n```\nvariant Tree[Int] {\n  | Leaf(value: Int)\n  | Branch(\n      value: Int,\n      left: deferred => Tree[Int],\n      right: deferred => Tree[Int]\n    )\n}\n\nrecord LinkedListNode[String] {\n  head: String\n  tail: variant Option[deferred => LinkedListNode[String]] {\n    | None\n    | Some(value: deferred => LinkedListNode[String])\n  }\n}\n```\n\n**Key Properties:**\n- Fully self-contained: no external type references except `deferred`\n- Primitives render as bare type names (they are leaves)\n- Complex types (`record`, `variant`, `sequence`, `map`, `wrapper`) are prefixed with their kind\n- `deferred => TypeName` breaks recursive cycles\n- Proper indentation for nested structures\n- Line-oriented for diff-friendliness\n\n**Why SDL format instead of Scala types?**\n\nScala syntax cannot represent fully-inlined nested type definitions:\n```scala\n// This is invalid Scala - can't inline case class definitions\ncase class Person(\n  name: String,\n  address: case class Address { ... }  // Not allowed!\n)\n```\n\nYou'd have to define types separately and reference by name, which breaks \"turtles all the way down.\" The SDL format is fully inlineable, and because everything is expanded inline, diffs show changes at any depth:\n\n```diff\n record Person {\n   name: String\n+  email: String\n   address: record Address {\n     street: String\n+    zip: String\n   }\n }\n```\n\n**Rationale:** Complete structural visibility - you can see the entire schema shape without looking anything up, and schema evolution is visible in text diffs.\n\n---\n\n### 5. Schema[A]\n\n**Format:** Delegates to its underlying `Reflect`, showing the full structure.\n\n```\nSchema {\n  record Person {\n    name: String\n    age: Int\n    address: record Address {\n      street: String\n      city: String\n    }\n  }\n}\n```\n\nFor simple primitives:\n```\nSchema {\n  Int\n}\n```\n\n---\n\n### 6. DynamicValue (EJSON Format)\n\n**Format:** Extended JSON (EJSON) - a superset of JSON that handles non-string keys, tagged variants, typed primitives, and distinguishes records from maps.\n\n#### Primitives\n```\n\"hello\"\n42\n3.14\ntrue\nnull\n```\n\n#### Typed Primitives (with metadata)\n\nPrimitives that would lose type information when rendered as JSON can be annotated:\n```\n1705312800 @ {type: \"instant\"}\n\"P1Y2M3D\" @ {type: \"period\"}\n\"PT1H30M\" @ {type: \"duration\"}\n\"2024-01-15\" @ {type: \"localDate\"}\n```\n\n#### Records (unquoted keys)\n```\n{\n  name: \"John\",\n  age: 30,\n  active: true\n}\n```\n\n#### Sequences\n```\n[1, 2, 3]\n\n[\n  \"apple\",\n  \"banana\",\n  \"cherry\"\n]\n```\n\n#### Maps (quoted string keys)\n```\n{\n  \"name\": \"John\",\n  \"age-group\": \"30-40\"\n}\n```\n\n#### Maps (non-string keys)\n```\n{ true: \"yes\", false: \"no\" }\n\n{\n  1: \"one\",\n  2: \"two\",\n  3: \"three\"\n}\n```\n\n#### Variants (value @ metadata with tag)\n```\n{} @ {tag: \"None\"}\n\n{ value: 42 } @ {tag: \"Some\"}\n\n{\n  ccnum: 4111111111111111,\n  expiry: \"12/25\"\n} @ {tag: \"CreditCard\"}\n\n{ value: \"error message\" } @ {tag: \"Left\"}\n```\n\n#### Metadata Composition\n\nMetadata can itself have metadata:\n```\n{ value: 42 } @ {tag: \"Some\"} @ {source: \"userInput\"}\n```\n\n#### Nested Example\n```\n{\n  user: {\n    name: \"Alice\",\n    payment: {\n      ccnum: 4111111111111111\n    } @ {tag: \"CreditCard\"},\n    scores: [95, 87, 92],\n    metadata: {\n      \"verified\": true,\n      1: \"first\",\n      2: \"second\"\n    },\n    createdAt: 1705312800 @ {type: \"instant\"}\n  }\n}\n```\n\n**Key Properties:**\n- **Records** have unquoted keys: `{ name: \"John\" }`\n- **Maps** have quoted string keys: `{ \"name\": \"John\" }` or unquoted non-string keys: `{ 42: \"answer\" }`\n- **Variants** use postfix metadata: `{ value: 42 } @ {tag: \"Some\"}`\n- **Typed primitives** use postfix metadata: `123 @ {type: \"instant\"}`\n- **Metadata composes**: `value @ meta1 @ meta2`\n- Proper indentation for nested structures\n- Format is reversibly parseable\n\n**Rationale:** Familiar JSON-like syntax, natural extension for Scala's richer type system, with clean separation of data and metadata.\n\n---\n\n### 7. DynamicPatch / Patch[S]\n\n**Format:** Line-oriented diff representation using `+`/`-`/`~` markers, inspired by json-diff and unified diff.\n\n#### Simple Operations\n```\n.name = \"John\"\n.age += 5\n.score -= 10\n.balance += 100.50\n```\n\n#### Sequence Edits\n```\n.items:\n  + [0: \"inserted at index 0\"]\n  + [3: \"inserted at index 3\"]\n  - [0]\n  - [2, 5, 7]\n  ~ [0: \"modified value\"]\n```\n\nAppend (no index):\n```\n.tags:\n  + \"appended value\"\n  + \"another appended\"\n```\n\n#### Map Edits\n```\n.config:\n  + {\"newKey\": \"new value\"}\n  + {42: \"numeric key\"}\n  - {\"deletedKey\"}\n  - {99}\n  ~ {\"existingKey\": \"updated value\"}\n```\n\n#### Complete Patch Example\n```\nDynamicPatch {\n  .name = \"John Smith\"\n  .age += 1\n  .address.city = \"New York\"\n  .address.zip = \"10001\"\n  .tags:\n    + \"verified\"\n    + \"premium\"\n    - [0]\n  .metadata:\n    + {\"created\": \"2024-01-15\"}\n    - {\"temporary\"}\n  .scores[*] += 10\n}\n```\n\n#### Nested Patch\n```\nDynamicPatch {\n  .user.profile:\n    .name = \"Alice\"\n    .settings:\n      + {\"theme\": \"dark\"}\n}\n```\n\n**Rationale:** \n- Familiar `+`/`-`/`~` markers from diff tools\n- Consistent syntax: `+ {key: value}` for maps, `+ [index: value]` for sequences\n- Path syntax matches path interpolator\n- Line-oriented for visual scanning\n- Indentation shows structure\n\n---\n\n### 8. Term[F, S, A]\n\n**Format:** Field name followed by fully-expanded type\n\nSimple case:\n```\nname: String\n```\n\nComplex case:\n```\naddress: record Address {\n  street: String\n  city: String\n}\n```\n\nVariant field:\n```\nstatus: variant Status {\n  | Active\n  | Inactive(reason: String)\n}\n```\n\nWrapper field:\n```\nuserId: wrapper UserId(String)\n\nemail: wrapper ValidatedEmail(\n  record EmailParts {\n    local: String\n    domain: String\n  }\n)\n```\n\n---\n\n### 9. Json Types\n\n**Format:** Delegate to existing `print` method\n\n```scala\noverride def toString: String = print\n```\n\n---\n\n## Testing Requirements\n\nEach type's `toString` should have dedicated tests that:\n\n1. **Demonstrate the format** - Tests serve as documentation of expected output\n2. **Verify beauty** - Output should be visually inspected for readability\n3. **Test edge cases** - Empty collections, deeply nested structures, special characters\n4. **Test round-trip consistency** - Where applicable, verify output could be parsed back\n\n### Example Test Structure\n\n```scala\nsuite(\"TypeName toString\") {\n  test(\"renders simple types\") {\n    assertEquals(TypeName.int.toString, \"scala.Int\")\n  }\n  \n  test(\"renders parameterized types\") {\n    assertEquals(\n      TypeName.option(TypeName.string).toString,\n      \"scala.Option[scala.String]\"\n    )\n  }\n  \n  test(\"renders nested parameterized types\") {\n    assertEquals(\n      TypeName.map(TypeName.string, TypeName.list(TypeName.int)).toString,\n      \"scala.collection.immutable.Map[scala.String, scala.collection.immutable.List[scala.Int]]\"\n    )\n  }\n}\n\nsuite(\"DynamicValue toString (EJSON)\") {\n  test(\"renders records with unquoted keys\") {\n    val value = DynamicValue.Record(Vector(\n      \"name\" -> DynamicValue.Primitive(PrimitiveValue.String(\"John\")),\n      \"age\" -> DynamicValue.Primitive(PrimitiveValue.Int(30))\n    ))\n    assertEquals(value.toString, \n      \"\"\"|{\n         |  name: \"John\",\n         |  age: 30\n         |}\"\"\".stripMargin)\n  }\n  \n  test(\"renders maps with quoted string keys\") {\n    val value = DynamicValue.Map(Vector(\n      DynamicValue.Primitive(PrimitiveValue.String(\"name\")) -> \n        DynamicValue.Primitive(PrimitiveValue.String(\"John\"))\n    ))\n    assertEquals(value.toString,\n      \"\"\"|{\n         |  \"name\": \"John\"\n         |}\"\"\".stripMargin)\n  }\n  \n  test(\"renders variants with postfix @ metadata\") {\n    // { value: 42 } @ {tag: \"Some\"}\n  }\n  \n  test(\"renders typed primitives with @ metadata\") {\n    // 1705312800 @ {type: \"instant\"}\n  }\n  \n  test(\"renders maps with non-string keys\") {\n    // { true: \"yes\", 42: \"answer\" }\n  }\n  \n  test(\"renders nested variant in record\") {\n    // {\n    //   payment: {\n    //     ccnum: 4111111111111111\n    //   } @ {tag: \"CreditCard\"}\n    // }\n  }\n}\n\nsuite(\"DynamicPatch toString\") {\n  test(\"renders simple set operation\") {\n    // .name = \"John\"\n  }\n  \n  test(\"renders numeric delta\") {\n    // .age += 5\n  }\n  \n  test(\"renders sequence edits with consistent syntax\") {\n    // .items:\n    //   + [0: \"inserted\"]\n    //   + \"appended\"\n    //   - [2]\n  }\n  \n  test(\"renders map edits with consistent syntax\") {\n    // .config:\n    //   + {\"key\": \"value\"}\n    //   - {\"oldKey\"}\n  }\n  \n  test(\"renders multi-operation patch with indentation\") {\n    // DynamicPatch {\n    //   .name = \"John\"\n    //   .tags:\n    //     + \"new\"\n    // }\n  }\n}\n\nsuite(\"Schema toString\") {\n  test(\"renders full structure\") {\n    // Schema {\n    //   record Person {\n    //     name: String\n    //     age: Int\n    //   }\n    // }\n  }\n}\n\nsuite(\"Reflect toString\") {\n  test(\"renders primitive\") {\n    // String\n  }\n  \n  test(\"renders simple record\") {\n    // record Point {\n    //   x: Int\n    //   y: Int\n    // }\n  }\n  \n  test(\"renders nested record fully expanded\") {\n    // record Person {\n    //   name: String\n    //   address: record Address {\n    //     street: String\n    //     city: String\n    //   }\n    // }\n  }\n  \n  test(\"renders variant with cases\") {\n    // variant Option[Int] {\n    //   | None\n    //   | Some(value: Int)\n    // }\n  }\n  \n  test(\"renders sequence with complex element\") {\n    // sequence List[\n    //   record Item {\n    //     name: String\n    //   }\n    // ]\n  }\n  \n  test(\"renders wrapper with complex underlying type\") {\n    // wrapper ValidatedEmail(\n    //   record EmailParts {\n    //     local: String\n    //     domain: String\n    //   }\n    // )\n  }\n  \n  test(\"renders deferred to break recursion\") {\n    // variant Tree[Int] {\n    //   | Leaf(value: Int)\n    //   | Branch(\n    //       left: deferred => Tree[Int],\n    //       right: deferred => Tree[Int]\n    //     )\n    // }\n  }\n}\n```\n\n---\n\n## Files to Modify\n\n- `schema/shared/src/main/scala/zio/blocks/schema/TypeName.scala`\n- `schema/shared/src/main/scala/zio/blocks/schema/DynamicOptic.scala`\n- `schema/shared/src/main/scala/zio/blocks/schema/Optic.scala`\n- `schema/shared/src/main/scala/zio/blocks/schema/Reflect.scala`\n- `schema/shared/src/main/scala/zio/blocks/schema/Schema.scala`\n- `schema/shared/src/main/scala/zio/blocks/schema/DynamicValue.scala`\n- `schema/shared/src/main/scala/zio/blocks/schema/patch/DynamicPatch.scala`\n- `schema/shared/src/main/scala/zio/blocks/schema/patch/Patch.scala`\n- `schema/shared/src/main/scala/zio/blocks/schema/Term.scala`\n- `schema/shared/src/main/scala/zio/blocks/schema/json/Json.scala`\n\n---\n\n## Design References\n\n| Type | Prior Art |\n|------|-----------|\n| TypeName | Scala type syntax |\n| DynamicOptic | zio-blocks path interpolator `p\"...\"` |\n| Optic | zio-blocks `$` macro |\n| Reflect | GraphQL SDL, Protobuf |\n| DynamicValue | JSON (extended for non-string keys and tagged variants) |\n| DynamicPatch | json-diff, unified diff format |\n",
                  "html_url": "https://github.com/zio/zio-blocks/issues/802"
                },
                "type": "github"
              },
              "hash": "zio/zio-blocks#802",
              "body": "# Implement custom toString for schema types\n\n## Summary\n\nAdd custom `toString` implementations across the zio-blocks schema library to provide human-readable, debugger-friendly representations. Each type's format should draw from established prior art and match existing project conventions where applicable.\n\n## Motivation\n\nCurrently, many types use default case class `toString`, which produces verbose, hard-to-read output that makes debugging difficult. For example:\n\n```\nTypeName(Namespace(List(scala, collection, immutable)),List,List(TypeName(Namespace(List(scala)),Int,List())))\n```\n\nShould instead be:\n\n```\nscala.collection.immutable.List[scala.Int]\n```\n\nAll output should be **beautiful and human-readable**, using proper indentation and line breaks where appropriate.\n\n---\n\n## Specifications\n\n### 1. TypeName[A]\n\n**Format:** Valid Scala type syntax\n\n**Examples:**\n```\nscala.Int\nscala.Option[scala.String]\nscala.collection.immutable.List[scala.Int]\nscala.collection.immutable.Map[scala.String, scala.Int]\ncom.example.Person\n```\n\n**Rationale:** Immediately recognizable, copy-pasteable into Scala code.\n\n---\n\n### 2. DynamicOptic\n\n**Format:** Match the path interpolator (`p\"...\"`) syntax exactly.\n\n**Examples:**\n```\n.name\n.address.street\n.name<Some>\n.users[0]\n.users[0,2,5]\n.items[*]\n.config{\"host\"}\n.ports{80}\n.lookup{*}\n.ports{*:}\n```\n\n**Node Mapping:**\n\n| Node | Syntax |\n|------|--------|\n| Field(name) | `.name` |\n| Case(name) | `<Name>` |\n| AtIndex(n) | `[n]` |\n| AtIndices(ns) | `[n1,n2,n3]` |\n| AtMapKey(k) | `{\"key\"}` or `{42}` or `{true}` |\n| AtMapKeys(ks) | `{\"k1\", \"k2\"}` |\n| Elements | `[*]` |\n| MapKeys | `{*:}` |\n| MapValues | `{*}` |\n| Wrapped | `.~` |\n\n**Rationale:** Users can copy debug output directly into `p\"...\"` strings.\n\n---\n\n### 3. Optic Types (Lens, Prism, Optional, Traversal)\n\n**Format:** Match the `$` macro syntax\n\n**Examples:**\n```\nLens(_.name)\nLens(_.address.street)\nPrism(_.when[Some].value)\nOptional(_.result.when[Success].data)\nTraversal(_.users.each.email)\n```\n\n**Rationale:** Shows the Scala code you'd write with the `$` macro.\n\n---\n\n### 4. Reflect[F, A] Types\n\n**Format:** Fully recursive inline expansion. Every type is expanded to its leaves (primitives or deferred references). No external references - the entire structure is self-contained.\n\n#### Reflect.Primitive\n\nPrimitives are leaf nodes, rendered as their type name:\n```\nString\nInt\nBoolean\njava.time.Instant\n```\n\n#### Reflect.Record\n\nRecords show all fields with their fully-expanded types:\n```\nrecord Person {\n  name: String\n  age: Int\n  address: record Address {\n    street: String\n    city: String\n    zip: String\n  }\n}\n```\n\n#### Reflect.Variant\n\nVariants show all cases with their fully-expanded payloads:\n```\nvariant Option[Int] {\n  | None\n  | Some(value: Int)\n}\n\nvariant PaymentMethod {\n  | Cash\n  | CreditCard(\n      number: String,\n      expiry: String,\n      cvv: String\n    )\n  | BankTransfer(\n      account: record BankAccount {\n        routing: String\n        number: String\n      }\n    )\n}\n```\n\n#### Reflect.Sequence\n\nSequences show the collection type with fully-expanded element type:\n```\nsequence List[String]\n\nsequence Vector[\n  record OrderItem {\n    product: String\n    quantity: Int\n    price: BigDecimal\n  }\n]\n```\n\n#### Reflect.Map\n\nMaps show the map type with fully-expanded key and value types:\n```\nmap Map[String, Int]\n\nmap Map[\n  String,\n  record Config {\n    value: String\n    enabled: Boolean\n  }\n]\n```\n\n#### Reflect.Deferred\n\nDeferred types are shown as references (not expanded) to prevent infinite recursion:\n```\ndeferred => Person\n```\n\n#### Reflect.Wrapper\n\nWrappers show the fully-expanded underlying type:\n```\nwrapper UserId(String)\n\nwrapper ValidatedEmail(\n  record EmailParts {\n    local: String\n    domain: String\n  }\n)\n\nwrapper OrderId(\n  wrapper UUID(String)\n)\n```\n\n#### Complex Nested Example\n\nA fully-expanded real-world schema:\n```\nrecord Order {\n  id: wrapper OrderId(String)\n  customer: record Customer {\n    name: String\n    email: wrapper Email(String)\n    address: record Address {\n      street: String\n      city: String\n      country: String\n    }\n  }\n  items: sequence Vector[\n    record OrderItem {\n      product: String\n      quantity: Int\n      price: BigDecimal\n    }\n  ]\n  status: variant OrderStatus {\n    | Pending\n    | Shipped(trackingNumber: String)\n    | Delivered(deliveredAt: java.time.Instant)\n    | Cancelled(reason: String)\n  }\n  metadata: map Map[String, String]\n  previousOrder: deferred => Order\n}\n```\n\n#### Recursive Types\n\nTypes that reference themselves use `deferred` to break the cycle:\n```\nvariant Tree[Int] {\n  | Leaf(value: Int)\n  | Branch(\n      value: Int,\n      left: deferred => Tree[Int],\n      right: deferred => Tree[Int]\n    )\n}\n\nrecord LinkedListNode[String] {\n  head: String\n  tail: variant Option[deferred => LinkedListNode[String]] {\n    | None\n    | Some(value: deferred => LinkedListNode[String])\n  }\n}\n```\n\n**Key Properties:**\n- Fully self-contained: no external type references except `deferred`\n- Primitives render as bare type names (they are leaves)\n- Complex types (`record`, `variant`, `sequence`, `map`, `wrapper`) are prefixed with their kind\n- `deferred => TypeName` breaks recursive cycles\n- Proper indentation for nested structures\n- Line-oriented for diff-friendliness\n\n**Why SDL format instead of Scala types?**\n\nScala syntax cannot represent fully-inlined nested type definitions:\n```scala\n// This is invalid Scala - can't inline case class definitions\ncase class Person(\n  name: String,\n  address: case class Address { ... }  // Not allowed!\n)\n```\n\nYou'd have to define types separately and reference by name, which breaks \"turtles all the way down.\" The SDL format is fully inlineable, and because everything is expanded inline, diffs show changes at any depth:\n\n```diff\n record Person {\n   name: String\n+  email: String\n   address: record Address {\n     street: String\n+    zip: String\n   }\n }\n```\n\n**Rationale:** Complete structural visibility - you can see the entire schema shape without looking anything up, and schema evolution is visible in text diffs.\n\n---\n\n### 5. Schema[A]\n\n**Format:** Delegates to its underlying `Reflect`, showing the full structure.\n\n```\nSchema {\n  record Person {\n    name: String\n    age: Int\n    address: record Address {\n      street: String\n      city: String\n    }\n  }\n}\n```\n\nFor simple primitives:\n```\nSchema {\n  Int\n}\n```\n\n---\n\n### 6. DynamicValue (EJSON Format)\n\n**Format:** Extended JSON (EJSON) - a superset of JSON that handles non-string keys, tagged variants, typed primitives, and distinguishes records from maps.\n\n#### Primitives\n```\n\"hello\"\n42\n3.14\ntrue\nnull\n```\n\n#### Typed Primitives (with metadata)\n\nPrimitives that would lose type information when rendered as JSON can be annotated:\n```\n1705312800 @ {type: \"instant\"}\n\"P1Y2M3D\" @ {type: \"period\"}\n\"PT1H30M\" @ {type: \"duration\"}\n\"2024-01-15\" @ {type: \"localDate\"}\n```\n\n#### Records (unquoted keys)\n```\n{\n  name: \"John\",\n  age: 30,\n  active: true\n}\n```\n\n#### Sequences\n```\n[1, 2, 3]\n\n[\n  \"apple\",\n  \"banana\",\n  \"cherry\"\n]\n```\n\n#### Maps (quoted string keys)\n```\n{\n  \"name\": \"John\",\n  \"age-group\": \"30-40\"\n}\n```\n\n#### Maps (non-string keys)\n```\n{ true: \"yes\", false: \"no\" }\n\n{\n  1: \"one\",\n  2: \"two\",\n  3: \"three\"\n}\n```\n\n#### Variants (value @ metadata with tag)\n```\n{} @ {tag: \"None\"}\n\n{ value: 42 } @ {tag: \"Some\"}\n\n{\n  ccnum: 4111111111111111,\n  expiry: \"12/25\"\n} @ {tag: \"CreditCard\"}\n\n{ value: \"error message\" } @ {tag: \"Left\"}\n```\n\n#### Metadata Composition\n\nMetadata can itself have metadata:\n```\n{ value: 42 } @ {tag: \"Some\"} @ {source: \"userInput\"}\n```\n\n#### Nested Example\n```\n{\n  user: {\n    name: \"Alice\",\n    payment: {\n      ccnum: 4111111111111111\n    } @ {tag: \"CreditCard\"},\n    scores: [95, 87, 92],\n    metadata: {\n      \"verified\": true,\n      1: \"first\",\n      2: \"second\"\n    },\n    createdAt: 1705312800 @ {type: \"instant\"}\n  }\n}\n```\n\n**Key Properties:**\n- **Records** have unquoted keys: `{ name: \"John\" }`\n- **Maps** have quoted string keys: `{ \"name\": \"John\" }` or unquoted non-string keys: `{ 42: \"answer\" }`\n- **Variants** use postfix metadata: `{ value: 42 } @ {tag: \"Some\"}`\n- **Typed primitives** use postfix metadata: `123 @ {type: \"instant\"}`\n- **Metadata composes**: `value @ meta1 @ meta2`\n- Proper indentation for nested structures\n- Format is reversibly parseable\n\n**Rationale:** Familiar JSON-like syntax, natural extension for Scala's richer type system, with clean separation of data and metadata.\n\n---\n\n### 7. DynamicPatch / Patch[S]\n\n**Format:** Line-oriented diff representation using `+`/`-`/`~` markers, inspired by json-diff and unified diff.\n\n#### Simple Operations\n```\n.name = \"John\"\n.age += 5\n.score -= 10\n.balance += 100.50\n```\n\n#### Sequence Edits\n```\n.items:\n  + [0: \"inserted at index 0\"]\n  + [3: \"inserted at index 3\"]\n  - [0]\n  - [2, 5, 7]\n  ~ [0: \"modified value\"]\n```\n\nAppend (no index):\n```\n.tags:\n  + \"appended value\"\n  + \"another appended\"\n```\n\n#### Map Edits\n```\n.config:\n  + {\"newKey\": \"new value\"}\n  + {42: \"numeric key\"}\n  - {\"deletedKey\"}\n  - {99}\n  ~ {\"existingKey\": \"updated value\"}\n```\n\n#### Complete Patch Example\n```\nDynamicPatch {\n  .name = \"John Smith\"\n  .age += 1\n  .address.city = \"New York\"\n  .address.zip = \"10001\"\n  .tags:\n    + \"verified\"\n    + \"premium\"\n    - [0]\n  .metadata:\n    + {\"created\": \"2024-01-15\"}\n    - {\"temporary\"}\n  .scores[*] += 10\n}\n```\n\n#### Nested Patch\n```\nDynamicPatch {\n  .user.profile:\n    .name = \"Alice\"\n    .settings:\n      + {\"theme\": \"dark\"}\n}\n```\n\n**Rationale:** \n- Familiar `+`/`-`/`~` markers from diff tools\n- Consistent syntax: `+ {key: value}` for maps, `+ [index: value]` for sequences\n- Path syntax matches path interpolator\n- Line-oriented for visual scanning\n- Indentation shows structure\n\n---\n\n### 8. Term[F, S, A]\n\n**Format:** Field name followed by fully-expanded type\n\nSimple case:\n```\nname: String\n```\n\nComplex case:\n```\naddress: record Address {\n  street: String\n  city: String\n}\n```\n\nVariant field:\n```\nstatus: variant Status {\n  | Active\n  | Inactive(reason: String)\n}\n```\n\nWrapper field:\n```\nuserId: wrapper UserId(String)\n\nemail: wrapper ValidatedEmail(\n  record EmailParts {\n    local: String\n    domain: String\n  }\n)\n```\n\n---\n\n### 9. Json Types\n\n**Format:** Delegate to existing `print` method\n\n```scala\noverride def toString: String = print\n```\n\n---\n\n## Testing Requirements\n\nEach type's `toString` should have dedicated tests that:\n\n1. **Demonstrate the format** - Tests serve as documentation of expected output\n2. **Verify beauty** - Output should be visually inspected for readability\n3. **Test edge cases** - Empty collections, deeply nested structures, special characters\n4. **Test round-trip consistency** - Where applicable, verify output could be parsed back\n\n### Example Test Structure\n\n```scala\nsuite(\"TypeName toString\") {\n  test(\"renders simple types\") {\n    assertEquals(TypeName.int.toString, \"scala.Int\")\n  }\n  \n  test(\"renders parameterized types\") {\n    assertEquals(\n      TypeName.option(TypeName.string).toString,\n      \"scala.Option[scala.String]\"\n    )\n  }\n  \n  test(\"renders nested parameterized types\") {\n    assertEquals(\n      TypeName.map(TypeName.string, TypeName.list(TypeName.int)).toString,\n      \"scala.collection.immutable.Map[scala.String, scala.collection.immutable.List[scala.Int]]\"\n    )\n  }\n}\n\nsuite(\"DynamicValue toString (EJSON)\") {\n  test(\"renders records with unquoted keys\") {\n    val value = DynamicValue.Record(Vector(\n      \"name\" -> DynamicValue.Primitive(PrimitiveValue.String(\"John\")),\n      \"age\" -> DynamicValue.Primitive(PrimitiveValue.Int(30))\n    ))\n    assertEquals(value.toString, \n      \"\"\"|{\n         |  name: \"John\",\n         |  age: 30\n         |}\"\"\".stripMargin)\n  }\n  \n  test(\"renders maps with quoted string keys\") {\n    val value = DynamicValue.Map(Vector(\n      DynamicValue.Primitive(PrimitiveValue.String(\"name\")) -> \n        DynamicValue.Primitive(PrimitiveValue.String(\"John\"))\n    ))\n    assertEquals(value.toString,\n      \"\"\"|{\n         |  \"name\": \"John\"\n         |}\"\"\".stripMargin)\n  }\n  \n  test(\"renders variants with postfix @ metadata\") {\n    // { value: 42 } @ {tag: \"Some\"}\n  }\n  \n  test(\"renders typed primitives with @ metadata\") {\n    // 1705312800 @ {type: \"instant\"}\n  }\n  \n  test(\"renders maps with non-string keys\") {\n    // { true: \"yes\", 42: \"answer\" }\n  }\n  \n  test(\"renders nested variant in record\") {\n    // {\n    //   payment: {\n    //     ccnum: 4111111111111111\n    //   } @ {tag: \"CreditCard\"}\n    // }\n  }\n}\n\nsuite(\"DynamicPatch toString\") {\n  test(\"renders simple set operation\") {\n    // .name = \"John\"\n  }\n  \n  test(\"renders numeric delta\") {\n    // .age += 5\n  }\n  \n  test(\"renders sequence edits with consistent syntax\") {\n    // .items:\n    //   + [0: \"inserted\"]\n    //   + \"appended\"\n    //   - [2]\n  }\n  \n  test(\"renders map edits with consistent syntax\") {\n    // .config:\n    //   + {\"key\": \"value\"}\n    //   - {\"oldKey\"}\n  }\n  \n  test(\"renders multi-operation patch with indentation\") {\n    // DynamicPatch {\n    //   .name = \"John\"\n    //   .tags:\n    //     + \"new\"\n    // }\n  }\n}\n\nsuite(\"Schema toString\") {\n  test(\"renders full structure\") {\n    // Schema {\n    //   record Person {\n    //     name: String\n    //     age: Int\n    //   }\n    // }\n  }\n}\n\nsuite(\"Reflect toString\") {\n  test(\"renders primitive\") {\n    // String\n  }\n  \n  test(\"renders simple record\") {\n    // record Point {\n    //   x: Int\n    //   y: Int\n    // }\n  }\n  \n  test(\"renders nested record fully expanded\") {\n    // record Person {\n    //   name: String\n    //   address: record Address {\n    //     street: String\n    //     city: String\n    //   }\n    // }\n  }\n  \n  test(\"renders variant with cases\") {\n    // variant Option[Int] {\n    //   | None\n    //   | Some(value: Int)\n    // }\n  }\n  \n  test(\"renders sequence with complex element\") {\n    // sequence List[\n    //   record Item {\n    //     name: String\n    //   }\n    // ]\n  }\n  \n  test(\"renders wrapper with complex underlying type\") {\n    // wrapper ValidatedEmail(\n    //   record EmailParts {\n    //     local: String\n    //     domain: String\n    //   }\n    // )\n  }\n  \n  test(\"renders deferred to break recursion\") {\n    // variant Tree[Int] {\n    //   | Leaf(value: Int)\n    //   | Branch(\n    //       left: deferred => Tree[Int],\n    //       right: deferred => Tree[Int]\n    //     )\n    // }\n  }\n}\n```\n\n---\n\n## Files to Modify\n\n- `schema/shared/src/main/scala/zio/blocks/schema/TypeName.scala`\n- `schema/shared/src/main/scala/zio/blocks/schema/DynamicOptic.scala`\n- `schema/shared/src/main/scala/zio/blocks/schema/Optic.scala`\n- `schema/shared/src/main/scala/zio/blocks/schema/Reflect.scala`\n- `schema/shared/src/main/scala/zio/blocks/schema/Schema.scala`\n- `schema/shared/src/main/scala/zio/blocks/schema/DynamicValue.scala`\n- `schema/shared/src/main/scala/zio/blocks/schema/patch/DynamicPatch.scala`\n- `schema/shared/src/main/scala/zio/blocks/schema/patch/Patch.scala`\n- `schema/shared/src/main/scala/zio/blocks/schema/Term.scala`\n- `schema/shared/src/main/scala/zio/blocks/schema/json/Json.scala`\n\n---\n\n## Design References\n\n| Type | Prior Art |\n|------|-----------|\n| TypeName | Scala type syntax |\n| DynamicOptic | zio-blocks path interpolator `p\"...\"` |\n| Optic | zio-blocks `$` macro |\n| Reflect | GraphQL SDL, Protobuf |\n| DynamicValue | JSON (extended for non-string keys and tagged variants) |\n| DynamicPatch | json-diff, unified diff format |\n",
              "url": "https://github.com/zio/zio-blocks/issues/802",
              "tech": [],
              "repo_name": "zio-blocks",
              "repo_owner": "zio",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "ZIO#801",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "ZIO",
              "id": "generated-ZIO",
              "name": "ZIO",
              "description": "",
              "members": [],
              "display_name": "ZIO",
              "created_at": "2026-01-24T11:31:18.430Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/ZIO?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "zio",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-24T11:31:18.430Z",
            "created_at": "2026-01-24T11:31:18.430Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-ZIO#801",
              "status": "open",
              "type": "issue",
              "number": 801,
              "title": "Enhance json interpolator",
              "source": {
                "data": {
                  "id": "source-ZIO#801",
                  "user": {
                    "login": "jdegoes",
                    "id": 156745,
                    "node_id": "MDQ6VXNlcjE1Njc0NQ==",
                    "avatar_url": "https://avatars.githubusercontent.com/u/156745?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/jdegoes",
                    "html_url": "https://github.com/jdegoes",
                    "followers_url": "https://api.github.com/users/jdegoes/followers",
                    "following_url": "https://api.github.com/users/jdegoes/following{/other_user}",
                    "gists_url": "https://api.github.com/users/jdegoes/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/jdegoes/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/jdegoes/subscriptions",
                    "organizations_url": "https://api.github.com/users/jdegoes/orgs",
                    "repos_url": "https://api.github.com/users/jdegoes/repos",
                    "events_url": "https://api.github.com/users/jdegoes/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/jdegoes/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Enhance json interpolator",
                  "body": "# Enhance JSON String Interpolator with Type-Safe Interpolation\n\n## Overview\n\nEnhance the existing `json` string interpolator to support type-safe interpolation in three contexts:\n\n1. **Key position**: Any \"stringable\" type (types defined in `PrimitiveType`)\n2. **Value position**: Any type `A` with a `JsonEncoder[A]` instance\n3. **Inside string literals**: Any stringable type embedded within a JSON string value\n\nAll unsupported interpolations should fail at compile time with helpful error messages.\n\n---\n\n## Background\n\n### Current Behavior\n\nThe existing `json` interpolator (see `JsonInterpolatorSpec`) already supports:\n- Compile-time validation of JSON literal syntax\n- Interpolation of primitives and many standard types in both key and value positions\n- Interpolation of `Option`, `Map`, `Iterable`, `Array`, and `Json` values\n\n### What's Missing\n\n1. **Systematic key position support**: Should accept exactly the \"stringable\" types (those in `PrimitiveType`) rather than an ad-hoc set\n2. **JsonEncoder-based value interpolation**: Should accept any type with `JsonEncoder[A]` in value position\n3. **String literal interpolation**: No current support for `json\"\"\"{\"msg\": \"Hello $name\"}\"\"\"`\n4. **Compile-time errors**: Should fail with clear messages for unsupported types\n\n### Stringable Types\n\n\"Stringable\" types are those defined in `PrimitiveType`, which have canonical string representations:\n\n| Category | Types |\n|----------|-------|\n| Scala primitives | `Unit`, `Boolean`, `Byte`, `Short`, `Int`, `Long`, `Float`, `Double`, `Char`, `String` |\n| Arbitrary precision | `BigInt`, `BigDecimal` |\n| Java Time | `DayOfWeek`, `Duration`, `Instant`, `LocalDate`, `LocalDateTime`, `LocalTime`, `Month`, `MonthDay`, `OffsetDateTime`, `OffsetTime`, `Period`, `Year`, `YearMonth`, `ZoneId`, `ZoneOffset`, `ZonedDateTime` |\n| Java Util | `Currency`, `UUID` |\n\n### JsonEncoder\n\n`JsonEncoder[A]` already exists and has implicit resolution that prioritizes `JsonBinaryCodec[A]` and falls back to derivation from `Schema[A]`. No changes to `JsonEncoder` are required.\n\n---\n\n## Requirements\n\n### 1. Key Position Interpolation\n\nAny stringable type can be interpolated in key position:\n```scala\nval userId = UUID.randomUUID()\nval timestamp = Instant.now()\nval code = 404\n\njson\"\"\"{$userId: \"user data\"}\"\"\"      // UUID key\njson\"\"\"{$timestamp: {\"cpu\": 0.5}}\"\"\"  // Instant key\njson\"\"\"{$code: \"Not Found\"}\"\"\"        // Int key\n```\n\nNon-stringable types in key position must fail at compile time.\n\n### 2. Value Position Interpolation\n\nAny type `A` with `JsonEncoder[A]` can be interpolated in value position:\n```scala\ncase class Address(street: String, city: String)\nobject Address { implicit val schema: Schema[Address] = Schema.derived }\n\ncase class Person(name: String, address: Address)\nobject Person { implicit val schema: Schema[Person] = Schema.derived }\n\nval alice = Person(\"Alice\", Address(\"123 Main\", \"NYC\"))\njson\"\"\"{\"employee\": $alice}\"\"\"  // Works: JsonEncoder derived from Schema[Person]\n\nval team = List(alice)\njson\"\"\"{\"team\": $team}\"\"\"  // Works\n```\n\nTypes without `JsonEncoder` must fail at compile time.\n\n### 3. String Literal Interpolation\n\nStringable types can be embedded inside JSON string values:\n```scala\nval userId = UUID.randomUUID()\nval date = LocalDate.of(2024, 1, 15)\nval version = 3\n\njson\"\"\"{\"id\": \"user-$userId\"}\"\"\"\n// {\"id\": \"user-550e8400-e29b-41d4-a716-446655440000\"}\n\njson\"\"\"{\"path\": \"/reports/$date/v$version\"}\"\"\"\n// {\"path\": \"/reports/2024-01-15/v3\"}\n\n// Both $name and ${expr} syntax work per standard Scala interpolator rules\nval x = 10\njson\"\"\"{\"range\": \"${x * 2} to ${x * 3}\"}\"\"\"\n// {\"range\": \"20 to 30\"}\n```\n\nNon-stringable types inside string literals must fail at compile time.\n\n### 4. Compile-Time Error Messages\n\nError messages should clearly indicate:\n- Which interpolation context failed (key, value, or string literal)\n- What type was provided\n- What is required to fix it\n\n---\n\n## Files to Modify\n\n| File | Changes |\n|------|---------|\n| JSON interpolator macro implementation | Enhance to support three interpolation contexts with appropriate type constraints |\n| `schema/shared/src/test/scala/zio/blocks/schema/json/JsonInterpolatorSpec.scala` | Add comprehensive tests |\n\n---\n\n## Required Tests\n\nAll tests should be added to `JsonInterpolatorSpec.scala`.\n\n### 1. Key Position Tests\n```scala\nsuite(\"key position interpolation\")(\n  test(\"supports all PrimitiveType types as keys\") {\n    val s: String = \"key\"\n    val b: Boolean = true\n    val byte: Byte = 1\n    val short: Short = 2\n    val int: Int = 3\n    val long: Long = 4L\n    val float: Float = 1.5f\n    val double: Double = 2.5\n    val char: Char = 'k'\n    val bigInt: BigInt = BigInt(\"12345678901234567890\")\n    val bigDec: BigDecimal = BigDecimal(\"123.456\")\n    val uuid: UUID = UUID.randomUUID()\n    val instant: Instant = Instant.now()\n    val localDate: LocalDate = LocalDate.of(2024, 1, 15)\n    val localTime: LocalTime = LocalTime.of(10, 30)\n    val localDateTime: LocalDateTime = LocalDateTime.of(2024, 1, 15, 10, 30)\n    val offsetTime: OffsetTime = OffsetTime.of(10, 30, 0, 0, ZoneOffset.UTC)\n    val offsetDateTime: OffsetDateTime = OffsetDateTime.now()\n    val zonedDateTime: ZonedDateTime = ZonedDateTime.now()\n    val duration: Duration = Duration.ofHours(1)\n    val period: Period = Period.ofDays(30)\n    val dayOfWeek: DayOfWeek = DayOfWeek.MONDAY\n    val month: Month = Month.JANUARY\n    val monthDay: MonthDay = MonthDay.of(1, 15)\n    val year: Year = Year.of(2024)\n    val yearMonth: YearMonth = YearMonth.of(2024, 1)\n    val zoneId: ZoneId = ZoneId.of(\"UTC\")\n    val zoneOffset: ZoneOffset = ZoneOffset.UTC\n    val currency: Currency = Currency.getInstance(\"USD\")\n    \n    assertTrue(\n      json\"\"\"{$s: 1}\"\"\".get(s).int == Right(1),\n      json\"\"\"{$b: 1}\"\"\".get(\"true\").int == Right(1),\n      json\"\"\"{$byte: 1}\"\"\".get(\"1\").int == Right(1),\n      json\"\"\"{$short: 1}\"\"\".get(\"2\").int == Right(1),\n      json\"\"\"{$int: 1}\"\"\".get(\"3\").int == Right(1),\n      json\"\"\"{$long: 1}\"\"\".get(\"4\").int == Right(1),\n      json\"\"\"{$uuid: 1}\"\"\".get(uuid.toString).int == Right(1),\n      json\"\"\"{$instant: 1}\"\"\".get(instant.toString).int == Right(1),\n      json\"\"\"{$localDate: 1}\"\"\".get(localDate.toString).int == Right(1),\n      json\"\"\"{$currency: 1}\"\"\".get(\"USD\").int == Right(1)\n      // ... etc for all types\n    )\n  },\n  \n  test(\"property: stringable types work as keys\") {\n    check(Gen.uuid) { uuid =>\n      assertTrue(json\"\"\"{$uuid: \"v\"}\"\"\".get(uuid.toString).string == Right(\"v\"))\n    } &&\n    check(Gen.int) { n =>\n      assertTrue(json\"\"\"{$n: \"v\"}\"\"\".get(n.toString).string == Right(\"v\"))\n    } &&\n    check(genInstant) { instant =>\n      assertTrue(json\"\"\"{$instant: \"v\"}\"\"\".get(instant.toString).string == Right(\"v\"))\n    } &&\n    check(genLocalDate) { date =>\n      assertTrue(json\"\"\"{$date: \"v\"}\"\"\".get(date.toString).string == Right(\"v\"))\n    }\n    // ... etc for other types with generators\n  },\n  \n  test(\"compile fails for non-stringable types in key position\") {\n    typeCheck(\"\"\"\n      case class Point(x: Int, y: Int)\n      object Point { implicit val schema: Schema[Point] = Schema.derived }\n      val p = Point(1, 2)\n      json\"\"{$p: \"value\"}\"\"\n    \"\"\").map(assert(_)(isLeft(containsString(\"key\"))))\n  } @@ TestAspect.exceptNative\n)\n```\n\n### 2. Value Position Tests\n```scala\nsuite(\"value position interpolation\")(\n  test(\"supports types with Schema\") {\n    case class Address(street: String, city: String)\n    object Address { implicit val schema: Schema[Address] = Schema.derived }\n    \n    case class Person(name: String, age: Int, address: Address)\n    object Person { implicit val schema: Schema[Person] = Schema.derived }\n    \n    val alice = Person(\"Alice\", 30, Address(\"123 Main\", \"NYC\"))\n    val result = json\"\"\"{\"employee\": $alice}\"\"\"\n    \n    assertTrue(\n      result.get(\"employee\").get(\"name\").string == Right(\"Alice\"),\n      result.get(\"employee\").get(\"age\").int == Right(30),\n      result.get(\"employee\").get(\"address\").get(\"city\").string == Right(\"NYC\")\n    )\n  },\n  \n  test(\"supports nested complex types\") {\n    case class Inner(value: Int)\n    object Inner { implicit val schema: Schema[Inner] = Schema.derived }\n    \n    case class Outer(inner: Inner, inners: List[Inner])\n    object Outer { implicit val schema: Schema[Outer] = Schema.derived }\n    \n    val o = Outer(Inner(1), List(Inner(2), Inner(3)))\n    val result = json\"\"\"{\"data\": $o}\"\"\"\n    \n    assertTrue(\n      result.get(\"data\").get(\"inner\").get(\"value\").int == Right(1),\n      result.get(\"data\").get(\"inners\")(0).get(\"value\").int == Right(2)\n    )\n  },\n  \n  test(\"supports sealed traits\") {\n    sealed trait Status\n    object Status {\n      case object Active extends Status\n      case class Suspended(reason: String) extends Status\n      implicit val schema: Schema[Status] = Schema.derived\n    }\n    \n    val active: Status = Status.Active\n    val suspended: Status = Status.Suspended(\"Payment overdue\")\n    \n    assertTrue(\n      json\"\"\"{\"status\": $active}\"\"\".get(\"status\").one.isRight,\n      json\"\"\"{\"status\": $suspended}\"\"\".get(\"status\").get(\"Suspended\").get(\"reason\").string == Right(\"Payment overdue\")\n    )\n  },\n  \n  test(\"supports Option of complex types\") {\n    case class Item(name: String)\n    object Item { implicit val schema: Schema[Item] = Schema.derived }\n    \n    val some: Option[Item] = Some(Item(\"thing\"))\n    val none: Option[Item] = None\n    \n    assertTrue(\n      json\"\"\"{\"item\": $some}\"\"\".get(\"item\").get(\"name\").string == Right(\"thing\"),\n      json\"\"\"{\"item\": $none}\"\"\".get(\"item\").one == Right(Json.Null)\n    )\n  },\n  \n  test(\"supports collections of complex types\") {\n    case class Point(x: Int, y: Int)\n    object Point { implicit val schema: Schema[Point] = Schema.derived }\n    \n    val points = List(Point(1, 2), Point(3, 4))\n    val pointSet = Set(Point(5, 6))\n    val pointVec = Vector(Point(7, 8))\n    \n    assertTrue(\n      json\"\"\"{\"points\": $points}\"\"\".get(\"points\")(0).get(\"x\").int == Right(1),\n      json\"\"\"{\"points\": $pointSet}\"\"\".get(\"points\")(0).get(\"x\").int == Right(5),\n      json\"\"\"{\"points\": $pointVec}\"\"\".get(\"points\")(0).get(\"x\").int == Right(7)\n    )\n  },\n  \n  test(\"supports Map with complex value types\") {\n    case class Stats(count: Int)\n    object Stats { implicit val schema: Schema[Stats] = Schema.derived }\n    \n    val data = Map(\"a\" -> Stats(10), \"b\" -> Stats(20))\n    val result = json\"\"\"{\"stats\": $data}\"\"\"\n    \n    assertTrue(\n      result.get(\"stats\").get(\"a\").get(\"count\").int == Right(10),\n      result.get(\"stats\").get(\"b\").get(\"count\").int == Right(20)\n    )\n  },\n  \n  test(\"compile fails for types without JsonEncoder\") {\n    typeCheck(\"\"\"\n      case class NoSchema(x: Int)\n      val v = NoSchema(1)\n      json\"{\"value\": $v}\"\n    \"\"\").map(assert(_)(isLeft))\n  } @@ TestAspect.exceptNative\n)\n```\n\n### 3. String Literal Interpolation Tests\n```scala\nsuite(\"string literal interpolation\")(\n  test(\"supports String interpolation in strings\") {\n    val name = \"Alice\"\n    assertTrue(\n      json\"\"\"{\"greeting\": \"Hello, $name!\"}\"\"\".get(\"greeting\").string == Right(\"Hello, Alice!\")\n    )\n  },\n  \n  test(\"supports numeric types in strings\") {\n    val x = 42\n    val y = 3.14\n    val big = BigInt(\"12345678901234567890\")\n    \n    assertTrue(\n      json\"\"\"{\"msg\": \"x is $x\"}\"\"\".get(\"msg\").string == Right(\"x is 42\"),\n      json\"\"\"{\"msg\": \"y is $y\"}\"\"\".get(\"msg\").string == Right(\"y is 3.14\"),\n      json\"\"\"{\"msg\": \"big is $big\"}\"\"\".get(\"msg\").string == Right(\"big is 12345678901234567890\")\n    )\n  },\n  \n  test(\"supports UUID in strings\") {\n    val id = UUID.fromString(\"550e8400-e29b-41d4-a716-446655440000\")\n    assertTrue(\n      json\"\"\"{\"ref\": \"user-$id\"}\"\"\".get(\"ref\").string == Right(\"user-550e8400-e29b-41d4-a716-446655440000\")\n    )\n  },\n  \n  test(\"supports temporal types in strings\") {\n    val date = LocalDate.of(2024, 1, 15)\n    val time = LocalTime.of(10, 30, 0)\n    val instant = Instant.parse(\"2024-01-15T10:30:00Z\")\n    \n    assertTrue(\n      json\"\"\"{\"file\": \"report-$date.pdf\"}\"\"\".get(\"file\").string == Right(\"report-2024-01-15.pdf\"),\n      json\"\"\"{\"log\": \"Event at $time\"}\"\"\".get(\"log\").string == Right(\"Event at 10:30\"),\n      json\"\"\"{\"ts\": \"Created: $instant\"}\"\"\".get(\"ts\").string == Right(\"Created: 2024-01-15T10:30:00Z\")\n    )\n  },\n  \n  test(\"supports Currency in strings\") {\n    val currency = Currency.getInstance(\"USD\")\n    assertTrue(\n      json\"\"\"{\"label\": \"Price in $currency\"}\"\"\".get(\"label\").string == Right(\"Price in USD\")\n    )\n  },\n  \n  test(\"supports ${expr} syntax for expressions\") {\n    val x = 10\n    val items = List(\"a\", \"b\", \"c\")\n    \n    assertTrue(\n      json\"\"\"{\"range\": \"${x * 2} to ${x * 3}\"}\"\"\".get(\"range\").string == Right(\"20 to 30\"),\n      json\"\"\"{\"count\": \"Found ${items.size} items\"}\"\"\".get(\"count\").string == Right(\"Found 3 items\")\n    )\n  },\n  \n  test(\"supports multiple interpolations in one string\") {\n    val date = LocalDate.of(2024, 1, 15)\n    val version = 3\n    val env = \"prod\"\n    \n    assertTrue(\n      json\"\"\"{\"path\": \"/data/$env/$date/v$version/output.json\"}\"\"\".get(\"path\").string == \n        Right(\"/data/prod/2024-01-15/v3/output.json\")\n    )\n  },\n  \n  test(\"handles empty interpolation results\") {\n    val empty = \"\"\n    assertTrue(\n      json\"\"\"{\"msg\": \"[$empty]\"}\"\"\".get(\"msg\").string == Right(\"[]\")\n    )\n  },\n  \n  test(\"handles special characters in interpolated strings\") {\n    val path = \"foo/bar\"\n    val query = \"a=1&b=2\"\n    \n    assertTrue(\n      json\"\"\"{\"url\": \"http://example.com/$path?$query\"}\"\"\".get(\"url\").string == \n        Right(\"http://example.com/foo/bar?a=1&b=2\")\n    )\n  },\n  \n  test(\"compile fails for non-stringable types in string literals\") {\n    typeCheck(\"\"\"\n      case class Point(x: Int, y: Int)\n      object Point { implicit val schema: Schema[Point] = Schema.derived }\n      val p = Point(1, 2)\n      json\"{\"msg\": \"Point is $p\"}\"\n    \"\"\").map(assert(_)(isLeft))\n  } @@ TestAspect.exceptNative\n)\n```\n\n### 4. Mixed Context Tests\n```scala\nsuite(\"mixed interpolation contexts\")(\n  test(\"combines key, value, and string interpolation\") {\n    case class Data(value: Int)\n    object Data { implicit val schema: Schema[Data] = Schema.derived }\n    \n    val key = UUID.randomUUID()\n    val data = Data(42)\n    val timestamp = Instant.now()\n    \n    val result = json\"\"\"{\n      $key: {\n        \"data\": $data,\n        \"note\": \"Recorded at $timestamp\"\n      }\n    }\"\"\"\n    \n    assertTrue(\n      result.get(key.toString).get(\"data\").get(\"value\").int == Right(42),\n      result.get(key.toString).get(\"note\").string == Right(s\"Recorded at $timestamp\")\n    )\n  },\n  \n  test(\"multiple keys with different stringable types\") {\n    val intKey = 1\n    val uuidKey = UUID.randomUUID()\n    val dateKey = LocalDate.of(2024, 1, 15)\n    \n    val result = json\"\"\"{\n      $intKey: \"one\",\n      $uuidKey: \"uuid\",\n      $dateKey: \"date\"\n    }\"\"\"\n    \n    assertTrue(\n      result.get(\"1\").string == Right(\"one\"),\n      result.get(uuidKey.toString).string == Right(\"uuid\"),\n      result.get(\"2024-01-15\").string == Right(\"date\")\n    )\n  },\n  \n  test(\"array with mixed value types\") {\n    case class Item(n: Int)\n    object Item { implicit val schema: Schema[Item] = Schema.derived }\n    \n    val item = Item(1)\n    val num = 42\n    val str = \"hello\"\n    \n    val result = json\"\"\"[$item, $num, $str]\"\"\"\n    \n    assertTrue(\n      result(0).get(\"n\").int == Right(1),\n      result(1).int == Right(42),\n      result(2).string == Right(\"hello\")\n    )\n  }\n)\n```\n\n---\n\n## Acceptance Criteria\n\n- [ ] All stringable types (those in `PrimitiveType`) work in key position\n- [ ] All stringable types work inside string literals (e.g., `\"hello $name\"`)\n- [ ] Any type with `JsonEncoder[A]` works in value position\n- [ ] Compile-time failure with clear error messages for:\n  - Non-stringable type in key position\n  - Type without `JsonEncoder` in value position\n  - Non-stringable type inside a string literal\n- [ ] Existing interpolator functionality is preserved (no regressions)\n- [ ] All tests pass on JVM, JS, and Native platforms (except `typeCheck` tests on Native)\n- [ ] Code follows existing project style and conventions",
                  "html_url": "https://github.com/zio/zio-blocks/issues/801"
                },
                "type": "github"
              },
              "hash": "zio/zio-blocks#801",
              "body": "# Enhance JSON String Interpolator with Type-Safe Interpolation\n\n## Overview\n\nEnhance the existing `json` string interpolator to support type-safe interpolation in three contexts:\n\n1. **Key position**: Any \"stringable\" type (types defined in `PrimitiveType`)\n2. **Value position**: Any type `A` with a `JsonEncoder[A]` instance\n3. **Inside string literals**: Any stringable type embedded within a JSON string value\n\nAll unsupported interpolations should fail at compile time with helpful error messages.\n\n---\n\n## Background\n\n### Current Behavior\n\nThe existing `json` interpolator (see `JsonInterpolatorSpec`) already supports:\n- Compile-time validation of JSON literal syntax\n- Interpolation of primitives and many standard types in both key and value positions\n- Interpolation of `Option`, `Map`, `Iterable`, `Array`, and `Json` values\n\n### What's Missing\n\n1. **Systematic key position support**: Should accept exactly the \"stringable\" types (those in `PrimitiveType`) rather than an ad-hoc set\n2. **JsonEncoder-based value interpolation**: Should accept any type with `JsonEncoder[A]` in value position\n3. **String literal interpolation**: No current support for `json\"\"\"{\"msg\": \"Hello $name\"}\"\"\"`\n4. **Compile-time errors**: Should fail with clear messages for unsupported types\n\n### Stringable Types\n\n\"Stringable\" types are those defined in `PrimitiveType`, which have canonical string representations:\n\n| Category | Types |\n|----------|-------|\n| Scala primitives | `Unit`, `Boolean`, `Byte`, `Short`, `Int`, `Long`, `Float`, `Double`, `Char`, `String` |\n| Arbitrary precision | `BigInt`, `BigDecimal` |\n| Java Time | `DayOfWeek`, `Duration`, `Instant`, `LocalDate`, `LocalDateTime`, `LocalTime`, `Month`, `MonthDay`, `OffsetDateTime`, `OffsetTime`, `Period`, `Year`, `YearMonth`, `ZoneId`, `ZoneOffset`, `ZonedDateTime` |\n| Java Util | `Currency`, `UUID` |\n\n### JsonEncoder\n\n`JsonEncoder[A]` already exists and has implicit resolution that prioritizes `JsonBinaryCodec[A]` and falls back to derivation from `Schema[A]`. No changes to `JsonEncoder` are required.\n\n---\n\n## Requirements\n\n### 1. Key Position Interpolation\n\nAny stringable type can be interpolated in key position:\n```scala\nval userId = UUID.randomUUID()\nval timestamp = Instant.now()\nval code = 404\n\njson\"\"\"{$userId: \"user data\"}\"\"\"      // UUID key\njson\"\"\"{$timestamp: {\"cpu\": 0.5}}\"\"\"  // Instant key\njson\"\"\"{$code: \"Not Found\"}\"\"\"        // Int key\n```\n\nNon-stringable types in key position must fail at compile time.\n\n### 2. Value Position Interpolation\n\nAny type `A` with `JsonEncoder[A]` can be interpolated in value position:\n```scala\ncase class Address(street: String, city: String)\nobject Address { implicit val schema: Schema[Address] = Schema.derived }\n\ncase class Person(name: String, address: Address)\nobject Person { implicit val schema: Schema[Person] = Schema.derived }\n\nval alice = Person(\"Alice\", Address(\"123 Main\", \"NYC\"))\njson\"\"\"{\"employee\": $alice}\"\"\"  // Works: JsonEncoder derived from Schema[Person]\n\nval team = List(alice)\njson\"\"\"{\"team\": $team}\"\"\"  // Works\n```\n\nTypes without `JsonEncoder` must fail at compile time.\n\n### 3. String Literal Interpolation\n\nStringable types can be embedded inside JSON string values:\n```scala\nval userId = UUID.randomUUID()\nval date = LocalDate.of(2024, 1, 15)\nval version = 3\n\njson\"\"\"{\"id\": \"user-$userId\"}\"\"\"\n// {\"id\": \"user-550e8400-e29b-41d4-a716-446655440000\"}\n\njson\"\"\"{\"path\": \"/reports/$date/v$version\"}\"\"\"\n// {\"path\": \"/reports/2024-01-15/v3\"}\n\n// Both $name and ${expr} syntax work per standard Scala interpolator rules\nval x = 10\njson\"\"\"{\"range\": \"${x * 2} to ${x * 3}\"}\"\"\"\n// {\"range\": \"20 to 30\"}\n```\n\nNon-stringable types inside string literals must fail at compile time.\n\n### 4. Compile-Time Error Messages\n\nError messages should clearly indicate:\n- Which interpolation context failed (key, value, or string literal)\n- What type was provided\n- What is required to fix it\n\n---\n\n## Files to Modify\n\n| File | Changes |\n|------|---------|\n| JSON interpolator macro implementation | Enhance to support three interpolation contexts with appropriate type constraints |\n| `schema/shared/src/test/scala/zio/blocks/schema/json/JsonInterpolatorSpec.scala` | Add comprehensive tests |\n\n---\n\n## Required Tests\n\nAll tests should be added to `JsonInterpolatorSpec.scala`.\n\n### 1. Key Position Tests\n```scala\nsuite(\"key position interpolation\")(\n  test(\"supports all PrimitiveType types as keys\") {\n    val s: String = \"key\"\n    val b: Boolean = true\n    val byte: Byte = 1\n    val short: Short = 2\n    val int: Int = 3\n    val long: Long = 4L\n    val float: Float = 1.5f\n    val double: Double = 2.5\n    val char: Char = 'k'\n    val bigInt: BigInt = BigInt(\"12345678901234567890\")\n    val bigDec: BigDecimal = BigDecimal(\"123.456\")\n    val uuid: UUID = UUID.randomUUID()\n    val instant: Instant = Instant.now()\n    val localDate: LocalDate = LocalDate.of(2024, 1, 15)\n    val localTime: LocalTime = LocalTime.of(10, 30)\n    val localDateTime: LocalDateTime = LocalDateTime.of(2024, 1, 15, 10, 30)\n    val offsetTime: OffsetTime = OffsetTime.of(10, 30, 0, 0, ZoneOffset.UTC)\n    val offsetDateTime: OffsetDateTime = OffsetDateTime.now()\n    val zonedDateTime: ZonedDateTime = ZonedDateTime.now()\n    val duration: Duration = Duration.ofHours(1)\n    val period: Period = Period.ofDays(30)\n    val dayOfWeek: DayOfWeek = DayOfWeek.MONDAY\n    val month: Month = Month.JANUARY\n    val monthDay: MonthDay = MonthDay.of(1, 15)\n    val year: Year = Year.of(2024)\n    val yearMonth: YearMonth = YearMonth.of(2024, 1)\n    val zoneId: ZoneId = ZoneId.of(\"UTC\")\n    val zoneOffset: ZoneOffset = ZoneOffset.UTC\n    val currency: Currency = Currency.getInstance(\"USD\")\n    \n    assertTrue(\n      json\"\"\"{$s: 1}\"\"\".get(s).int == Right(1),\n      json\"\"\"{$b: 1}\"\"\".get(\"true\").int == Right(1),\n      json\"\"\"{$byte: 1}\"\"\".get(\"1\").int == Right(1),\n      json\"\"\"{$short: 1}\"\"\".get(\"2\").int == Right(1),\n      json\"\"\"{$int: 1}\"\"\".get(\"3\").int == Right(1),\n      json\"\"\"{$long: 1}\"\"\".get(\"4\").int == Right(1),\n      json\"\"\"{$uuid: 1}\"\"\".get(uuid.toString).int == Right(1),\n      json\"\"\"{$instant: 1}\"\"\".get(instant.toString).int == Right(1),\n      json\"\"\"{$localDate: 1}\"\"\".get(localDate.toString).int == Right(1),\n      json\"\"\"{$currency: 1}\"\"\".get(\"USD\").int == Right(1)\n      // ... etc for all types\n    )\n  },\n  \n  test(\"property: stringable types work as keys\") {\n    check(Gen.uuid) { uuid =>\n      assertTrue(json\"\"\"{$uuid: \"v\"}\"\"\".get(uuid.toString).string == Right(\"v\"))\n    } &&\n    check(Gen.int) { n =>\n      assertTrue(json\"\"\"{$n: \"v\"}\"\"\".get(n.toString).string == Right(\"v\"))\n    } &&\n    check(genInstant) { instant =>\n      assertTrue(json\"\"\"{$instant: \"v\"}\"\"\".get(instant.toString).string == Right(\"v\"))\n    } &&\n    check(genLocalDate) { date =>\n      assertTrue(json\"\"\"{$date: \"v\"}\"\"\".get(date.toString).string == Right(\"v\"))\n    }\n    // ... etc for other types with generators\n  },\n  \n  test(\"compile fails for non-stringable types in key position\") {\n    typeCheck(\"\"\"\n      case class Point(x: Int, y: Int)\n      object Point { implicit val schema: Schema[Point] = Schema.derived }\n      val p = Point(1, 2)\n      json\"\"{$p: \"value\"}\"\"\n    \"\"\").map(assert(_)(isLeft(containsString(\"key\"))))\n  } @@ TestAspect.exceptNative\n)\n```\n\n### 2. Value Position Tests\n```scala\nsuite(\"value position interpolation\")(\n  test(\"supports types with Schema\") {\n    case class Address(street: String, city: String)\n    object Address { implicit val schema: Schema[Address] = Schema.derived }\n    \n    case class Person(name: String, age: Int, address: Address)\n    object Person { implicit val schema: Schema[Person] = Schema.derived }\n    \n    val alice = Person(\"Alice\", 30, Address(\"123 Main\", \"NYC\"))\n    val result = json\"\"\"{\"employee\": $alice}\"\"\"\n    \n    assertTrue(\n      result.get(\"employee\").get(\"name\").string == Right(\"Alice\"),\n      result.get(\"employee\").get(\"age\").int == Right(30),\n      result.get(\"employee\").get(\"address\").get(\"city\").string == Right(\"NYC\")\n    )\n  },\n  \n  test(\"supports nested complex types\") {\n    case class Inner(value: Int)\n    object Inner { implicit val schema: Schema[Inner] = Schema.derived }\n    \n    case class Outer(inner: Inner, inners: List[Inner])\n    object Outer { implicit val schema: Schema[Outer] = Schema.derived }\n    \n    val o = Outer(Inner(1), List(Inner(2), Inner(3)))\n    val result = json\"\"\"{\"data\": $o}\"\"\"\n    \n    assertTrue(\n      result.get(\"data\").get(\"inner\").get(\"value\").int == Right(1),\n      result.get(\"data\").get(\"inners\")(0).get(\"value\").int == Right(2)\n    )\n  },\n  \n  test(\"supports sealed traits\") {\n    sealed trait Status\n    object Status {\n      case object Active extends Status\n      case class Suspended(reason: String) extends Status\n      implicit val schema: Schema[Status] = Schema.derived\n    }\n    \n    val active: Status = Status.Active\n    val suspended: Status = Status.Suspended(\"Payment overdue\")\n    \n    assertTrue(\n      json\"\"\"{\"status\": $active}\"\"\".get(\"status\").one.isRight,\n      json\"\"\"{\"status\": $suspended}\"\"\".get(\"status\").get(\"Suspended\").get(\"reason\").string == Right(\"Payment overdue\")\n    )\n  },\n  \n  test(\"supports Option of complex types\") {\n    case class Item(name: String)\n    object Item { implicit val schema: Schema[Item] = Schema.derived }\n    \n    val some: Option[Item] = Some(Item(\"thing\"))\n    val none: Option[Item] = None\n    \n    assertTrue(\n      json\"\"\"{\"item\": $some}\"\"\".get(\"item\").get(\"name\").string == Right(\"thing\"),\n      json\"\"\"{\"item\": $none}\"\"\".get(\"item\").one == Right(Json.Null)\n    )\n  },\n  \n  test(\"supports collections of complex types\") {\n    case class Point(x: Int, y: Int)\n    object Point { implicit val schema: Schema[Point] = Schema.derived }\n    \n    val points = List(Point(1, 2), Point(3, 4))\n    val pointSet = Set(Point(5, 6))\n    val pointVec = Vector(Point(7, 8))\n    \n    assertTrue(\n      json\"\"\"{\"points\": $points}\"\"\".get(\"points\")(0).get(\"x\").int == Right(1),\n      json\"\"\"{\"points\": $pointSet}\"\"\".get(\"points\")(0).get(\"x\").int == Right(5),\n      json\"\"\"{\"points\": $pointVec}\"\"\".get(\"points\")(0).get(\"x\").int == Right(7)\n    )\n  },\n  \n  test(\"supports Map with complex value types\") {\n    case class Stats(count: Int)\n    object Stats { implicit val schema: Schema[Stats] = Schema.derived }\n    \n    val data = Map(\"a\" -> Stats(10), \"b\" -> Stats(20))\n    val result = json\"\"\"{\"stats\": $data}\"\"\"\n    \n    assertTrue(\n      result.get(\"stats\").get(\"a\").get(\"count\").int == Right(10),\n      result.get(\"stats\").get(\"b\").get(\"count\").int == Right(20)\n    )\n  },\n  \n  test(\"compile fails for types without JsonEncoder\") {\n    typeCheck(\"\"\"\n      case class NoSchema(x: Int)\n      val v = NoSchema(1)\n      json\"{\"value\": $v}\"\n    \"\"\").map(assert(_)(isLeft))\n  } @@ TestAspect.exceptNative\n)\n```\n\n### 3. String Literal Interpolation Tests\n```scala\nsuite(\"string literal interpolation\")(\n  test(\"supports String interpolation in strings\") {\n    val name = \"Alice\"\n    assertTrue(\n      json\"\"\"{\"greeting\": \"Hello, $name!\"}\"\"\".get(\"greeting\").string == Right(\"Hello, Alice!\")\n    )\n  },\n  \n  test(\"supports numeric types in strings\") {\n    val x = 42\n    val y = 3.14\n    val big = BigInt(\"12345678901234567890\")\n    \n    assertTrue(\n      json\"\"\"{\"msg\": \"x is $x\"}\"\"\".get(\"msg\").string == Right(\"x is 42\"),\n      json\"\"\"{\"msg\": \"y is $y\"}\"\"\".get(\"msg\").string == Right(\"y is 3.14\"),\n      json\"\"\"{\"msg\": \"big is $big\"}\"\"\".get(\"msg\").string == Right(\"big is 12345678901234567890\")\n    )\n  },\n  \n  test(\"supports UUID in strings\") {\n    val id = UUID.fromString(\"550e8400-e29b-41d4-a716-446655440000\")\n    assertTrue(\n      json\"\"\"{\"ref\": \"user-$id\"}\"\"\".get(\"ref\").string == Right(\"user-550e8400-e29b-41d4-a716-446655440000\")\n    )\n  },\n  \n  test(\"supports temporal types in strings\") {\n    val date = LocalDate.of(2024, 1, 15)\n    val time = LocalTime.of(10, 30, 0)\n    val instant = Instant.parse(\"2024-01-15T10:30:00Z\")\n    \n    assertTrue(\n      json\"\"\"{\"file\": \"report-$date.pdf\"}\"\"\".get(\"file\").string == Right(\"report-2024-01-15.pdf\"),\n      json\"\"\"{\"log\": \"Event at $time\"}\"\"\".get(\"log\").string == Right(\"Event at 10:30\"),\n      json\"\"\"{\"ts\": \"Created: $instant\"}\"\"\".get(\"ts\").string == Right(\"Created: 2024-01-15T10:30:00Z\")\n    )\n  },\n  \n  test(\"supports Currency in strings\") {\n    val currency = Currency.getInstance(\"USD\")\n    assertTrue(\n      json\"\"\"{\"label\": \"Price in $currency\"}\"\"\".get(\"label\").string == Right(\"Price in USD\")\n    )\n  },\n  \n  test(\"supports ${expr} syntax for expressions\") {\n    val x = 10\n    val items = List(\"a\", \"b\", \"c\")\n    \n    assertTrue(\n      json\"\"\"{\"range\": \"${x * 2} to ${x * 3}\"}\"\"\".get(\"range\").string == Right(\"20 to 30\"),\n      json\"\"\"{\"count\": \"Found ${items.size} items\"}\"\"\".get(\"count\").string == Right(\"Found 3 items\")\n    )\n  },\n  \n  test(\"supports multiple interpolations in one string\") {\n    val date = LocalDate.of(2024, 1, 15)\n    val version = 3\n    val env = \"prod\"\n    \n    assertTrue(\n      json\"\"\"{\"path\": \"/data/$env/$date/v$version/output.json\"}\"\"\".get(\"path\").string == \n        Right(\"/data/prod/2024-01-15/v3/output.json\")\n    )\n  },\n  \n  test(\"handles empty interpolation results\") {\n    val empty = \"\"\n    assertTrue(\n      json\"\"\"{\"msg\": \"[$empty]\"}\"\"\".get(\"msg\").string == Right(\"[]\")\n    )\n  },\n  \n  test(\"handles special characters in interpolated strings\") {\n    val path = \"foo/bar\"\n    val query = \"a=1&b=2\"\n    \n    assertTrue(\n      json\"\"\"{\"url\": \"http://example.com/$path?$query\"}\"\"\".get(\"url\").string == \n        Right(\"http://example.com/foo/bar?a=1&b=2\")\n    )\n  },\n  \n  test(\"compile fails for non-stringable types in string literals\") {\n    typeCheck(\"\"\"\n      case class Point(x: Int, y: Int)\n      object Point { implicit val schema: Schema[Point] = Schema.derived }\n      val p = Point(1, 2)\n      json\"{\"msg\": \"Point is $p\"}\"\n    \"\"\").map(assert(_)(isLeft))\n  } @@ TestAspect.exceptNative\n)\n```\n\n### 4. Mixed Context Tests\n```scala\nsuite(\"mixed interpolation contexts\")(\n  test(\"combines key, value, and string interpolation\") {\n    case class Data(value: Int)\n    object Data { implicit val schema: Schema[Data] = Schema.derived }\n    \n    val key = UUID.randomUUID()\n    val data = Data(42)\n    val timestamp = Instant.now()\n    \n    val result = json\"\"\"{\n      $key: {\n        \"data\": $data,\n        \"note\": \"Recorded at $timestamp\"\n      }\n    }\"\"\"\n    \n    assertTrue(\n      result.get(key.toString).get(\"data\").get(\"value\").int == Right(42),\n      result.get(key.toString).get(\"note\").string == Right(s\"Recorded at $timestamp\")\n    )\n  },\n  \n  test(\"multiple keys with different stringable types\") {\n    val intKey = 1\n    val uuidKey = UUID.randomUUID()\n    val dateKey = LocalDate.of(2024, 1, 15)\n    \n    val result = json\"\"\"{\n      $intKey: \"one\",\n      $uuidKey: \"uuid\",\n      $dateKey: \"date\"\n    }\"\"\"\n    \n    assertTrue(\n      result.get(\"1\").string == Right(\"one\"),\n      result.get(uuidKey.toString).string == Right(\"uuid\"),\n      result.get(\"2024-01-15\").string == Right(\"date\")\n    )\n  },\n  \n  test(\"array with mixed value types\") {\n    case class Item(n: Int)\n    object Item { implicit val schema: Schema[Item] = Schema.derived }\n    \n    val item = Item(1)\n    val num = 42\n    val str = \"hello\"\n    \n    val result = json\"\"\"[$item, $num, $str]\"\"\"\n    \n    assertTrue(\n      result(0).get(\"n\").int == Right(1),\n      result(1).int == Right(42),\n      result(2).string == Right(\"hello\")\n    )\n  }\n)\n```\n\n---\n\n## Acceptance Criteria\n\n- [ ] All stringable types (those in `PrimitiveType`) work in key position\n- [ ] All stringable types work inside string literals (e.g., `\"hello $name\"`)\n- [ ] Any type with `JsonEncoder[A]` works in value position\n- [ ] Compile-time failure with clear error messages for:\n  - Non-stringable type in key position\n  - Type without `JsonEncoder` in value position\n  - Non-stringable type inside a string literal\n- [ ] Existing interpolator functionality is preserved (no regressions)\n- [ ] All tests pass on JVM, JS, and Native platforms (except `typeCheck` tests on Native)\n- [ ] Code follows existing project style and conventions",
              "url": "https://github.com/zio/zio-blocks/issues/801",
              "tech": [],
              "repo_name": "zio-blocks",
              "repo_owner": "zio",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "ZIO#462",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "ZIO",
              "id": "generated-ZIO",
              "name": "ZIO",
              "description": "",
              "members": [],
              "display_name": "ZIO",
              "created_at": "2026-01-24T11:31:18.615Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/ZIO?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "zio",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-24T11:31:18.615Z",
            "created_at": "2026-01-24T11:31:18.615Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-ZIO#462",
              "status": "open",
              "type": "issue",
              "number": 462,
              "title": "JSON Schema Support",
              "source": {
                "data": {
                  "id": "source-ZIO#462",
                  "user": {
                    "login": "jdegoes",
                    "id": 156745,
                    "node_id": "MDQ6VXNlcjE1Njc0NQ==",
                    "avatar_url": "https://avatars.githubusercontent.com/u/156745?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/jdegoes",
                    "html_url": "https://github.com/jdegoes",
                    "followers_url": "https://api.github.com/users/jdegoes/followers",
                    "following_url": "https://api.github.com/users/jdegoes/following{/other_user}",
                    "gists_url": "https://api.github.com/users/jdegoes/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/jdegoes/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/jdegoes/subscriptions",
                    "organizations_url": "https://api.github.com/users/jdegoes/orgs",
                    "repos_url": "https://api.github.com/users/jdegoes/repos",
                    "events_url": "https://api.github.com/users/jdegoes/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/jdegoes/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "JSON Schema Support",
                  "body": "# Add JSON Schema 2020-12 Support\n\n## Overview\n\nThis ticket adds first-class [JSON Schema 2020-12](https://json-schema.org/draft/2020-12/json-schema-core) support to ZIO Blocks, enabling:\n\n1. A `JsonSchema` ADT that precisely models the JSON Schema specification\n2. Bidirectional conversion between `Schema[A]` and `JsonSchema`\n3. Runtime validation of `Json` values against `JsonSchema`\n4. Schema extraction from `JsonBinaryCodec[A]` instances\n\nThis follows the established pattern used by `AvroBinaryCodec`, which exposes an `avroSchema: AvroSchema` field for each codec instance.\n\n---\n\n## Background: ZIO Blocks Architecture\n\nIf you're new to ZIO Blocks (ZIO Schema 2), here's the essential context:\n\n### Core Types\n\n| Type | Purpose |\n|------|---------|\n| `Schema[A]` | Reified structure of Scala type `A` with construction/deconstruction capabilities |\n| `Reflect[F, A]` | The underlying ADT representing type structure. `Schema[A]` wraps `Reflect[Binding, A]` |\n| `DynamicValue` | A semi-structured representation (superset of JSON) that any `Schema[A]` can convert to/from |\n| `Json` | The JSON AST in `zio.blocks.schema.json` |\n| `JsonBinaryCodec[A]` | Typeclass for JSON serialization, derived from `Schema[A]` via `JsonBinaryCodecDeriver` |\n\n### How Derivation Works\n```scala\ncase class Person(name: String, age: Int)\nobject Person {\n  implicit val schema: Schema[Person] = Schema.derived\n}\n\n// Derive a JSON codec from the schema:\nval codec: JsonBinaryCodec[Person] = Schema[Person].derive(JsonFormat.deriver)\n\n// Or use encode/decode directly (caches the codec):\nSchema[Person].encode(JsonFormat)(buffer)(person)\nSchema[Person].decode(JsonFormat)(buffer)\n```\n\n### Key Insight: DynamicValue as the Bridge\n\n`Schema[A]` can convert any `A` to `DynamicValue` and back. Since `DynamicValue` is structurally similar to JSON, and `Json.fromDynamicValue` / `Json.toDynamicValue` exist, we can create `Schema[Json]` by wrapping `Schema[DynamicValue]`.\n\nThis is how `Schema.fromJsonSchema` will work: it wraps `Schema[DynamicValue]` with validation logic that checks the `JsonSchema` constraints.\n\n### Metadata That Maps to JSON Schema\n\n| ZIO Blocks Type | JSON Schema Equivalent |\n|-----------------|------------------------|\n| `TypeName[A]` | Can be stored in `$id` or custom extension for round-trip |\n| `Doc` | `title` / `description` |\n| `Validation[A]` | `minimum`, `maximum`, `minLength`, `maxLength`, `pattern`, etc. |\n| `Modifier.rename` | Affects property names |\n| `Modifier.alias` | Could map to extension for alternative names |\n| `Modifier.transient` | Field excluded from schema |\n| `Modifier.config` | Extensible metadata (e.g., `\"json-schema.format\" -> \"email\"`) |\n| `DiscriminatorKind` | Affects `oneOf`/`anyOf` structure and `discriminator` keyword |\n| `NameMapper` | Applied to field/case names during schema generation |\n\n### Reference: AvroBinaryCodec Pattern\n\nLook at `AvroBinaryCodec` for the established pattern. Each codec instance has:\n```scala\nabstract class AvroBinaryCodec[A](...) extends BinaryCodec[A] {\n  def avroSchema: AvroSchema  // <-- We want the equivalent for JSON Schema\n  // ...\n}\n```\n\nThe `AvroFormat` deriver constructs the `avroSchema` for each primitive, record, variant, sequence, map, and wrapper type.\n\n---\n\n## Requirements\n\n### 1. Create `JsonSchema` ADT\n\nCreate a new sealed trait `JsonSchema` in `zio.blocks.schema.json` that models JSON Schema 2020-12.\n\n**Location:** `schema/shared/src/main/scala/zio/blocks/schema/json/JsonSchema.scala` (and related files as needed)\n\nThe ADT must support:\n- Boolean schemas (`true` accepts all, `false` rejects all)\n- Full schema objects with all standard vocabularies (core, applicator, validation, format, content, metadata)\n- Round-trip JSON serialization (`toJson` / `fromJson`)\n- Validation (`check` method returning accumulated errors)\n- Combinators (`&&` for allOf, `||` for anyOf, `!` for not)\n\nSee the **JsonSchema Sketch** section below for a starting point.\n\n### 2. Add `toJsonSchema` to `JsonBinaryCodec[A]`\n\n**Location:** `schema/shared/src/main/scala/zio/blocks/schema/json/JsonBinaryCodec.scala`\n```scala\nabstract class JsonBinaryCodec[A](...) extends BinaryCodec[A] {\n  // ... existing methods ...\n  \n  /** Returns the JSON Schema describing values this codec encodes/decodes. */\n  def toJsonSchema: JsonSchema\n}\n```\n\nThen implement this in `JsonBinaryCodecDeriver` for each derivation case (primitives, records, variants, sequences, maps, wrappers, dynamic).\n\n**Important considerations:**\n- The schema must reflect the codec's configuration: `fieldNameMapper`, `caseNameMapper`, `discriminatorKind`, etc.\n- `Modifier.rename` and `Modifier.alias` on fields/cases affect property names\n- `Modifier.transient` fields should be excluded\n- `Modifier.config` with keys like `\"json-schema.format\"` should be respected\n- `Doc` on fields/types should map to `description`\n- `Validation[A]` on primitives should map to validation keywords\n\n### 3. Add `toJsonSchema` to `Schema[A]`\n\n**Location:** `schema/shared/src/main/scala/zio/blocks/schema/Schema.scala`\n```scala\nfinal case class Schema[A](reflect: Reflect.Bound[A]) {\n  // ... existing methods ...\n  \n  /** \n   * Convert this schema to a JsonSchema representation.\n   * This always succeedsevery Schema structure has a JsonSchema equivalent.\n   */\n  def toJsonSchema: JsonSchema\n}\n```\n\nThis can be implemented by deriving a `JsonBinaryCodec[A]` and calling its `toJsonSchema`, or by directly traversing the `Reflect` structure. The codec-based approach is recommended because it ensures the schema matches actual serialization behavior.\n\n### 4. Add `Schema.fromJsonSchema`\n\n**Location:** `schema/shared/src/main/scala/zio/blocks/schema/Schema.scala`\n```scala\nobject Schema extends SchemaCompanionVersionSpecific {\n  // ... existing methods ...\n  \n  /**\n   * Construct a Schema[Json] from a JsonSchema.\n   * Values are validated against the JsonSchema during construction.\n   */\n  def fromJsonSchema(jsonSchema: JsonSchema): Schema[Json]\n}\n```\n\n**Implementation approach:**\n```scala\ndef fromJsonSchema(jsonSchema: JsonSchema): Schema[Json] = {\n  Schema[DynamicValue].wrap[Json](\n    wrap = { dv =>\n      val json = Json.fromDynamicValue(dv)\n      jsonSchema.check(json) match {\n        case None        => Right(json)\n        case Some(error) => Left(error.message)\n      }\n    },\n    unwrap = _.toDynamicValue\n  )\n}\n```\n\nThis uses the existing `Schema.wrap` mechanism which creates a `Reflect.Wrapper` with validation on construction.\n\n### 5. Add `Schema[Json]` Instance\n\n**Location:** `schema/shared/src/main/scala/zio/blocks/schema/Schema.scala`\n```scala\nobject Schema extends SchemaCompanionVersionSpecific {\n  // ... existing methods ...\n  \n  /** Schema for Json values (no validation, accepts any Json). */\n  implicit val json: Schema[Json] = Schema[DynamicValue].wrapTotal[Json](\n    wrap = Json.fromDynamicValue,\n    unwrap = _.toDynamicValue\n  )\n}\n```\n\n### 6. Update `Json.check` and `Json.conforms`\n\n**Location:** `schema/shared/src/main/scala/zio/blocks/schema/json/Json.scala`\n\nThe current stubs are:\n```scala\ndef check(schema: Json): Either[JsonError, Unit] = ???\ndef conforms(schema: Json): Boolean = ???\n```\n\nChange to:\n```scala\n/** \n * Validates this JSON value against a JsonSchema.\n * Returns None if valid, Some(error) with accumulated failures if invalid.\n */\ndef check(schema: JsonSchema): Option[SchemaError] = schema.check(this)\n\n/** Returns true if this JSON value conforms to the schema. */\ndef conforms(schema: JsonSchema): Boolean = check(schema).isEmpty\n```\n\nNote: `SchemaError` already supports error accumulation via its `::[SchemaError.Single]` structure.\n\n### 7. Add `Schema[JsonSchema]` Instance\n\nThe `JsonSchema` type itself should have a `Schema` instance so it can be serialized, diffed, patched, etc. using ZIO Blocks machinery.\n```scala\nobject JsonSchema {\n  implicit val schema: Schema[JsonSchema] = Schema.derived // or manual construction\n}\n```\n\nThis may require careful handling of the recursive structure.\n\n---\n\n## JsonSchema Sketch\n\nBelow is a sketch of the `JsonSchema` ADT. This is a **starting point, not a final specification**. Use your judgment to refine it based on the JSON Schema 2020-12 spec and practical implementation needs.\n```scala\npackage zio.blocks.schema.json\n\nimport java.net.URI\n\n// =============================================================================\n// Newtypes for Precision\n// =============================================================================\n\n/** Non-negative integer (>= 0). Used for minLength, maxLength, minItems, etc. */\nfinal case class NonNegativeInt private (value: Int) extends AnyVal\nobject NonNegativeInt {\n  def apply(n: Int): Option[NonNegativeInt] =\n    if (n >= 0) Some(new NonNegativeInt(n)) else None\n  def unsafe(n: Int): NonNegativeInt = new NonNegativeInt(n)\n  \n  implicit val schema: Schema[NonNegativeInt] = ???\n}\n\n/** Strictly positive number (> 0). Used for multipleOf. */\nfinal case class PositiveNumber private (value: BigDecimal) extends AnyVal\nobject PositiveNumber {\n  def apply(n: BigDecimal): Option[PositiveNumber] =\n    if (n > 0) Some(new PositiveNumber(n)) else None\n  def unsafe(n: BigDecimal): PositiveNumber = new PositiveNumber(n)\n  \n  implicit val schema: Schema[PositiveNumber] = ???\n}\n\n/** ECMA-262 regular expression pattern. */\nfinal case class RegexPattern(value: String) extends AnyVal\nobject RegexPattern {\n  implicit val schema: Schema[RegexPattern] = ???\n}\n\n/** URI-Reference per RFC 3986 (may be relative). */\nfinal case class UriReference(value: String) extends AnyVal\nobject UriReference {\n  implicit val schema: Schema[UriReference] = ???\n}\n\n/** Anchor name (plain name fragment without #). */\nfinal case class Anchor(value: String) extends AnyVal\nobject Anchor {\n  implicit val schema: Schema[Anchor] = ???\n}\n\n// =============================================================================\n// JSON Primitive Type Enumeration\n// =============================================================================\n\nsealed trait JsonType extends Product with Serializable {\n  def toJsonString: String = this match {\n    case JsonType.Null    => \"null\"\n    case JsonType.Boolean => \"boolean\"\n    case JsonType.String  => \"string\"\n    case JsonType.Number  => \"number\"\n    case JsonType.Integer => \"integer\"\n    case JsonType.Array   => \"array\"\n    case JsonType.Object  => \"object\"\n  }\n}\nobject JsonType {\n  case object Null    extends JsonType\n  case object Boolean extends JsonType\n  case object String  extends JsonType\n  case object Number  extends JsonType\n  case object Integer extends JsonType\n  case object Array   extends JsonType\n  case object Object  extends JsonType\n  \n  def fromString(s: String): Option[JsonType] = s match {\n    case \"null\"    => Some(Null)\n    case \"boolean\" => Some(Boolean)\n    case \"string\"  => Some(String)\n    case \"number\"  => Some(Number)\n    case \"integer\" => Some(Integer)\n    case \"array\"   => Some(Array)\n    case \"object\"  => Some(Object)\n    case _         => None\n  }\n  \n  implicit val schema: Schema[JsonType] = ???\n}\n\n// =============================================================================\n// Type Keyword: Single Type or Array of Types\n// =============================================================================\n\nsealed trait SchemaType extends Product with Serializable {\n  def toJson: Json = this match {\n    case SchemaType.Single(t)   => Json.Str(t.toJsonString)\n    case SchemaType.Union(ts)   => Json.Arr(ts.map(t => Json.Str(t.toJsonString)): _*)\n  }\n}\nobject SchemaType {\n  final case class Single(value: JsonType)     extends SchemaType\n  final case class Union(values: ::[JsonType]) extends SchemaType\n  \n  def fromJson(json: Json): Either[SchemaError, SchemaType] = ???\n  \n  implicit val schema: Schema[SchemaType] = ???\n}\n\n// =============================================================================\n// JSON Schema 2020-12 ADT\n// =============================================================================\n\nsealed trait JsonSchema extends Product with Serializable {\n  \n  /** Serialize this schema to its canonical JSON representation. */\n  def toJson: Json\n  \n  /** \n   * Validate a JSON value against this schema.\n   * Returns None if valid, Some(error) with accumulated failures if invalid.\n   */\n  def check(json: Json): Option[SchemaError]\n  \n  /** Returns true if the JSON value conforms to this schema. */\n  def conforms(json: Json): Boolean = check(json).isEmpty\n  \n  // ===========================================================================\n  // Combinators\n  // ===========================================================================\n  \n  /** Combine with another schema using allOf. */\n  def &&(that: JsonSchema): JsonSchema\n  \n  /** Combine with another schema using anyOf. */\n  def ||(that: JsonSchema): JsonSchema\n  \n  /** Negate this schema. */\n  def unary_! : JsonSchema = JsonSchema.SchemaObject(not = Some(this))\n}\n\nobject JsonSchema {\n  \n  // ===========================================================================\n  // Parsing\n  // ===========================================================================\n  \n  /** Parse a JsonSchema from its JSON representation. */\n  def fromJson(json: Json): Either[SchemaError, JsonSchema]\n  \n  /** Parse a JsonSchema from a JSON string. */\n  def parse(jsonString: String): Either[SchemaError, JsonSchema]\n  \n  // ===========================================================================\n  // Schema & Codec instances\n  // ===========================================================================\n  \n  implicit val schema: Schema[JsonSchema] = ???\n  implicit val jsonBinaryCodec: JsonBinaryCodec[JsonSchema] = ???\n  \n  // ===========================================================================\n  // Boolean Schemas\n  // ===========================================================================\n\n  /** Schema that accepts all instances. Equivalent to `{}`. */\n  case object True extends JsonSchema {\n    override def toJson: Json = Json.Bool(true)\n    override def check(json: Json): Option[SchemaError] = None\n  }\n\n  /** Schema that rejects all instances. Equivalent to `{\"not\": {}}`. */\n  case object False extends JsonSchema {\n    override def toJson: Json = Json.Bool(false)\n    override def check(json: Json): Option[SchemaError] = \n      Some(SchemaError.expectationMismatch(Nil, \"Schema rejects all values\"))\n  }\n\n  // ===========================================================================\n  // Schema Object\n  // ===========================================================================\n  \n  /** \n   * A schema object containing keywords from JSON Schema 2020-12.\n   * All fields are optional; an empty SchemaObject is equivalent to True.\n   */\n  final case class SchemaObject(\n    // =========================================================================\n    // Core Vocabulary\n    // =========================================================================\n    \n    $id: Option[UriReference] = None,\n    $schema: Option[URI] = None,\n    $anchor: Option[Anchor] = None,\n    $dynamicAnchor: Option[Anchor] = None,\n    $ref: Option[UriReference] = None,\n    $dynamicRef: Option[UriReference] = None,\n    $vocabulary: Option[Map[URI, Boolean]] = None,\n    $defs: Option[Map[String, JsonSchema]] = None,\n    $comment: Option[String] = None,\n\n    // =========================================================================\n    // Applicator Vocabulary (Composition)\n    // =========================================================================\n    \n    allOf: Option[::[JsonSchema]] = None,\n    anyOf: Option[::[JsonSchema]] = None,\n    oneOf: Option[::[JsonSchema]] = None,\n    not: Option[JsonSchema] = None,\n\n    // =========================================================================\n    // Applicator Vocabulary (Conditional)\n    // =========================================================================\n    \n    `if`: Option[JsonSchema] = None,\n    `then`: Option[JsonSchema] = None,\n    `else`: Option[JsonSchema] = None,\n\n    // =========================================================================\n    // Applicator Vocabulary (Object)\n    // =========================================================================\n    \n    properties: Option[Map[String, JsonSchema]] = None,\n    patternProperties: Option[Map[RegexPattern, JsonSchema]] = None,\n    additionalProperties: Option[JsonSchema] = None,\n    propertyNames: Option[JsonSchema] = None,\n    dependentSchemas: Option[Map[String, JsonSchema]] = None,\n\n    // =========================================================================\n    // Applicator Vocabulary (Array)\n    // =========================================================================\n    \n    prefixItems: Option[::[JsonSchema]] = None,\n    items: Option[JsonSchema] = None,\n    contains: Option[JsonSchema] = None,\n\n    // =========================================================================\n    // Unevaluated Vocabulary\n    // =========================================================================\n    \n    unevaluatedProperties: Option[JsonSchema] = None,\n    unevaluatedItems: Option[JsonSchema] = None,\n\n    // =========================================================================\n    // Validation Vocabulary (Type)\n    // =========================================================================\n    \n    `type`: Option[SchemaType] = None,\n    `enum`: Option[::[Json]] = None,\n    const: Option[Json] = None,\n\n    // =========================================================================\n    // Validation Vocabulary (Numeric)\n    // =========================================================================\n    \n    multipleOf: Option[PositiveNumber] = None,\n    maximum: Option[BigDecimal] = None,\n    exclusiveMaximum: Option[BigDecimal] = None,\n    minimum: Option[BigDecimal] = None,\n    exclusiveMinimum: Option[BigDecimal] = None,\n\n    // =========================================================================\n    // Validation Vocabulary (String)\n    // =========================================================================\n    \n    minLength: Option[NonNegativeInt] = None,\n    maxLength: Option[NonNegativeInt] = None,\n    pattern: Option[RegexPattern] = None,\n\n    // =========================================================================\n    // Validation Vocabulary (Array)\n    // =========================================================================\n    \n    minItems: Option[NonNegativeInt] = None,\n    maxItems: Option[NonNegativeInt] = None,\n    uniqueItems: Option[Boolean] = None,\n    minContains: Option[NonNegativeInt] = None,\n    maxContains: Option[NonNegativeInt] = None,\n\n    // =========================================================================\n    // Validation Vocabulary (Object)\n    // =========================================================================\n    \n    minProperties: Option[NonNegativeInt] = None,\n    maxProperties: Option[NonNegativeInt] = None,\n    required: Option[Set[String]] = None,\n    dependentRequired: Option[Map[String, Set[String]]] = None,\n\n    // =========================================================================\n    // Format Vocabulary\n    // =========================================================================\n    \n    format: Option[String] = None,\n\n    // =========================================================================\n    // Content Vocabulary\n    // =========================================================================\n    \n    contentEncoding: Option[String] = None,\n    contentMediaType: Option[String] = None,\n    contentSchema: Option[JsonSchema] = None,\n\n    // =========================================================================\n    // Meta-Data Vocabulary\n    // =========================================================================\n    \n    title: Option[String] = None,\n    description: Option[String] = None,\n    default: Option[Json] = None,\n    deprecated: Option[Boolean] = None,\n    readOnly: Option[Boolean] = None,\n    writeOnly: Option[Boolean] = None,\n    examples: Option[::[Json]] = None,\n\n    // =========================================================================\n    // Extensions\n    // =========================================================================\n    \n    /** Unrecognized keywords for round-trip fidelity and vendor extensions. */\n    extensions: Map[String, Json] = Map.empty\n\n  ) extends JsonSchema {\n    override def toJson: Json = ???\n    override def check(json: Json): Option[SchemaError] = ???\n  }\n\n  object SchemaObject {\n    val empty: SchemaObject = SchemaObject()\n  }\n  \n  // ===========================================================================\n  // Smart Constructors\n  // ===========================================================================\n  \n  def ofType(t: JsonType): JsonSchema = \n    SchemaObject(`type` = Some(SchemaType.Single(t)))\n  \n  def string(\n    minLength: Option[NonNegativeInt] = None,\n    maxLength: Option[NonNegativeInt] = None,\n    pattern: Option[RegexPattern] = None,\n    format: Option[String] = None\n  ): JsonSchema = SchemaObject(\n    `type` = Some(SchemaType.Single(JsonType.String)),\n    minLength = minLength,\n    maxLength = maxLength,\n    pattern = pattern,\n    format = format\n  )\n  \n  def number(\n    minimum: Option[BigDecimal] = None,\n    maximum: Option[BigDecimal] = None,\n    exclusiveMinimum: Option[BigDecimal] = None,\n    exclusiveMaximum: Option[BigDecimal] = None,\n    multipleOf: Option[PositiveNumber] = None\n  ): JsonSchema = SchemaObject(\n    `type` = Some(SchemaType.Single(JsonType.Number)),\n    minimum = minimum,\n    maximum = maximum,\n    exclusiveMinimum = exclusiveMinimum,\n    exclusiveMaximum = exclusiveMaximum,\n    multipleOf = multipleOf\n  )\n  \n  def integer(\n    minimum: Option[BigDecimal] = None,\n    maximum: Option[BigDecimal] = None\n  ): JsonSchema = SchemaObject(\n    `type` = Some(SchemaType.Single(JsonType.Integer)),\n    minimum = minimum,\n    maximum = maximum\n  )\n  \n  def array(\n    items: Option[JsonSchema] = None,\n    minItems: Option[NonNegativeInt] = None,\n    maxItems: Option[NonNegativeInt] = None,\n    uniqueItems: Option[Boolean] = None\n  ): JsonSchema = SchemaObject(\n    `type` = Some(SchemaType.Single(JsonType.Array)),\n    items = items,\n    minItems = minItems,\n    maxItems = maxItems,\n    uniqueItems = uniqueItems\n  )\n  \n  def `object`(\n    properties: Option[Map[String, JsonSchema]] = None,\n    required: Option[Set[String]] = None,\n    additionalProperties: Option[JsonSchema] = None\n  ): JsonSchema = SchemaObject(\n    `type` = Some(SchemaType.Single(JsonType.Object)),\n    properties = properties,\n    required = required,\n    additionalProperties = additionalProperties\n  )\n  \n  def enumOf(values: ::[Json]): JsonSchema = SchemaObject(`enum` = Some(values))\n  \n  def constOf(value: Json): JsonSchema = SchemaObject(const = Some(value))\n  \n  def ref(uri: UriReference): JsonSchema = SchemaObject($ref = Some(uri))\n  \n  val `null`: JsonSchema = ofType(JsonType.Null)\n  val boolean: JsonSchema = ofType(JsonType.Boolean)\n}\n```\n\n---\n\n## Validation to JsonSchema Mapping\n\nThe `Validation[A]` type in ZIO Blocks maps to JSON Schema validation keywords. Implement this mapping when generating schemas from `PrimitiveType`:\n\n| `Validation[A]` | JSON Schema Keywords |\n|-----------------|---------------------|\n| `Validation.None` | (no constraints) |\n| `Validation.Numeric.Positive` | `exclusiveMinimum: 0` |\n| `Validation.Numeric.NonNegative` | `minimum: 0` |\n| `Validation.Numeric.Negative` | `exclusiveMaximum: 0` |\n| `Validation.Numeric.NonPositive` | `maximum: 0` |\n| `Validation.Numeric.Range(min, max)` | `minimum` / `maximum` |\n| `Validation.Numeric.Set(values)` | `enum: [...]` |\n| `Validation.String.NonEmpty` | `minLength: 1` |\n| `Validation.String.Empty` | `maxLength: 0` |\n| `Validation.String.Length(min, max)` | `minLength` / `maxLength` |\n| `Validation.String.Pattern(regex)` | `pattern` |\n\n---\n\n## Modifier.config Keys\n\nSupport these `Modifier.config` keys when generating JSON Schema:\n\n| Key | Effect |\n|-----|--------|\n| `json-schema.format` | Sets `format` keyword (e.g., `\"email\"`, `\"date-time\"`, `\"uuid\"`) |\n| `json-schema.deprecated` | Sets `deprecated: true` |\n| `json-schema.title` | Overrides `title` |\n| `json-schema.description` | Overrides `description` |\n\n---\n\n## Files to Create or Modify\n\n| File | Action |\n|------|--------|\n| `schema/shared/src/main/scala/zio/blocks/schema/json/JsonSchema.scala` | **CREATE** - Main ADT |\n| `schema/shared/src/main/scala/zio/blocks/schema/json/JsonBinaryCodec.scala` | **MODIFY** - Add `def toJsonSchema: JsonSchema` |\n| `schema/shared/src/main/scala/zio/blocks/schema/json/JsonBinaryCodecDeriver.scala` | **MODIFY** - Implement `toJsonSchema` for all derivation cases |\n| `schema/shared/src/main/scala/zio/blocks/schema/Schema.scala` | **MODIFY** - Add `toJsonSchema`, `fromJsonSchema`, `Schema[Json]` |\n| `schema/shared/src/main/scala/zio/blocks/schema/json/Json.scala` | **MODIFY** - Update `check`/`conforms` signatures |\n\n---\n\n## Required Test Suites\n\nAll tests should use ZIO Test and follow the existing test patterns in the codebase.\n\n### 1. `JsonSchemaSpec`  Core ADT Tests\n\n**Location:** `schema/shared/src/test/scala/zio/blocks/schema/json/JsonSchemaSpec.scala`\n\nMust test:\n\n- **Boolean schemas**: `True` accepts all JSON, `False` rejects all JSON\n- **Type validation**: Each `JsonType` validates correctly (null, boolean, string, number, integer, array, object)\n- **Type unions**: `type: [\"string\", \"number\"]` accepts either\n- **Numeric constraints**: `minimum`, `maximum`, `exclusiveMinimum`, `exclusiveMaximum`, `multipleOf`\n- **String constraints**: `minLength`, `maxLength`, `pattern`\n- **Array constraints**: `minItems`, `maxItems`, `uniqueItems`, `prefixItems`, `items`, `contains`, `minContains`, `maxContains`\n- **Object constraints**: `properties`, `required`, `additionalProperties`, `propertyNames`, `minProperties`, `maxProperties`, `patternProperties`, `dependentRequired`, `dependentSchemas`\n- **Composition**: `allOf`, `anyOf`, `oneOf`, `not`\n- **Conditional**: `if`/`then`/`else`\n- **Enum and const**: exact value matching\n- **Error accumulation**: Multiple validation failures are collected, not just the first\n\n### 2. `JsonSchemaRoundTripSpec`  Serialization Tests\n\n**Location:** `schema/shared/src/test/scala/zio/blocks/schema/json/JsonSchemaRoundTripSpec.scala`\n\nMust test:\n\n- **`toJson` / `fromJson` round-trip**: For every `JsonSchema`, `JsonSchema.fromJson(schema.toJson) == Right(schema)`\n- **Parse canonical examples**: Parse schemas from the JSON Schema test suite or spec examples\n- **Boolean schema serialization**: `true` and `false` as JSON booleans\n- **Empty object equivalence**: `{}` parses to `SchemaObject.empty` which is equivalent to `True`\n- **Extension preservation**: Unknown keywords in `extensions` survive round-trip\n- **All keyword serialization**: Every field in `SchemaObject` serializes to the correct JSON keyword\n\n### 3. `JsonBinaryCodecToJsonSchemaSpec`  Codec Schema Extraction Tests\n\n**Location:** `schema/shared/src/test/scala/zio/blocks/schema/json/JsonBinaryCodecToJsonSchemaSpec.scala`\n\nMust test:\n\n- **Primitives**: Each primitive type produces correct JSON Schema (`String`  `type: \"string\"`, `Int`  `type: \"integer\"`, etc.)\n- **Temporal types**: `Instant`, `LocalDate`, etc. produce `type: \"string\"` with appropriate `format`\n- **Records**: Case classes produce `type: \"object\"` with `properties` and `required`\n- **Variants (sealed traits)**: Produce `oneOf` or discriminator-based schema depending on `DiscriminatorKind`\n- **Enumerations**: Sealed traits with all case objects produce `enum`\n- **Option fields**: Non-required properties or union with `null`\n- **Collections**: `List[A]`, `Set[A]`, `Vector[A]` produce `type: \"array\"` with `items`\n- **Maps**: `Map[String, V]` produces `type: \"object\"` with `additionalProperties`\n- **Nested structures**: Deeply nested case classes produce correct nested schemas\n- **Field renaming**: `Modifier.rename` and `fieldNameMapper` affect property names\n- **Transient fields**: `Modifier.transient` fields are excluded from schema\n- **Documentation**: `Doc` maps to `description`\n- **Validation constraints**: `Validation[A]` on primitives maps to validation keywords\n- **Config modifiers**: `Modifier.config(\"json-schema.format\", \"email\")` sets `format`\n\n### 4. `SchemaToJsonSchemaSpec`  Schema Conversion Tests\n\n**Location:** `schema/shared/src/test/scala/zio/blocks/schema/json/SchemaToJsonSchemaSpec.scala`\n\nMust test:\n\n- **All built-in schemas**: `Schema[Int]`, `Schema[String]`, `Schema[Boolean]`, etc.\n- **Derived schemas**: `Schema.derived` for case classes and sealed traits\n- **Consistency with codec**: `Schema[A].toJsonSchema` should match `Schema[A].derive(JsonFormat.deriver).toJsonSchema`\n- **Recursive types**: Self-referential case classes produce schemas with `$ref` or equivalent\n\n### 5. `SchemaFromJsonSchemaSpec`  Schema Construction Tests\n\n**Location:** `schema/shared/src/test/scala/zio/blocks/schema/json/SchemaFromJsonSchemaSpec.scala`\n\nMust test:\n\n- **Valid JSON passes**: `Schema.fromJsonSchema(schema)` accepts conforming JSON\n- **Invalid JSON fails**: Non-conforming JSON fails with descriptive error\n- **Error messages**: Validation errors include path information\n- **Round-trip through DynamicValue**: JSON  DynamicValue  JSON preserves structure\n- **Encode/decode works**: The resulting `Schema[Json]` can be used with `JsonFormat` for encoding/decoding\n\n### 6. `JsonCheckSpec`  Json.check/conforms Tests\n\n**Location:** `schema/shared/src/test/scala/zio/blocks/schema/json/JsonCheckSpec.scala`\n\nMust test:\n\n- **Method signatures**: `check` returns `Option[SchemaError]`, `conforms` returns `Boolean`\n- **Delegation**: These methods delegate to `JsonSchema.check`\n- **All validation scenarios**: Mirror tests from `JsonSchemaSpec` but called via `Json` methods\n\n### 7. `JsonSchemaCombinatorSpec`  Combinator Tests\n\n**Location:** `schema/shared/src/test/scala/zio/blocks/schema/json/JsonSchemaCombinatorSpec.scala`\n\nMust test:\n\n- **`&&` (allOf)**: `schema1 && schema2` validates if both pass\n- **`||` (anyOf)**: `schema1 || schema2` validates if either passes\n- **`!` (not)**: `!schema` validates if schema fails\n- **Associativity**: `(a && b) && c` equivalent to `a && (b && c)`\n- **Commutativity**: `a && b` equivalent to `b && a` (for validation purposes)\n- **De Morgan's laws**: `!(a && b)` equivalent to `!a || !b`\n\n---\n\n## Acceptance Criteria\n\n- [ ] All test suites pass\n- [ ] `JsonSchema` ADT covers JSON Schema 2020-12 core, applicator, validation, format, content, and metadata vocabularies\n- [ ] `JsonSchema#toJson` produces valid JSON Schema documents\n- [ ] `JsonSchema.fromJson` parses valid JSON Schema documents\n- [ ] `JsonSchema#check` validates JSON values with accumulated errors\n- [ ] `JsonBinaryCodec[A].toJsonSchema` produces accurate schemas reflecting codec configuration\n- [ ] `Schema[A].toJsonSchema` works for all derivable types\n- [ ] `Schema.fromJsonSchema` produces a working `Schema[Json]` with validation\n- [ ] `Json#check` and `Json#conforms` work with the new `JsonSchema` parameter type\n- [ ] `Validation[A]` constraints map to appropriate JSON Schema keywords\n- [ ] `Doc` maps to `description`\n- [ ] `Modifier.rename`, `Modifier.transient`, and `Modifier.config` are respected\n- [ ] Code follows existing project style and conventions\n- [ ] No new dependencies are introduced (use existing `Json` type, not a third-party JSON library)\n\n---\n\n## Notes for Implementers\n\n1. **Start with the ADT**: Get `JsonSchema` working with `toJson`/`fromJson`/`check` before integrating with `JsonBinaryCodec`.\n\n2. **Study the Avro implementation**: `AvroFormat` and `AvroBinaryCodec` show the established pattern for schema extraction from codecs.\n\n3. **Validation is the hard part**: The `check` method needs to correctly implement JSON Schema validation semantics, including `unevaluatedProperties`/`unevaluatedItems` which require tracking which properties/items were \"evaluated\" by other keywords.\n\n4. **Error accumulation**: Use `SchemaError` which already supports multiple errors. Include path information using `DynamicOptic`.\n\n5. **`$ref` resolution**: For this initial implementation, `$ref` within the same document (using `$defs`) should work. Cross-document references are out of scope.\n\n6. **Format validation**: The `format` keyword is an annotation by default in 2020-12. Implement validation for common formats (`date-time`, `date`, `time`, `email`, `uuid`, `uri`) but make it non-fatal or configurable.\n\n7. **Test against the official test suite**: The [JSON Schema Test Suite](https://github.com/json-schema-org/JSON-Schema-Test-Suite) provides comprehensive test cases. Consider using it to validate your implementation.",
                  "html_url": "https://github.com/zio/zio-blocks/issues/462"
                },
                "type": "github"
              },
              "hash": "zio/zio-blocks#462",
              "body": "# Add JSON Schema 2020-12 Support\n\n## Overview\n\nThis ticket adds first-class [JSON Schema 2020-12](https://json-schema.org/draft/2020-12/json-schema-core) support to ZIO Blocks, enabling:\n\n1. A `JsonSchema` ADT that precisely models the JSON Schema specification\n2. Bidirectional conversion between `Schema[A]` and `JsonSchema`\n3. Runtime validation of `Json` values against `JsonSchema`\n4. Schema extraction from `JsonBinaryCodec[A]` instances\n\nThis follows the established pattern used by `AvroBinaryCodec`, which exposes an `avroSchema: AvroSchema` field for each codec instance.\n\n---\n\n## Background: ZIO Blocks Architecture\n\nIf you're new to ZIO Blocks (ZIO Schema 2), here's the essential context:\n\n### Core Types\n\n| Type | Purpose |\n|------|---------|\n| `Schema[A]` | Reified structure of Scala type `A` with construction/deconstruction capabilities |\n| `Reflect[F, A]` | The underlying ADT representing type structure. `Schema[A]` wraps `Reflect[Binding, A]` |\n| `DynamicValue` | A semi-structured representation (superset of JSON) that any `Schema[A]` can convert to/from |\n| `Json` | The JSON AST in `zio.blocks.schema.json` |\n| `JsonBinaryCodec[A]` | Typeclass for JSON serialization, derived from `Schema[A]` via `JsonBinaryCodecDeriver` |\n\n### How Derivation Works\n```scala\ncase class Person(name: String, age: Int)\nobject Person {\n  implicit val schema: Schema[Person] = Schema.derived\n}\n\n// Derive a JSON codec from the schema:\nval codec: JsonBinaryCodec[Person] = Schema[Person].derive(JsonFormat.deriver)\n\n// Or use encode/decode directly (caches the codec):\nSchema[Person].encode(JsonFormat)(buffer)(person)\nSchema[Person].decode(JsonFormat)(buffer)\n```\n\n### Key Insight: DynamicValue as the Bridge\n\n`Schema[A]` can convert any `A` to `DynamicValue` and back. Since `DynamicValue` is structurally similar to JSON, and `Json.fromDynamicValue` / `Json.toDynamicValue` exist, we can create `Schema[Json]` by wrapping `Schema[DynamicValue]`.\n\nThis is how `Schema.fromJsonSchema` will work: it wraps `Schema[DynamicValue]` with validation logic that checks the `JsonSchema` constraints.\n\n### Metadata That Maps to JSON Schema\n\n| ZIO Blocks Type | JSON Schema Equivalent |\n|-----------------|------------------------|\n| `TypeName[A]` | Can be stored in `$id` or custom extension for round-trip |\n| `Doc` | `title` / `description` |\n| `Validation[A]` | `minimum`, `maximum`, `minLength`, `maxLength`, `pattern`, etc. |\n| `Modifier.rename` | Affects property names |\n| `Modifier.alias` | Could map to extension for alternative names |\n| `Modifier.transient` | Field excluded from schema |\n| `Modifier.config` | Extensible metadata (e.g., `\"json-schema.format\" -> \"email\"`) |\n| `DiscriminatorKind` | Affects `oneOf`/`anyOf` structure and `discriminator` keyword |\n| `NameMapper` | Applied to field/case names during schema generation |\n\n### Reference: AvroBinaryCodec Pattern\n\nLook at `AvroBinaryCodec` for the established pattern. Each codec instance has:\n```scala\nabstract class AvroBinaryCodec[A](...) extends BinaryCodec[A] {\n  def avroSchema: AvroSchema  // <-- We want the equivalent for JSON Schema\n  // ...\n}\n```\n\nThe `AvroFormat` deriver constructs the `avroSchema` for each primitive, record, variant, sequence, map, and wrapper type.\n\n---\n\n## Requirements\n\n### 1. Create `JsonSchema` ADT\n\nCreate a new sealed trait `JsonSchema` in `zio.blocks.schema.json` that models JSON Schema 2020-12.\n\n**Location:** `schema/shared/src/main/scala/zio/blocks/schema/json/JsonSchema.scala` (and related files as needed)\n\nThe ADT must support:\n- Boolean schemas (`true` accepts all, `false` rejects all)\n- Full schema objects with all standard vocabularies (core, applicator, validation, format, content, metadata)\n- Round-trip JSON serialization (`toJson` / `fromJson`)\n- Validation (`check` method returning accumulated errors)\n- Combinators (`&&` for allOf, `||` for anyOf, `!` for not)\n\nSee the **JsonSchema Sketch** section below for a starting point.\n\n### 2. Add `toJsonSchema` to `JsonBinaryCodec[A]`\n\n**Location:** `schema/shared/src/main/scala/zio/blocks/schema/json/JsonBinaryCodec.scala`\n```scala\nabstract class JsonBinaryCodec[A](...) extends BinaryCodec[A] {\n  // ... existing methods ...\n  \n  /** Returns the JSON Schema describing values this codec encodes/decodes. */\n  def toJsonSchema: JsonSchema\n}\n```\n\nThen implement this in `JsonBinaryCodecDeriver` for each derivation case (primitives, records, variants, sequences, maps, wrappers, dynamic).\n\n**Important considerations:**\n- The schema must reflect the codec's configuration: `fieldNameMapper`, `caseNameMapper`, `discriminatorKind`, etc.\n- `Modifier.rename` and `Modifier.alias` on fields/cases affect property names\n- `Modifier.transient` fields should be excluded\n- `Modifier.config` with keys like `\"json-schema.format\"` should be respected\n- `Doc` on fields/types should map to `description`\n- `Validation[A]` on primitives should map to validation keywords\n\n### 3. Add `toJsonSchema` to `Schema[A]`\n\n**Location:** `schema/shared/src/main/scala/zio/blocks/schema/Schema.scala`\n```scala\nfinal case class Schema[A](reflect: Reflect.Bound[A]) {\n  // ... existing methods ...\n  \n  /** \n   * Convert this schema to a JsonSchema representation.\n   * This always succeedsevery Schema structure has a JsonSchema equivalent.\n   */\n  def toJsonSchema: JsonSchema\n}\n```\n\nThis can be implemented by deriving a `JsonBinaryCodec[A]` and calling its `toJsonSchema`, or by directly traversing the `Reflect` structure. The codec-based approach is recommended because it ensures the schema matches actual serialization behavior.\n\n### 4. Add `Schema.fromJsonSchema`\n\n**Location:** `schema/shared/src/main/scala/zio/blocks/schema/Schema.scala`\n```scala\nobject Schema extends SchemaCompanionVersionSpecific {\n  // ... existing methods ...\n  \n  /**\n   * Construct a Schema[Json] from a JsonSchema.\n   * Values are validated against the JsonSchema during construction.\n   */\n  def fromJsonSchema(jsonSchema: JsonSchema): Schema[Json]\n}\n```\n\n**Implementation approach:**\n```scala\ndef fromJsonSchema(jsonSchema: JsonSchema): Schema[Json] = {\n  Schema[DynamicValue].wrap[Json](\n    wrap = { dv =>\n      val json = Json.fromDynamicValue(dv)\n      jsonSchema.check(json) match {\n        case None        => Right(json)\n        case Some(error) => Left(error.message)\n      }\n    },\n    unwrap = _.toDynamicValue\n  )\n}\n```\n\nThis uses the existing `Schema.wrap` mechanism which creates a `Reflect.Wrapper` with validation on construction.\n\n### 5. Add `Schema[Json]` Instance\n\n**Location:** `schema/shared/src/main/scala/zio/blocks/schema/Schema.scala`\n```scala\nobject Schema extends SchemaCompanionVersionSpecific {\n  // ... existing methods ...\n  \n  /** Schema for Json values (no validation, accepts any Json). */\n  implicit val json: Schema[Json] = Schema[DynamicValue].wrapTotal[Json](\n    wrap = Json.fromDynamicValue,\n    unwrap = _.toDynamicValue\n  )\n}\n```\n\n### 6. Update `Json.check` and `Json.conforms`\n\n**Location:** `schema/shared/src/main/scala/zio/blocks/schema/json/Json.scala`\n\nThe current stubs are:\n```scala\ndef check(schema: Json): Either[JsonError, Unit] = ???\ndef conforms(schema: Json): Boolean = ???\n```\n\nChange to:\n```scala\n/** \n * Validates this JSON value against a JsonSchema.\n * Returns None if valid, Some(error) with accumulated failures if invalid.\n */\ndef check(schema: JsonSchema): Option[SchemaError] = schema.check(this)\n\n/** Returns true if this JSON value conforms to the schema. */\ndef conforms(schema: JsonSchema): Boolean = check(schema).isEmpty\n```\n\nNote: `SchemaError` already supports error accumulation via its `::[SchemaError.Single]` structure.\n\n### 7. Add `Schema[JsonSchema]` Instance\n\nThe `JsonSchema` type itself should have a `Schema` instance so it can be serialized, diffed, patched, etc. using ZIO Blocks machinery.\n```scala\nobject JsonSchema {\n  implicit val schema: Schema[JsonSchema] = Schema.derived // or manual construction\n}\n```\n\nThis may require careful handling of the recursive structure.\n\n---\n\n## JsonSchema Sketch\n\nBelow is a sketch of the `JsonSchema` ADT. This is a **starting point, not a final specification**. Use your judgment to refine it based on the JSON Schema 2020-12 spec and practical implementation needs.\n```scala\npackage zio.blocks.schema.json\n\nimport java.net.URI\n\n// =============================================================================\n// Newtypes for Precision\n// =============================================================================\n\n/** Non-negative integer (>= 0). Used for minLength, maxLength, minItems, etc. */\nfinal case class NonNegativeInt private (value: Int) extends AnyVal\nobject NonNegativeInt {\n  def apply(n: Int): Option[NonNegativeInt] =\n    if (n >= 0) Some(new NonNegativeInt(n)) else None\n  def unsafe(n: Int): NonNegativeInt = new NonNegativeInt(n)\n  \n  implicit val schema: Schema[NonNegativeInt] = ???\n}\n\n/** Strictly positive number (> 0). Used for multipleOf. */\nfinal case class PositiveNumber private (value: BigDecimal) extends AnyVal\nobject PositiveNumber {\n  def apply(n: BigDecimal): Option[PositiveNumber] =\n    if (n > 0) Some(new PositiveNumber(n)) else None\n  def unsafe(n: BigDecimal): PositiveNumber = new PositiveNumber(n)\n  \n  implicit val schema: Schema[PositiveNumber] = ???\n}\n\n/** ECMA-262 regular expression pattern. */\nfinal case class RegexPattern(value: String) extends AnyVal\nobject RegexPattern {\n  implicit val schema: Schema[RegexPattern] = ???\n}\n\n/** URI-Reference per RFC 3986 (may be relative). */\nfinal case class UriReference(value: String) extends AnyVal\nobject UriReference {\n  implicit val schema: Schema[UriReference] = ???\n}\n\n/** Anchor name (plain name fragment without #). */\nfinal case class Anchor(value: String) extends AnyVal\nobject Anchor {\n  implicit val schema: Schema[Anchor] = ???\n}\n\n// =============================================================================\n// JSON Primitive Type Enumeration\n// =============================================================================\n\nsealed trait JsonType extends Product with Serializable {\n  def toJsonString: String = this match {\n    case JsonType.Null    => \"null\"\n    case JsonType.Boolean => \"boolean\"\n    case JsonType.String  => \"string\"\n    case JsonType.Number  => \"number\"\n    case JsonType.Integer => \"integer\"\n    case JsonType.Array   => \"array\"\n    case JsonType.Object  => \"object\"\n  }\n}\nobject JsonType {\n  case object Null    extends JsonType\n  case object Boolean extends JsonType\n  case object String  extends JsonType\n  case object Number  extends JsonType\n  case object Integer extends JsonType\n  case object Array   extends JsonType\n  case object Object  extends JsonType\n  \n  def fromString(s: String): Option[JsonType] = s match {\n    case \"null\"    => Some(Null)\n    case \"boolean\" => Some(Boolean)\n    case \"string\"  => Some(String)\n    case \"number\"  => Some(Number)\n    case \"integer\" => Some(Integer)\n    case \"array\"   => Some(Array)\n    case \"object\"  => Some(Object)\n    case _         => None\n  }\n  \n  implicit val schema: Schema[JsonType] = ???\n}\n\n// =============================================================================\n// Type Keyword: Single Type or Array of Types\n// =============================================================================\n\nsealed trait SchemaType extends Product with Serializable {\n  def toJson: Json = this match {\n    case SchemaType.Single(t)   => Json.Str(t.toJsonString)\n    case SchemaType.Union(ts)   => Json.Arr(ts.map(t => Json.Str(t.toJsonString)): _*)\n  }\n}\nobject SchemaType {\n  final case class Single(value: JsonType)     extends SchemaType\n  final case class Union(values: ::[JsonType]) extends SchemaType\n  \n  def fromJson(json: Json): Either[SchemaError, SchemaType] = ???\n  \n  implicit val schema: Schema[SchemaType] = ???\n}\n\n// =============================================================================\n// JSON Schema 2020-12 ADT\n// =============================================================================\n\nsealed trait JsonSchema extends Product with Serializable {\n  \n  /** Serialize this schema to its canonical JSON representation. */\n  def toJson: Json\n  \n  /** \n   * Validate a JSON value against this schema.\n   * Returns None if valid, Some(error) with accumulated failures if invalid.\n   */\n  def check(json: Json): Option[SchemaError]\n  \n  /** Returns true if the JSON value conforms to this schema. */\n  def conforms(json: Json): Boolean = check(json).isEmpty\n  \n  // ===========================================================================\n  // Combinators\n  // ===========================================================================\n  \n  /** Combine with another schema using allOf. */\n  def &&(that: JsonSchema): JsonSchema\n  \n  /** Combine with another schema using anyOf. */\n  def ||(that: JsonSchema): JsonSchema\n  \n  /** Negate this schema. */\n  def unary_! : JsonSchema = JsonSchema.SchemaObject(not = Some(this))\n}\n\nobject JsonSchema {\n  \n  // ===========================================================================\n  // Parsing\n  // ===========================================================================\n  \n  /** Parse a JsonSchema from its JSON representation. */\n  def fromJson(json: Json): Either[SchemaError, JsonSchema]\n  \n  /** Parse a JsonSchema from a JSON string. */\n  def parse(jsonString: String): Either[SchemaError, JsonSchema]\n  \n  // ===========================================================================\n  // Schema & Codec instances\n  // ===========================================================================\n  \n  implicit val schema: Schema[JsonSchema] = ???\n  implicit val jsonBinaryCodec: JsonBinaryCodec[JsonSchema] = ???\n  \n  // ===========================================================================\n  // Boolean Schemas\n  // ===========================================================================\n\n  /** Schema that accepts all instances. Equivalent to `{}`. */\n  case object True extends JsonSchema {\n    override def toJson: Json = Json.Bool(true)\n    override def check(json: Json): Option[SchemaError] = None\n  }\n\n  /** Schema that rejects all instances. Equivalent to `{\"not\": {}}`. */\n  case object False extends JsonSchema {\n    override def toJson: Json = Json.Bool(false)\n    override def check(json: Json): Option[SchemaError] = \n      Some(SchemaError.expectationMismatch(Nil, \"Schema rejects all values\"))\n  }\n\n  // ===========================================================================\n  // Schema Object\n  // ===========================================================================\n  \n  /** \n   * A schema object containing keywords from JSON Schema 2020-12.\n   * All fields are optional; an empty SchemaObject is equivalent to True.\n   */\n  final case class SchemaObject(\n    // =========================================================================\n    // Core Vocabulary\n    // =========================================================================\n    \n    $id: Option[UriReference] = None,\n    $schema: Option[URI] = None,\n    $anchor: Option[Anchor] = None,\n    $dynamicAnchor: Option[Anchor] = None,\n    $ref: Option[UriReference] = None,\n    $dynamicRef: Option[UriReference] = None,\n    $vocabulary: Option[Map[URI, Boolean]] = None,\n    $defs: Option[Map[String, JsonSchema]] = None,\n    $comment: Option[String] = None,\n\n    // =========================================================================\n    // Applicator Vocabulary (Composition)\n    // =========================================================================\n    \n    allOf: Option[::[JsonSchema]] = None,\n    anyOf: Option[::[JsonSchema]] = None,\n    oneOf: Option[::[JsonSchema]] = None,\n    not: Option[JsonSchema] = None,\n\n    // =========================================================================\n    // Applicator Vocabulary (Conditional)\n    // =========================================================================\n    \n    `if`: Option[JsonSchema] = None,\n    `then`: Option[JsonSchema] = None,\n    `else`: Option[JsonSchema] = None,\n\n    // =========================================================================\n    // Applicator Vocabulary (Object)\n    // =========================================================================\n    \n    properties: Option[Map[String, JsonSchema]] = None,\n    patternProperties: Option[Map[RegexPattern, JsonSchema]] = None,\n    additionalProperties: Option[JsonSchema] = None,\n    propertyNames: Option[JsonSchema] = None,\n    dependentSchemas: Option[Map[String, JsonSchema]] = None,\n\n    // =========================================================================\n    // Applicator Vocabulary (Array)\n    // =========================================================================\n    \n    prefixItems: Option[::[JsonSchema]] = None,\n    items: Option[JsonSchema] = None,\n    contains: Option[JsonSchema] = None,\n\n    // =========================================================================\n    // Unevaluated Vocabulary\n    // =========================================================================\n    \n    unevaluatedProperties: Option[JsonSchema] = None,\n    unevaluatedItems: Option[JsonSchema] = None,\n\n    // =========================================================================\n    // Validation Vocabulary (Type)\n    // =========================================================================\n    \n    `type`: Option[SchemaType] = None,\n    `enum`: Option[::[Json]] = None,\n    const: Option[Json] = None,\n\n    // =========================================================================\n    // Validation Vocabulary (Numeric)\n    // =========================================================================\n    \n    multipleOf: Option[PositiveNumber] = None,\n    maximum: Option[BigDecimal] = None,\n    exclusiveMaximum: Option[BigDecimal] = None,\n    minimum: Option[BigDecimal] = None,\n    exclusiveMinimum: Option[BigDecimal] = None,\n\n    // =========================================================================\n    // Validation Vocabulary (String)\n    // =========================================================================\n    \n    minLength: Option[NonNegativeInt] = None,\n    maxLength: Option[NonNegativeInt] = None,\n    pattern: Option[RegexPattern] = None,\n\n    // =========================================================================\n    // Validation Vocabulary (Array)\n    // =========================================================================\n    \n    minItems: Option[NonNegativeInt] = None,\n    maxItems: Option[NonNegativeInt] = None,\n    uniqueItems: Option[Boolean] = None,\n    minContains: Option[NonNegativeInt] = None,\n    maxContains: Option[NonNegativeInt] = None,\n\n    // =========================================================================\n    // Validation Vocabulary (Object)\n    // =========================================================================\n    \n    minProperties: Option[NonNegativeInt] = None,\n    maxProperties: Option[NonNegativeInt] = None,\n    required: Option[Set[String]] = None,\n    dependentRequired: Option[Map[String, Set[String]]] = None,\n\n    // =========================================================================\n    // Format Vocabulary\n    // =========================================================================\n    \n    format: Option[String] = None,\n\n    // =========================================================================\n    // Content Vocabulary\n    // =========================================================================\n    \n    contentEncoding: Option[String] = None,\n    contentMediaType: Option[String] = None,\n    contentSchema: Option[JsonSchema] = None,\n\n    // =========================================================================\n    // Meta-Data Vocabulary\n    // =========================================================================\n    \n    title: Option[String] = None,\n    description: Option[String] = None,\n    default: Option[Json] = None,\n    deprecated: Option[Boolean] = None,\n    readOnly: Option[Boolean] = None,\n    writeOnly: Option[Boolean] = None,\n    examples: Option[::[Json]] = None,\n\n    // =========================================================================\n    // Extensions\n    // =========================================================================\n    \n    /** Unrecognized keywords for round-trip fidelity and vendor extensions. */\n    extensions: Map[String, Json] = Map.empty\n\n  ) extends JsonSchema {\n    override def toJson: Json = ???\n    override def check(json: Json): Option[SchemaError] = ???\n  }\n\n  object SchemaObject {\n    val empty: SchemaObject = SchemaObject()\n  }\n  \n  // ===========================================================================\n  // Smart Constructors\n  // ===========================================================================\n  \n  def ofType(t: JsonType): JsonSchema = \n    SchemaObject(`type` = Some(SchemaType.Single(t)))\n  \n  def string(\n    minLength: Option[NonNegativeInt] = None,\n    maxLength: Option[NonNegativeInt] = None,\n    pattern: Option[RegexPattern] = None,\n    format: Option[String] = None\n  ): JsonSchema = SchemaObject(\n    `type` = Some(SchemaType.Single(JsonType.String)),\n    minLength = minLength,\n    maxLength = maxLength,\n    pattern = pattern,\n    format = format\n  )\n  \n  def number(\n    minimum: Option[BigDecimal] = None,\n    maximum: Option[BigDecimal] = None,\n    exclusiveMinimum: Option[BigDecimal] = None,\n    exclusiveMaximum: Option[BigDecimal] = None,\n    multipleOf: Option[PositiveNumber] = None\n  ): JsonSchema = SchemaObject(\n    `type` = Some(SchemaType.Single(JsonType.Number)),\n    minimum = minimum,\n    maximum = maximum,\n    exclusiveMinimum = exclusiveMinimum,\n    exclusiveMaximum = exclusiveMaximum,\n    multipleOf = multipleOf\n  )\n  \n  def integer(\n    minimum: Option[BigDecimal] = None,\n    maximum: Option[BigDecimal] = None\n  ): JsonSchema = SchemaObject(\n    `type` = Some(SchemaType.Single(JsonType.Integer)),\n    minimum = minimum,\n    maximum = maximum\n  )\n  \n  def array(\n    items: Option[JsonSchema] = None,\n    minItems: Option[NonNegativeInt] = None,\n    maxItems: Option[NonNegativeInt] = None,\n    uniqueItems: Option[Boolean] = None\n  ): JsonSchema = SchemaObject(\n    `type` = Some(SchemaType.Single(JsonType.Array)),\n    items = items,\n    minItems = minItems,\n    maxItems = maxItems,\n    uniqueItems = uniqueItems\n  )\n  \n  def `object`(\n    properties: Option[Map[String, JsonSchema]] = None,\n    required: Option[Set[String]] = None,\n    additionalProperties: Option[JsonSchema] = None\n  ): JsonSchema = SchemaObject(\n    `type` = Some(SchemaType.Single(JsonType.Object)),\n    properties = properties,\n    required = required,\n    additionalProperties = additionalProperties\n  )\n  \n  def enumOf(values: ::[Json]): JsonSchema = SchemaObject(`enum` = Some(values))\n  \n  def constOf(value: Json): JsonSchema = SchemaObject(const = Some(value))\n  \n  def ref(uri: UriReference): JsonSchema = SchemaObject($ref = Some(uri))\n  \n  val `null`: JsonSchema = ofType(JsonType.Null)\n  val boolean: JsonSchema = ofType(JsonType.Boolean)\n}\n```\n\n---\n\n## Validation to JsonSchema Mapping\n\nThe `Validation[A]` type in ZIO Blocks maps to JSON Schema validation keywords. Implement this mapping when generating schemas from `PrimitiveType`:\n\n| `Validation[A]` | JSON Schema Keywords |\n|-----------------|---------------------|\n| `Validation.None` | (no constraints) |\n| `Validation.Numeric.Positive` | `exclusiveMinimum: 0` |\n| `Validation.Numeric.NonNegative` | `minimum: 0` |\n| `Validation.Numeric.Negative` | `exclusiveMaximum: 0` |\n| `Validation.Numeric.NonPositive` | `maximum: 0` |\n| `Validation.Numeric.Range(min, max)` | `minimum` / `maximum` |\n| `Validation.Numeric.Set(values)` | `enum: [...]` |\n| `Validation.String.NonEmpty` | `minLength: 1` |\n| `Validation.String.Empty` | `maxLength: 0` |\n| `Validation.String.Length(min, max)` | `minLength` / `maxLength` |\n| `Validation.String.Pattern(regex)` | `pattern` |\n\n---\n\n## Modifier.config Keys\n\nSupport these `Modifier.config` keys when generating JSON Schema:\n\n| Key | Effect |\n|-----|--------|\n| `json-schema.format` | Sets `format` keyword (e.g., `\"email\"`, `\"date-time\"`, `\"uuid\"`) |\n| `json-schema.deprecated` | Sets `deprecated: true` |\n| `json-schema.title` | Overrides `title` |\n| `json-schema.description` | Overrides `description` |\n\n---\n\n## Files to Create or Modify\n\n| File | Action |\n|------|--------|\n| `schema/shared/src/main/scala/zio/blocks/schema/json/JsonSchema.scala` | **CREATE** - Main ADT |\n| `schema/shared/src/main/scala/zio/blocks/schema/json/JsonBinaryCodec.scala` | **MODIFY** - Add `def toJsonSchema: JsonSchema` |\n| `schema/shared/src/main/scala/zio/blocks/schema/json/JsonBinaryCodecDeriver.scala` | **MODIFY** - Implement `toJsonSchema` for all derivation cases |\n| `schema/shared/src/main/scala/zio/blocks/schema/Schema.scala` | **MODIFY** - Add `toJsonSchema`, `fromJsonSchema`, `Schema[Json]` |\n| `schema/shared/src/main/scala/zio/blocks/schema/json/Json.scala` | **MODIFY** - Update `check`/`conforms` signatures |\n\n---\n\n## Required Test Suites\n\nAll tests should use ZIO Test and follow the existing test patterns in the codebase.\n\n### 1. `JsonSchemaSpec`  Core ADT Tests\n\n**Location:** `schema/shared/src/test/scala/zio/blocks/schema/json/JsonSchemaSpec.scala`\n\nMust test:\n\n- **Boolean schemas**: `True` accepts all JSON, `False` rejects all JSON\n- **Type validation**: Each `JsonType` validates correctly (null, boolean, string, number, integer, array, object)\n- **Type unions**: `type: [\"string\", \"number\"]` accepts either\n- **Numeric constraints**: `minimum`, `maximum`, `exclusiveMinimum`, `exclusiveMaximum`, `multipleOf`\n- **String constraints**: `minLength`, `maxLength`, `pattern`\n- **Array constraints**: `minItems`, `maxItems`, `uniqueItems`, `prefixItems`, `items`, `contains`, `minContains`, `maxContains`\n- **Object constraints**: `properties`, `required`, `additionalProperties`, `propertyNames`, `minProperties`, `maxProperties`, `patternProperties`, `dependentRequired`, `dependentSchemas`\n- **Composition**: `allOf`, `anyOf`, `oneOf`, `not`\n- **Conditional**: `if`/`then`/`else`\n- **Enum and const**: exact value matching\n- **Error accumulation**: Multiple validation failures are collected, not just the first\n\n### 2. `JsonSchemaRoundTripSpec`  Serialization Tests\n\n**Location:** `schema/shared/src/test/scala/zio/blocks/schema/json/JsonSchemaRoundTripSpec.scala`\n\nMust test:\n\n- **`toJson` / `fromJson` round-trip**: For every `JsonSchema`, `JsonSchema.fromJson(schema.toJson) == Right(schema)`\n- **Parse canonical examples**: Parse schemas from the JSON Schema test suite or spec examples\n- **Boolean schema serialization**: `true` and `false` as JSON booleans\n- **Empty object equivalence**: `{}` parses to `SchemaObject.empty` which is equivalent to `True`\n- **Extension preservation**: Unknown keywords in `extensions` survive round-trip\n- **All keyword serialization**: Every field in `SchemaObject` serializes to the correct JSON keyword\n\n### 3. `JsonBinaryCodecToJsonSchemaSpec`  Codec Schema Extraction Tests\n\n**Location:** `schema/shared/src/test/scala/zio/blocks/schema/json/JsonBinaryCodecToJsonSchemaSpec.scala`\n\nMust test:\n\n- **Primitives**: Each primitive type produces correct JSON Schema (`String`  `type: \"string\"`, `Int`  `type: \"integer\"`, etc.)\n- **Temporal types**: `Instant`, `LocalDate`, etc. produce `type: \"string\"` with appropriate `format`\n- **Records**: Case classes produce `type: \"object\"` with `properties` and `required`\n- **Variants (sealed traits)**: Produce `oneOf` or discriminator-based schema depending on `DiscriminatorKind`\n- **Enumerations**: Sealed traits with all case objects produce `enum`\n- **Option fields**: Non-required properties or union with `null`\n- **Collections**: `List[A]`, `Set[A]`, `Vector[A]` produce `type: \"array\"` with `items`\n- **Maps**: `Map[String, V]` produces `type: \"object\"` with `additionalProperties`\n- **Nested structures**: Deeply nested case classes produce correct nested schemas\n- **Field renaming**: `Modifier.rename` and `fieldNameMapper` affect property names\n- **Transient fields**: `Modifier.transient` fields are excluded from schema\n- **Documentation**: `Doc` maps to `description`\n- **Validation constraints**: `Validation[A]` on primitives maps to validation keywords\n- **Config modifiers**: `Modifier.config(\"json-schema.format\", \"email\")` sets `format`\n\n### 4. `SchemaToJsonSchemaSpec`  Schema Conversion Tests\n\n**Location:** `schema/shared/src/test/scala/zio/blocks/schema/json/SchemaToJsonSchemaSpec.scala`\n\nMust test:\n\n- **All built-in schemas**: `Schema[Int]`, `Schema[String]`, `Schema[Boolean]`, etc.\n- **Derived schemas**: `Schema.derived` for case classes and sealed traits\n- **Consistency with codec**: `Schema[A].toJsonSchema` should match `Schema[A].derive(JsonFormat.deriver).toJsonSchema`\n- **Recursive types**: Self-referential case classes produce schemas with `$ref` or equivalent\n\n### 5. `SchemaFromJsonSchemaSpec`  Schema Construction Tests\n\n**Location:** `schema/shared/src/test/scala/zio/blocks/schema/json/SchemaFromJsonSchemaSpec.scala`\n\nMust test:\n\n- **Valid JSON passes**: `Schema.fromJsonSchema(schema)` accepts conforming JSON\n- **Invalid JSON fails**: Non-conforming JSON fails with descriptive error\n- **Error messages**: Validation errors include path information\n- **Round-trip through DynamicValue**: JSON  DynamicValue  JSON preserves structure\n- **Encode/decode works**: The resulting `Schema[Json]` can be used with `JsonFormat` for encoding/decoding\n\n### 6. `JsonCheckSpec`  Json.check/conforms Tests\n\n**Location:** `schema/shared/src/test/scala/zio/blocks/schema/json/JsonCheckSpec.scala`\n\nMust test:\n\n- **Method signatures**: `check` returns `Option[SchemaError]`, `conforms` returns `Boolean`\n- **Delegation**: These methods delegate to `JsonSchema.check`\n- **All validation scenarios**: Mirror tests from `JsonSchemaSpec` but called via `Json` methods\n\n### 7. `JsonSchemaCombinatorSpec`  Combinator Tests\n\n**Location:** `schema/shared/src/test/scala/zio/blocks/schema/json/JsonSchemaCombinatorSpec.scala`\n\nMust test:\n\n- **`&&` (allOf)**: `schema1 && schema2` validates if both pass\n- **`||` (anyOf)**: `schema1 || schema2` validates if either passes\n- **`!` (not)**: `!schema` validates if schema fails\n- **Associativity**: `(a && b) && c` equivalent to `a && (b && c)`\n- **Commutativity**: `a && b` equivalent to `b && a` (for validation purposes)\n- **De Morgan's laws**: `!(a && b)` equivalent to `!a || !b`\n\n---\n\n## Acceptance Criteria\n\n- [ ] All test suites pass\n- [ ] `JsonSchema` ADT covers JSON Schema 2020-12 core, applicator, validation, format, content, and metadata vocabularies\n- [ ] `JsonSchema#toJson` produces valid JSON Schema documents\n- [ ] `JsonSchema.fromJson` parses valid JSON Schema documents\n- [ ] `JsonSchema#check` validates JSON values with accumulated errors\n- [ ] `JsonBinaryCodec[A].toJsonSchema` produces accurate schemas reflecting codec configuration\n- [ ] `Schema[A].toJsonSchema` works for all derivable types\n- [ ] `Schema.fromJsonSchema` produces a working `Schema[Json]` with validation\n- [ ] `Json#check` and `Json#conforms` work with the new `JsonSchema` parameter type\n- [ ] `Validation[A]` constraints map to appropriate JSON Schema keywords\n- [ ] `Doc` maps to `description`\n- [ ] `Modifier.rename`, `Modifier.transient`, and `Modifier.config` are respected\n- [ ] Code follows existing project style and conventions\n- [ ] No new dependencies are introduced (use existing `Json` type, not a third-party JSON library)\n\n---\n\n## Notes for Implementers\n\n1. **Start with the ADT**: Get `JsonSchema` working with `toJson`/`fromJson`/`check` before integrating with `JsonBinaryCodec`.\n\n2. **Study the Avro implementation**: `AvroFormat` and `AvroBinaryCodec` show the established pattern for schema extraction from codecs.\n\n3. **Validation is the hard part**: The `check` method needs to correctly implement JSON Schema validation semantics, including `unevaluatedProperties`/`unevaluatedItems` which require tracking which properties/items were \"evaluated\" by other keywords.\n\n4. **Error accumulation**: Use `SchemaError` which already supports multiple errors. Include path information using `DynamicOptic`.\n\n5. **`$ref` resolution**: For this initial implementation, `$ref` within the same document (using `$defs`) should work. Cross-document references are out of scope.\n\n6. **Format validation**: The `format` keyword is an annotation by default in 2020-12. Implement validation for common formats (`date-time`, `date`, `time`, `email`, `uuid`, `uri`) but make it non-fatal or configurable.\n\n7. **Test against the official test suite**: The [JSON Schema Test Suite](https://github.com/json-schema-org/JSON-Schema-Test-Suite) provides comprehensive test cases. Consider using it to validate your implementation.",
              "url": "https://github.com/zio/zio-blocks/issues/462",
              "tech": [],
              "repo_name": "zio-blocks",
              "repo_owner": "zio",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "ZIO#517",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "ZIO",
              "id": "generated-ZIO",
              "name": "ZIO",
              "description": "",
              "members": [],
              "display_name": "ZIO",
              "created_at": "2026-01-24T11:31:18.805Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/ZIO?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "zio",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-24T11:31:18.805Z",
            "created_at": "2026-01-24T11:31:18.805Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-ZIO#517",
              "status": "open",
              "type": "issue",
              "number": 517,
              "title": "Add structural schemas",
              "source": {
                "data": {
                  "id": "source-ZIO#517",
                  "user": {
                    "login": "jdegoes",
                    "id": 156745,
                    "node_id": "MDQ6VXNlcjE1Njc0NQ==",
                    "avatar_url": "https://avatars.githubusercontent.com/u/156745?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/jdegoes",
                    "html_url": "https://github.com/jdegoes",
                    "followers_url": "https://api.github.com/users/jdegoes/followers",
                    "following_url": "https://api.github.com/users/jdegoes/following{/other_user}",
                    "gists_url": "https://api.github.com/users/jdegoes/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/jdegoes/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/jdegoes/subscriptions",
                    "organizations_url": "https://api.github.com/users/jdegoes/orgs",
                    "repos_url": "https://api.github.com/users/jdegoes/repos",
                    "events_url": "https://api.github.com/users/jdegoes/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/jdegoes/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Add structural schemas",
                  "body": "# Structural Type Schema Support\n\n## Overview\n\nExtend `Schema[A]` to support structural types, enabling schema derivation for types defined by their structure rather than their nominal identity. This allows for duck-typed schema validation and conversion between nominal and structural representations.\n\n## Core Concepts\n\n### Direct Structural Schema Derivation\n\nSchemas can be derived directly for structural types:\n\n```scala\n// Scala 3\ntype Person = { def name: String; def age: Int }\nval schema = Schema.derived[Person]\n\n// Scala 2\ntype Person = { def name: String; def age: Int }\nval schema = Schema.derived[Person]\n```\n\n**Note**: Both Scala 2 and Scala 3 use `def` for uniformity, even though Scala 3 supports `val` in structural types.\n\n**Implementation**: Schemas have bindings, which allow construction / deconstruction of values. Values for structural types are backed by:\n- **Scala 3**: `Selectable` \n- **Scala 2**: `Dynamic`\n\n### Nominal to Structural Conversion\n\nConvert nominal type schemas to their structural equivalents:\n\n```scala\ncase class Person(name: String, age: Int)\n\n// Get the structural schema corresponding to Person's shape\nval structuralSchema: Schema[{ def name: String; def age: Int }] = \n  Schema.derived[Person].structural\n```\n\n### Schema API Extension\n\n```scala\ncase class Schema[A](/* existing fields */) {\n  /**\n   * Convert this schema to a structural type schema.\n   * \n   * The structural type represents the \"shape\" of A without its nominal identity.\n   * This enables duck typing and structural validation.\n   * \n   * @param toStructural Macro-generated conversion to structural representation\n   * @return Schema for the structural type corresponding to A\n   */\n  def structural(implicit toStructural: ToStructural[A]): Schema[toStructural.StructuralType] = \n    toStructural.apply(this)\n}\n\n/**\n * Type class for converting nominal schemas to structural schemas.\n * Generated by macro for all supported types. Macro fails if a structural\n * type cannot be generated.\n *\n * NOTE: This approach has to be tested to yield inferrable types, and revised\n * if necessary. Inferrable types (from calling Schema#structural) are a must-have.\n */\ntrait ToStructural[A] {\n  type StructuralType\n  def apply(schema: Schema[A]): Schema[StructuralType]\n}\n\nobject ToStructural {\n  type Aux[A, S] = ToStructural[A] { type StructuralType = S }\n  \n  // Scala 3\n  transparent inline given [A]: ToStructural[A] = ${toStructuralMacro[A]}\n  \n  // Scala 2\n  implicit def materialize[A]: ToStructural[A] = macro toStructuralImpl[A]\n}\n```\n\n---\n\n## Examples\n\n### 1. Simple Product Types\n\n#### Case Class to Structural\n\n```scala\n// Both Scala 2 and Scala 3\ncase class Person(name: String, age: Int)\n\n// Original nominal schema\nval nominalSchema: Schema[Person] = Schema.derived[Person]\n\n// Convert to structural\nval structuralSchema: Schema[{ def name: String; def age: Int }] = \n  nominalSchema.structural\n\n// Direct structural derivation (equivalent)\nval directStructural: Schema[{ def name: String; def age: Int }] = \n  Schema.derived[{ def name: String; def age: Int }]\n```\n\n### 2. Nested Structures\n\n```scala\ncase class Address(street: String, city: String, zip: Int)\ncase class Person(name: String, age: Int, address: Address)\n\nval structuralSchema = Schema.derived[Person].structural\n// Type: Schema[{ \n//   def name: String\n//   def age: Int\n//   def address: { def street: String; def city: String; def zip: Int }\n// }]\n```\n\n### 3. Collections and Options\n\n```scala\ncase class Team(name: String, members: List[String], leader: Option[String])\n\nval structuralSchema = Schema.derived[Team].structural\n// Type: Schema[{\n//   def name: String\n//   def members: List[String]\n//   def leader: Option[String]\n// }]\n```\n\n### 4. Tuples to Structural\n\n```scala\n// Tuples can be converted to structural types\nval tupleSchema: Schema[(String, Int, Boolean)] = Schema.derived[(String, Int, Boolean)]\n\nval structuralSchema = tupleSchema.structural\n// Type: Schema[{ def _1: String; def _2: Int; def _3: Boolean }]\n```\n\n### 5. Sum Types (Sealed Traits) - Scala 3 Only\n\nSealed traits become union types of structural representations, with tag information stored at the type level:\n\n```scala\n// Scala 3 only\nsealed trait Result\ncase class Success(value: Int) extends Result\ncase class Failure(error: String) extends Result\n\nval structuralSchema = Schema.derived[Result].structural\n// Type: Schema[\n//   { type Tag = \"Success\"; def value: Int } | { type Tag = \"Failure\"; def error: String }\n// ]\n```\n\n**Note**: Sum type to structural conversion is **not supported in Scala 2** because it requires union types. Attempting to call `.structural` on a sealed trait schema in Scala 2 will result in a compile-time error.\n\n### 6. Enums (Scala 3 Only)\n\n```scala\nenum Status:\n  case Active, Inactive, Suspended\n\nval structuralSchema = Schema.derived[Status].structural\n// Type: Schema[{type Tag = \"Active\"} | {type Tag = \"Inactive\"} | {type Tag = \"Suspended\"}]\n```\n\n### 7. Opaque Types (Scala 3)\n\n```scala\nopaque type UserId = String\nobject UserId:\n  def apply(value: String): Either[String, UserId] = \n    if value.nonEmpty then Right(value) else Left(\"Empty user ID\")\n\ncase class User(id: UserId, name: String)\n\nval structuralSchema = Schema.derived[User].structural\n// Type: Schema[{ def id: String; def name: String }]\n// Opaque type is unwrapped to its underlying type\n```\n\n### 8. Bidirectional Conversion\n\nStructural schemas work seamlessly with `Into`/`As` (if this ticket is implemented **after** that ticket):\n\n```scala\ncase class Person(name: String, age: Int)\n\nval structuralSchema = Schema.derived[Person].structural\n\n// Create structural value (Scala 3)\nval structuralPerson = new Selectable {\n  def selectDynamic(field: String): Any = field match {\n    case \"name\" => \"Alice\"\n    case \"age\" => 30\n  }\n}\n\n// Convert structural to nominal using Into\nval person: Either[SchemaError, Person] = \n  Into[{ def name: String; def age: Int }, Person].into(structuralPerson)\n// => Right(Person(\"Alice\", 30))\n\n// Convert nominal to structural\nval backToStructural: Either[SchemaError, { def name: String; def age: Int }] = \n  Into[Person, { def name: String; def age: Int }].into(Person(\"Bob\", 25))\n```\n\n### 9. Empty and Single-Field Products\n\n```scala\n// Empty case class\ncase class Empty()\nval emptyStructural = Schema.derived[Empty].structural\n// Type: Schema[{}]\n\n// Single field\ncase class Id(value: String)\nval idStructural = Schema.derived[Id].structural\n// Type: Schema[{ def value: String }]\n```\n\n### 10. Large Products\n\n```scala\ncase class LargeRecord(\n  f1: String, f2: Int, f3: Boolean, f4: Double, f5: Long,\n  f6: String, f7: Int, f8: Boolean, f9: Double, f10: Long,\n  f11: String, f12: Int, f13: Boolean, f14: Double, f15: Long,\n  f16: String, f17: Int, f18: Boolean, f19: Double, f20: Long,\n  f21: String\n)\n\nval structuralSchema = Schema.derived[LargeRecord].structural\n// Type: Schema[{\n//   def f1: String; def f2: Int; def f3: Boolean; ...\n//   def f21: String\n// }]\n```\n\n---\n\n## Type Name Handling\n\n### Current Limitation\n\nSchemas currently use `TypeName[A]` to identify types. Structural types don't have meaningful nominal type names, which creates a mismatch.\n\n### Temporary Solution\n\nUntil `TypeName[A]` is replaced with `TypeId[A]` (see issue #471), structural schemas will use a normalized string representation of the structural type as a fake type name:\n\n```scala\ncase class Person(name: String, age: Int)\n\nval schema = Schema.derived[Person]\nschema.typeName // => TypeName for \"Person\"\n\nval structural = schema.structural\nstructural.typeName // => TypeName for \"{age:Int,name:String}\"\n// Normalized: fields sorted alphabetically, types fully qualified\n```\n\n### Normalization Rules\n\n1. **Field ordering**: Alphabetical by field name\n2. **Type qualification**: Use simple names for primitives and standard library types\n3. **Whitespace**: No whitespace in generated names\n4. **Collections**: Standard notation (e.g., `List[Int]`)\n5. **Options**: Explicit `Option[T]` notation\n6. **Nested structures**: Recursive application of rules\n7. **Deterministic**: Same structure always produces same normalized name\n\n### Examples\n\n```scala\n// Simple product\ncase class Point(x: Int, y: Int)\nSchema.derived[Point].structural.typeName \n// => \"{x:Int,y:Int}\"\n\n// Nested product\ncase class Address(street: String, zip: Int)\ncase class Person(name: String, address: Address)\nSchema.derived[Person].structural.typeName\n// => \"{address:{street:String,zip:Int},name:String}\"\n\n// With collections\ncase class Team(name: String, members: List[String])\nSchema.derived[Team].structural.typeName\n// => \"{members:List[String],name:String}\"\n\n// Union type (Scala 3)\nsealed trait Result\ncase class Success(value: Int) extends Result\ncase class Failure(error: String) extends Result\nSchema.derived[Result].structural.typeName\n// => \"{error:String}|{value:Int}\"\n```\n\n### Future: TypeId[A]\n\nThe upcoming `TypeId[A]` replacement will properly handle structural types by representing them by their structure rather than a string-based hack. See issue #471 for details.\n\n---\n\n## Limitations and Edge Cases\n\n### 1. Generic Types\n\n**Behavior depends on existing Schema derivation support for generic types.**\n\nIf `Schema.derived[Container[Int]]` already works, then structural conversion should work:\n\n```scala\ncase class Container[T](value: T)\n\n// If this works:\nval schema = Schema.derived[Container[Int]]\n\n// Then this should work:\nval structural = schema.structural\n// Type: Schema[{ def value: Int }]\n```\n\nIf generic type derivation is not currently supported, this ticket **does not require implementing it**. The macro should produce a clear compile-time error for unsupported generic types.\n\n### 2. Recursive Types\n\nRecursive types will **fail at compile-time** because Scala does not support infinite types:\n\n```scala\ncase class Tree(value: Int, children: List[Tree])\n\n// This will FAIL at compile-time:\nval structural = Schema.derived[Tree].structural\n// Compile error: Cannot generate infinite structural type\n\n// The structural type would need to be:\n// { def value: Int; def children: List[{ def value: Int; def children: List[...] }] }\n// which is infinite and unsupported\n```\n\nThe macro must detect recursive types and produce a helpful error message:\n\n```\nCompile error: Cannot generate structural type for recursive type Tree.\nStructural types cannot represent recursive structures.\n```\n\n### 3. Mutually Recursive Types\n\nSimilarly, mutually recursive types are unsupported:\n\n```scala\ncase class Node(id: Int, edges: List[Edge])\ncase class Edge(from: Int, to: Node)\n\n// This will FAIL at compile-time:\nval nodeStructural = Schema.derived[Node].structural\n// Compile error: Cannot generate structural type for mutually recursive types\n```\n\n### 4. Sum Types in Scala 2\n\nSealed traits and sum types **cannot be converted to structural types in Scala 2** because they require union types:\n\n```scala\n// Scala 2\nsealed trait Result\ncase class Success(value: Int) extends Result\ncase class Failure(error: String) extends Result\n\n// This will FAIL at compile-time in Scala 2:\nval structural = Schema.derived[Result].structural\n// Compile error: Cannot generate structural type for sum types in Scala 2.\n// Union types are required, which are only available in Scala 3.\n```\n\nThe macro must detect sum types in Scala 2 and produce a clear error.\n\n### 5. Case Objects\n\nCase objects become empty structural types:\n\n```scala\ncase object Singleton\n\nval structural = Schema.derived[Singleton.type].structural\n// Type: Schema[{}]\n```\n\nFor sum types with case objects (Scala 3):\n\n```scala\nsealed trait Status\ncase object Active extends Status\ncase object Inactive extends Status\n\nval structural = Schema.derived[Status].structural\n// Type: Schema[{} | {}]\n// Not particularly useful, but valid\n```\n\n### 6. Structural Types as Source\n\nDeriving schemas directly for structural types is supported:\n\n```scala\ntype PersonStructure = { def name: String; def age: Int }\n\nval schema = Schema.derived[PersonStructure]\n// Should work if structural type derivation is implemented\n```\n\nThe schema's bindings will use `Selectable` (Scala 3) or `Dynamic` (Scala 2) to construct and deconstruct values.\n\n---\n\n## Integration with Into/As\n\nStructural schemas compose naturally with `Into`/`As` conversions.\n\n### Nominal  Structural\n\n```scala\ncase class Person(name: String, age: Int)\n\n// Auto-derived conversion\nval nominalToStructural: Into[Person, { def name: String; def age: Int }] = \n  Into.derived\n\nval person = Person(\"Alice\", 30)\nval structural = nominalToStructural.into(person)\n// => Right(<Selectable/Dynamic instance>)\n```\n\n### Structural  Nominal\n\n```scala\ntype PersonStructure = { def name: String; def age: Int }\ncase class Person(name: String, age: Int)\n\n// Auto-derived conversion\nval structuralToNominal: Into[PersonStructure, Person] = \n  Into.derived\n\nval structural: PersonStructure = new Selectable {\n  def selectDynamic(field: String): Any = field match {\n    case \"name\" => \"Bob\"\n    case \"age\" => 25\n  }\n}\n\nval person = structuralToNominal.into(structural)\n// => Right(Person(\"Bob\", 25))\n```\n\n### Bidirectional (As)\n\n```scala\ncase class Person(name: String, age: Int)\n\n// Bidirectional conversion\nval personAs: As[Person, { def name: String; def age: Int }] = \n  As.derived\n\n// Nominal  Structural\nval structural = personAs.into(Person(\"Alice\", 30))\n\n// Structural  Nominal\nval nominal = structural.flatMap(personAs.from)\n// Round-trip successful\n```\n\n### Schema-Guided Conversion\n\n```scala\ncase class PersonV1(firstName: String, lastName: String, age: Int)\ncase class PersonV2(name: String, age: Int)\n\n// Use structural type as intermediary\ntype PersonStructure = { def name: String; def age: Int }\n\n// Step 1: Transform V1 to structural (custom logic)\nval v1ToStructural: Into[PersonV1, PersonStructure] = \n  new Into[PersonV1, PersonStructure] {\n    def into(v1: PersonV1): Either[SchemaError, PersonStructure] = {\n      Right(new Selectable {\n        def selectDynamic(field: String): Any = field match {\n          case \"name\" => s\"${v1.firstName} ${v1.lastName}\"\n          case \"age\" => v1.age\n        }\n      })\n    }\n  }\n\n// Step 2: Auto-convert structural to V2\nval structuralToV2: Into[PersonStructure, PersonV2] = Into.derived\n\n// Composed migration\ndef migrate(v1: PersonV1): Either[SchemaError, PersonV2] = {\n  v1ToStructural.into(v1).flatMap(structuralToV2.into)\n}\n```\n\n---\n\n## Testing Requirements\n\n### Test Matrix\n\n1. **Direct Structural Derivation**\n   - Simple products (case classes)\n   - Nested products\n   - Collections (List, Vector, Set, Map, Option, Either)\n   - Tuples (2-22 elements)\n   - Empty case classes\n   - Single-field case classes\n   - Large products (20+ fields)\n   - Case objects\n\n2. **Nominal to Structural Conversion**\n   - Case class  structural\n   - Tuple  structural\n   - Nested case classes  nested structural\n   - Case class with collections  structural with collections\n   - Empty case class  empty structural\n\n3. **Sum Types (Scala 3 Only)**\n   - Sealed trait  union type structural\n   - Sealed trait with case objects\n   - Enum  union type structural\n   - Nested sum types\n\n4. **Type Name Generation**\n   - Simple product normalized name\n   - Nested product normalized name\n   - Name determinism (same structure = same name)\n   - Alphabetical field ordering in names\n   - Union type names (Scala 3)\n\n5. **Selectable/Dynamic Implementation**\n   - Scala 3 Selectable field access\n   - Scala 2 Dynamic field access\n   - Field access correctness\n   - Missing field behavior\n   - Extra field behavior\n\n6. **Integration with Into/As**\n   - Nominal  Structural via Into\n   - Structural  Nominal via Into\n   - Round-trip via As\n   - Composed conversions with structural intermediary\n\n7. **Error Cases (Compile-Time)**\n   - Recursive types produce error\n   - Mutually recursive types produce error\n   - Sum types in Scala 2 produce error\n   - Unsupported types produce helpful errors\n\n8. **Generic Types** (if supported by existing Schema derivation)\n   - Fully applied generic  structural\n   - Generic with nested structural fields\n\n### Scala 2 vs Scala 3 Test Separation\n\n```\nsrc/test/scala/\n  structural/\n    common/\n      SimpleProductSpec.scala\n      NestedProductSpec.scala\n      CollectionsSpec.scala\n      TuplesSpec.scala\n      EmptyProductSpec.scala\n      SingleFieldSpec.scala\n      LargeProductSpec.scala\n      TypeNameNormalizationSpec.scala\n      IntoIntegrationSpec.scala\n      AsIntegrationSpec.scala\n      \n    scala3/\n      UnionTypesSpec.scala\n      SealedTraitToUnionSpec.scala\n      EnumToUnionSpec.scala\n      SelectableImplementationSpec.scala\n      \n    scala2/\n      DynamicImplementationSpec.scala\n      SumTypeErrorSpec.scala (verifies compile error)\n      \n    errors/\n      RecursiveTypeErrorSpec.scala\n      MutualRecursionErrorSpec.scala\n      UnsupportedTypeErrorSpec.scala\n```\n\n### Test Examples\n\n```scala\n// Test: Simple product to structural\ntest(\"case class converts to structural schema\") {\n  case class Person(name: String, age: Int)\n  \n  val structural = Schema.derived[Person].structural\n  \n  // Type check (this is a compile-time test)\n  val _: Schema[{ def name: String; def age: Int }] = structural\n  \n  assert(structural.typeName.toString.contains(\"name\"))\n  assert(structural.typeName.toString.contains(\"age\"))\n}\n\n// Test: Nested products\ntest(\"nested case classes convert to nested structural\") {\n  case class Address(street: String, zip: Int)\n  case class Person(name: String, address: Address)\n  \n  val structural = Schema.derived[Person].structural\n  \n  val _: Schema[{ \n    def name: String\n    def address: { def street: String; def zip: Int }\n  }] = structural\n}\n\n// Test: Tuple to structural\ntest(\"tuple converts to structural with _N fields\") {\n  val structural = Schema.derived[(String, Int, Boolean)].structural\n  \n  val _: Schema[{ def _1: String; def _2: Int; def _3: Boolean }] = structural\n}\n\n// Test: Union type (Scala 3 only)\ntest(\"sealed trait converts to union type structural\") {\n  sealed trait Result\n  case class Success(value: Int) extends Result\n  case class Failure(error: String) extends Result\n  \n  val structural = Schema.derived[Result].structural\n  \n  val _: Schema[{ def value: Int } | { def error: String }] = structural\n}\n\n// Test: Type name normalization\ntest(\"structural type names are normalized and deterministic\") {\n  case class Person(name: String, age: Int)\n  case class User(age: Int, name: String) // Different field order\n  \n  val personStructural = Schema.derived[Person].structural\n  val userStructural = Schema.derived[User].structural\n  \n  // Same structure, same normalized name\n  assert(personStructural.typeName == userStructural.typeName)\n  \n  // Alphabetical ordering\n  assert(personStructural.typeName.toString.contains(\"age\"))\n  assert(personStructural.typeName.toString.indexOf(\"age\") < \n         personStructural.typeName.toString.indexOf(\"name\"))\n}\n\n// Test: Integration with Into\ntest(\"structural to nominal conversion via Into\") {\n  case class Person(name: String, age: Int)\n  type PersonStructure = { def name: String; def age: Int }\n  \n  val structural: PersonStructure = new Selectable {\n    def selectDynamic(field: String): Any = field match {\n      case \"name\" => \"Alice\"\n      case \"age\" => 30\n    }\n  }\n  \n  val person = Into[PersonStructure, Person].into(structural)\n  assert(person == Right(Person(\"Alice\", 30)))\n}\n\n// Test: Round-trip via As\ntest(\"nominal to structural and back preserves data\") {\n  case class Person(name: String, age: Int)\n  type PersonStructure = { def name: String; def age: Int }\n  \n  val original = Person(\"Alice\", 30)\n  \n  val toStructural = As[Person, PersonStructure].into(original)\n  val backToNominal = toStructural.flatMap(As[Person, PersonStructure].from)\n  \n  assert(backToNominal == Right(original))\n}\n\n// Test: Recursive type compile error\ntest(\"recursive types produce compile error\") {\n  case class Tree(value: Int, children: List[Tree])\n  \n  assertDoesNotCompile(\"Schema.derived[Tree].structural\")\n}\n\n// Test: Sum type in Scala 2 compile error\ntest(\"sum types in Scala 2 produce compile error\") {\n  sealed trait Result\n  case class Success(value: Int) extends Result\n  \n  // Scala 2 only\n  assertDoesNotCompile(\"Schema.derived[Result].structural\")\n}\n```\n\n---\n\n## Implementation Notes\n\n### Macro Behavior\n\nThe macro must:\n\n1. **Detect product types** (case classes, tuples) and generate structural types with `def` members\n2. **Detect sum types** (sealed traits, enums) and:\n   - In Scala 3: Generate union types of structural representations\n   - In Scala 2: Fail with clear error message\n3. **Detect recursive types** and fail with clear error message\n4. **Normalize structural type representations** for type name generation\n5. **Generate `ToStructural` instance** with:\n   - `StructuralType` type member set to the generated structural type\n   - `apply` method that transforms the schema appropriately\n6. **Preserve field metadata** from original schema where applicable\n7. **Generate appropriate bindings** using `Selectable` (Scala 3) or `Dynamic` (Scala 2)\n\n### Schema Transformation\n\nWhen converting `Schema[A]` to `Schema[StructuralType]`:\n\n1. **Preserve field information**: Field names, types, optional/required status\n2. **Update type name**: Use normalized structural representation\n3. **Transform bindings**: Replace nominal constructors/deconstructors with structural equivalents\n4. **Preserve validation**: Maintain any validation logic that applies to field values\n5. **Handle nested schemas**: Recursively transform nested product types\n\n### Error Messages\n\nProvide clear compile-time errors:\n\n```scala\n// Recursive type\ncase class Tree(value: Int, children: List[Tree])\nSchema.derived[Tree].structural\n\n// Error:\n\"\"\"\nCannot generate structural type for recursive type Tree.\nStructural types cannot represent recursive structures.\nScala's type system does not support infinite types.\n\"\"\"\n\n// Sum type in Scala 2\nsealed trait Result\ncase class Success(value: Int) extends Result\nSchema.derived[Result].structural\n\n// Error (Scala 2 only):\n\"\"\"\nCannot generate structural type for sum type Result.\nStructural representation of sum types requires union types,\nwhich are only available in Scala 3.\nConsider upgrading to Scala 3 or using a different approach.\n\"\"\"\n```\n\n---\n\n## Deliverables\n\n1.  `ToStructural[A]` trait and macro for Scala 2.13\n2.  `ToStructural[A]` trait and macro for Scala 3.5\n3.  `structural` method on `Schema[A]`\n4.  Support for product types (case classes, tuples)\n5.  Support for sum types (sealed traits, enums) in Scala 3 only\n6.  Normalized type name generation\n7.  `Selectable` bindings (Scala 3) and `Dynamic` bindings (Scala 2)\n8.  Integration with `Into`/`As` for structural  nominal conversions\n9.  Comprehensive test suite (300+ test cases)\n10.  Clear error messages for unsupported cases\n11.  Documentation with examples",
                  "html_url": "https://github.com/zio/zio-blocks/issues/517"
                },
                "type": "github"
              },
              "hash": "zio/zio-blocks#517",
              "body": "# Structural Type Schema Support\n\n## Overview\n\nExtend `Schema[A]` to support structural types, enabling schema derivation for types defined by their structure rather than their nominal identity. This allows for duck-typed schema validation and conversion between nominal and structural representations.\n\n## Core Concepts\n\n### Direct Structural Schema Derivation\n\nSchemas can be derived directly for structural types:\n\n```scala\n// Scala 3\ntype Person = { def name: String; def age: Int }\nval schema = Schema.derived[Person]\n\n// Scala 2\ntype Person = { def name: String; def age: Int }\nval schema = Schema.derived[Person]\n```\n\n**Note**: Both Scala 2 and Scala 3 use `def` for uniformity, even though Scala 3 supports `val` in structural types.\n\n**Implementation**: Schemas have bindings, which allow construction / deconstruction of values. Values for structural types are backed by:\n- **Scala 3**: `Selectable` \n- **Scala 2**: `Dynamic`\n\n### Nominal to Structural Conversion\n\nConvert nominal type schemas to their structural equivalents:\n\n```scala\ncase class Person(name: String, age: Int)\n\n// Get the structural schema corresponding to Person's shape\nval structuralSchema: Schema[{ def name: String; def age: Int }] = \n  Schema.derived[Person].structural\n```\n\n### Schema API Extension\n\n```scala\ncase class Schema[A](/* existing fields */) {\n  /**\n   * Convert this schema to a structural type schema.\n   * \n   * The structural type represents the \"shape\" of A without its nominal identity.\n   * This enables duck typing and structural validation.\n   * \n   * @param toStructural Macro-generated conversion to structural representation\n   * @return Schema for the structural type corresponding to A\n   */\n  def structural(implicit toStructural: ToStructural[A]): Schema[toStructural.StructuralType] = \n    toStructural.apply(this)\n}\n\n/**\n * Type class for converting nominal schemas to structural schemas.\n * Generated by macro for all supported types. Macro fails if a structural\n * type cannot be generated.\n *\n * NOTE: This approach has to be tested to yield inferrable types, and revised\n * if necessary. Inferrable types (from calling Schema#structural) are a must-have.\n */\ntrait ToStructural[A] {\n  type StructuralType\n  def apply(schema: Schema[A]): Schema[StructuralType]\n}\n\nobject ToStructural {\n  type Aux[A, S] = ToStructural[A] { type StructuralType = S }\n  \n  // Scala 3\n  transparent inline given [A]: ToStructural[A] = ${toStructuralMacro[A]}\n  \n  // Scala 2\n  implicit def materialize[A]: ToStructural[A] = macro toStructuralImpl[A]\n}\n```\n\n---\n\n## Examples\n\n### 1. Simple Product Types\n\n#### Case Class to Structural\n\n```scala\n// Both Scala 2 and Scala 3\ncase class Person(name: String, age: Int)\n\n// Original nominal schema\nval nominalSchema: Schema[Person] = Schema.derived[Person]\n\n// Convert to structural\nval structuralSchema: Schema[{ def name: String; def age: Int }] = \n  nominalSchema.structural\n\n// Direct structural derivation (equivalent)\nval directStructural: Schema[{ def name: String; def age: Int }] = \n  Schema.derived[{ def name: String; def age: Int }]\n```\n\n### 2. Nested Structures\n\n```scala\ncase class Address(street: String, city: String, zip: Int)\ncase class Person(name: String, age: Int, address: Address)\n\nval structuralSchema = Schema.derived[Person].structural\n// Type: Schema[{ \n//   def name: String\n//   def age: Int\n//   def address: { def street: String; def city: String; def zip: Int }\n// }]\n```\n\n### 3. Collections and Options\n\n```scala\ncase class Team(name: String, members: List[String], leader: Option[String])\n\nval structuralSchema = Schema.derived[Team].structural\n// Type: Schema[{\n//   def name: String\n//   def members: List[String]\n//   def leader: Option[String]\n// }]\n```\n\n### 4. Tuples to Structural\n\n```scala\n// Tuples can be converted to structural types\nval tupleSchema: Schema[(String, Int, Boolean)] = Schema.derived[(String, Int, Boolean)]\n\nval structuralSchema = tupleSchema.structural\n// Type: Schema[{ def _1: String; def _2: Int; def _3: Boolean }]\n```\n\n### 5. Sum Types (Sealed Traits) - Scala 3 Only\n\nSealed traits become union types of structural representations, with tag information stored at the type level:\n\n```scala\n// Scala 3 only\nsealed trait Result\ncase class Success(value: Int) extends Result\ncase class Failure(error: String) extends Result\n\nval structuralSchema = Schema.derived[Result].structural\n// Type: Schema[\n//   { type Tag = \"Success\"; def value: Int } | { type Tag = \"Failure\"; def error: String }\n// ]\n```\n\n**Note**: Sum type to structural conversion is **not supported in Scala 2** because it requires union types. Attempting to call `.structural` on a sealed trait schema in Scala 2 will result in a compile-time error.\n\n### 6. Enums (Scala 3 Only)\n\n```scala\nenum Status:\n  case Active, Inactive, Suspended\n\nval structuralSchema = Schema.derived[Status].structural\n// Type: Schema[{type Tag = \"Active\"} | {type Tag = \"Inactive\"} | {type Tag = \"Suspended\"}]\n```\n\n### 7. Opaque Types (Scala 3)\n\n```scala\nopaque type UserId = String\nobject UserId:\n  def apply(value: String): Either[String, UserId] = \n    if value.nonEmpty then Right(value) else Left(\"Empty user ID\")\n\ncase class User(id: UserId, name: String)\n\nval structuralSchema = Schema.derived[User].structural\n// Type: Schema[{ def id: String; def name: String }]\n// Opaque type is unwrapped to its underlying type\n```\n\n### 8. Bidirectional Conversion\n\nStructural schemas work seamlessly with `Into`/`As` (if this ticket is implemented **after** that ticket):\n\n```scala\ncase class Person(name: String, age: Int)\n\nval structuralSchema = Schema.derived[Person].structural\n\n// Create structural value (Scala 3)\nval structuralPerson = new Selectable {\n  def selectDynamic(field: String): Any = field match {\n    case \"name\" => \"Alice\"\n    case \"age\" => 30\n  }\n}\n\n// Convert structural to nominal using Into\nval person: Either[SchemaError, Person] = \n  Into[{ def name: String; def age: Int }, Person].into(structuralPerson)\n// => Right(Person(\"Alice\", 30))\n\n// Convert nominal to structural\nval backToStructural: Either[SchemaError, { def name: String; def age: Int }] = \n  Into[Person, { def name: String; def age: Int }].into(Person(\"Bob\", 25))\n```\n\n### 9. Empty and Single-Field Products\n\n```scala\n// Empty case class\ncase class Empty()\nval emptyStructural = Schema.derived[Empty].structural\n// Type: Schema[{}]\n\n// Single field\ncase class Id(value: String)\nval idStructural = Schema.derived[Id].structural\n// Type: Schema[{ def value: String }]\n```\n\n### 10. Large Products\n\n```scala\ncase class LargeRecord(\n  f1: String, f2: Int, f3: Boolean, f4: Double, f5: Long,\n  f6: String, f7: Int, f8: Boolean, f9: Double, f10: Long,\n  f11: String, f12: Int, f13: Boolean, f14: Double, f15: Long,\n  f16: String, f17: Int, f18: Boolean, f19: Double, f20: Long,\n  f21: String\n)\n\nval structuralSchema = Schema.derived[LargeRecord].structural\n// Type: Schema[{\n//   def f1: String; def f2: Int; def f3: Boolean; ...\n//   def f21: String\n// }]\n```\n\n---\n\n## Type Name Handling\n\n### Current Limitation\n\nSchemas currently use `TypeName[A]` to identify types. Structural types don't have meaningful nominal type names, which creates a mismatch.\n\n### Temporary Solution\n\nUntil `TypeName[A]` is replaced with `TypeId[A]` (see issue #471), structural schemas will use a normalized string representation of the structural type as a fake type name:\n\n```scala\ncase class Person(name: String, age: Int)\n\nval schema = Schema.derived[Person]\nschema.typeName // => TypeName for \"Person\"\n\nval structural = schema.structural\nstructural.typeName // => TypeName for \"{age:Int,name:String}\"\n// Normalized: fields sorted alphabetically, types fully qualified\n```\n\n### Normalization Rules\n\n1. **Field ordering**: Alphabetical by field name\n2. **Type qualification**: Use simple names for primitives and standard library types\n3. **Whitespace**: No whitespace in generated names\n4. **Collections**: Standard notation (e.g., `List[Int]`)\n5. **Options**: Explicit `Option[T]` notation\n6. **Nested structures**: Recursive application of rules\n7. **Deterministic**: Same structure always produces same normalized name\n\n### Examples\n\n```scala\n// Simple product\ncase class Point(x: Int, y: Int)\nSchema.derived[Point].structural.typeName \n// => \"{x:Int,y:Int}\"\n\n// Nested product\ncase class Address(street: String, zip: Int)\ncase class Person(name: String, address: Address)\nSchema.derived[Person].structural.typeName\n// => \"{address:{street:String,zip:Int},name:String}\"\n\n// With collections\ncase class Team(name: String, members: List[String])\nSchema.derived[Team].structural.typeName\n// => \"{members:List[String],name:String}\"\n\n// Union type (Scala 3)\nsealed trait Result\ncase class Success(value: Int) extends Result\ncase class Failure(error: String) extends Result\nSchema.derived[Result].structural.typeName\n// => \"{error:String}|{value:Int}\"\n```\n\n### Future: TypeId[A]\n\nThe upcoming `TypeId[A]` replacement will properly handle structural types by representing them by their structure rather than a string-based hack. See issue #471 for details.\n\n---\n\n## Limitations and Edge Cases\n\n### 1. Generic Types\n\n**Behavior depends on existing Schema derivation support for generic types.**\n\nIf `Schema.derived[Container[Int]]` already works, then structural conversion should work:\n\n```scala\ncase class Container[T](value: T)\n\n// If this works:\nval schema = Schema.derived[Container[Int]]\n\n// Then this should work:\nval structural = schema.structural\n// Type: Schema[{ def value: Int }]\n```\n\nIf generic type derivation is not currently supported, this ticket **does not require implementing it**. The macro should produce a clear compile-time error for unsupported generic types.\n\n### 2. Recursive Types\n\nRecursive types will **fail at compile-time** because Scala does not support infinite types:\n\n```scala\ncase class Tree(value: Int, children: List[Tree])\n\n// This will FAIL at compile-time:\nval structural = Schema.derived[Tree].structural\n// Compile error: Cannot generate infinite structural type\n\n// The structural type would need to be:\n// { def value: Int; def children: List[{ def value: Int; def children: List[...] }] }\n// which is infinite and unsupported\n```\n\nThe macro must detect recursive types and produce a helpful error message:\n\n```\nCompile error: Cannot generate structural type for recursive type Tree.\nStructural types cannot represent recursive structures.\n```\n\n### 3. Mutually Recursive Types\n\nSimilarly, mutually recursive types are unsupported:\n\n```scala\ncase class Node(id: Int, edges: List[Edge])\ncase class Edge(from: Int, to: Node)\n\n// This will FAIL at compile-time:\nval nodeStructural = Schema.derived[Node].structural\n// Compile error: Cannot generate structural type for mutually recursive types\n```\n\n### 4. Sum Types in Scala 2\n\nSealed traits and sum types **cannot be converted to structural types in Scala 2** because they require union types:\n\n```scala\n// Scala 2\nsealed trait Result\ncase class Success(value: Int) extends Result\ncase class Failure(error: String) extends Result\n\n// This will FAIL at compile-time in Scala 2:\nval structural = Schema.derived[Result].structural\n// Compile error: Cannot generate structural type for sum types in Scala 2.\n// Union types are required, which are only available in Scala 3.\n```\n\nThe macro must detect sum types in Scala 2 and produce a clear error.\n\n### 5. Case Objects\n\nCase objects become empty structural types:\n\n```scala\ncase object Singleton\n\nval structural = Schema.derived[Singleton.type].structural\n// Type: Schema[{}]\n```\n\nFor sum types with case objects (Scala 3):\n\n```scala\nsealed trait Status\ncase object Active extends Status\ncase object Inactive extends Status\n\nval structural = Schema.derived[Status].structural\n// Type: Schema[{} | {}]\n// Not particularly useful, but valid\n```\n\n### 6. Structural Types as Source\n\nDeriving schemas directly for structural types is supported:\n\n```scala\ntype PersonStructure = { def name: String; def age: Int }\n\nval schema = Schema.derived[PersonStructure]\n// Should work if structural type derivation is implemented\n```\n\nThe schema's bindings will use `Selectable` (Scala 3) or `Dynamic` (Scala 2) to construct and deconstruct values.\n\n---\n\n## Integration with Into/As\n\nStructural schemas compose naturally with `Into`/`As` conversions.\n\n### Nominal  Structural\n\n```scala\ncase class Person(name: String, age: Int)\n\n// Auto-derived conversion\nval nominalToStructural: Into[Person, { def name: String; def age: Int }] = \n  Into.derived\n\nval person = Person(\"Alice\", 30)\nval structural = nominalToStructural.into(person)\n// => Right(<Selectable/Dynamic instance>)\n```\n\n### Structural  Nominal\n\n```scala\ntype PersonStructure = { def name: String; def age: Int }\ncase class Person(name: String, age: Int)\n\n// Auto-derived conversion\nval structuralToNominal: Into[PersonStructure, Person] = \n  Into.derived\n\nval structural: PersonStructure = new Selectable {\n  def selectDynamic(field: String): Any = field match {\n    case \"name\" => \"Bob\"\n    case \"age\" => 25\n  }\n}\n\nval person = structuralToNominal.into(structural)\n// => Right(Person(\"Bob\", 25))\n```\n\n### Bidirectional (As)\n\n```scala\ncase class Person(name: String, age: Int)\n\n// Bidirectional conversion\nval personAs: As[Person, { def name: String; def age: Int }] = \n  As.derived\n\n// Nominal  Structural\nval structural = personAs.into(Person(\"Alice\", 30))\n\n// Structural  Nominal\nval nominal = structural.flatMap(personAs.from)\n// Round-trip successful\n```\n\n### Schema-Guided Conversion\n\n```scala\ncase class PersonV1(firstName: String, lastName: String, age: Int)\ncase class PersonV2(name: String, age: Int)\n\n// Use structural type as intermediary\ntype PersonStructure = { def name: String; def age: Int }\n\n// Step 1: Transform V1 to structural (custom logic)\nval v1ToStructural: Into[PersonV1, PersonStructure] = \n  new Into[PersonV1, PersonStructure] {\n    def into(v1: PersonV1): Either[SchemaError, PersonStructure] = {\n      Right(new Selectable {\n        def selectDynamic(field: String): Any = field match {\n          case \"name\" => s\"${v1.firstName} ${v1.lastName}\"\n          case \"age\" => v1.age\n        }\n      })\n    }\n  }\n\n// Step 2: Auto-convert structural to V2\nval structuralToV2: Into[PersonStructure, PersonV2] = Into.derived\n\n// Composed migration\ndef migrate(v1: PersonV1): Either[SchemaError, PersonV2] = {\n  v1ToStructural.into(v1).flatMap(structuralToV2.into)\n}\n```\n\n---\n\n## Testing Requirements\n\n### Test Matrix\n\n1. **Direct Structural Derivation**\n   - Simple products (case classes)\n   - Nested products\n   - Collections (List, Vector, Set, Map, Option, Either)\n   - Tuples (2-22 elements)\n   - Empty case classes\n   - Single-field case classes\n   - Large products (20+ fields)\n   - Case objects\n\n2. **Nominal to Structural Conversion**\n   - Case class  structural\n   - Tuple  structural\n   - Nested case classes  nested structural\n   - Case class with collections  structural with collections\n   - Empty case class  empty structural\n\n3. **Sum Types (Scala 3 Only)**\n   - Sealed trait  union type structural\n   - Sealed trait with case objects\n   - Enum  union type structural\n   - Nested sum types\n\n4. **Type Name Generation**\n   - Simple product normalized name\n   - Nested product normalized name\n   - Name determinism (same structure = same name)\n   - Alphabetical field ordering in names\n   - Union type names (Scala 3)\n\n5. **Selectable/Dynamic Implementation**\n   - Scala 3 Selectable field access\n   - Scala 2 Dynamic field access\n   - Field access correctness\n   - Missing field behavior\n   - Extra field behavior\n\n6. **Integration with Into/As**\n   - Nominal  Structural via Into\n   - Structural  Nominal via Into\n   - Round-trip via As\n   - Composed conversions with structural intermediary\n\n7. **Error Cases (Compile-Time)**\n   - Recursive types produce error\n   - Mutually recursive types produce error\n   - Sum types in Scala 2 produce error\n   - Unsupported types produce helpful errors\n\n8. **Generic Types** (if supported by existing Schema derivation)\n   - Fully applied generic  structural\n   - Generic with nested structural fields\n\n### Scala 2 vs Scala 3 Test Separation\n\n```\nsrc/test/scala/\n  structural/\n    common/\n      SimpleProductSpec.scala\n      NestedProductSpec.scala\n      CollectionsSpec.scala\n      TuplesSpec.scala\n      EmptyProductSpec.scala\n      SingleFieldSpec.scala\n      LargeProductSpec.scala\n      TypeNameNormalizationSpec.scala\n      IntoIntegrationSpec.scala\n      AsIntegrationSpec.scala\n      \n    scala3/\n      UnionTypesSpec.scala\n      SealedTraitToUnionSpec.scala\n      EnumToUnionSpec.scala\n      SelectableImplementationSpec.scala\n      \n    scala2/\n      DynamicImplementationSpec.scala\n      SumTypeErrorSpec.scala (verifies compile error)\n      \n    errors/\n      RecursiveTypeErrorSpec.scala\n      MutualRecursionErrorSpec.scala\n      UnsupportedTypeErrorSpec.scala\n```\n\n### Test Examples\n\n```scala\n// Test: Simple product to structural\ntest(\"case class converts to structural schema\") {\n  case class Person(name: String, age: Int)\n  \n  val structural = Schema.derived[Person].structural\n  \n  // Type check (this is a compile-time test)\n  val _: Schema[{ def name: String; def age: Int }] = structural\n  \n  assert(structural.typeName.toString.contains(\"name\"))\n  assert(structural.typeName.toString.contains(\"age\"))\n}\n\n// Test: Nested products\ntest(\"nested case classes convert to nested structural\") {\n  case class Address(street: String, zip: Int)\n  case class Person(name: String, address: Address)\n  \n  val structural = Schema.derived[Person].structural\n  \n  val _: Schema[{ \n    def name: String\n    def address: { def street: String; def zip: Int }\n  }] = structural\n}\n\n// Test: Tuple to structural\ntest(\"tuple converts to structural with _N fields\") {\n  val structural = Schema.derived[(String, Int, Boolean)].structural\n  \n  val _: Schema[{ def _1: String; def _2: Int; def _3: Boolean }] = structural\n}\n\n// Test: Union type (Scala 3 only)\ntest(\"sealed trait converts to union type structural\") {\n  sealed trait Result\n  case class Success(value: Int) extends Result\n  case class Failure(error: String) extends Result\n  \n  val structural = Schema.derived[Result].structural\n  \n  val _: Schema[{ def value: Int } | { def error: String }] = structural\n}\n\n// Test: Type name normalization\ntest(\"structural type names are normalized and deterministic\") {\n  case class Person(name: String, age: Int)\n  case class User(age: Int, name: String) // Different field order\n  \n  val personStructural = Schema.derived[Person].structural\n  val userStructural = Schema.derived[User].structural\n  \n  // Same structure, same normalized name\n  assert(personStructural.typeName == userStructural.typeName)\n  \n  // Alphabetical ordering\n  assert(personStructural.typeName.toString.contains(\"age\"))\n  assert(personStructural.typeName.toString.indexOf(\"age\") < \n         personStructural.typeName.toString.indexOf(\"name\"))\n}\n\n// Test: Integration with Into\ntest(\"structural to nominal conversion via Into\") {\n  case class Person(name: String, age: Int)\n  type PersonStructure = { def name: String; def age: Int }\n  \n  val structural: PersonStructure = new Selectable {\n    def selectDynamic(field: String): Any = field match {\n      case \"name\" => \"Alice\"\n      case \"age\" => 30\n    }\n  }\n  \n  val person = Into[PersonStructure, Person].into(structural)\n  assert(person == Right(Person(\"Alice\", 30)))\n}\n\n// Test: Round-trip via As\ntest(\"nominal to structural and back preserves data\") {\n  case class Person(name: String, age: Int)\n  type PersonStructure = { def name: String; def age: Int }\n  \n  val original = Person(\"Alice\", 30)\n  \n  val toStructural = As[Person, PersonStructure].into(original)\n  val backToNominal = toStructural.flatMap(As[Person, PersonStructure].from)\n  \n  assert(backToNominal == Right(original))\n}\n\n// Test: Recursive type compile error\ntest(\"recursive types produce compile error\") {\n  case class Tree(value: Int, children: List[Tree])\n  \n  assertDoesNotCompile(\"Schema.derived[Tree].structural\")\n}\n\n// Test: Sum type in Scala 2 compile error\ntest(\"sum types in Scala 2 produce compile error\") {\n  sealed trait Result\n  case class Success(value: Int) extends Result\n  \n  // Scala 2 only\n  assertDoesNotCompile(\"Schema.derived[Result].structural\")\n}\n```\n\n---\n\n## Implementation Notes\n\n### Macro Behavior\n\nThe macro must:\n\n1. **Detect product types** (case classes, tuples) and generate structural types with `def` members\n2. **Detect sum types** (sealed traits, enums) and:\n   - In Scala 3: Generate union types of structural representations\n   - In Scala 2: Fail with clear error message\n3. **Detect recursive types** and fail with clear error message\n4. **Normalize structural type representations** for type name generation\n5. **Generate `ToStructural` instance** with:\n   - `StructuralType` type member set to the generated structural type\n   - `apply` method that transforms the schema appropriately\n6. **Preserve field metadata** from original schema where applicable\n7. **Generate appropriate bindings** using `Selectable` (Scala 3) or `Dynamic` (Scala 2)\n\n### Schema Transformation\n\nWhen converting `Schema[A]` to `Schema[StructuralType]`:\n\n1. **Preserve field information**: Field names, types, optional/required status\n2. **Update type name**: Use normalized structural representation\n3. **Transform bindings**: Replace nominal constructors/deconstructors with structural equivalents\n4. **Preserve validation**: Maintain any validation logic that applies to field values\n5. **Handle nested schemas**: Recursively transform nested product types\n\n### Error Messages\n\nProvide clear compile-time errors:\n\n```scala\n// Recursive type\ncase class Tree(value: Int, children: List[Tree])\nSchema.derived[Tree].structural\n\n// Error:\n\"\"\"\nCannot generate structural type for recursive type Tree.\nStructural types cannot represent recursive structures.\nScala's type system does not support infinite types.\n\"\"\"\n\n// Sum type in Scala 2\nsealed trait Result\ncase class Success(value: Int) extends Result\nSchema.derived[Result].structural\n\n// Error (Scala 2 only):\n\"\"\"\nCannot generate structural type for sum type Result.\nStructural representation of sum types requires union types,\nwhich are only available in Scala 3.\nConsider upgrading to Scala 3 or using a different approach.\n\"\"\"\n```\n\n---\n\n## Deliverables\n\n1.  `ToStructural[A]` trait and macro for Scala 2.13\n2.  `ToStructural[A]` trait and macro for Scala 3.5\n3.  `structural` method on `Schema[A]`\n4.  Support for product types (case classes, tuples)\n5.  Support for sum types (sealed traits, enums) in Scala 3 only\n6.  Normalized type name generation\n7.  `Selectable` bindings (Scala 3) and `Dynamic` bindings (Scala 2)\n8.  Integration with `Into`/`As` for structural  nominal conversions\n9.  Comprehensive test suite (300+ test cases)\n10.  Clear error messages for unsupported cases\n11.  Documentation with examples",
              "url": "https://github.com/zio/zio-blocks/issues/517",
              "tech": [],
              "repo_name": "zio-blocks",
              "repo_owner": "zio",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "ZIO#685",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "ZIO",
              "id": "generated-ZIO",
              "name": "ZIO",
              "description": "",
              "members": [],
              "display_name": "ZIO",
              "created_at": "2026-01-24T11:31:18.961Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/ZIO?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "zio",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-24T11:31:18.961Z",
            "created_at": "2026-01-24T11:31:18.961Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-ZIO#685",
              "status": "open",
              "type": "issue",
              "number": 685,
              "title": "Add JsonPatch - Depends on #679",
              "source": {
                "data": {
                  "id": "source-ZIO#685",
                  "user": {
                    "login": "jdegoes",
                    "id": 156745,
                    "node_id": "MDQ6VXNlcjE1Njc0NQ==",
                    "avatar_url": "https://avatars.githubusercontent.com/u/156745?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/jdegoes",
                    "html_url": "https://github.com/jdegoes",
                    "followers_url": "https://api.github.com/users/jdegoes/followers",
                    "following_url": "https://api.github.com/users/jdegoes/following{/other_user}",
                    "gists_url": "https://api.github.com/users/jdegoes/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/jdegoes/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/jdegoes/subscriptions",
                    "organizations_url": "https://api.github.com/users/jdegoes/orgs",
                    "repos_url": "https://api.github.com/users/jdegoes/repos",
                    "events_url": "https://api.github.com/users/jdegoes/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/jdegoes/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Add JsonPatch - Depends on #679",
                  "body": "<html><head></head><body><h1>Add <code>JsonPatch</code> type for diffing and patching JSON values</h1>\n<h2>Summary</h2>\n<p>Implement a <code>JsonPatch</code> type that enables computing diffs between JSON values and applying patches to transform one JSON value into another. This type should mirror the existing <code>DynamicPatch</code> implementation, adapted for JSON's simpler data model.</p>\n<h2>Motivation</h2>\n<p><code>DynamicValue</code> has a well-designed <code>DynamicPatch</code> system with:</p>\n<ul>\n<li>Monoid composition (<code>++</code> with <code>empty</code> identity)</li>\n<li>LCS-based sequence diffing</li>\n<li>Primitive delta operations (numeric deltas, string edits)</li>\n<li>Comprehensive algebraic laws verified by property tests</li>\n</ul>\n<p>The proposed <code>Json</code> type (see #TBD) needs equivalent patching capabilities. Rather than converting <code>Json  DynamicValue</code> for every patch operation, a native <code>JsonPatch</code> provides:</p>\n<ul>\n<li>Type safety (no conversion errors for JSON-incompatible DynamicPatch operations)</li>\n<li>API consistency with the <code>Json</code> type</li>\n<li>Potential for JSON-specific optimizations</li>\n</ul>\n<h2>Design Sketch</h2>\n<p>A design sketch is available at <a href=\"https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/json/JsonPatch.scala\"><code>schema/shared/src/main/scala/zio/blocks/schema/json/JsonPatch.scala</code></a>. This sketch is <strong>a guide, not a specification</strong>  implementers should use judgment and deviate where appropriate.</p>\n<h3>Core Types</h3>\n<p>The design mirrors <code>DynamicPatch</code> with JSON-specific adaptations:</p>\n\nDynamicPatch | JsonPatch | Notes\n-- | -- | --\nDynamicPatch(Vector[DynamicPatchOp]) | JsonPatch(Vector[JsonPatchOp]) | Same structure\nOperation.Set | Op.Set | Same\nOperation.PrimitiveDelta | Op.PrimitiveDelta | Simplified for JSON types\nOperation.SequenceEdit | Op.ArrayEdit | Renamed\nOperation.MapEdit | Op.ObjectEdit | String keys only\nOperation.Patch | Op.Nested | Same\nSeqOp | ArrayOp | Same operations\nMapOp | ObjectOp | String keys only\nPrimitiveOp (14 variants) | PrimitiveOp (2 variants) | See below\n\n\n<h3>StringOp</h3>\n<p>Mirror <code>DynamicPatch.StringOp</code> exactly:</p>\n<ul>\n<li><code>Insert(index: Int, text: String)</code></li>\n<li><code>Delete(index: Int, length: Int)</code></li>\n<li><code>Append(text: String)</code></li>\n<li><code>Modify(index: Int, length: Int, text: String)</code></li>\n</ul>\n<h3>ArrayOp</h3>\n<p>Mirror <code>DynamicPatch.SeqOp</code>:</p>\n<ul>\n<li><code>Insert(index: Int, values: Vector[Json])</code></li>\n<li><code>Append(values: Vector[Json])</code></li>\n<li><code>Delete(index: Int, count: Int)</code></li>\n<li><code>Modify(index: Int, op: Op)</code></li>\n</ul>\n<h3>ObjectOp</h3>\n<p>Mirror <code>DynamicPatch.MapOp</code> with string keys:</p>\n<ul>\n<li><code>Add(key: String, value: Json)</code></li>\n<li><code>Remove(key: String)</code></li>\n<li><code>Modify(key: String, patch: JsonPatch)</code></li>\n</ul>\n<h2>Requirements</h2>\n<h3>Functional Requirements</h3>\n<ul>\n<li>[ ] <strong>F1</strong>: <code>JsonPatch.diff(source, target)</code> computes a patch transforming source to target</li>\n<li>[ ] <strong>F2</strong>: <code>patch.apply(json, mode)</code> applies a patch with configurable failure handling</li>\n<li>[ ] <strong>F3</strong>: <code>patch1 ++ patch2</code> composes patches (apply first, then second)</li>\n<li>[ ] <strong>F4</strong>: <code>JsonPatch.empty</code> is the identity element for composition</li>\n<li>[ ] <strong>F5</strong>: Support <code>JsonPatchMode.Strict</code>, <code>Lenient</code>, and <code>Clobber</code> modes</li>\n<li>[ ] <strong>F6</strong>: Bidirectional conversion: <code>toDynamicPatch</code> / <code>fromDynamicPatch</code></li>\n</ul>\n<h3>Algebraic Laws</h3>\n<p>All laws must be verified with property-based tests (see <code>PatchLawsSpec</code> for reference):</p>\n<ul>\n<li>[ ] <strong>L1</strong>: Left identity  <code>(empty ++ p)(j) == p(j)</code></li>\n<li>[ ] <strong>L2</strong>: Right identity  <code>(p ++ empty)(j) == p(j)</code></li>\n<li>[ ] <strong>L3</strong>: Associativity  <code>((p1 ++ p2) ++ p3)(j) == (p1 ++ (p2 ++ p3))(j)</code></li>\n<li>[ ] <strong>L4</strong>: Roundtrip  <code>diff(a, b)(a) == Right(b)</code></li>\n<li>[ ] <strong>L5</strong>: Identity diff  <code>diff(j, j).isEmpty</code></li>\n<li>[ ] <strong>L6</strong>: Diff composition  <code>(diff(a, b) ++ diff(b, c))(a) == Right(c)</code></li>\n<li>[ ] <strong>L7</strong>: Lenient subsumes Strict  if <code>p(j, Strict) == Right(r)</code> then <code>p(j, Lenient) == Right(r)</code></li>\n</ul>\n<h3>Testing Requirements</h3>\n<ul>\n<li>[ ] <strong>T1</strong>: Property-based tests for all algebraic laws (see <code>PatchLawsSpec</code>)</li>\n<li>[ ] <strong>T2</strong>: Test each operation type (<code>Set</code>, <code>PrimitiveDelta</code>, <code>ArrayEdit</code>, <code>ObjectEdit</code>, <code>Nested</code>)</li>\n<li>[ ] <strong>T3</strong>: Test each <code>ArrayOp</code> variant (<code>Insert</code>, <code>Append</code>, <code>Delete</code>, <code>Modify</code>)</li>\n<li>[ ] <strong>T4</strong>: Test each <code>ObjectOp</code> variant (<code>Add</code>, <code>Remove</code>, <code>Modify</code>)</li>\n<li>[ ] <strong>T5</strong>: Test each <code>StringOp</code> variant (<code>Insert</code>, <code>Delete</code>, <code>Append</code>, <code>Modify</code>)</li>\n<li>[ ] <strong>T6</strong>: Test <code>NumberDelta</code> with positive, negative, zero, and decimal deltas</li>\n<li>[ ] <strong>T7</strong>: Test all three <code>JsonPatchMode</code> behaviors</li>\n<li>[ ] <strong>T8</strong>: Test <code>toDynamicPatch</code> / <code>fromDynamicPatch</code> roundtrip</li>\n<li>[ ] <strong>T9</strong>: Test edge cases: empty arrays, empty objects, empty strings, nested structures</li>\n<li>[ ] <strong>T10</strong>: Test error cases: invalid paths, type mismatches, out-of-bounds indices</li>\n</ul>\n<h3>Documentation Requirements</h3>\n<ul>\n<li>[ ] <strong>D1</strong>: ScalaDoc for all public types and methods</li>\n<li>[ ] <strong>D2</strong>: Usage examples in ScalaDoc (see sketch for examples)</li>\n<li>[ ] <strong>D3</strong>: Document algebraic laws in type-level comments</li>\n<li>[ ] <strong>D4</strong>: Document relationship to <code>DynamicPatch</code></li>\n</ul>\n<h3>Implementation Notes</h3>\n<ol>\n<li>\n<p><strong>Follow <code>DynamicPatch</code> patterns</strong>: The implementation in <code>DynamicPatch.scala</code> is the reference. Study <code>Differ.scala</code> for diff algorithms (especially LCS for sequences and strings).</p>\n</li>\n<li>\n<p><strong>Reuse algorithms where possible</strong>: Consider whether <code>JsonPatch</code> can delegate to <code>DynamicPatch</code> internally, or share algorithm implementations.</p>\n</li>\n<li>\n<p><strong>Keep it minimal</strong>: Resist adding operations not present in <code>DynamicPatch</code>. The design is intentionally minimal and principled.</p>\n</li>\n<li>\n<p><strong>Performance considerations</strong>: The register-based design of ZIO Blocks prioritizes performance. Avoid unnecessary allocations in hot paths.</p>\n</li>\n</ol>\n<h2>Out of Scope</h2>\n<p>The following are explicitly <strong>not</strong> part of this issue:</p>\n<ul>\n<li>RFC 6902 JSON Patch serialization format (separate issue)</li>\n<li>Patch inversion / undo support (separate issue)</li>\n<li>Patch optimization / compaction (separate issue)</li>\n<li>Integration with <code>Json</code> type methods like <code>json.diff(other)</code> (depends on <code>Json</code> implementation)</li>\n</ul>\n<h2>Related</h2>\n<ul>\n<li><code>DynamicPatch</code>  <a href=\"https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/DynamicPatch.scala\"><code>schema/shared/src/main/scala/zio/blocks/schema/patch/DynamicPatch.scala</code></a></li>\n<li><code>Differ</code>  <a href=\"https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/Differ.scala\"><code>schema/shared/src/main/scala/zio/blocks/schema/patch/Differ.scala</code></a></li>\n<li><code>PatchLawsSpec</code>  <a href=\"https://claude.ai/chat/schema/shared/src/test/scala/zio/blocks/schema/patch/PatchLawsSpec.scala\"><code>schema/shared/src/test/scala/zio/blocks/schema/patch/PatchLawsSpec.scala</code></a></li>\n<li><code>PatchMode</code>  <a href=\"https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/PatchMode.scala\"><code>schema/shared/src/main/scala/zio/blocks/schema/patch/PatchMode.scala</code></a></li>\n</ul>\n<h2>Acceptance Criteria</h2>\n<ul>\n<li>[ ] All functional requirements (F1-F6) implemented</li>\n<li>[ ] All algebraic laws (L1-L7) pass property-based tests</li>\n<li>[ ] All testing requirements (T1-T10) have corresponding test cases</li>\n<li>[ ] All documentation requirements (D1-D4) complete</li>\n<li>[ ] Code reviewed and approved</li>\n<li>[ ] CI passing</li>\n</ul></body></html># Add `JsonPatch` type for diffing and patching JSON values\n\n## Summary\n\nImplement a `JsonPatch` type that enables computing diffs between JSON values and applying patches to transform one JSON value into another. This type should mirror the existing `DynamicPatch` implementation, adapted for JSON's simpler data model.\n\n## Motivation\n\n`DynamicValue` has a well-designed `DynamicPatch` system with:\n- Monoid composition (`++` with `empty` identity)\n- LCS-based sequence diffing\n- Primitive delta operations (numeric deltas, string edits)\n- Comprehensive algebraic laws verified by property tests\n\nThe proposed `Json` type (see #TBD) needs equivalent patching capabilities. Rather than converting `Json  DynamicValue` for every patch operation, a native `JsonPatch` provides:\n- Type safety (no conversion errors for JSON-incompatible DynamicPatch operations)\n- API consistency with the `Json` type\n- Potential for JSON-specific optimizations\n\n## Design Sketch\n\nA design sketch is available at [`[schema/shared/src/main/scala/zio/blocks/schema/json/JsonPatch.scala](https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/json/JsonPatch.scala)`](./schema/shared/src/main/scala/zio/blocks/schema/json/JsonPatch.scala). This sketch is **a guide, not a specification**  implementers should use judgment and deviate where appropriate.\n\n### Core Types\n\nThe design mirrors `DynamicPatch` with JSON-specific adaptations:\n\n| DynamicPatch | JsonPatch | Notes |\n|--------------|-----------|-------|\n| `DynamicPatch(Vector[DynamicPatchOp])` | `JsonPatch(Vector[JsonPatchOp])` | Same structure |\n| `Operation.Set` | `Op.Set` | Same |\n| `Operation.PrimitiveDelta` | `Op.PrimitiveDelta` | Simplified for JSON types |\n| `Operation.SequenceEdit` | `Op.ArrayEdit` | Renamed |\n| `Operation.MapEdit` | `Op.ObjectEdit` | String keys only |\n| `Operation.Patch` | `Op.Nested` | Same |\n| `SeqOp` | `ArrayOp` | Same operations |\n| `MapOp` | `ObjectOp` | String keys only |\n| `PrimitiveOp` (14 variants) | `PrimitiveOp` (2 variants) | See below |\n\n### Primitive Operations\n\nJSON has a simpler type system than `DynamicValue`:\n\n| JSON Type | Delta Operation | Notes |\n|-----------|-----------------|-------|\n| Number | `NumberDelta(BigDecimal)` | Unifies all numeric deltas |\n| String | `StringEdit(Vector[StringOp])` | Same as `DynamicPatch` |\n| Boolean | Use `Op.Set` | No delta (same as `DynamicPatch`) |\n| Null | Use `Op.Set` | No delta |\n\n### StringOp\n\nMirror `DynamicPatch.StringOp` exactly:\n- `Insert(index: Int, text: String)`\n- `Delete(index: Int, length: Int)`\n- `Append(text: String)`\n- `Modify(index: Int, length: Int, text: String)`\n\n### ArrayOp\n\nMirror `DynamicPatch.SeqOp`:\n- `Insert(index: Int, values: Vector[Json])`\n- `Append(values: Vector[Json])`\n- `Delete(index: Int, count: Int)`\n- `Modify(index: Int, op: Op)`\n\n### ObjectOp\n\nMirror `DynamicPatch.MapOp` with string keys:\n- `Add(key: String, value: Json)`\n- `Remove(key: String)`\n- `Modify(key: String, patch: JsonPatch)`\n\n## Requirements\n\n### Functional Requirements\n\n- [ ] **F1**: `JsonPatch.diff(source, target)` computes a patch transforming source to target\n- [ ] **F2**: `patch.apply(json, mode)` applies a patch with configurable failure handling\n- [ ] **F3**: `patch1 ++ patch2` composes patches (apply first, then second)\n- [ ] **F4**: `JsonPatch.empty` is the identity element for composition\n- [ ] **F5**: Support `JsonPatchMode.Strict`, `Lenient`, and `Clobber` modes\n- [ ] **F6**: Bidirectional conversion: `toDynamicPatch` / `fromDynamicPatch`\n\n### Algebraic Laws\n\nAll laws must be verified with property-based tests (see `PatchLawsSpec` for reference):\n\n- [ ] **L1**: Left identity  `(empty ++ p)(j) == p(j)`\n- [ ] **L2**: Right identity  `(p ++ empty)(j) == p(j)`\n- [ ] **L3**: Associativity  `((p1 ++ p2) ++ p3)(j) == (p1 ++ (p2 ++ p3))(j)`\n- [ ] **L4**: Roundtrip  `diff(a, b)(a) == Right(b)`\n- [ ] **L5**: Identity diff  `diff(j, j).isEmpty`\n- [ ] **L6**: Diff composition  `(diff(a, b) ++ diff(b, c))(a) == Right(c)`\n- [ ] **L7**: Lenient subsumes Strict  if `p(j, Strict) == Right(r)` then `p(j, Lenient) == Right(r)`\n\n### Testing Requirements\n\n- [ ] **T1**: Property-based tests for all algebraic laws (see `PatchLawsSpec`)\n- [ ] **T2**: Test each operation type (`Set`, `PrimitiveDelta`, `ArrayEdit`, `ObjectEdit`, `Nested`)\n- [ ] **T3**: Test each `ArrayOp` variant (`Insert`, `Append`, `Delete`, `Modify`)\n- [ ] **T4**: Test each `ObjectOp` variant (`Add`, `Remove`, `Modify`)\n- [ ] **T5**: Test each `StringOp` variant (`Insert`, `Delete`, `Append`, `Modify`)\n- [ ] **T6**: Test `NumberDelta` with positive, negative, zero, and decimal deltas\n- [ ] **T7**: Test all three `JsonPatchMode` behaviors\n- [ ] **T8**: Test `toDynamicPatch` / `fromDynamicPatch` roundtrip\n- [ ] **T9**: Test edge cases: empty arrays, empty objects, empty strings, nested structures\n- [ ] **T10**: Test error cases: invalid paths, type mismatches, out-of-bounds indices\n\n### Documentation Requirements\n\n- [ ] **D1**: ScalaDoc for all public types and methods\n- [ ] **D2**: Usage examples in ScalaDoc (see sketch for examples)\n- [ ] **D3**: Document algebraic laws in type-level comments\n- [ ] **D4**: Document relationship to `DynamicPatch`\n\n## Related\n\n- `DynamicPatch`  [`[schema/shared/src/main/scala/zio/blocks/schema/patch/DynamicPatch.scala](https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/DynamicPatch.scala)`](./schema/shared/src/main/scala/zio/blocks/schema/patch/DynamicPatch.scala)\n- `Differ`  [`[schema/shared/src/main/scala/zio/blocks/schema/patch/Differ.scala](https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/Differ.scala)`](./schema/shared/src/main/scala/zio/blocks/schema/patch/Differ.scala)\n- `PatchLawsSpec`  [`[schema/shared/src/test/scala/zio/blocks/schema/patch/PatchLawsSpec.scala](https://claude.ai/chat/schema/shared/src/test/scala/zio/blocks/schema/patch/PatchLawsSpec.scala)`](./schema/shared/src/test/scala/zio/blocks/schema/patch/PatchLawsSpec.scala)\n- `PatchMode`  [`[schema/shared/src/main/scala/zio/blocks/schema/patch/PatchMode.scala](https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/PatchMode.scala)`](./schema/shared/src/main/scala/zio/blocks/schema/patch/PatchMode.scala)\n\n## Acceptance Criteria\n\n- [ ] All functional requirements (F1-F6) implemented\n- [ ] All algebraic laws (L1-L7) pass property-based tests\n- [ ] All testing requirements (T1-T10) have corresponding test cases\n- [ ] All documentation requirements (D1-D4) complete\n- [ ] Code reviewed and approved\n- [ ] CI passing\n\n# Sketch\n\n```scala\npackage zio.blocks.schema.json\n\nimport zio.blocks.schema.DynamicOptic\nimport zio.blocks.schema.patch.DynamicPatch\n\n// =============================================================================\n// JSON PATCH\n// =============================================================================\n\n/**\n * An untyped patch that operates on [[Json]] values.\n *\n * `JsonPatch` is the JSON-specific counterpart to [[DynamicPatch]]. It represents\n * a sequence of operations that transform one JSON value into another. Patches\n * are serializable and composable.\n *\n * ==Design==\n *\n * This type directly mirrors [[DynamicPatch]] but is specialized for JSON's\n * simpler data model:\n *  - JSON has 4 leaf types (String, Number, Boolean, Null) vs 30 PrimitiveValues\n *  - JSON objects have string keys only (no arbitrary-keyed maps)\n *  - JSON has no native Variant type\n *\n * ==Algebraic Laws==\n *\n * '''Monoid Laws''' (under `++` composition):\n * {{{\n * // 1. LEFT IDENTITY\n *  p: JsonPatch, j: Json.\n *   (JsonPatch.empty ++ p)(j, mode) == p(j, mode)\n *\n * // 2. RIGHT IDENTITY\n *  p: JsonPatch, j: Json.\n *   (p ++ JsonPatch.empty)(j, mode) == p(j, mode)\n *\n * // 3. ASSOCIATIVITY\n *  p1, p2, p3: JsonPatch, j: Json.\n *   ((p1 ++ p2) ++ p3)(j, mode) == (p1 ++ (p2 ++ p3))(j, mode)\n * }}}\n *\n * '''Diff/Apply Laws''':\n * {{{\n * // 4. ROUNDTRIP\n *  source, target: Json.\n *   JsonPatch.diff(source, target)(source, Strict) == Right(target)\n *\n * // 5. IDENTITY DIFF\n *  j: Json.\n *   JsonPatch.diff(j, j).isEmpty == true\n *\n * // 6. DIFF COMPOSITION\n *  a, b, c: Json.\n *   (JsonPatch.diff(a, b) ++ JsonPatch.diff(b, c))(a, Strict) == Right(c)\n * }}}\n *\n * '''PatchMode Laws''':\n * {{{\n * // 7. STRICT FAILS ON ERROR\n * // Strict mode fails on first precondition violation\n *\n * // 8. LENIENT SKIPS ERRORS\n * // Lenient mode skips failing operations, always returns Right\n *\n * // 9. LENIENT SUBSUMES STRICT\n *  p: JsonPatch, j: Json.\n *   p(j, Strict) == Right(r) implies p(j, Lenient) == Right(r)\n *\n * // 10. CLOBBER FORCES SUCCESS\n * // Clobber mode creates missing paths, always returns Right\n * }}}\n *\n * @param ops The sequence of patch operations\n */\nfinal case class JsonPatch(ops: Vector[JsonPatch.JsonPatchOp]) {\n\n  /**\n   * Applies this patch to a JSON value.\n   *\n   * @param json The JSON value to patch\n   * @param mode The patch mode (default: Strict)\n   * @return Either an error or the patched value\n   */\n  def apply(json: Json, mode: JsonPatchMode = JsonPatchMode.Strict): Either[JsonError, Json]\n\n  /**\n   * Composes this patch with another. Applies this patch first, then `that`.\n   *\n   * This is the monoid `combine` operation.\n   */\n  def ++(that: JsonPatch): JsonPatch = JsonPatch(ops ++ that.ops)\n\n  /**\n   * Returns true if this patch contains no operations.\n   */\n  def isEmpty: Boolean = ops.isEmpty\n\n  /**\n   * Converts this JSON patch to a [[DynamicPatch]].\n   */\n  def toDynamicPatch: DynamicPatch\n}\n\nobject JsonPatch {\n\n  /**\n   * Empty patch  the identity element for `++` composition.\n   */\n  val empty: JsonPatch = JsonPatch(Vector.empty)\n\n  /**\n   * Creates a patch with a single operation at the root path.\n   */\n  def root(op: Op): JsonPatch =\n    JsonPatch(Vector(JsonPatchOp(DynamicOptic.root, op)))\n\n  /**\n   * Creates a patch with a single operation at the given path.\n   */\n  def apply(path: DynamicOptic, op: Op): JsonPatch =\n    JsonPatch(Vector(JsonPatchOp(path, op)))\n\n  /**\n   * Computes a patch that transforms `oldJson` into `newJson`.\n   *\n   * Law: `diff(old, new)(old, Strict) == Right(new)`\n   */\n  def diff(oldJson: Json, newJson: Json): JsonPatch\n\n  /**\n   * Creates a JSON patch from a [[DynamicPatch]].\n   *\n   * May fail if the DynamicPatch contains operations not representable in JSON\n   * (e.g., non-string map keys, temporal deltas, variant operations).\n   */\n  def fromDynamicPatch(patch: DynamicPatch): Either[JsonError, JsonPatch]\n\n  // ===========================================================================\n  // JsonPatchOp  a single operation at a path\n  // ===========================================================================\n\n  /**\n   * A single patch operation: a path and what to do there.\n   *\n   * Mirrors [[DynamicPatch.DynamicPatchOp]].\n   */\n  final case class JsonPatchOp(path: DynamicOptic, op: Op)\n\n  // ===========================================================================\n  // Op  the operation to perform at a path\n  // ===========================================================================\n\n  /**\n   * The operation to perform at a target location.\n   *\n   * Mirrors [[DynamicPatch.Operation]] but specialized for JSON.\n   */\n  sealed trait Op\n\n  object Op {\n\n    /**\n     * Set a value directly (replacement).\n     *\n     * Mirrors [[DynamicPatch.Operation.Set]].\n     */\n    final case class Set(value: Json) extends Op\n\n    /**\n     * Apply a primitive delta operation.\n     *\n     * Used for numeric deltas and string edits.\n     * Mirrors [[DynamicPatch.Operation.PrimitiveDelta]].\n     */\n    final case class PrimitiveDelta(op: PrimitiveOp) extends Op\n\n    /**\n     * Apply array edit operations.\n     *\n     * Used for inserting, appending, deleting, or modifying array elements.\n     * Mirrors [[DynamicPatch.Operation.SequenceEdit]].\n     */\n    final case class ArrayEdit(ops: Vector[ArrayOp]) extends Op\n\n    /**\n     * Apply object edit operations.\n     *\n     * Used for adding, removing, or modifying object fields.\n     * Mirrors [[DynamicPatch.Operation.MapEdit]] but with string keys.\n     */\n    final case class ObjectEdit(ops: Vector[ObjectOp]) extends Op\n\n    /**\n     * Apply a nested patch.\n     *\n     * Used to group operations sharing a common path prefix.\n     * Mirrors [[DynamicPatch.Operation.Patch]].\n     */\n    final case class Nested(patch: JsonPatch) extends Op\n  }\n\n  // ===========================================================================\n  // PrimitiveOp  delta operations for JSON primitives\n  // ===========================================================================\n\n  /**\n   * Delta operations for JSON primitive values.\n   *\n   * JSON has only one numeric type, so we use BigDecimal for deltas.\n   * Boolean has no delta (use Set to toggle).\n   * Null has no delta (use Set to change).\n   *\n   * Mirrors [[DynamicPatch.PrimitiveOp]] but simplified for JSON's type system.\n   */\n  sealed trait PrimitiveOp\n\n  object PrimitiveOp {\n\n    /**\n     * Add a delta to a JSON number.\n     *\n     * Applied by: `currentValue + delta`\n     *\n     * Mirrors the numeric delta operations in [[DynamicPatch.PrimitiveOp]]\n     * (IntDelta, LongDelta, DoubleDelta, etc.) unified into one type.\n     */\n    final case class NumberDelta(delta: BigDecimal) extends PrimitiveOp\n\n    /**\n     * Apply string edit operations.\n     *\n     * Mirrors [[DynamicPatch.PrimitiveOp.StringEdit]].\n     */\n    final case class StringEdit(ops: Vector[StringOp]) extends PrimitiveOp\n  }\n\n  // ===========================================================================\n  // StringOp  edit operations for strings\n  // ===========================================================================\n\n  /**\n   * Edit operations for JSON strings.\n   *\n   * Mirrors [[DynamicPatch.StringOp]] exactly.\n   */\n  sealed trait StringOp\n\n  object StringOp {\n\n    /**\n     * Insert text at the given index.\n     */\n    final case class Insert(index: Int, text: String) extends StringOp\n\n    /**\n     * Delete characters starting at the given index.\n     */\n    final case class Delete(index: Int, length: Int) extends StringOp\n\n    /**\n     * Append text to the end of the string.\n     */\n    final case class Append(text: String) extends StringOp\n\n    /**\n     * Replace characters starting at index with new text.\n     */\n    final case class Modify(index: Int, length: Int, text: String) extends StringOp\n  }\n\n  // ===========================================================================\n  // ArrayOp  edit operations for arrays\n  // ===========================================================================\n\n  /**\n   * Edit operations for JSON arrays.\n   *\n   * Mirrors [[DynamicPatch.SeqOp]] but with Json values.\n   */\n  sealed trait ArrayOp\n\n  object ArrayOp {\n\n    /**\n     * Insert values at the given index.\n     */\n    final case class Insert(index: Int, values: Vector[Json]) extends ArrayOp\n\n    /**\n     * Append values to the end of the array.\n     */\n    final case class Append(values: Vector[Json]) extends ArrayOp\n\n    /**\n     * Delete elements starting at the given index.\n     */\n    final case class Delete(index: Int, count: Int) extends ArrayOp\n\n    /**\n     * Modify the element at the given index with a nested operation.\n     */\n    final case class Modify(index: Int, op: Op) extends ArrayOp\n  }\n\n  // ===========================================================================\n  // ObjectOp  edit operations for objects\n  // ===========================================================================\n\n  /**\n   * Edit operations for JSON objects.\n   *\n   * Mirrors [[DynamicPatch.MapOp]] but with string keys (JSON constraint).\n   */\n  sealed trait ObjectOp\n\n  object ObjectOp {\n\n    /**\n     * Add a field to the object.\n     */\n    final case class Add(key: String, value: Json) extends ObjectOp\n\n    /**\n     * Remove a field from the object.\n     */\n    final case class Remove(key: String) extends ObjectOp\n\n    /**\n     * Modify a field's value with a nested patch.\n     */\n    final case class Modify(key: String, patch: JsonPatch) extends ObjectOp\n  }\n}\n\n// =============================================================================\n// PATCH MODE\n// =============================================================================\n\n/**\n * Controls how patch application handles failures.\n *\n * Mirrors [[zio.blocks.schema.patch.PatchMode]].\n */\nsealed trait JsonPatchMode\n\nobject JsonPatchMode {\n\n  /**\n   * Fail on precondition violations.\n   */\n  case object Strict extends JsonPatchMode\n\n  /**\n   * Skip operations that fail preconditions.\n   */\n  case object Lenient extends JsonPatchMode\n\n  /**\n   * Replace/overwrite on conflicts (create missing paths).\n   */\n  case object Clobber extends JsonPatchMode\n}\n\n// =============================================================================\n// USAGE EXAMPLES\n// =============================================================================\n\n/*\n * ==Example 1: Basic Patching==\n *\n * {{{\n * import zio.blocks.schema.json._\n *\n * val json = Json.Object(Vector(\n *   \"name\" -> Json.String(\"Alice\"),\n *   \"age\" -> Json.Number(\"30\")\n * ))\n *\n * // Replace name\n * val patch = JsonPatch.root(JsonPatch.Op.Set(Json.String(\"Bob\")))\n *   // Or at a specific path:\n *   // JsonPatch(DynamicOptic.root.field(\"name\"), JsonPatch.Op.Set(Json.String(\"Bob\")))\n *\n * val result = patch(json, JsonPatchMode.Strict)\n * }}}\n *\n * ==Example 2: Diff and Apply (Roundtrip Law)==\n *\n * {{{\n * val source = Json.Object(Vector(\"x\" -> Json.Number(\"1\")))\n * val target = Json.Object(Vector(\"x\" -> Json.Number(\"5\")))\n *\n * val patch = JsonPatch.diff(source, target)\n *\n * // Roundtrip law\n * assert(patch(source, JsonPatchMode.Strict) == Right(target))\n *\n * // Identity diff law\n * assert(JsonPatch.diff(source, source).isEmpty)\n * }}}\n *\n * ==Example 3: Monoid Laws==\n *\n * {{{\n * val p1 = JsonPatch.diff(a, b)\n * val p2 = JsonPatch.diff(b, c)\n * val p3 = JsonPatch.diff(c, d)\n *\n * // Left identity\n * assert((JsonPatch.empty ++ p1)(a, Strict) == p1(a, Strict))\n *\n * // Right identity\n * assert((p1 ++ JsonPatch.empty)(a, Strict) == p1(a, Strict))\n *\n * // Associativity\n * assert(((p1 ++ p2) ++ p3)(a, Strict) == (p1 ++ (p2 ++ p3))(a, Strict))\n * }}}\n *\n * ==Example 4: Numeric Delta==\n *\n * {{{\n * val json = Json.Number(\"10\")\n *\n * // Add 5 to the number (more efficient than Set for large structures)\n * val patch = JsonPatch.root(\n *   JsonPatch.Op.PrimitiveDelta(JsonPatch.PrimitiveOp.NumberDelta(BigDecimal(5)))\n * )\n *\n * assert(patch(json, Strict) == Right(Json.Number(\"15\")))\n * }}}\n *\n * ==Example 5: String Edit==\n *\n * {{{\n * val json = Json.String(\"hello world\")\n *\n * // Change \"hello\" to \"hi\" using LCS-based edits\n * val patch = JsonPatch.root(\n *   JsonPatch.Op.PrimitiveDelta(\n *     JsonPatch.PrimitiveOp.StringEdit(Vector(\n *       JsonPatch.StringOp.Delete(0, 5),\n *       JsonPatch.StringOp.Insert(0, \"hi\")\n *     ))\n *   )\n * )\n *\n * assert(patch(json, Strict) == Right(Json.String(\"hi world\")))\n * }}}\n *\n * ==Example 6: Array Edit==\n *\n * {{{\n * val json = Json.Array(Vector(Json.Number(\"1\"), Json.Number(\"2\"), Json.Number(\"3\")))\n *\n * // Delete element at index 1, append new element\n * val patch = JsonPatch.root(\n *   JsonPatch.Op.ArrayEdit(Vector(\n *     JsonPatch.ArrayOp.Delete(1, 1),\n *     JsonPatch.ArrayOp.Append(Vector(Json.Number(\"4\")))\n *   ))\n * )\n *\n * // Result: [1, 3, 4]\n * }}}\n *\n * ==Example 7: Object Edit==\n *\n * {{{\n * val json = Json.Object(Vector(\"a\" -> Json.Number(\"1\"), \"b\" -> Json.Number(\"2\")))\n *\n * // Remove field \"a\", add field \"c\"\n * val patch = JsonPatch.root(\n *   JsonPatch.Op.ObjectEdit(Vector(\n *     JsonPatch.ObjectOp.Remove(\"a\"),\n *     JsonPatch.ObjectOp.Add(\"c\", Json.Number(\"3\"))\n *   ))\n * )\n *\n * // Result: {\"b\": 2, \"c\": 3}\n * }}}\n *\n * ==Example 8: Nested Patch==\n *\n * {{{\n * val json = Json.Object(Vector(\n *   \"user\" -> Json.Object(Vector(\n *     \"name\" -> Json.String(\"Alice\"),\n *     \"age\" -> Json.Number(\"30\")\n *   ))\n * ))\n *\n * // Patch nested inside \"user\"\n * val innerPatch = JsonPatch(Vector(\n *   JsonPatch.JsonPatchOp(\n *     DynamicOptic.root.field(\"age\"),\n *     JsonPatch.Op.PrimitiveDelta(JsonPatch.PrimitiveOp.NumberDelta(BigDecimal(1)))\n *   )\n * ))\n *\n * val patch = JsonPatch(\n *   DynamicOptic.root.field(\"user\"),\n *   JsonPatch.Op.Nested(innerPatch)\n * )\n *\n * // Increments user.age by 1\n * }}}\n *\n * ==Example 9: Diff Composition Law==\n *\n * {{{\n * val a = Json.Number(\"1\")\n * val b = Json.Number(\"5\")\n * val c = Json.Number(\"10\")\n *\n * val p1 = JsonPatch.diff(a, b)  // delta +4\n * val p2 = JsonPatch.diff(b, c)  // delta +5\n *\n * // Composition law: applying composed patch equals applying sequentially\n * assert((p1 ++ p2)(a, Strict) == Right(c))\n * }}}\n *\n * ==Example 10: PatchMode Behavior==\n *\n * {{{\n * val json = Json.Object(Vector(\"a\" -> Json.Number(\"1\")))\n *\n * // Try to remove non-existent field\n * val patch = JsonPatch.root(\n *   JsonPatch.Op.ObjectEdit(Vector(JsonPatch.ObjectOp.Remove(\"nonexistent\")))\n * )\n *\n * // Strict: fails\n * assert(patch(json, JsonPatchMode.Strict).isLeft)\n *\n * // Lenient: skips, returns unchanged\n * assert(patch(json, JsonPatchMode.Lenient) == Right(json))\n *\n * // Clobber: skips (nothing to clobber), returns unchanged\n * assert(patch(json, JsonPatchMode.Clobber) == Right(json))\n * }}}\n */\n```",
                  "html_url": "https://github.com/zio/zio-blocks/issues/685"
                },
                "type": "github"
              },
              "hash": "zio/zio-blocks#685",
              "body": "<html><head></head><body><h1>Add <code>JsonPatch</code> type for diffing and patching JSON values</h1>\n<h2>Summary</h2>\n<p>Implement a <code>JsonPatch</code> type that enables computing diffs between JSON values and applying patches to transform one JSON value into another. This type should mirror the existing <code>DynamicPatch</code> implementation, adapted for JSON's simpler data model.</p>\n<h2>Motivation</h2>\n<p><code>DynamicValue</code> has a well-designed <code>DynamicPatch</code> system with:</p>\n<ul>\n<li>Monoid composition (<code>++</code> with <code>empty</code> identity)</li>\n<li>LCS-based sequence diffing</li>\n<li>Primitive delta operations (numeric deltas, string edits)</li>\n<li>Comprehensive algebraic laws verified by property tests</li>\n</ul>\n<p>The proposed <code>Json</code> type (see #TBD) needs equivalent patching capabilities. Rather than converting <code>Json  DynamicValue</code> for every patch operation, a native <code>JsonPatch</code> provides:</p>\n<ul>\n<li>Type safety (no conversion errors for JSON-incompatible DynamicPatch operations)</li>\n<li>API consistency with the <code>Json</code> type</li>\n<li>Potential for JSON-specific optimizations</li>\n</ul>\n<h2>Design Sketch</h2>\n<p>A design sketch is available at <a href=\"https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/json/JsonPatch.scala\"><code>schema/shared/src/main/scala/zio/blocks/schema/json/JsonPatch.scala</code></a>. This sketch is <strong>a guide, not a specification</strong>  implementers should use judgment and deviate where appropriate.</p>\n<h3>Core Types</h3>\n<p>The design mirrors <code>DynamicPatch</code> with JSON-specific adaptations:</p>\n\nDynamicPatch | JsonPatch | Notes\n-- | -- | --\nDynamicPatch(Vector[DynamicPatchOp]) | JsonPatch(Vector[JsonPatchOp]) | Same structure\nOperation.Set | Op.Set | Same\nOperation.PrimitiveDelta | Op.PrimitiveDelta | Simplified for JSON types\nOperation.SequenceEdit | Op.ArrayEdit | Renamed\nOperation.MapEdit | Op.ObjectEdit | String keys only\nOperation.Patch | Op.Nested | Same\nSeqOp | ArrayOp | Same operations\nMapOp | ObjectOp | String keys only\nPrimitiveOp (14 variants) | PrimitiveOp (2 variants) | See below\n\n\n<h3>StringOp</h3>\n<p>Mirror <code>DynamicPatch.StringOp</code> exactly:</p>\n<ul>\n<li><code>Insert(index: Int, text: String)</code></li>\n<li><code>Delete(index: Int, length: Int)</code></li>\n<li><code>Append(text: String)</code></li>\n<li><code>Modify(index: Int, length: Int, text: String)</code></li>\n</ul>\n<h3>ArrayOp</h3>\n<p>Mirror <code>DynamicPatch.SeqOp</code>:</p>\n<ul>\n<li><code>Insert(index: Int, values: Vector[Json])</code></li>\n<li><code>Append(values: Vector[Json])</code></li>\n<li><code>Delete(index: Int, count: Int)</code></li>\n<li><code>Modify(index: Int, op: Op)</code></li>\n</ul>\n<h3>ObjectOp</h3>\n<p>Mirror <code>DynamicPatch.MapOp</code> with string keys:</p>\n<ul>\n<li><code>Add(key: String, value: Json)</code></li>\n<li><code>Remove(key: String)</code></li>\n<li><code>Modify(key: String, patch: JsonPatch)</code></li>\n</ul>\n<h2>Requirements</h2>\n<h3>Functional Requirements</h3>\n<ul>\n<li>[ ] <strong>F1</strong>: <code>JsonPatch.diff(source, target)</code> computes a patch transforming source to target</li>\n<li>[ ] <strong>F2</strong>: <code>patch.apply(json, mode)</code> applies a patch with configurable failure handling</li>\n<li>[ ] <strong>F3</strong>: <code>patch1 ++ patch2</code> composes patches (apply first, then second)</li>\n<li>[ ] <strong>F4</strong>: <code>JsonPatch.empty</code> is the identity element for composition</li>\n<li>[ ] <strong>F5</strong>: Support <code>JsonPatchMode.Strict</code>, <code>Lenient</code>, and <code>Clobber</code> modes</li>\n<li>[ ] <strong>F6</strong>: Bidirectional conversion: <code>toDynamicPatch</code> / <code>fromDynamicPatch</code></li>\n</ul>\n<h3>Algebraic Laws</h3>\n<p>All laws must be verified with property-based tests (see <code>PatchLawsSpec</code> for reference):</p>\n<ul>\n<li>[ ] <strong>L1</strong>: Left identity  <code>(empty ++ p)(j) == p(j)</code></li>\n<li>[ ] <strong>L2</strong>: Right identity  <code>(p ++ empty)(j) == p(j)</code></li>\n<li>[ ] <strong>L3</strong>: Associativity  <code>((p1 ++ p2) ++ p3)(j) == (p1 ++ (p2 ++ p3))(j)</code></li>\n<li>[ ] <strong>L4</strong>: Roundtrip  <code>diff(a, b)(a) == Right(b)</code></li>\n<li>[ ] <strong>L5</strong>: Identity diff  <code>diff(j, j).isEmpty</code></li>\n<li>[ ] <strong>L6</strong>: Diff composition  <code>(diff(a, b) ++ diff(b, c))(a) == Right(c)</code></li>\n<li>[ ] <strong>L7</strong>: Lenient subsumes Strict  if <code>p(j, Strict) == Right(r)</code> then <code>p(j, Lenient) == Right(r)</code></li>\n</ul>\n<h3>Testing Requirements</h3>\n<ul>\n<li>[ ] <strong>T1</strong>: Property-based tests for all algebraic laws (see <code>PatchLawsSpec</code>)</li>\n<li>[ ] <strong>T2</strong>: Test each operation type (<code>Set</code>, <code>PrimitiveDelta</code>, <code>ArrayEdit</code>, <code>ObjectEdit</code>, <code>Nested</code>)</li>\n<li>[ ] <strong>T3</strong>: Test each <code>ArrayOp</code> variant (<code>Insert</code>, <code>Append</code>, <code>Delete</code>, <code>Modify</code>)</li>\n<li>[ ] <strong>T4</strong>: Test each <code>ObjectOp</code> variant (<code>Add</code>, <code>Remove</code>, <code>Modify</code>)</li>\n<li>[ ] <strong>T5</strong>: Test each <code>StringOp</code> variant (<code>Insert</code>, <code>Delete</code>, <code>Append</code>, <code>Modify</code>)</li>\n<li>[ ] <strong>T6</strong>: Test <code>NumberDelta</code> with positive, negative, zero, and decimal deltas</li>\n<li>[ ] <strong>T7</strong>: Test all three <code>JsonPatchMode</code> behaviors</li>\n<li>[ ] <strong>T8</strong>: Test <code>toDynamicPatch</code> / <code>fromDynamicPatch</code> roundtrip</li>\n<li>[ ] <strong>T9</strong>: Test edge cases: empty arrays, empty objects, empty strings, nested structures</li>\n<li>[ ] <strong>T10</strong>: Test error cases: invalid paths, type mismatches, out-of-bounds indices</li>\n</ul>\n<h3>Documentation Requirements</h3>\n<ul>\n<li>[ ] <strong>D1</strong>: ScalaDoc for all public types and methods</li>\n<li>[ ] <strong>D2</strong>: Usage examples in ScalaDoc (see sketch for examples)</li>\n<li>[ ] <strong>D3</strong>: Document algebraic laws in type-level comments</li>\n<li>[ ] <strong>D4</strong>: Document relationship to <code>DynamicPatch</code></li>\n</ul>\n<h3>Implementation Notes</h3>\n<ol>\n<li>\n<p><strong>Follow <code>DynamicPatch</code> patterns</strong>: The implementation in <code>DynamicPatch.scala</code> is the reference. Study <code>Differ.scala</code> for diff algorithms (especially LCS for sequences and strings).</p>\n</li>\n<li>\n<p><strong>Reuse algorithms where possible</strong>: Consider whether <code>JsonPatch</code> can delegate to <code>DynamicPatch</code> internally, or share algorithm implementations.</p>\n</li>\n<li>\n<p><strong>Keep it minimal</strong>: Resist adding operations not present in <code>DynamicPatch</code>. The design is intentionally minimal and principled.</p>\n</li>\n<li>\n<p><strong>Performance considerations</strong>: The register-based design of ZIO Blocks prioritizes performance. Avoid unnecessary allocations in hot paths.</p>\n</li>\n</ol>\n<h2>Out of Scope</h2>\n<p>The following are explicitly <strong>not</strong> part of this issue:</p>\n<ul>\n<li>RFC 6902 JSON Patch serialization format (separate issue)</li>\n<li>Patch inversion / undo support (separate issue)</li>\n<li>Patch optimization / compaction (separate issue)</li>\n<li>Integration with <code>Json</code> type methods like <code>json.diff(other)</code> (depends on <code>Json</code> implementation)</li>\n</ul>\n<h2>Related</h2>\n<ul>\n<li><code>DynamicPatch</code>  <a href=\"https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/DynamicPatch.scala\"><code>schema/shared/src/main/scala/zio/blocks/schema/patch/DynamicPatch.scala</code></a></li>\n<li><code>Differ</code>  <a href=\"https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/Differ.scala\"><code>schema/shared/src/main/scala/zio/blocks/schema/patch/Differ.scala</code></a></li>\n<li><code>PatchLawsSpec</code>  <a href=\"https://claude.ai/chat/schema/shared/src/test/scala/zio/blocks/schema/patch/PatchLawsSpec.scala\"><code>schema/shared/src/test/scala/zio/blocks/schema/patch/PatchLawsSpec.scala</code></a></li>\n<li><code>PatchMode</code>  <a href=\"https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/PatchMode.scala\"><code>schema/shared/src/main/scala/zio/blocks/schema/patch/PatchMode.scala</code></a></li>\n</ul>\n<h2>Acceptance Criteria</h2>\n<ul>\n<li>[ ] All functional requirements (F1-F6) implemented</li>\n<li>[ ] All algebraic laws (L1-L7) pass property-based tests</li>\n<li>[ ] All testing requirements (T1-T10) have corresponding test cases</li>\n<li>[ ] All documentation requirements (D1-D4) complete</li>\n<li>[ ] Code reviewed and approved</li>\n<li>[ ] CI passing</li>\n</ul></body></html># Add `JsonPatch` type for diffing and patching JSON values\n\n## Summary\n\nImplement a `JsonPatch` type that enables computing diffs between JSON values and applying patches to transform one JSON value into another. This type should mirror the existing `DynamicPatch` implementation, adapted for JSON's simpler data model.\n\n## Motivation\n\n`DynamicValue` has a well-designed `DynamicPatch` system with:\n- Monoid composition (`++` with `empty` identity)\n- LCS-based sequence diffing\n- Primitive delta operations (numeric deltas, string edits)\n- Comprehensive algebraic laws verified by property tests\n\nThe proposed `Json` type (see #TBD) needs equivalent patching capabilities. Rather than converting `Json  DynamicValue` for every patch operation, a native `JsonPatch` provides:\n- Type safety (no conversion errors for JSON-incompatible DynamicPatch operations)\n- API consistency with the `Json` type\n- Potential for JSON-specific optimizations\n\n## Design Sketch\n\nA design sketch is available at [`[schema/shared/src/main/scala/zio/blocks/schema/json/JsonPatch.scala](https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/json/JsonPatch.scala)`](./schema/shared/src/main/scala/zio/blocks/schema/json/JsonPatch.scala). This sketch is **a guide, not a specification**  implementers should use judgment and deviate where appropriate.\n\n### Core Types\n\nThe design mirrors `DynamicPatch` with JSON-specific adaptations:\n\n| DynamicPatch | JsonPatch | Notes |\n|--------------|-----------|-------|\n| `DynamicPatch(Vector[DynamicPatchOp])` | `JsonPatch(Vector[JsonPatchOp])` | Same structure |\n| `Operation.Set` | `Op.Set` | Same |\n| `Operation.PrimitiveDelta` | `Op.PrimitiveDelta` | Simplified for JSON types |\n| `Operation.SequenceEdit` | `Op.ArrayEdit` | Renamed |\n| `Operation.MapEdit` | `Op.ObjectEdit` | String keys only |\n| `Operation.Patch` | `Op.Nested` | Same |\n| `SeqOp` | `ArrayOp` | Same operations |\n| `MapOp` | `ObjectOp` | String keys only |\n| `PrimitiveOp` (14 variants) | `PrimitiveOp` (2 variants) | See below |\n\n### Primitive Operations\n\nJSON has a simpler type system than `DynamicValue`:\n\n| JSON Type | Delta Operation | Notes |\n|-----------|-----------------|-------|\n| Number | `NumberDelta(BigDecimal)` | Unifies all numeric deltas |\n| String | `StringEdit(Vector[StringOp])` | Same as `DynamicPatch` |\n| Boolean | Use `Op.Set` | No delta (same as `DynamicPatch`) |\n| Null | Use `Op.Set` | No delta |\n\n### StringOp\n\nMirror `DynamicPatch.StringOp` exactly:\n- `Insert(index: Int, text: String)`\n- `Delete(index: Int, length: Int)`\n- `Append(text: String)`\n- `Modify(index: Int, length: Int, text: String)`\n\n### ArrayOp\n\nMirror `DynamicPatch.SeqOp`:\n- `Insert(index: Int, values: Vector[Json])`\n- `Append(values: Vector[Json])`\n- `Delete(index: Int, count: Int)`\n- `Modify(index: Int, op: Op)`\n\n### ObjectOp\n\nMirror `DynamicPatch.MapOp` with string keys:\n- `Add(key: String, value: Json)`\n- `Remove(key: String)`\n- `Modify(key: String, patch: JsonPatch)`\n\n## Requirements\n\n### Functional Requirements\n\n- [ ] **F1**: `JsonPatch.diff(source, target)` computes a patch transforming source to target\n- [ ] **F2**: `patch.apply(json, mode)` applies a patch with configurable failure handling\n- [ ] **F3**: `patch1 ++ patch2` composes patches (apply first, then second)\n- [ ] **F4**: `JsonPatch.empty` is the identity element for composition\n- [ ] **F5**: Support `JsonPatchMode.Strict`, `Lenient`, and `Clobber` modes\n- [ ] **F6**: Bidirectional conversion: `toDynamicPatch` / `fromDynamicPatch`\n\n### Algebraic Laws\n\nAll laws must be verified with property-based tests (see `PatchLawsSpec` for reference):\n\n- [ ] **L1**: Left identity  `(empty ++ p)(j) == p(j)`\n- [ ] **L2**: Right identity  `(p ++ empty)(j) == p(j)`\n- [ ] **L3**: Associativity  `((p1 ++ p2) ++ p3)(j) == (p1 ++ (p2 ++ p3))(j)`\n- [ ] **L4**: Roundtrip  `diff(a, b)(a) == Right(b)`\n- [ ] **L5**: Identity diff  `diff(j, j).isEmpty`\n- [ ] **L6**: Diff composition  `(diff(a, b) ++ diff(b, c))(a) == Right(c)`\n- [ ] **L7**: Lenient subsumes Strict  if `p(j, Strict) == Right(r)` then `p(j, Lenient) == Right(r)`\n\n### Testing Requirements\n\n- [ ] **T1**: Property-based tests for all algebraic laws (see `PatchLawsSpec`)\n- [ ] **T2**: Test each operation type (`Set`, `PrimitiveDelta`, `ArrayEdit`, `ObjectEdit`, `Nested`)\n- [ ] **T3**: Test each `ArrayOp` variant (`Insert`, `Append`, `Delete`, `Modify`)\n- [ ] **T4**: Test each `ObjectOp` variant (`Add`, `Remove`, `Modify`)\n- [ ] **T5**: Test each `StringOp` variant (`Insert`, `Delete`, `Append`, `Modify`)\n- [ ] **T6**: Test `NumberDelta` with positive, negative, zero, and decimal deltas\n- [ ] **T7**: Test all three `JsonPatchMode` behaviors\n- [ ] **T8**: Test `toDynamicPatch` / `fromDynamicPatch` roundtrip\n- [ ] **T9**: Test edge cases: empty arrays, empty objects, empty strings, nested structures\n- [ ] **T10**: Test error cases: invalid paths, type mismatches, out-of-bounds indices\n\n### Documentation Requirements\n\n- [ ] **D1**: ScalaDoc for all public types and methods\n- [ ] **D2**: Usage examples in ScalaDoc (see sketch for examples)\n- [ ] **D3**: Document algebraic laws in type-level comments\n- [ ] **D4**: Document relationship to `DynamicPatch`\n\n## Related\n\n- `DynamicPatch`  [`[schema/shared/src/main/scala/zio/blocks/schema/patch/DynamicPatch.scala](https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/DynamicPatch.scala)`](./schema/shared/src/main/scala/zio/blocks/schema/patch/DynamicPatch.scala)\n- `Differ`  [`[schema/shared/src/main/scala/zio/blocks/schema/patch/Differ.scala](https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/Differ.scala)`](./schema/shared/src/main/scala/zio/blocks/schema/patch/Differ.scala)\n- `PatchLawsSpec`  [`[schema/shared/src/test/scala/zio/blocks/schema/patch/PatchLawsSpec.scala](https://claude.ai/chat/schema/shared/src/test/scala/zio/blocks/schema/patch/PatchLawsSpec.scala)`](./schema/shared/src/test/scala/zio/blocks/schema/patch/PatchLawsSpec.scala)\n- `PatchMode`  [`[schema/shared/src/main/scala/zio/blocks/schema/patch/PatchMode.scala](https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/PatchMode.scala)`](./schema/shared/src/main/scala/zio/blocks/schema/patch/PatchMode.scala)\n\n## Acceptance Criteria\n\n- [ ] All functional requirements (F1-F6) implemented\n- [ ] All algebraic laws (L1-L7) pass property-based tests\n- [ ] All testing requirements (T1-T10) have corresponding test cases\n- [ ] All documentation requirements (D1-D4) complete\n- [ ] Code reviewed and approved\n- [ ] CI passing\n\n# Sketch\n\n```scala\npackage zio.blocks.schema.json\n\nimport zio.blocks.schema.DynamicOptic\nimport zio.blocks.schema.patch.DynamicPatch\n\n// =============================================================================\n// JSON PATCH\n// =============================================================================\n\n/**\n * An untyped patch that operates on [[Json]] values.\n *\n * `JsonPatch` is the JSON-specific counterpart to [[DynamicPatch]]. It represents\n * a sequence of operations that transform one JSON value into another. Patches\n * are serializable and composable.\n *\n * ==Design==\n *\n * This type directly mirrors [[DynamicPatch]] but is specialized for JSON's\n * simpler data model:\n *  - JSON has 4 leaf types (String, Number, Boolean, Null) vs 30 PrimitiveValues\n *  - JSON objects have string keys only (no arbitrary-keyed maps)\n *  - JSON has no native Variant type\n *\n * ==Algebraic Laws==\n *\n * '''Monoid Laws''' (under `++` composition):\n * {{{\n * // 1. LEFT IDENTITY\n *  p: JsonPatch, j: Json.\n *   (JsonPatch.empty ++ p)(j, mode) == p(j, mode)\n *\n * // 2. RIGHT IDENTITY\n *  p: JsonPatch, j: Json.\n *   (p ++ JsonPatch.empty)(j, mode) == p(j, mode)\n *\n * // 3. ASSOCIATIVITY\n *  p1, p2, p3: JsonPatch, j: Json.\n *   ((p1 ++ p2) ++ p3)(j, mode) == (p1 ++ (p2 ++ p3))(j, mode)\n * }}}\n *\n * '''Diff/Apply Laws''':\n * {{{\n * // 4. ROUNDTRIP\n *  source, target: Json.\n *   JsonPatch.diff(source, target)(source, Strict) == Right(target)\n *\n * // 5. IDENTITY DIFF\n *  j: Json.\n *   JsonPatch.diff(j, j).isEmpty == true\n *\n * // 6. DIFF COMPOSITION\n *  a, b, c: Json.\n *   (JsonPatch.diff(a, b) ++ JsonPatch.diff(b, c))(a, Strict) == Right(c)\n * }}}\n *\n * '''PatchMode Laws''':\n * {{{\n * // 7. STRICT FAILS ON ERROR\n * // Strict mode fails on first precondition violation\n *\n * // 8. LENIENT SKIPS ERRORS\n * // Lenient mode skips failing operations, always returns Right\n *\n * // 9. LENIENT SUBSUMES STRICT\n *  p: JsonPatch, j: Json.\n *   p(j, Strict) == Right(r) implies p(j, Lenient) == Right(r)\n *\n * // 10. CLOBBER FORCES SUCCESS\n * // Clobber mode creates missing paths, always returns Right\n * }}}\n *\n * @param ops The sequence of patch operations\n */\nfinal case class JsonPatch(ops: Vector[JsonPatch.JsonPatchOp]) {\n\n  /**\n   * Applies this patch to a JSON value.\n   *\n   * @param json The JSON value to patch\n   * @param mode The patch mode (default: Strict)\n   * @return Either an error or the patched value\n   */\n  def apply(json: Json, mode: JsonPatchMode = JsonPatchMode.Strict): Either[JsonError, Json]\n\n  /**\n   * Composes this patch with another. Applies this patch first, then `that`.\n   *\n   * This is the monoid `combine` operation.\n   */\n  def ++(that: JsonPatch): JsonPatch = JsonPatch(ops ++ that.ops)\n\n  /**\n   * Returns true if this patch contains no operations.\n   */\n  def isEmpty: Boolean = ops.isEmpty\n\n  /**\n   * Converts this JSON patch to a [[DynamicPatch]].\n   */\n  def toDynamicPatch: DynamicPatch\n}\n\nobject JsonPatch {\n\n  /**\n   * Empty patch  the identity element for `++` composition.\n   */\n  val empty: JsonPatch = JsonPatch(Vector.empty)\n\n  /**\n   * Creates a patch with a single operation at the root path.\n   */\n  def root(op: Op): JsonPatch =\n    JsonPatch(Vector(JsonPatchOp(DynamicOptic.root, op)))\n\n  /**\n   * Creates a patch with a single operation at the given path.\n   */\n  def apply(path: DynamicOptic, op: Op): JsonPatch =\n    JsonPatch(Vector(JsonPatchOp(path, op)))\n\n  /**\n   * Computes a patch that transforms `oldJson` into `newJson`.\n   *\n   * Law: `diff(old, new)(old, Strict) == Right(new)`\n   */\n  def diff(oldJson: Json, newJson: Json): JsonPatch\n\n  /**\n   * Creates a JSON patch from a [[DynamicPatch]].\n   *\n   * May fail if the DynamicPatch contains operations not representable in JSON\n   * (e.g., non-string map keys, temporal deltas, variant operations).\n   */\n  def fromDynamicPatch(patch: DynamicPatch): Either[JsonError, JsonPatch]\n\n  // ===========================================================================\n  // JsonPatchOp  a single operation at a path\n  // ===========================================================================\n\n  /**\n   * A single patch operation: a path and what to do there.\n   *\n   * Mirrors [[DynamicPatch.DynamicPatchOp]].\n   */\n  final case class JsonPatchOp(path: DynamicOptic, op: Op)\n\n  // ===========================================================================\n  // Op  the operation to perform at a path\n  // ===========================================================================\n\n  /**\n   * The operation to perform at a target location.\n   *\n   * Mirrors [[DynamicPatch.Operation]] but specialized for JSON.\n   */\n  sealed trait Op\n\n  object Op {\n\n    /**\n     * Set a value directly (replacement).\n     *\n     * Mirrors [[DynamicPatch.Operation.Set]].\n     */\n    final case class Set(value: Json) extends Op\n\n    /**\n     * Apply a primitive delta operation.\n     *\n     * Used for numeric deltas and string edits.\n     * Mirrors [[DynamicPatch.Operation.PrimitiveDelta]].\n     */\n    final case class PrimitiveDelta(op: PrimitiveOp) extends Op\n\n    /**\n     * Apply array edit operations.\n     *\n     * Used for inserting, appending, deleting, or modifying array elements.\n     * Mirrors [[DynamicPatch.Operation.SequenceEdit]].\n     */\n    final case class ArrayEdit(ops: Vector[ArrayOp]) extends Op\n\n    /**\n     * Apply object edit operations.\n     *\n     * Used for adding, removing, or modifying object fields.\n     * Mirrors [[DynamicPatch.Operation.MapEdit]] but with string keys.\n     */\n    final case class ObjectEdit(ops: Vector[ObjectOp]) extends Op\n\n    /**\n     * Apply a nested patch.\n     *\n     * Used to group operations sharing a common path prefix.\n     * Mirrors [[DynamicPatch.Operation.Patch]].\n     */\n    final case class Nested(patch: JsonPatch) extends Op\n  }\n\n  // ===========================================================================\n  // PrimitiveOp  delta operations for JSON primitives\n  // ===========================================================================\n\n  /**\n   * Delta operations for JSON primitive values.\n   *\n   * JSON has only one numeric type, so we use BigDecimal for deltas.\n   * Boolean has no delta (use Set to toggle).\n   * Null has no delta (use Set to change).\n   *\n   * Mirrors [[DynamicPatch.PrimitiveOp]] but simplified for JSON's type system.\n   */\n  sealed trait PrimitiveOp\n\n  object PrimitiveOp {\n\n    /**\n     * Add a delta to a JSON number.\n     *\n     * Applied by: `currentValue + delta`\n     *\n     * Mirrors the numeric delta operations in [[DynamicPatch.PrimitiveOp]]\n     * (IntDelta, LongDelta, DoubleDelta, etc.) unified into one type.\n     */\n    final case class NumberDelta(delta: BigDecimal) extends PrimitiveOp\n\n    /**\n     * Apply string edit operations.\n     *\n     * Mirrors [[DynamicPatch.PrimitiveOp.StringEdit]].\n     */\n    final case class StringEdit(ops: Vector[StringOp]) extends PrimitiveOp\n  }\n\n  // ===========================================================================\n  // StringOp  edit operations for strings\n  // ===========================================================================\n\n  /**\n   * Edit operations for JSON strings.\n   *\n   * Mirrors [[DynamicPatch.StringOp]] exactly.\n   */\n  sealed trait StringOp\n\n  object StringOp {\n\n    /**\n     * Insert text at the given index.\n     */\n    final case class Insert(index: Int, text: String) extends StringOp\n\n    /**\n     * Delete characters starting at the given index.\n     */\n    final case class Delete(index: Int, length: Int) extends StringOp\n\n    /**\n     * Append text to the end of the string.\n     */\n    final case class Append(text: String) extends StringOp\n\n    /**\n     * Replace characters starting at index with new text.\n     */\n    final case class Modify(index: Int, length: Int, text: String) extends StringOp\n  }\n\n  // ===========================================================================\n  // ArrayOp  edit operations for arrays\n  // ===========================================================================\n\n  /**\n   * Edit operations for JSON arrays.\n   *\n   * Mirrors [[DynamicPatch.SeqOp]] but with Json values.\n   */\n  sealed trait ArrayOp\n\n  object ArrayOp {\n\n    /**\n     * Insert values at the given index.\n     */\n    final case class Insert(index: Int, values: Vector[Json]) extends ArrayOp\n\n    /**\n     * Append values to the end of the array.\n     */\n    final case class Append(values: Vector[Json]) extends ArrayOp\n\n    /**\n     * Delete elements starting at the given index.\n     */\n    final case class Delete(index: Int, count: Int) extends ArrayOp\n\n    /**\n     * Modify the element at the given index with a nested operation.\n     */\n    final case class Modify(index: Int, op: Op) extends ArrayOp\n  }\n\n  // ===========================================================================\n  // ObjectOp  edit operations for objects\n  // ===========================================================================\n\n  /**\n   * Edit operations for JSON objects.\n   *\n   * Mirrors [[DynamicPatch.MapOp]] but with string keys (JSON constraint).\n   */\n  sealed trait ObjectOp\n\n  object ObjectOp {\n\n    /**\n     * Add a field to the object.\n     */\n    final case class Add(key: String, value: Json) extends ObjectOp\n\n    /**\n     * Remove a field from the object.\n     */\n    final case class Remove(key: String) extends ObjectOp\n\n    /**\n     * Modify a field's value with a nested patch.\n     */\n    final case class Modify(key: String, patch: JsonPatch) extends ObjectOp\n  }\n}\n\n// =============================================================================\n// PATCH MODE\n// =============================================================================\n\n/**\n * Controls how patch application handles failures.\n *\n * Mirrors [[zio.blocks.schema.patch.PatchMode]].\n */\nsealed trait JsonPatchMode\n\nobject JsonPatchMode {\n\n  /**\n   * Fail on precondition violations.\n   */\n  case object Strict extends JsonPatchMode\n\n  /**\n   * Skip operations that fail preconditions.\n   */\n  case object Lenient extends JsonPatchMode\n\n  /**\n   * Replace/overwrite on conflicts (create missing paths).\n   */\n  case object Clobber extends JsonPatchMode\n}\n\n// =============================================================================\n// USAGE EXAMPLES\n// =============================================================================\n\n/*\n * ==Example 1: Basic Patching==\n *\n * {{{\n * import zio.blocks.schema.json._\n *\n * val json = Json.Object(Vector(\n *   \"name\" -> Json.String(\"Alice\"),\n *   \"age\" -> Json.Number(\"30\")\n * ))\n *\n * // Replace name\n * val patch = JsonPatch.root(JsonPatch.Op.Set(Json.String(\"Bob\")))\n *   // Or at a specific path:\n *   // JsonPatch(DynamicOptic.root.field(\"name\"), JsonPatch.Op.Set(Json.String(\"Bob\")))\n *\n * val result = patch(json, JsonPatchMode.Strict)\n * }}}\n *\n * ==Example 2: Diff and Apply (Roundtrip Law)==\n *\n * {{{\n * val source = Json.Object(Vector(\"x\" -> Json.Number(\"1\")))\n * val target = Json.Object(Vector(\"x\" -> Json.Number(\"5\")))\n *\n * val patch = JsonPatch.diff(source, target)\n *\n * // Roundtrip law\n * assert(patch(source, JsonPatchMode.Strict) == Right(target))\n *\n * // Identity diff law\n * assert(JsonPatch.diff(source, source).isEmpty)\n * }}}\n *\n * ==Example 3: Monoid Laws==\n *\n * {{{\n * val p1 = JsonPatch.diff(a, b)\n * val p2 = JsonPatch.diff(b, c)\n * val p3 = JsonPatch.diff(c, d)\n *\n * // Left identity\n * assert((JsonPatch.empty ++ p1)(a, Strict) == p1(a, Strict))\n *\n * // Right identity\n * assert((p1 ++ JsonPatch.empty)(a, Strict) == p1(a, Strict))\n *\n * // Associativity\n * assert(((p1 ++ p2) ++ p3)(a, Strict) == (p1 ++ (p2 ++ p3))(a, Strict))\n * }}}\n *\n * ==Example 4: Numeric Delta==\n *\n * {{{\n * val json = Json.Number(\"10\")\n *\n * // Add 5 to the number (more efficient than Set for large structures)\n * val patch = JsonPatch.root(\n *   JsonPatch.Op.PrimitiveDelta(JsonPatch.PrimitiveOp.NumberDelta(BigDecimal(5)))\n * )\n *\n * assert(patch(json, Strict) == Right(Json.Number(\"15\")))\n * }}}\n *\n * ==Example 5: String Edit==\n *\n * {{{\n * val json = Json.String(\"hello world\")\n *\n * // Change \"hello\" to \"hi\" using LCS-based edits\n * val patch = JsonPatch.root(\n *   JsonPatch.Op.PrimitiveDelta(\n *     JsonPatch.PrimitiveOp.StringEdit(Vector(\n *       JsonPatch.StringOp.Delete(0, 5),\n *       JsonPatch.StringOp.Insert(0, \"hi\")\n *     ))\n *   )\n * )\n *\n * assert(patch(json, Strict) == Right(Json.String(\"hi world\")))\n * }}}\n *\n * ==Example 6: Array Edit==\n *\n * {{{\n * val json = Json.Array(Vector(Json.Number(\"1\"), Json.Number(\"2\"), Json.Number(\"3\")))\n *\n * // Delete element at index 1, append new element\n * val patch = JsonPatch.root(\n *   JsonPatch.Op.ArrayEdit(Vector(\n *     JsonPatch.ArrayOp.Delete(1, 1),\n *     JsonPatch.ArrayOp.Append(Vector(Json.Number(\"4\")))\n *   ))\n * )\n *\n * // Result: [1, 3, 4]\n * }}}\n *\n * ==Example 7: Object Edit==\n *\n * {{{\n * val json = Json.Object(Vector(\"a\" -> Json.Number(\"1\"), \"b\" -> Json.Number(\"2\")))\n *\n * // Remove field \"a\", add field \"c\"\n * val patch = JsonPatch.root(\n *   JsonPatch.Op.ObjectEdit(Vector(\n *     JsonPatch.ObjectOp.Remove(\"a\"),\n *     JsonPatch.ObjectOp.Add(\"c\", Json.Number(\"3\"))\n *   ))\n * )\n *\n * // Result: {\"b\": 2, \"c\": 3}\n * }}}\n *\n * ==Example 8: Nested Patch==\n *\n * {{{\n * val json = Json.Object(Vector(\n *   \"user\" -> Json.Object(Vector(\n *     \"name\" -> Json.String(\"Alice\"),\n *     \"age\" -> Json.Number(\"30\")\n *   ))\n * ))\n *\n * // Patch nested inside \"user\"\n * val innerPatch = JsonPatch(Vector(\n *   JsonPatch.JsonPatchOp(\n *     DynamicOptic.root.field(\"age\"),\n *     JsonPatch.Op.PrimitiveDelta(JsonPatch.PrimitiveOp.NumberDelta(BigDecimal(1)))\n *   )\n * ))\n *\n * val patch = JsonPatch(\n *   DynamicOptic.root.field(\"user\"),\n *   JsonPatch.Op.Nested(innerPatch)\n * )\n *\n * // Increments user.age by 1\n * }}}\n *\n * ==Example 9: Diff Composition Law==\n *\n * {{{\n * val a = Json.Number(\"1\")\n * val b = Json.Number(\"5\")\n * val c = Json.Number(\"10\")\n *\n * val p1 = JsonPatch.diff(a, b)  // delta +4\n * val p2 = JsonPatch.diff(b, c)  // delta +5\n *\n * // Composition law: applying composed patch equals applying sequentially\n * assert((p1 ++ p2)(a, Strict) == Right(c))\n * }}}\n *\n * ==Example 10: PatchMode Behavior==\n *\n * {{{\n * val json = Json.Object(Vector(\"a\" -> Json.Number(\"1\")))\n *\n * // Try to remove non-existent field\n * val patch = JsonPatch.root(\n *   JsonPatch.Op.ObjectEdit(Vector(JsonPatch.ObjectOp.Remove(\"nonexistent\")))\n * )\n *\n * // Strict: fails\n * assert(patch(json, JsonPatchMode.Strict).isLeft)\n *\n * // Lenient: skips, returns unchanged\n * assert(patch(json, JsonPatchMode.Lenient) == Right(json))\n *\n * // Clobber: skips (nothing to clobber), returns unchanged\n * assert(patch(json, JsonPatchMode.Clobber) == Right(json))\n * }}}\n */\n```",
              "url": "https://github.com/zio/zio-blocks/issues/685",
              "tech": [],
              "repo_name": "zio-blocks",
              "repo_owner": "zio",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "ZIO#682",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "ZIO",
              "id": "generated-ZIO",
              "name": "ZIO",
              "description": "",
              "members": [],
              "display_name": "ZIO",
              "created_at": "2026-01-24T11:31:19.172Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/ZIO?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "zio",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-24T11:31:19.172Z",
            "created_at": "2026-01-24T11:31:19.172Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-ZIO#682",
              "status": "open",
              "type": "issue",
              "number": 682,
              "title": "Port Message Pack Support to ZIO Schema 2",
              "source": {
                "data": {
                  "id": "source-ZIO#682",
                  "user": {
                    "login": "jdegoes",
                    "id": 156745,
                    "node_id": "MDQ6VXNlcjE1Njc0NQ==",
                    "avatar_url": "https://avatars.githubusercontent.com/u/156745?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/jdegoes",
                    "html_url": "https://github.com/jdegoes",
                    "followers_url": "https://api.github.com/users/jdegoes/followers",
                    "following_url": "https://api.github.com/users/jdegoes/following{/other_user}",
                    "gists_url": "https://api.github.com/users/jdegoes/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/jdegoes/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/jdegoes/subscriptions",
                    "organizations_url": "https://api.github.com/users/jdegoes/orgs",
                    "repos_url": "https://api.github.com/users/jdegoes/repos",
                    "events_url": "https://api.github.com/users/jdegoes/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/jdegoes/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Port Message Pack Support to ZIO Schema 2",
                  "body": "In a separate top-level project (schema-messagepack), port the [old ZIO Schema Message Pack support](https://github.com/zio/zio-schema/tree/main/zio-schema-msg-pack/src) to ZIO Schema 2.\n\nMust have at least as many tests as the old version, with any known bugs in the implementation identified and fixed.",
                  "html_url": "https://github.com/zio/zio-blocks/issues/682"
                },
                "type": "github"
              },
              "hash": "zio/zio-blocks#682",
              "body": "In a separate top-level project (schema-messagepack), port the [old ZIO Schema Message Pack support](https://github.com/zio/zio-schema/tree/main/zio-schema-msg-pack/src) to ZIO Schema 2.\n\nMust have at least as many tests as the old version, with any known bugs in the implementation identified and fixed.",
              "url": "https://github.com/zio/zio-blocks/issues/682",
              "tech": [],
              "repo_name": "zio-blocks",
              "repo_owner": "zio",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "ZIO#519",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "ZIO",
              "id": "generated-ZIO",
              "name": "ZIO",
              "description": "",
              "members": [],
              "display_name": "ZIO",
              "created_at": "2026-01-24T11:31:19.354Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/ZIO?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "zio",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-24T11:31:19.354Z",
            "created_at": "2026-01-24T11:31:19.354Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-ZIO#519",
              "status": "open",
              "type": "issue",
              "number": 519,
              "title": "Schema Migration System for ZIO Schema 2",
              "source": {
                "data": {
                  "id": "source-ZIO#519",
                  "user": {
                    "login": "jdegoes",
                    "id": 156745,
                    "node_id": "MDQ6VXNlcjE1Njc0NQ==",
                    "avatar_url": "https://avatars.githubusercontent.com/u/156745?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/jdegoes",
                    "html_url": "https://github.com/jdegoes",
                    "followers_url": "https://api.github.com/users/jdegoes/followers",
                    "following_url": "https://api.github.com/users/jdegoes/following{/other_user}",
                    "gists_url": "https://api.github.com/users/jdegoes/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/jdegoes/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/jdegoes/subscriptions",
                    "organizations_url": "https://api.github.com/users/jdegoes/orgs",
                    "repos_url": "https://api.github.com/users/jdegoes/repos",
                    "events_url": "https://api.github.com/users/jdegoes/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/jdegoes/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Schema Migration System for ZIO Schema 2",
                  "body": "## Overview\n\nImplement a **pure, algebraic migration system** for ZIO Schema 2 that represents **structural transformations between schema versions** as first-class, serializable data.\n\nA migration describes how to transform data from one schema version to another, enabling:\n\n* schema evolution\n* backward / forward compatibility\n* data versioning\n* offline migrations (JSON, SQL, data lakes, registries, etc.)\n\nThe system provides a **typed, macro-validated user API** (`Migration[A, B]`) built on a **pure, serializable core** (`DynamicMigration`) that operates on `DynamicValue`. \n\nThe ADT is fully introspectable and can be used to generate DDL, etc.\n\n## Motivation & Big Picture\n\n### Why structural types?\n\nWhen evolving schemas over time, **older versions of data types should not require runtime representations**.\n\nIn this design:\n\n* **Current versions** are represented by real case classes / enums\n* **Past versions** are represented using:\n\n  * **structural types** for records\n  * **abstract types + intersection types** for sum types\n\nThese types:\n\n* exist **only at compile time**\n* have **no runtime representation**\n* introduce **zero runtime overhead**\n* do **not require optics or instances to be kept around**\n\nThis allows you to describe arbitrarily old versions of data *without polluting your runtime or codebase*.\n\n#### Typical Workflow\n\nA typical workflow looks like:\n\n1. You have a current type:\n\n   ```scala\n   @schema\n   case class Person(name: String, age: Int)\n   ```\n\n2. You derive and copy its structural shape:\n\n   ```scala\n   type PersonV1 = { def name: String; def age: Int }\n   ```\n\n3. You evolve the real type:\n\n   ```scala\n   @schema\n   case class Person(fullName: String, age: Int, country: String)\n   ```\n\n4. You keep only:\n\n   * the **current** runtime type\n   * the **structural type** for the old version\n   * a **pure migration** between them\n\nNo old case classes. No old optics. No runtime baggage.\n\nNote there is no requirement that the \"current\" type actually be a real case class, enum, etc.--so you can work purely with structural types, allowing you to define migrations for data types that are never materialized as runtime structures.\n\n---\n\n### Why pure data migrations?\n\nMigrations are represented entirely as **pure data**:\n\n* no user functions\n* no closures\n* no reflection\n* no runtime code generation\n\nAs a result:\n\n* migrations can be **serialized**\n* stored in **registries**\n* applied **dynamically**\n* inspected and transformed\n* used to generate:\n\n  * upgraders\n  * downgraders\n  * SQL DDL / DML\n  * offline data transforms\n\nWhile code generation is **out of scope for this ticket**, this explains many design decisions (invertibility, path-based actions, no functions).\n\n---\n\n## Core Architecture\n\n### Type Hierarchy\n\n```scala\n// Typed migration (user-facing API)\ncase class Migration[A, B](\n  dynamicMigration: DynamicMigration,\n  sourceSchema: Schema[A], // These are structural schemas!!!\n  targetSchema: Schema[B] // These are structural schemas!!!\n) {\n  /** Apply migration to transform A to B */\n  def apply(value: A): Either[MigrationError, B]\n\n  /** Compose migrations sequentially */\n  def ++[C](that: Migration[B, C]): Migration[A, C]\n\n  /** Alias for ++ */\n  def andThen[C](that: Migration[B, C]): Migration[A, C] = this ++ that\n\n  /** Reverse migration (structural inverse; runtime is best-effort) */\n  def reverse: Migration[B, A]\n}\n```\n\n```scala\n// Untyped migration (pure data, fully serializable)\ncase class DynamicMigration(\n  actions: Vector[MigrationAction]\n) {\n  def apply(value: DynamicValue): Either[MigrationError, DynamicValue]\n  def ++(that: DynamicMigration): DynamicMigration\n  def reverse: DynamicMigration\n}\n```\n\n* `Migration[A, B]` is introspectable, but not pure data due to bindings inside schemas\n* `DynamicMigration` is **fully serializable**\n\n---\n\n## User-Facing API: Selector Expressions\n\n### Selectors, not optics\n\nThe user-facing API **does not expose optics**.\n\nInstead, all locations are specified using **selector expressions**:\n\n```scala\nS => A\n```\n\nExamples:\n\n```scala\n_.name\n_.address.street\n_.addresses.each.streetNumber\n_.country.when[UK]\n```\n\nTo see the syntax, one can look at the `optic` macro, which utilizes the same selector syntax for optic creation (e.g. `optic(_.address.street)`, etc.).\n\n### Macro extraction\n\nAll builder methods that accept selectors are **implemented via macros** (or via a macro-generated type class such as `ToDynamicOptic`).\n\nThe macro:\n\n1. Inspects the selector expression\n2. Validates it is a supported projection\n3. Converts it into a `DynamicOptic`\n4. Stores that optic in the migration action\n\nSupported projections include:\n\n* field access (`_.foo.bar`)\n* case selection (`_.country.when[UK]`)\n* collection traversal (`_.items.each`)\n* (future) key access, wrappers, etc.\n\n`DynamicOptic` is **never exposed publicly**.\n\n---\n\n## Migration Builder\n\nAll selector-accepting methods are implemented via macros. For simplicity, these are shown as functions (e.g. `A => Any`), but this is NOT the way to implement them. Either all these functions need to be macros, or a macro needs to be used to generate an implicit / given at each call site. Macros may do additional validation to constrain the validity of these different types of transformations.\n\n```scala\nclass MigrationBuilder[A, B](\n  sourceSchema: Schema[A],\n  targetSchema: Schema[B],\n  actions: Vector[MigrationAction]\n) {\n\n  // ----- Record operations -----\n\n  def addField(\n    target: B => Any,\n    default: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  def dropField(\n    source: A => Any,\n    defaultForReverse: SchemaExpr[B, ?] = SchemaExpr.DefaultValue\n  ): MigrationBuilder[A, B]\n\n  def renameField(\n    from: A => Any,\n    to: B => Any\n  ): MigrationBuilder[A, B]\n\n  def transformField(\n    from: A => Any,\n    to: B => Any,\n    transform: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  def mandateField(\n    source: A => Option[?],\n    target: B => Any,\n    default: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  def optionalizeField(\n    source: A => Any,\n    target: B => Option[?]\n  ): MigrationBuilder[A, B]\n\n  def changeFieldType(\n    source: A => Any,\n    target: B => Any,\n    converter: SchemaExpr[A, ?]  // primitive-to-primitive only\n  ): MigrationBuilder[A, B]\n\n  // ----- Enum operations (limited) -----\n\n  def renameCase[SumA, SumB](\n    from: String,\n    to: String\n  ): MigrationBuilder[A, B]\n\n  def transformCase[SumA, CaseA, SumB, CaseB](\n    caseMigration: MigrationBuilder[CaseA, CaseB] => MigrationBuilder[CaseA, CaseB]\n  ): MigrationBuilder[A, B]\n\n  // ----- Collections -----\n\n  def transformElements(\n    at: A => Vector[?],\n    transform: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  // ----- Maps -----\n\n  def transformKeys(\n    at: A => Map[?, ?],\n    transform: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  def transformValues(\n    at: A => Map[?, ?],\n    transform: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  /** Build migration with full macro validation */\n  def build: Migration[A, B]\n\n  /** Build migration without full validation */\n  def buildPartial: Migration[A, B]\n}\n```\n\n---\n\n## Migration Actions (Untyped Core)\n\nAll actions operate at a **path**, represented by `DynamicOptic`.\n\n```scala\nsealed trait MigrationAction {\n  def at: DynamicOptic\n  def reverse: MigrationAction\n}\n```\n\n### Record Actions\n\n```scala\ncase class AddField(\n  at: DynamicOptic,\n  default: SchemaExpr[?]\n) extends MigrationAction\n\ncase class DropField(\n  at: DynamicOptic,\n  defaultForReverse: SchemaExpr[?]\n) extends MigrationAction\n\ncase class Rename(\n  at: DynamicOptic,\n  to: String\n) extends MigrationAction\n\ncase class TransformValue(\n  at: DynamicOptic,\n  transform: SchemaExpr[?]\n) extends MigrationAction\n\ncase class Mandate(\n  at: DynamicOptic,\n  default: SchemaExpr[?]\n) extends MigrationAction\n\ncase class Optionalize(\n  at: DynamicOptic\n) extends MigrationAction\n\ncase class Join(\n  at: DynamicOptic,\n  sourcePaths: Vector[DynamicOptic],\n  combiner: SchemaExpr[?]\n) extends MigrationAction\n\ncase class Split(\n  at: DynamicOptic,\n  targetPaths: Vector[DynamicOptic],\n  splitter: SchemaExpr[?]\n) extends MigrationAction\n\ncase class ChangeType(\n  at: DynamicOptic,\n  converter: SchemaExpr[?]\n) extends MigrationAction\n```\n\n---\n\n### Enum Actions (Supported)\n\n```scala\ncase class RenameCase(\n  at: DynamicOptic,\n  from: String,\n  to: String\n) extends MigrationAction\n\ncase class TransformCase(\n  at: DynamicOptic,\n  actions: Vector[MigrationAction]\n) extends MigrationAction\n```\n\n> Enum case addition / removal is **out of scope** for this ticket\n> (requires composite value construction).\n\n---\n\n### Collection / Map Actions\n\n```scala\ncase class TransformElements(\n  at: DynamicOptic,\n  transform: SchemaExpr[?]\n) extends MigrationAction\n\ncase class TransformKeys(\n  at: DynamicOptic,\n  transform: SchemaExpr[?]\n) extends MigrationAction\n\ncase class TransformValues(\n  at: DynamicOptic,\n  transform: SchemaExpr[?]\n) extends MigrationAction\n```\n\n---\n\n## SchemaExpr Integration\n\n* Used for all value-level transformations\n* **Constraints for this ticket**:\n\n  * primitive  primitive only\n  * joins / splits must produce primitives\n  * no record / enum construction\n\n### `SchemaExpr.DefaultValue`\n\nA special expression that:\n\n1. uses the macro-captured field schema\n2. calls `schema.defaultValue`\n3. converts the value to `DynamicValue`\n4. is stored for reverse migrations\n\n---\n\n## Type Modeling\n\n### Records (Structural Types)\n\n```scala\ntype PersonV0 = { val firstName: String; val lastName: String }\ntype PersonV1 = { val fullName: String; val age: Int }\n\nimplicit val v0Schema: Schema[PersonV0] = Schema.structural[PersonV0]\nimplicit val v1Schema: Schema[PersonV1] = Schema.structural[PersonV1]\n```\n\n---\n\n### Enums (Union of Structural Types with Tags)\n\nEnums are encoded into structural types by using union types, together with singleton types (string literals, which represent the name of the case of the enum).\n\nIn structural types, the names of the type aliases shown below are not relevant, nor are they used.\n\n```scala\ntype OldCreditCard =\n  { type Tag = \"CreditCard\"; def number: String; def exp: String }\ntype OldWireTransfer =\n  { type Tag = \"WireTransfer\"; def account: String; def routing: String }\ntype OldPaymentMethod = OldCreditCard | OldWireTransfer\n```\n\nMacros extract:\n\n* refinement type  structure of the case\n* type `Tag` with singleton type  case tag\n\n---\n\n## Laws\n\n### Identity\n\n```scala\nMigration.identity[A].apply(a) == Right(a)\n```\n\n### Associativity\n\n```scala\n(m1 ++ m2) ++ m3 == m1 ++ (m2 ++ m3)\n```\n\n### Structural Reverse\n\n```scala\nm.reverse.reverse == m\n```\n\n### Best-Effort Semantic Inverse\n\n```scala\nm.apply(a) == Right(b)  m.reverse.apply(b) == Right(a)\n```\n\n(when sufficient information exists)\n\n---\n\n## Error Handling\n\n* All runtime errors return `MigrationError`\n* Errors must capture **path information** (`DynamicOptic`)\n* Enables diagnostics such as:\n\n> Failed to apply TransformValue at `.addresses.each.streetNumber`\n\n---\n\n## Example\n\n```scala\ntype PersonV0 = { val firstName: String; val lastName: String }\n\n@schema\ncase class Person(fullName: String, age: Int)\n\nval migration =\n  Migration.newBuilder[PersonV0, Person]\n    .addField(_.age, 0)\n    .build\n\nval old =\n  new { val firstName = \"John\"; val lastName = \"Doe\" }\n\nmigration(old)\n// Right(Person(\"John Doe\", 0))\n```\n\n---\n\n## Success Criteria\n\n* [ ] `DynamicMigration` fully serializable\n* [ ] `Migration[A, B]` wraps schemas and actions\n* [ ] All actions path-based via `DynamicOptic`\n* [ ] User API uses selector functions (`S => A`) for \"optics\" on old and new types\n* [ ] Macro validation in `.build` to confirm \"old\" has been migrated to \"new\"\n* [ ] `.buildPartial` supported\n* [ ] Structural reverse implemented\n* [ ] Identity & associativity laws hold\n* [ ] Enum rename / transform supported\n* [ ] Errors include path information\n* [ ] Comprehensive tests\n* [ ] Scala 2.13 and Scala 3.5+ supported\n",
                  "html_url": "https://github.com/zio/zio-blocks/issues/519"
                },
                "type": "github"
              },
              "hash": "zio/zio-blocks#519",
              "body": "## Overview\n\nImplement a **pure, algebraic migration system** for ZIO Schema 2 that represents **structural transformations between schema versions** as first-class, serializable data.\n\nA migration describes how to transform data from one schema version to another, enabling:\n\n* schema evolution\n* backward / forward compatibility\n* data versioning\n* offline migrations (JSON, SQL, data lakes, registries, etc.)\n\nThe system provides a **typed, macro-validated user API** (`Migration[A, B]`) built on a **pure, serializable core** (`DynamicMigration`) that operates on `DynamicValue`. \n\nThe ADT is fully introspectable and can be used to generate DDL, etc.\n\n## Motivation & Big Picture\n\n### Why structural types?\n\nWhen evolving schemas over time, **older versions of data types should not require runtime representations**.\n\nIn this design:\n\n* **Current versions** are represented by real case classes / enums\n* **Past versions** are represented using:\n\n  * **structural types** for records\n  * **abstract types + intersection types** for sum types\n\nThese types:\n\n* exist **only at compile time**\n* have **no runtime representation**\n* introduce **zero runtime overhead**\n* do **not require optics or instances to be kept around**\n\nThis allows you to describe arbitrarily old versions of data *without polluting your runtime or codebase*.\n\n#### Typical Workflow\n\nA typical workflow looks like:\n\n1. You have a current type:\n\n   ```scala\n   @schema\n   case class Person(name: String, age: Int)\n   ```\n\n2. You derive and copy its structural shape:\n\n   ```scala\n   type PersonV1 = { def name: String; def age: Int }\n   ```\n\n3. You evolve the real type:\n\n   ```scala\n   @schema\n   case class Person(fullName: String, age: Int, country: String)\n   ```\n\n4. You keep only:\n\n   * the **current** runtime type\n   * the **structural type** for the old version\n   * a **pure migration** between them\n\nNo old case classes. No old optics. No runtime baggage.\n\nNote there is no requirement that the \"current\" type actually be a real case class, enum, etc.--so you can work purely with structural types, allowing you to define migrations for data types that are never materialized as runtime structures.\n\n---\n\n### Why pure data migrations?\n\nMigrations are represented entirely as **pure data**:\n\n* no user functions\n* no closures\n* no reflection\n* no runtime code generation\n\nAs a result:\n\n* migrations can be **serialized**\n* stored in **registries**\n* applied **dynamically**\n* inspected and transformed\n* used to generate:\n\n  * upgraders\n  * downgraders\n  * SQL DDL / DML\n  * offline data transforms\n\nWhile code generation is **out of scope for this ticket**, this explains many design decisions (invertibility, path-based actions, no functions).\n\n---\n\n## Core Architecture\n\n### Type Hierarchy\n\n```scala\n// Typed migration (user-facing API)\ncase class Migration[A, B](\n  dynamicMigration: DynamicMigration,\n  sourceSchema: Schema[A], // These are structural schemas!!!\n  targetSchema: Schema[B] // These are structural schemas!!!\n) {\n  /** Apply migration to transform A to B */\n  def apply(value: A): Either[MigrationError, B]\n\n  /** Compose migrations sequentially */\n  def ++[C](that: Migration[B, C]): Migration[A, C]\n\n  /** Alias for ++ */\n  def andThen[C](that: Migration[B, C]): Migration[A, C] = this ++ that\n\n  /** Reverse migration (structural inverse; runtime is best-effort) */\n  def reverse: Migration[B, A]\n}\n```\n\n```scala\n// Untyped migration (pure data, fully serializable)\ncase class DynamicMigration(\n  actions: Vector[MigrationAction]\n) {\n  def apply(value: DynamicValue): Either[MigrationError, DynamicValue]\n  def ++(that: DynamicMigration): DynamicMigration\n  def reverse: DynamicMigration\n}\n```\n\n* `Migration[A, B]` is introspectable, but not pure data due to bindings inside schemas\n* `DynamicMigration` is **fully serializable**\n\n---\n\n## User-Facing API: Selector Expressions\n\n### Selectors, not optics\n\nThe user-facing API **does not expose optics**.\n\nInstead, all locations are specified using **selector expressions**:\n\n```scala\nS => A\n```\n\nExamples:\n\n```scala\n_.name\n_.address.street\n_.addresses.each.streetNumber\n_.country.when[UK]\n```\n\nTo see the syntax, one can look at the `optic` macro, which utilizes the same selector syntax for optic creation (e.g. `optic(_.address.street)`, etc.).\n\n### Macro extraction\n\nAll builder methods that accept selectors are **implemented via macros** (or via a macro-generated type class such as `ToDynamicOptic`).\n\nThe macro:\n\n1. Inspects the selector expression\n2. Validates it is a supported projection\n3. Converts it into a `DynamicOptic`\n4. Stores that optic in the migration action\n\nSupported projections include:\n\n* field access (`_.foo.bar`)\n* case selection (`_.country.when[UK]`)\n* collection traversal (`_.items.each`)\n* (future) key access, wrappers, etc.\n\n`DynamicOptic` is **never exposed publicly**.\n\n---\n\n## Migration Builder\n\nAll selector-accepting methods are implemented via macros. For simplicity, these are shown as functions (e.g. `A => Any`), but this is NOT the way to implement them. Either all these functions need to be macros, or a macro needs to be used to generate an implicit / given at each call site. Macros may do additional validation to constrain the validity of these different types of transformations.\n\n```scala\nclass MigrationBuilder[A, B](\n  sourceSchema: Schema[A],\n  targetSchema: Schema[B],\n  actions: Vector[MigrationAction]\n) {\n\n  // ----- Record operations -----\n\n  def addField(\n    target: B => Any,\n    default: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  def dropField(\n    source: A => Any,\n    defaultForReverse: SchemaExpr[B, ?] = SchemaExpr.DefaultValue\n  ): MigrationBuilder[A, B]\n\n  def renameField(\n    from: A => Any,\n    to: B => Any\n  ): MigrationBuilder[A, B]\n\n  def transformField(\n    from: A => Any,\n    to: B => Any,\n    transform: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  def mandateField(\n    source: A => Option[?],\n    target: B => Any,\n    default: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  def optionalizeField(\n    source: A => Any,\n    target: B => Option[?]\n  ): MigrationBuilder[A, B]\n\n  def changeFieldType(\n    source: A => Any,\n    target: B => Any,\n    converter: SchemaExpr[A, ?]  // primitive-to-primitive only\n  ): MigrationBuilder[A, B]\n\n  // ----- Enum operations (limited) -----\n\n  def renameCase[SumA, SumB](\n    from: String,\n    to: String\n  ): MigrationBuilder[A, B]\n\n  def transformCase[SumA, CaseA, SumB, CaseB](\n    caseMigration: MigrationBuilder[CaseA, CaseB] => MigrationBuilder[CaseA, CaseB]\n  ): MigrationBuilder[A, B]\n\n  // ----- Collections -----\n\n  def transformElements(\n    at: A => Vector[?],\n    transform: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  // ----- Maps -----\n\n  def transformKeys(\n    at: A => Map[?, ?],\n    transform: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  def transformValues(\n    at: A => Map[?, ?],\n    transform: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  /** Build migration with full macro validation */\n  def build: Migration[A, B]\n\n  /** Build migration without full validation */\n  def buildPartial: Migration[A, B]\n}\n```\n\n---\n\n## Migration Actions (Untyped Core)\n\nAll actions operate at a **path**, represented by `DynamicOptic`.\n\n```scala\nsealed trait MigrationAction {\n  def at: DynamicOptic\n  def reverse: MigrationAction\n}\n```\n\n### Record Actions\n\n```scala\ncase class AddField(\n  at: DynamicOptic,\n  default: SchemaExpr[?]\n) extends MigrationAction\n\ncase class DropField(\n  at: DynamicOptic,\n  defaultForReverse: SchemaExpr[?]\n) extends MigrationAction\n\ncase class Rename(\n  at: DynamicOptic,\n  to: String\n) extends MigrationAction\n\ncase class TransformValue(\n  at: DynamicOptic,\n  transform: SchemaExpr[?]\n) extends MigrationAction\n\ncase class Mandate(\n  at: DynamicOptic,\n  default: SchemaExpr[?]\n) extends MigrationAction\n\ncase class Optionalize(\n  at: DynamicOptic\n) extends MigrationAction\n\ncase class Join(\n  at: DynamicOptic,\n  sourcePaths: Vector[DynamicOptic],\n  combiner: SchemaExpr[?]\n) extends MigrationAction\n\ncase class Split(\n  at: DynamicOptic,\n  targetPaths: Vector[DynamicOptic],\n  splitter: SchemaExpr[?]\n) extends MigrationAction\n\ncase class ChangeType(\n  at: DynamicOptic,\n  converter: SchemaExpr[?]\n) extends MigrationAction\n```\n\n---\n\n### Enum Actions (Supported)\n\n```scala\ncase class RenameCase(\n  at: DynamicOptic,\n  from: String,\n  to: String\n) extends MigrationAction\n\ncase class TransformCase(\n  at: DynamicOptic,\n  actions: Vector[MigrationAction]\n) extends MigrationAction\n```\n\n> Enum case addition / removal is **out of scope** for this ticket\n> (requires composite value construction).\n\n---\n\n### Collection / Map Actions\n\n```scala\ncase class TransformElements(\n  at: DynamicOptic,\n  transform: SchemaExpr[?]\n) extends MigrationAction\n\ncase class TransformKeys(\n  at: DynamicOptic,\n  transform: SchemaExpr[?]\n) extends MigrationAction\n\ncase class TransformValues(\n  at: DynamicOptic,\n  transform: SchemaExpr[?]\n) extends MigrationAction\n```\n\n---\n\n## SchemaExpr Integration\n\n* Used for all value-level transformations\n* **Constraints for this ticket**:\n\n  * primitive  primitive only\n  * joins / splits must produce primitives\n  * no record / enum construction\n\n### `SchemaExpr.DefaultValue`\n\nA special expression that:\n\n1. uses the macro-captured field schema\n2. calls `schema.defaultValue`\n3. converts the value to `DynamicValue`\n4. is stored for reverse migrations\n\n---\n\n## Type Modeling\n\n### Records (Structural Types)\n\n```scala\ntype PersonV0 = { val firstName: String; val lastName: String }\ntype PersonV1 = { val fullName: String; val age: Int }\n\nimplicit val v0Schema: Schema[PersonV0] = Schema.structural[PersonV0]\nimplicit val v1Schema: Schema[PersonV1] = Schema.structural[PersonV1]\n```\n\n---\n\n### Enums (Union of Structural Types with Tags)\n\nEnums are encoded into structural types by using union types, together with singleton types (string literals, which represent the name of the case of the enum).\n\nIn structural types, the names of the type aliases shown below are not relevant, nor are they used.\n\n```scala\ntype OldCreditCard =\n  { type Tag = \"CreditCard\"; def number: String; def exp: String }\ntype OldWireTransfer =\n  { type Tag = \"WireTransfer\"; def account: String; def routing: String }\ntype OldPaymentMethod = OldCreditCard | OldWireTransfer\n```\n\nMacros extract:\n\n* refinement type  structure of the case\n* type `Tag` with singleton type  case tag\n\n---\n\n## Laws\n\n### Identity\n\n```scala\nMigration.identity[A].apply(a) == Right(a)\n```\n\n### Associativity\n\n```scala\n(m1 ++ m2) ++ m3 == m1 ++ (m2 ++ m3)\n```\n\n### Structural Reverse\n\n```scala\nm.reverse.reverse == m\n```\n\n### Best-Effort Semantic Inverse\n\n```scala\nm.apply(a) == Right(b)  m.reverse.apply(b) == Right(a)\n```\n\n(when sufficient information exists)\n\n---\n\n## Error Handling\n\n* All runtime errors return `MigrationError`\n* Errors must capture **path information** (`DynamicOptic`)\n* Enables diagnostics such as:\n\n> Failed to apply TransformValue at `.addresses.each.streetNumber`\n\n---\n\n## Example\n\n```scala\ntype PersonV0 = { val firstName: String; val lastName: String }\n\n@schema\ncase class Person(fullName: String, age: Int)\n\nval migration =\n  Migration.newBuilder[PersonV0, Person]\n    .addField(_.age, 0)\n    .build\n\nval old =\n  new { val firstName = \"John\"; val lastName = \"Doe\" }\n\nmigration(old)\n// Right(Person(\"John Doe\", 0))\n```\n\n---\n\n## Success Criteria\n\n* [ ] `DynamicMigration` fully serializable\n* [ ] `Migration[A, B]` wraps schemas and actions\n* [ ] All actions path-based via `DynamicOptic`\n* [ ] User API uses selector functions (`S => A`) for \"optics\" on old and new types\n* [ ] Macro validation in `.build` to confirm \"old\" has been migrated to \"new\"\n* [ ] `.buildPartial` supported\n* [ ] Structural reverse implemented\n* [ ] Identity & associativity laws hold\n* [ ] Enum rename / transform supported\n* [ ] Errors include path information\n* [ ] Comprehensive tests\n* [ ] Scala 2.13 and Scala 3.5+ supported\n",
              "url": "https://github.com/zio/zio-blocks/issues/519",
              "tech": [],
              "repo_name": "zio-blocks",
              "repo_owner": "zio",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "ZIO#517",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "ZIO",
              "id": "generated-ZIO",
              "name": "ZIO",
              "description": "",
              "members": [],
              "display_name": "ZIO",
              "created_at": "2026-01-24T11:31:19.410Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/ZIO?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "zio",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-24T11:31:19.410Z",
            "created_at": "2026-01-24T11:31:19.410Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-ZIO#517",
              "status": "open",
              "type": "issue",
              "number": 517,
              "title": "Add structural schemas",
              "source": {
                "data": {
                  "id": "source-ZIO#517",
                  "user": {
                    "login": "jdegoes",
                    "id": 156745,
                    "node_id": "MDQ6VXNlcjE1Njc0NQ==",
                    "avatar_url": "https://avatars.githubusercontent.com/u/156745?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/jdegoes",
                    "html_url": "https://github.com/jdegoes",
                    "followers_url": "https://api.github.com/users/jdegoes/followers",
                    "following_url": "https://api.github.com/users/jdegoes/following{/other_user}",
                    "gists_url": "https://api.github.com/users/jdegoes/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/jdegoes/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/jdegoes/subscriptions",
                    "organizations_url": "https://api.github.com/users/jdegoes/orgs",
                    "repos_url": "https://api.github.com/users/jdegoes/repos",
                    "events_url": "https://api.github.com/users/jdegoes/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/jdegoes/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Add structural schemas",
                  "body": "# Structural Type Schema Support\n\n## Overview\n\nExtend `Schema[A]` to support structural types, enabling schema derivation for types defined by their structure rather than their nominal identity. This allows for duck-typed schema validation and conversion between nominal and structural representations.\n\n## Core Concepts\n\n### Direct Structural Schema Derivation\n\nSchemas can be derived directly for structural types:\n\n```scala\n// Scala 3\ntype Person = { def name: String; def age: Int }\nval schema = Schema.derived[Person]\n\n// Scala 2\ntype Person = { def name: String; def age: Int }\nval schema = Schema.derived[Person]\n```\n\n**Note**: Both Scala 2 and Scala 3 use `def` for uniformity, even though Scala 3 supports `val` in structural types.\n\n**Implementation**: Schemas have bindings, which allow construction / deconstruction of values. Values for structural types are backed by:\n- **Scala 3**: `Selectable` \n- **Scala 2**: `Dynamic`\n\n### Nominal to Structural Conversion\n\nConvert nominal type schemas to their structural equivalents:\n\n```scala\ncase class Person(name: String, age: Int)\n\n// Get the structural schema corresponding to Person's shape\nval structuralSchema: Schema[{ def name: String; def age: Int }] = \n  Schema.derived[Person].structural\n```\n\n### Schema API Extension\n\n```scala\ncase class Schema[A](/* existing fields */) {\n  /**\n   * Convert this schema to a structural type schema.\n   * \n   * The structural type represents the \"shape\" of A without its nominal identity.\n   * This enables duck typing and structural validation.\n   * \n   * @param toStructural Macro-generated conversion to structural representation\n   * @return Schema for the structural type corresponding to A\n   */\n  def structural(implicit toStructural: ToStructural[A]): Schema[toStructural.StructuralType] = \n    toStructural.apply(this)\n}\n\n/**\n * Type class for converting nominal schemas to structural schemas.\n * Generated by macro for all supported types. Macro fails if a structural\n * type cannot be generated.\n *\n * NOTE: This approach has to be tested to yield inferrable types, and revised\n * if necessary. Inferrable types (from calling Schema#structural) are a must-have.\n */\ntrait ToStructural[A] {\n  type StructuralType\n  def apply(schema: Schema[A]): Schema[StructuralType]\n}\n\nobject ToStructural {\n  type Aux[A, S] = ToStructural[A] { type StructuralType = S }\n  \n  // Scala 3\n  transparent inline given [A]: ToStructural[A] = ${toStructuralMacro[A]}\n  \n  // Scala 2\n  implicit def materialize[A]: ToStructural[A] = macro toStructuralImpl[A]\n}\n```\n\n---\n\n## Examples\n\n### 1. Simple Product Types\n\n#### Case Class to Structural\n\n```scala\n// Both Scala 2 and Scala 3\ncase class Person(name: String, age: Int)\n\n// Original nominal schema\nval nominalSchema: Schema[Person] = Schema.derived[Person]\n\n// Convert to structural\nval structuralSchema: Schema[{ def name: String; def age: Int }] = \n  nominalSchema.structural\n\n// Direct structural derivation (equivalent)\nval directStructural: Schema[{ def name: String; def age: Int }] = \n  Schema.derived[{ def name: String; def age: Int }]\n```\n\n### 2. Nested Structures\n\n```scala\ncase class Address(street: String, city: String, zip: Int)\ncase class Person(name: String, age: Int, address: Address)\n\nval structuralSchema = Schema.derived[Person].structural\n// Type: Schema[{ \n//   def name: String\n//   def age: Int\n//   def address: { def street: String; def city: String; def zip: Int }\n// }]\n```\n\n### 3. Collections and Options\n\n```scala\ncase class Team(name: String, members: List[String], leader: Option[String])\n\nval structuralSchema = Schema.derived[Team].structural\n// Type: Schema[{\n//   def name: String\n//   def members: List[String]\n//   def leader: Option[String]\n// }]\n```\n\n### 4. Tuples to Structural\n\n```scala\n// Tuples can be converted to structural types\nval tupleSchema: Schema[(String, Int, Boolean)] = Schema.derived[(String, Int, Boolean)]\n\nval structuralSchema = tupleSchema.structural\n// Type: Schema[{ def _1: String; def _2: Int; def _3: Boolean }]\n```\n\n### 5. Sum Types (Sealed Traits) - Scala 3 Only\n\nSealed traits become union types of structural representations, with tag information stored at the type level:\n\n```scala\n// Scala 3 only\nsealed trait Result\ncase class Success(value: Int) extends Result\ncase class Failure(error: String) extends Result\n\nval structuralSchema = Schema.derived[Result].structural\n// Type: Schema[\n//   { type Tag = \"Success\"; def value: Int } | { type Tag = \"Failure\"; def error: String }\n// ]\n```\n\n**Note**: Sum type to structural conversion is **not supported in Scala 2** because it requires union types. Attempting to call `.structural` on a sealed trait schema in Scala 2 will result in a compile-time error.\n\n### 6. Enums (Scala 3 Only)\n\n```scala\nenum Status:\n  case Active, Inactive, Suspended\n\nval structuralSchema = Schema.derived[Status].structural\n// Type: Schema[{type Tag = \"Active\"} | {type Tag = \"Inactive\"} | {type Tag = \"Suspended\"}]\n```\n\n### 7. Opaque Types (Scala 3)\n\n```scala\nopaque type UserId = String\nobject UserId:\n  def apply(value: String): Either[String, UserId] = \n    if value.nonEmpty then Right(value) else Left(\"Empty user ID\")\n\ncase class User(id: UserId, name: String)\n\nval structuralSchema = Schema.derived[User].structural\n// Type: Schema[{ def id: String; def name: String }]\n// Opaque type is unwrapped to its underlying type\n```\n\n### 8. Bidirectional Conversion\n\nStructural schemas work seamlessly with `Into`/`As` (if this ticket is implemented **after** that ticket):\n\n```scala\ncase class Person(name: String, age: Int)\n\nval structuralSchema = Schema.derived[Person].structural\n\n// Create structural value (Scala 3)\nval structuralPerson = new Selectable {\n  def selectDynamic(field: String): Any = field match {\n    case \"name\" => \"Alice\"\n    case \"age\" => 30\n  }\n}\n\n// Convert structural to nominal using Into\nval person: Either[SchemaError, Person] = \n  Into[{ def name: String; def age: Int }, Person].into(structuralPerson)\n// => Right(Person(\"Alice\", 30))\n\n// Convert nominal to structural\nval backToStructural: Either[SchemaError, { def name: String; def age: Int }] = \n  Into[Person, { def name: String; def age: Int }].into(Person(\"Bob\", 25))\n```\n\n### 9. Empty and Single-Field Products\n\n```scala\n// Empty case class\ncase class Empty()\nval emptyStructural = Schema.derived[Empty].structural\n// Type: Schema[{}]\n\n// Single field\ncase class Id(value: String)\nval idStructural = Schema.derived[Id].structural\n// Type: Schema[{ def value: String }]\n```\n\n### 10. Large Products\n\n```scala\ncase class LargeRecord(\n  f1: String, f2: Int, f3: Boolean, f4: Double, f5: Long,\n  f6: String, f7: Int, f8: Boolean, f9: Double, f10: Long,\n  f11: String, f12: Int, f13: Boolean, f14: Double, f15: Long,\n  f16: String, f17: Int, f18: Boolean, f19: Double, f20: Long,\n  f21: String\n)\n\nval structuralSchema = Schema.derived[LargeRecord].structural\n// Type: Schema[{\n//   def f1: String; def f2: Int; def f3: Boolean; ...\n//   def f21: String\n// }]\n```\n\n---\n\n## Type Name Handling\n\n### Current Limitation\n\nSchemas currently use `TypeName[A]` to identify types. Structural types don't have meaningful nominal type names, which creates a mismatch.\n\n### Temporary Solution\n\nUntil `TypeName[A]` is replaced with `TypeId[A]` (see issue #471), structural schemas will use a normalized string representation of the structural type as a fake type name:\n\n```scala\ncase class Person(name: String, age: Int)\n\nval schema = Schema.derived[Person]\nschema.typeName // => TypeName for \"Person\"\n\nval structural = schema.structural\nstructural.typeName // => TypeName for \"{age:Int,name:String}\"\n// Normalized: fields sorted alphabetically, types fully qualified\n```\n\n### Normalization Rules\n\n1. **Field ordering**: Alphabetical by field name\n2. **Type qualification**: Use simple names for primitives and standard library types\n3. **Whitespace**: No whitespace in generated names\n4. **Collections**: Standard notation (e.g., `List[Int]`)\n5. **Options**: Explicit `Option[T]` notation\n6. **Nested structures**: Recursive application of rules\n7. **Deterministic**: Same structure always produces same normalized name\n\n### Examples\n\n```scala\n// Simple product\ncase class Point(x: Int, y: Int)\nSchema.derived[Point].structural.typeName \n// => \"{x:Int,y:Int}\"\n\n// Nested product\ncase class Address(street: String, zip: Int)\ncase class Person(name: String, address: Address)\nSchema.derived[Person].structural.typeName\n// => \"{address:{street:String,zip:Int},name:String}\"\n\n// With collections\ncase class Team(name: String, members: List[String])\nSchema.derived[Team].structural.typeName\n// => \"{members:List[String],name:String}\"\n\n// Union type (Scala 3)\nsealed trait Result\ncase class Success(value: Int) extends Result\ncase class Failure(error: String) extends Result\nSchema.derived[Result].structural.typeName\n// => \"{error:String}|{value:Int}\"\n```\n\n### Future: TypeId[A]\n\nThe upcoming `TypeId[A]` replacement will properly handle structural types by representing them by their structure rather than a string-based hack. See issue #471 for details.\n\n---\n\n## Limitations and Edge Cases\n\n### 1. Generic Types\n\n**Behavior depends on existing Schema derivation support for generic types.**\n\nIf `Schema.derived[Container[Int]]` already works, then structural conversion should work:\n\n```scala\ncase class Container[T](value: T)\n\n// If this works:\nval schema = Schema.derived[Container[Int]]\n\n// Then this should work:\nval structural = schema.structural\n// Type: Schema[{ def value: Int }]\n```\n\nIf generic type derivation is not currently supported, this ticket **does not require implementing it**. The macro should produce a clear compile-time error for unsupported generic types.\n\n### 2. Recursive Types\n\nRecursive types will **fail at compile-time** because Scala does not support infinite types:\n\n```scala\ncase class Tree(value: Int, children: List[Tree])\n\n// This will FAIL at compile-time:\nval structural = Schema.derived[Tree].structural\n// Compile error: Cannot generate infinite structural type\n\n// The structural type would need to be:\n// { def value: Int; def children: List[{ def value: Int; def children: List[...] }] }\n// which is infinite and unsupported\n```\n\nThe macro must detect recursive types and produce a helpful error message:\n\n```\nCompile error: Cannot generate structural type for recursive type Tree.\nStructural types cannot represent recursive structures.\n```\n\n### 3. Mutually Recursive Types\n\nSimilarly, mutually recursive types are unsupported:\n\n```scala\ncase class Node(id: Int, edges: List[Edge])\ncase class Edge(from: Int, to: Node)\n\n// This will FAIL at compile-time:\nval nodeStructural = Schema.derived[Node].structural\n// Compile error: Cannot generate structural type for mutually recursive types\n```\n\n### 4. Sum Types in Scala 2\n\nSealed traits and sum types **cannot be converted to structural types in Scala 2** because they require union types:\n\n```scala\n// Scala 2\nsealed trait Result\ncase class Success(value: Int) extends Result\ncase class Failure(error: String) extends Result\n\n// This will FAIL at compile-time in Scala 2:\nval structural = Schema.derived[Result].structural\n// Compile error: Cannot generate structural type for sum types in Scala 2.\n// Union types are required, which are only available in Scala 3.\n```\n\nThe macro must detect sum types in Scala 2 and produce a clear error.\n\n### 5. Case Objects\n\nCase objects become empty structural types:\n\n```scala\ncase object Singleton\n\nval structural = Schema.derived[Singleton.type].structural\n// Type: Schema[{}]\n```\n\nFor sum types with case objects (Scala 3):\n\n```scala\nsealed trait Status\ncase object Active extends Status\ncase object Inactive extends Status\n\nval structural = Schema.derived[Status].structural\n// Type: Schema[{} | {}]\n// Not particularly useful, but valid\n```\n\n### 6. Structural Types as Source\n\nDeriving schemas directly for structural types is supported:\n\n```scala\ntype PersonStructure = { def name: String; def age: Int }\n\nval schema = Schema.derived[PersonStructure]\n// Should work if structural type derivation is implemented\n```\n\nThe schema's bindings will use `Selectable` (Scala 3) or `Dynamic` (Scala 2) to construct and deconstruct values.\n\n---\n\n## Integration with Into/As\n\nStructural schemas compose naturally with `Into`/`As` conversions.\n\n### Nominal  Structural\n\n```scala\ncase class Person(name: String, age: Int)\n\n// Auto-derived conversion\nval nominalToStructural: Into[Person, { def name: String; def age: Int }] = \n  Into.derived\n\nval person = Person(\"Alice\", 30)\nval structural = nominalToStructural.into(person)\n// => Right(<Selectable/Dynamic instance>)\n```\n\n### Structural  Nominal\n\n```scala\ntype PersonStructure = { def name: String; def age: Int }\ncase class Person(name: String, age: Int)\n\n// Auto-derived conversion\nval structuralToNominal: Into[PersonStructure, Person] = \n  Into.derived\n\nval structural: PersonStructure = new Selectable {\n  def selectDynamic(field: String): Any = field match {\n    case \"name\" => \"Bob\"\n    case \"age\" => 25\n  }\n}\n\nval person = structuralToNominal.into(structural)\n// => Right(Person(\"Bob\", 25))\n```\n\n### Bidirectional (As)\n\n```scala\ncase class Person(name: String, age: Int)\n\n// Bidirectional conversion\nval personAs: As[Person, { def name: String; def age: Int }] = \n  As.derived\n\n// Nominal  Structural\nval structural = personAs.into(Person(\"Alice\", 30))\n\n// Structural  Nominal\nval nominal = structural.flatMap(personAs.from)\n// Round-trip successful\n```\n\n### Schema-Guided Conversion\n\n```scala\ncase class PersonV1(firstName: String, lastName: String, age: Int)\ncase class PersonV2(name: String, age: Int)\n\n// Use structural type as intermediary\ntype PersonStructure = { def name: String; def age: Int }\n\n// Step 1: Transform V1 to structural (custom logic)\nval v1ToStructural: Into[PersonV1, PersonStructure] = \n  new Into[PersonV1, PersonStructure] {\n    def into(v1: PersonV1): Either[SchemaError, PersonStructure] = {\n      Right(new Selectable {\n        def selectDynamic(field: String): Any = field match {\n          case \"name\" => s\"${v1.firstName} ${v1.lastName}\"\n          case \"age\" => v1.age\n        }\n      })\n    }\n  }\n\n// Step 2: Auto-convert structural to V2\nval structuralToV2: Into[PersonStructure, PersonV2] = Into.derived\n\n// Composed migration\ndef migrate(v1: PersonV1): Either[SchemaError, PersonV2] = {\n  v1ToStructural.into(v1).flatMap(structuralToV2.into)\n}\n```\n\n---\n\n## Testing Requirements\n\n### Test Matrix\n\n1. **Direct Structural Derivation**\n   - Simple products (case classes)\n   - Nested products\n   - Collections (List, Vector, Set, Map, Option, Either)\n   - Tuples (2-22 elements)\n   - Empty case classes\n   - Single-field case classes\n   - Large products (20+ fields)\n   - Case objects\n\n2. **Nominal to Structural Conversion**\n   - Case class  structural\n   - Tuple  structural\n   - Nested case classes  nested structural\n   - Case class with collections  structural with collections\n   - Empty case class  empty structural\n\n3. **Sum Types (Scala 3 Only)**\n   - Sealed trait  union type structural\n   - Sealed trait with case objects\n   - Enum  union type structural\n   - Nested sum types\n\n4. **Type Name Generation**\n   - Simple product normalized name\n   - Nested product normalized name\n   - Name determinism (same structure = same name)\n   - Alphabetical field ordering in names\n   - Union type names (Scala 3)\n\n5. **Selectable/Dynamic Implementation**\n   - Scala 3 Selectable field access\n   - Scala 2 Dynamic field access\n   - Field access correctness\n   - Missing field behavior\n   - Extra field behavior\n\n6. **Integration with Into/As**\n   - Nominal  Structural via Into\n   - Structural  Nominal via Into\n   - Round-trip via As\n   - Composed conversions with structural intermediary\n\n7. **Error Cases (Compile-Time)**\n   - Recursive types produce error\n   - Mutually recursive types produce error\n   - Sum types in Scala 2 produce error\n   - Unsupported types produce helpful errors\n\n8. **Generic Types** (if supported by existing Schema derivation)\n   - Fully applied generic  structural\n   - Generic with nested structural fields\n\n### Scala 2 vs Scala 3 Test Separation\n\n```\nsrc/test/scala/\n  structural/\n    common/\n      SimpleProductSpec.scala\n      NestedProductSpec.scala\n      CollectionsSpec.scala\n      TuplesSpec.scala\n      EmptyProductSpec.scala\n      SingleFieldSpec.scala\n      LargeProductSpec.scala\n      TypeNameNormalizationSpec.scala\n      IntoIntegrationSpec.scala\n      AsIntegrationSpec.scala\n      \n    scala3/\n      UnionTypesSpec.scala\n      SealedTraitToUnionSpec.scala\n      EnumToUnionSpec.scala\n      SelectableImplementationSpec.scala\n      \n    scala2/\n      DynamicImplementationSpec.scala\n      SumTypeErrorSpec.scala (verifies compile error)\n      \n    errors/\n      RecursiveTypeErrorSpec.scala\n      MutualRecursionErrorSpec.scala\n      UnsupportedTypeErrorSpec.scala\n```\n\n### Test Examples\n\n```scala\n// Test: Simple product to structural\ntest(\"case class converts to structural schema\") {\n  case class Person(name: String, age: Int)\n  \n  val structural = Schema.derived[Person].structural\n  \n  // Type check (this is a compile-time test)\n  val _: Schema[{ def name: String; def age: Int }] = structural\n  \n  assert(structural.typeName.toString.contains(\"name\"))\n  assert(structural.typeName.toString.contains(\"age\"))\n}\n\n// Test: Nested products\ntest(\"nested case classes convert to nested structural\") {\n  case class Address(street: String, zip: Int)\n  case class Person(name: String, address: Address)\n  \n  val structural = Schema.derived[Person].structural\n  \n  val _: Schema[{ \n    def name: String\n    def address: { def street: String; def zip: Int }\n  }] = structural\n}\n\n// Test: Tuple to structural\ntest(\"tuple converts to structural with _N fields\") {\n  val structural = Schema.derived[(String, Int, Boolean)].structural\n  \n  val _: Schema[{ def _1: String; def _2: Int; def _3: Boolean }] = structural\n}\n\n// Test: Union type (Scala 3 only)\ntest(\"sealed trait converts to union type structural\") {\n  sealed trait Result\n  case class Success(value: Int) extends Result\n  case class Failure(error: String) extends Result\n  \n  val structural = Schema.derived[Result].structural\n  \n  val _: Schema[{ def value: Int } | { def error: String }] = structural\n}\n\n// Test: Type name normalization\ntest(\"structural type names are normalized and deterministic\") {\n  case class Person(name: String, age: Int)\n  case class User(age: Int, name: String) // Different field order\n  \n  val personStructural = Schema.derived[Person].structural\n  val userStructural = Schema.derived[User].structural\n  \n  // Same structure, same normalized name\n  assert(personStructural.typeName == userStructural.typeName)\n  \n  // Alphabetical ordering\n  assert(personStructural.typeName.toString.contains(\"age\"))\n  assert(personStructural.typeName.toString.indexOf(\"age\") < \n         personStructural.typeName.toString.indexOf(\"name\"))\n}\n\n// Test: Integration with Into\ntest(\"structural to nominal conversion via Into\") {\n  case class Person(name: String, age: Int)\n  type PersonStructure = { def name: String; def age: Int }\n  \n  val structural: PersonStructure = new Selectable {\n    def selectDynamic(field: String): Any = field match {\n      case \"name\" => \"Alice\"\n      case \"age\" => 30\n    }\n  }\n  \n  val person = Into[PersonStructure, Person].into(structural)\n  assert(person == Right(Person(\"Alice\", 30)))\n}\n\n// Test: Round-trip via As\ntest(\"nominal to structural and back preserves data\") {\n  case class Person(name: String, age: Int)\n  type PersonStructure = { def name: String; def age: Int }\n  \n  val original = Person(\"Alice\", 30)\n  \n  val toStructural = As[Person, PersonStructure].into(original)\n  val backToNominal = toStructural.flatMap(As[Person, PersonStructure].from)\n  \n  assert(backToNominal == Right(original))\n}\n\n// Test: Recursive type compile error\ntest(\"recursive types produce compile error\") {\n  case class Tree(value: Int, children: List[Tree])\n  \n  assertDoesNotCompile(\"Schema.derived[Tree].structural\")\n}\n\n// Test: Sum type in Scala 2 compile error\ntest(\"sum types in Scala 2 produce compile error\") {\n  sealed trait Result\n  case class Success(value: Int) extends Result\n  \n  // Scala 2 only\n  assertDoesNotCompile(\"Schema.derived[Result].structural\")\n}\n```\n\n---\n\n## Implementation Notes\n\n### Macro Behavior\n\nThe macro must:\n\n1. **Detect product types** (case classes, tuples) and generate structural types with `def` members\n2. **Detect sum types** (sealed traits, enums) and:\n   - In Scala 3: Generate union types of structural representations\n   - In Scala 2: Fail with clear error message\n3. **Detect recursive types** and fail with clear error message\n4. **Normalize structural type representations** for type name generation\n5. **Generate `ToStructural` instance** with:\n   - `StructuralType` type member set to the generated structural type\n   - `apply` method that transforms the schema appropriately\n6. **Preserve field metadata** from original schema where applicable\n7. **Generate appropriate bindings** using `Selectable` (Scala 3) or `Dynamic` (Scala 2)\n\n### Schema Transformation\n\nWhen converting `Schema[A]` to `Schema[StructuralType]`:\n\n1. **Preserve field information**: Field names, types, optional/required status\n2. **Update type name**: Use normalized structural representation\n3. **Transform bindings**: Replace nominal constructors/deconstructors with structural equivalents\n4. **Preserve validation**: Maintain any validation logic that applies to field values\n5. **Handle nested schemas**: Recursively transform nested product types\n\n### Error Messages\n\nProvide clear compile-time errors:\n\n```scala\n// Recursive type\ncase class Tree(value: Int, children: List[Tree])\nSchema.derived[Tree].structural\n\n// Error:\n\"\"\"\nCannot generate structural type for recursive type Tree.\nStructural types cannot represent recursive structures.\nScala's type system does not support infinite types.\n\"\"\"\n\n// Sum type in Scala 2\nsealed trait Result\ncase class Success(value: Int) extends Result\nSchema.derived[Result].structural\n\n// Error (Scala 2 only):\n\"\"\"\nCannot generate structural type for sum type Result.\nStructural representation of sum types requires union types,\nwhich are only available in Scala 3.\nConsider upgrading to Scala 3 or using a different approach.\n\"\"\"\n```\n\n---\n\n## Deliverables\n\n1.  `ToStructural[A]` trait and macro for Scala 2.13\n2.  `ToStructural[A]` trait and macro for Scala 3.5\n3.  `structural` method on `Schema[A]`\n4.  Support for product types (case classes, tuples)\n5.  Support for sum types (sealed traits, enums) in Scala 3 only\n6.  Normalized type name generation\n7.  `Selectable` bindings (Scala 3) and `Dynamic` bindings (Scala 2)\n8.  Integration with `Into`/`As` for structural  nominal conversions\n9.  Comprehensive test suite (300+ test cases)\n10.  Clear error messages for unsupported cases\n11.  Documentation with examples",
                  "html_url": "https://github.com/zio/zio-blocks/issues/517"
                },
                "type": "github"
              },
              "hash": "zio/zio-blocks#517",
              "body": "# Structural Type Schema Support\n\n## Overview\n\nExtend `Schema[A]` to support structural types, enabling schema derivation for types defined by their structure rather than their nominal identity. This allows for duck-typed schema validation and conversion between nominal and structural representations.\n\n## Core Concepts\n\n### Direct Structural Schema Derivation\n\nSchemas can be derived directly for structural types:\n\n```scala\n// Scala 3\ntype Person = { def name: String; def age: Int }\nval schema = Schema.derived[Person]\n\n// Scala 2\ntype Person = { def name: String; def age: Int }\nval schema = Schema.derived[Person]\n```\n\n**Note**: Both Scala 2 and Scala 3 use `def` for uniformity, even though Scala 3 supports `val` in structural types.\n\n**Implementation**: Schemas have bindings, which allow construction / deconstruction of values. Values for structural types are backed by:\n- **Scala 3**: `Selectable` \n- **Scala 2**: `Dynamic`\n\n### Nominal to Structural Conversion\n\nConvert nominal type schemas to their structural equivalents:\n\n```scala\ncase class Person(name: String, age: Int)\n\n// Get the structural schema corresponding to Person's shape\nval structuralSchema: Schema[{ def name: String; def age: Int }] = \n  Schema.derived[Person].structural\n```\n\n### Schema API Extension\n\n```scala\ncase class Schema[A](/* existing fields */) {\n  /**\n   * Convert this schema to a structural type schema.\n   * \n   * The structural type represents the \"shape\" of A without its nominal identity.\n   * This enables duck typing and structural validation.\n   * \n   * @param toStructural Macro-generated conversion to structural representation\n   * @return Schema for the structural type corresponding to A\n   */\n  def structural(implicit toStructural: ToStructural[A]): Schema[toStructural.StructuralType] = \n    toStructural.apply(this)\n}\n\n/**\n * Type class for converting nominal schemas to structural schemas.\n * Generated by macro for all supported types. Macro fails if a structural\n * type cannot be generated.\n *\n * NOTE: This approach has to be tested to yield inferrable types, and revised\n * if necessary. Inferrable types (from calling Schema#structural) are a must-have.\n */\ntrait ToStructural[A] {\n  type StructuralType\n  def apply(schema: Schema[A]): Schema[StructuralType]\n}\n\nobject ToStructural {\n  type Aux[A, S] = ToStructural[A] { type StructuralType = S }\n  \n  // Scala 3\n  transparent inline given [A]: ToStructural[A] = ${toStructuralMacro[A]}\n  \n  // Scala 2\n  implicit def materialize[A]: ToStructural[A] = macro toStructuralImpl[A]\n}\n```\n\n---\n\n## Examples\n\n### 1. Simple Product Types\n\n#### Case Class to Structural\n\n```scala\n// Both Scala 2 and Scala 3\ncase class Person(name: String, age: Int)\n\n// Original nominal schema\nval nominalSchema: Schema[Person] = Schema.derived[Person]\n\n// Convert to structural\nval structuralSchema: Schema[{ def name: String; def age: Int }] = \n  nominalSchema.structural\n\n// Direct structural derivation (equivalent)\nval directStructural: Schema[{ def name: String; def age: Int }] = \n  Schema.derived[{ def name: String; def age: Int }]\n```\n\n### 2. Nested Structures\n\n```scala\ncase class Address(street: String, city: String, zip: Int)\ncase class Person(name: String, age: Int, address: Address)\n\nval structuralSchema = Schema.derived[Person].structural\n// Type: Schema[{ \n//   def name: String\n//   def age: Int\n//   def address: { def street: String; def city: String; def zip: Int }\n// }]\n```\n\n### 3. Collections and Options\n\n```scala\ncase class Team(name: String, members: List[String], leader: Option[String])\n\nval structuralSchema = Schema.derived[Team].structural\n// Type: Schema[{\n//   def name: String\n//   def members: List[String]\n//   def leader: Option[String]\n// }]\n```\n\n### 4. Tuples to Structural\n\n```scala\n// Tuples can be converted to structural types\nval tupleSchema: Schema[(String, Int, Boolean)] = Schema.derived[(String, Int, Boolean)]\n\nval structuralSchema = tupleSchema.structural\n// Type: Schema[{ def _1: String; def _2: Int; def _3: Boolean }]\n```\n\n### 5. Sum Types (Sealed Traits) - Scala 3 Only\n\nSealed traits become union types of structural representations, with tag information stored at the type level:\n\n```scala\n// Scala 3 only\nsealed trait Result\ncase class Success(value: Int) extends Result\ncase class Failure(error: String) extends Result\n\nval structuralSchema = Schema.derived[Result].structural\n// Type: Schema[\n//   { type Tag = \"Success\"; def value: Int } | { type Tag = \"Failure\"; def error: String }\n// ]\n```\n\n**Note**: Sum type to structural conversion is **not supported in Scala 2** because it requires union types. Attempting to call `.structural` on a sealed trait schema in Scala 2 will result in a compile-time error.\n\n### 6. Enums (Scala 3 Only)\n\n```scala\nenum Status:\n  case Active, Inactive, Suspended\n\nval structuralSchema = Schema.derived[Status].structural\n// Type: Schema[{type Tag = \"Active\"} | {type Tag = \"Inactive\"} | {type Tag = \"Suspended\"}]\n```\n\n### 7. Opaque Types (Scala 3)\n\n```scala\nopaque type UserId = String\nobject UserId:\n  def apply(value: String): Either[String, UserId] = \n    if value.nonEmpty then Right(value) else Left(\"Empty user ID\")\n\ncase class User(id: UserId, name: String)\n\nval structuralSchema = Schema.derived[User].structural\n// Type: Schema[{ def id: String; def name: String }]\n// Opaque type is unwrapped to its underlying type\n```\n\n### 8. Bidirectional Conversion\n\nStructural schemas work seamlessly with `Into`/`As` (if this ticket is implemented **after** that ticket):\n\n```scala\ncase class Person(name: String, age: Int)\n\nval structuralSchema = Schema.derived[Person].structural\n\n// Create structural value (Scala 3)\nval structuralPerson = new Selectable {\n  def selectDynamic(field: String): Any = field match {\n    case \"name\" => \"Alice\"\n    case \"age\" => 30\n  }\n}\n\n// Convert structural to nominal using Into\nval person: Either[SchemaError, Person] = \n  Into[{ def name: String; def age: Int }, Person].into(structuralPerson)\n// => Right(Person(\"Alice\", 30))\n\n// Convert nominal to structural\nval backToStructural: Either[SchemaError, { def name: String; def age: Int }] = \n  Into[Person, { def name: String; def age: Int }].into(Person(\"Bob\", 25))\n```\n\n### 9. Empty and Single-Field Products\n\n```scala\n// Empty case class\ncase class Empty()\nval emptyStructural = Schema.derived[Empty].structural\n// Type: Schema[{}]\n\n// Single field\ncase class Id(value: String)\nval idStructural = Schema.derived[Id].structural\n// Type: Schema[{ def value: String }]\n```\n\n### 10. Large Products\n\n```scala\ncase class LargeRecord(\n  f1: String, f2: Int, f3: Boolean, f4: Double, f5: Long,\n  f6: String, f7: Int, f8: Boolean, f9: Double, f10: Long,\n  f11: String, f12: Int, f13: Boolean, f14: Double, f15: Long,\n  f16: String, f17: Int, f18: Boolean, f19: Double, f20: Long,\n  f21: String\n)\n\nval structuralSchema = Schema.derived[LargeRecord].structural\n// Type: Schema[{\n//   def f1: String; def f2: Int; def f3: Boolean; ...\n//   def f21: String\n// }]\n```\n\n---\n\n## Type Name Handling\n\n### Current Limitation\n\nSchemas currently use `TypeName[A]` to identify types. Structural types don't have meaningful nominal type names, which creates a mismatch.\n\n### Temporary Solution\n\nUntil `TypeName[A]` is replaced with `TypeId[A]` (see issue #471), structural schemas will use a normalized string representation of the structural type as a fake type name:\n\n```scala\ncase class Person(name: String, age: Int)\n\nval schema = Schema.derived[Person]\nschema.typeName // => TypeName for \"Person\"\n\nval structural = schema.structural\nstructural.typeName // => TypeName for \"{age:Int,name:String}\"\n// Normalized: fields sorted alphabetically, types fully qualified\n```\n\n### Normalization Rules\n\n1. **Field ordering**: Alphabetical by field name\n2. **Type qualification**: Use simple names for primitives and standard library types\n3. **Whitespace**: No whitespace in generated names\n4. **Collections**: Standard notation (e.g., `List[Int]`)\n5. **Options**: Explicit `Option[T]` notation\n6. **Nested structures**: Recursive application of rules\n7. **Deterministic**: Same structure always produces same normalized name\n\n### Examples\n\n```scala\n// Simple product\ncase class Point(x: Int, y: Int)\nSchema.derived[Point].structural.typeName \n// => \"{x:Int,y:Int}\"\n\n// Nested product\ncase class Address(street: String, zip: Int)\ncase class Person(name: String, address: Address)\nSchema.derived[Person].structural.typeName\n// => \"{address:{street:String,zip:Int},name:String}\"\n\n// With collections\ncase class Team(name: String, members: List[String])\nSchema.derived[Team].structural.typeName\n// => \"{members:List[String],name:String}\"\n\n// Union type (Scala 3)\nsealed trait Result\ncase class Success(value: Int) extends Result\ncase class Failure(error: String) extends Result\nSchema.derived[Result].structural.typeName\n// => \"{error:String}|{value:Int}\"\n```\n\n### Future: TypeId[A]\n\nThe upcoming `TypeId[A]` replacement will properly handle structural types by representing them by their structure rather than a string-based hack. See issue #471 for details.\n\n---\n\n## Limitations and Edge Cases\n\n### 1. Generic Types\n\n**Behavior depends on existing Schema derivation support for generic types.**\n\nIf `Schema.derived[Container[Int]]` already works, then structural conversion should work:\n\n```scala\ncase class Container[T](value: T)\n\n// If this works:\nval schema = Schema.derived[Container[Int]]\n\n// Then this should work:\nval structural = schema.structural\n// Type: Schema[{ def value: Int }]\n```\n\nIf generic type derivation is not currently supported, this ticket **does not require implementing it**. The macro should produce a clear compile-time error for unsupported generic types.\n\n### 2. Recursive Types\n\nRecursive types will **fail at compile-time** because Scala does not support infinite types:\n\n```scala\ncase class Tree(value: Int, children: List[Tree])\n\n// This will FAIL at compile-time:\nval structural = Schema.derived[Tree].structural\n// Compile error: Cannot generate infinite structural type\n\n// The structural type would need to be:\n// { def value: Int; def children: List[{ def value: Int; def children: List[...] }] }\n// which is infinite and unsupported\n```\n\nThe macro must detect recursive types and produce a helpful error message:\n\n```\nCompile error: Cannot generate structural type for recursive type Tree.\nStructural types cannot represent recursive structures.\n```\n\n### 3. Mutually Recursive Types\n\nSimilarly, mutually recursive types are unsupported:\n\n```scala\ncase class Node(id: Int, edges: List[Edge])\ncase class Edge(from: Int, to: Node)\n\n// This will FAIL at compile-time:\nval nodeStructural = Schema.derived[Node].structural\n// Compile error: Cannot generate structural type for mutually recursive types\n```\n\n### 4. Sum Types in Scala 2\n\nSealed traits and sum types **cannot be converted to structural types in Scala 2** because they require union types:\n\n```scala\n// Scala 2\nsealed trait Result\ncase class Success(value: Int) extends Result\ncase class Failure(error: String) extends Result\n\n// This will FAIL at compile-time in Scala 2:\nval structural = Schema.derived[Result].structural\n// Compile error: Cannot generate structural type for sum types in Scala 2.\n// Union types are required, which are only available in Scala 3.\n```\n\nThe macro must detect sum types in Scala 2 and produce a clear error.\n\n### 5. Case Objects\n\nCase objects become empty structural types:\n\n```scala\ncase object Singleton\n\nval structural = Schema.derived[Singleton.type].structural\n// Type: Schema[{}]\n```\n\nFor sum types with case objects (Scala 3):\n\n```scala\nsealed trait Status\ncase object Active extends Status\ncase object Inactive extends Status\n\nval structural = Schema.derived[Status].structural\n// Type: Schema[{} | {}]\n// Not particularly useful, but valid\n```\n\n### 6. Structural Types as Source\n\nDeriving schemas directly for structural types is supported:\n\n```scala\ntype PersonStructure = { def name: String; def age: Int }\n\nval schema = Schema.derived[PersonStructure]\n// Should work if structural type derivation is implemented\n```\n\nThe schema's bindings will use `Selectable` (Scala 3) or `Dynamic` (Scala 2) to construct and deconstruct values.\n\n---\n\n## Integration with Into/As\n\nStructural schemas compose naturally with `Into`/`As` conversions.\n\n### Nominal  Structural\n\n```scala\ncase class Person(name: String, age: Int)\n\n// Auto-derived conversion\nval nominalToStructural: Into[Person, { def name: String; def age: Int }] = \n  Into.derived\n\nval person = Person(\"Alice\", 30)\nval structural = nominalToStructural.into(person)\n// => Right(<Selectable/Dynamic instance>)\n```\n\n### Structural  Nominal\n\n```scala\ntype PersonStructure = { def name: String; def age: Int }\ncase class Person(name: String, age: Int)\n\n// Auto-derived conversion\nval structuralToNominal: Into[PersonStructure, Person] = \n  Into.derived\n\nval structural: PersonStructure = new Selectable {\n  def selectDynamic(field: String): Any = field match {\n    case \"name\" => \"Bob\"\n    case \"age\" => 25\n  }\n}\n\nval person = structuralToNominal.into(structural)\n// => Right(Person(\"Bob\", 25))\n```\n\n### Bidirectional (As)\n\n```scala\ncase class Person(name: String, age: Int)\n\n// Bidirectional conversion\nval personAs: As[Person, { def name: String; def age: Int }] = \n  As.derived\n\n// Nominal  Structural\nval structural = personAs.into(Person(\"Alice\", 30))\n\n// Structural  Nominal\nval nominal = structural.flatMap(personAs.from)\n// Round-trip successful\n```\n\n### Schema-Guided Conversion\n\n```scala\ncase class PersonV1(firstName: String, lastName: String, age: Int)\ncase class PersonV2(name: String, age: Int)\n\n// Use structural type as intermediary\ntype PersonStructure = { def name: String; def age: Int }\n\n// Step 1: Transform V1 to structural (custom logic)\nval v1ToStructural: Into[PersonV1, PersonStructure] = \n  new Into[PersonV1, PersonStructure] {\n    def into(v1: PersonV1): Either[SchemaError, PersonStructure] = {\n      Right(new Selectable {\n        def selectDynamic(field: String): Any = field match {\n          case \"name\" => s\"${v1.firstName} ${v1.lastName}\"\n          case \"age\" => v1.age\n        }\n      })\n    }\n  }\n\n// Step 2: Auto-convert structural to V2\nval structuralToV2: Into[PersonStructure, PersonV2] = Into.derived\n\n// Composed migration\ndef migrate(v1: PersonV1): Either[SchemaError, PersonV2] = {\n  v1ToStructural.into(v1).flatMap(structuralToV2.into)\n}\n```\n\n---\n\n## Testing Requirements\n\n### Test Matrix\n\n1. **Direct Structural Derivation**\n   - Simple products (case classes)\n   - Nested products\n   - Collections (List, Vector, Set, Map, Option, Either)\n   - Tuples (2-22 elements)\n   - Empty case classes\n   - Single-field case classes\n   - Large products (20+ fields)\n   - Case objects\n\n2. **Nominal to Structural Conversion**\n   - Case class  structural\n   - Tuple  structural\n   - Nested case classes  nested structural\n   - Case class with collections  structural with collections\n   - Empty case class  empty structural\n\n3. **Sum Types (Scala 3 Only)**\n   - Sealed trait  union type structural\n   - Sealed trait with case objects\n   - Enum  union type structural\n   - Nested sum types\n\n4. **Type Name Generation**\n   - Simple product normalized name\n   - Nested product normalized name\n   - Name determinism (same structure = same name)\n   - Alphabetical field ordering in names\n   - Union type names (Scala 3)\n\n5. **Selectable/Dynamic Implementation**\n   - Scala 3 Selectable field access\n   - Scala 2 Dynamic field access\n   - Field access correctness\n   - Missing field behavior\n   - Extra field behavior\n\n6. **Integration with Into/As**\n   - Nominal  Structural via Into\n   - Structural  Nominal via Into\n   - Round-trip via As\n   - Composed conversions with structural intermediary\n\n7. **Error Cases (Compile-Time)**\n   - Recursive types produce error\n   - Mutually recursive types produce error\n   - Sum types in Scala 2 produce error\n   - Unsupported types produce helpful errors\n\n8. **Generic Types** (if supported by existing Schema derivation)\n   - Fully applied generic  structural\n   - Generic with nested structural fields\n\n### Scala 2 vs Scala 3 Test Separation\n\n```\nsrc/test/scala/\n  structural/\n    common/\n      SimpleProductSpec.scala\n      NestedProductSpec.scala\n      CollectionsSpec.scala\n      TuplesSpec.scala\n      EmptyProductSpec.scala\n      SingleFieldSpec.scala\n      LargeProductSpec.scala\n      TypeNameNormalizationSpec.scala\n      IntoIntegrationSpec.scala\n      AsIntegrationSpec.scala\n      \n    scala3/\n      UnionTypesSpec.scala\n      SealedTraitToUnionSpec.scala\n      EnumToUnionSpec.scala\n      SelectableImplementationSpec.scala\n      \n    scala2/\n      DynamicImplementationSpec.scala\n      SumTypeErrorSpec.scala (verifies compile error)\n      \n    errors/\n      RecursiveTypeErrorSpec.scala\n      MutualRecursionErrorSpec.scala\n      UnsupportedTypeErrorSpec.scala\n```\n\n### Test Examples\n\n```scala\n// Test: Simple product to structural\ntest(\"case class converts to structural schema\") {\n  case class Person(name: String, age: Int)\n  \n  val structural = Schema.derived[Person].structural\n  \n  // Type check (this is a compile-time test)\n  val _: Schema[{ def name: String; def age: Int }] = structural\n  \n  assert(structural.typeName.toString.contains(\"name\"))\n  assert(structural.typeName.toString.contains(\"age\"))\n}\n\n// Test: Nested products\ntest(\"nested case classes convert to nested structural\") {\n  case class Address(street: String, zip: Int)\n  case class Person(name: String, address: Address)\n  \n  val structural = Schema.derived[Person].structural\n  \n  val _: Schema[{ \n    def name: String\n    def address: { def street: String; def zip: Int }\n  }] = structural\n}\n\n// Test: Tuple to structural\ntest(\"tuple converts to structural with _N fields\") {\n  val structural = Schema.derived[(String, Int, Boolean)].structural\n  \n  val _: Schema[{ def _1: String; def _2: Int; def _3: Boolean }] = structural\n}\n\n// Test: Union type (Scala 3 only)\ntest(\"sealed trait converts to union type structural\") {\n  sealed trait Result\n  case class Success(value: Int) extends Result\n  case class Failure(error: String) extends Result\n  \n  val structural = Schema.derived[Result].structural\n  \n  val _: Schema[{ def value: Int } | { def error: String }] = structural\n}\n\n// Test: Type name normalization\ntest(\"structural type names are normalized and deterministic\") {\n  case class Person(name: String, age: Int)\n  case class User(age: Int, name: String) // Different field order\n  \n  val personStructural = Schema.derived[Person].structural\n  val userStructural = Schema.derived[User].structural\n  \n  // Same structure, same normalized name\n  assert(personStructural.typeName == userStructural.typeName)\n  \n  // Alphabetical ordering\n  assert(personStructural.typeName.toString.contains(\"age\"))\n  assert(personStructural.typeName.toString.indexOf(\"age\") < \n         personStructural.typeName.toString.indexOf(\"name\"))\n}\n\n// Test: Integration with Into\ntest(\"structural to nominal conversion via Into\") {\n  case class Person(name: String, age: Int)\n  type PersonStructure = { def name: String; def age: Int }\n  \n  val structural: PersonStructure = new Selectable {\n    def selectDynamic(field: String): Any = field match {\n      case \"name\" => \"Alice\"\n      case \"age\" => 30\n    }\n  }\n  \n  val person = Into[PersonStructure, Person].into(structural)\n  assert(person == Right(Person(\"Alice\", 30)))\n}\n\n// Test: Round-trip via As\ntest(\"nominal to structural and back preserves data\") {\n  case class Person(name: String, age: Int)\n  type PersonStructure = { def name: String; def age: Int }\n  \n  val original = Person(\"Alice\", 30)\n  \n  val toStructural = As[Person, PersonStructure].into(original)\n  val backToNominal = toStructural.flatMap(As[Person, PersonStructure].from)\n  \n  assert(backToNominal == Right(original))\n}\n\n// Test: Recursive type compile error\ntest(\"recursive types produce compile error\") {\n  case class Tree(value: Int, children: List[Tree])\n  \n  assertDoesNotCompile(\"Schema.derived[Tree].structural\")\n}\n\n// Test: Sum type in Scala 2 compile error\ntest(\"sum types in Scala 2 produce compile error\") {\n  sealed trait Result\n  case class Success(value: Int) extends Result\n  \n  // Scala 2 only\n  assertDoesNotCompile(\"Schema.derived[Result].structural\")\n}\n```\n\n---\n\n## Implementation Notes\n\n### Macro Behavior\n\nThe macro must:\n\n1. **Detect product types** (case classes, tuples) and generate structural types with `def` members\n2. **Detect sum types** (sealed traits, enums) and:\n   - In Scala 3: Generate union types of structural representations\n   - In Scala 2: Fail with clear error message\n3. **Detect recursive types** and fail with clear error message\n4. **Normalize structural type representations** for type name generation\n5. **Generate `ToStructural` instance** with:\n   - `StructuralType` type member set to the generated structural type\n   - `apply` method that transforms the schema appropriately\n6. **Preserve field metadata** from original schema where applicable\n7. **Generate appropriate bindings** using `Selectable` (Scala 3) or `Dynamic` (Scala 2)\n\n### Schema Transformation\n\nWhen converting `Schema[A]` to `Schema[StructuralType]`:\n\n1. **Preserve field information**: Field names, types, optional/required status\n2. **Update type name**: Use normalized structural representation\n3. **Transform bindings**: Replace nominal constructors/deconstructors with structural equivalents\n4. **Preserve validation**: Maintain any validation logic that applies to field values\n5. **Handle nested schemas**: Recursively transform nested product types\n\n### Error Messages\n\nProvide clear compile-time errors:\n\n```scala\n// Recursive type\ncase class Tree(value: Int, children: List[Tree])\nSchema.derived[Tree].structural\n\n// Error:\n\"\"\"\nCannot generate structural type for recursive type Tree.\nStructural types cannot represent recursive structures.\nScala's type system does not support infinite types.\n\"\"\"\n\n// Sum type in Scala 2\nsealed trait Result\ncase class Success(value: Int) extends Result\nSchema.derived[Result].structural\n\n// Error (Scala 2 only):\n\"\"\"\nCannot generate structural type for sum type Result.\nStructural representation of sum types requires union types,\nwhich are only available in Scala 3.\nConsider upgrading to Scala 3 or using a different approach.\n\"\"\"\n```\n\n---\n\n## Deliverables\n\n1.  `ToStructural[A]` trait and macro for Scala 2.13\n2.  `ToStructural[A]` trait and macro for Scala 3.5\n3.  `structural` method on `Schema[A]`\n4.  Support for product types (case classes, tuples)\n5.  Support for sum types (sealed traits, enums) in Scala 3 only\n6.  Normalized type name generation\n7.  `Selectable` bindings (Scala 3) and `Dynamic` bindings (Scala 2)\n8.  Integration with `Into`/`As` for structural  nominal conversions\n9.  Comprehensive test suite (300+ test cases)\n10.  Clear error messages for unsupported cases\n11.  Documentation with examples",
              "url": "https://github.com/zio/zio-blocks/issues/517",
              "tech": [],
              "repo_name": "zio-blocks",
              "repo_owner": "zio",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "ZIO#471",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "ZIO",
              "id": "generated-ZIO",
              "name": "ZIO",
              "description": "",
              "members": [],
              "display_name": "ZIO",
              "created_at": "2026-01-24T11:31:19.567Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/ZIO?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "zio",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-24T11:31:19.567Z",
            "created_at": "2026-01-24T11:31:19.567Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-ZIO#471",
              "status": "open",
              "type": "issue",
              "number": 471,
              "title": "Replace TypeName by TypeId & Macro Derivation",
              "source": {
                "data": {
                  "id": "source-ZIO#471",
                  "user": {
                    "login": "jdegoes",
                    "id": 156745,
                    "node_id": "MDQ6VXNlcjE1Njc0NQ==",
                    "avatar_url": "https://avatars.githubusercontent.com/u/156745?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/jdegoes",
                    "html_url": "https://github.com/jdegoes",
                    "followers_url": "https://api.github.com/users/jdegoes/followers",
                    "following_url": "https://api.github.com/users/jdegoes/following{/other_user}",
                    "gists_url": "https://api.github.com/users/jdegoes/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/jdegoes/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/jdegoes/subscriptions",
                    "organizations_url": "https://api.github.com/users/jdegoes/orgs",
                    "repos_url": "https://api.github.com/users/jdegoes/repos",
                    "events_url": "https://api.github.com/users/jdegoes/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/jdegoes/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Replace TypeName by TypeId & Macro Derivation",
                  "body": "# Design and Implement `TypeId` for Type Registry\n\n## Goal\n\nDesign and implement a `TypeId[A]` data structure that can faithfully represent any Scala type or type constructor, capturing sufficient metadata to support:\n\n- **Type identity**: Uniquely identifying types across serialization boundaries\n- **Subtype checking**: Implementing `isSubtypeOf` directly on `TypeId` without runtime reflection\n- **Type equality**: Determining structural and nominal type equivalence\n- **Map/Set keys**: Using `TypeId` as keys in type registries (requires correct `equals`/`hashCode`)\n- **Macro derivation**: Derivation of `TypeId` for any type or type constructor, source-compatible across Scala 2/3\n\nThe data type must be used to wholly replace `TypeName` in the source code of ZIO Blocks.\n\n## Requirements\n\n### API Surface\n```scala\n// Explicit derivation\nval stringId: TypeId[String] = TypeId.of[String]\nval listId: TypeId[List] = TypeId.of[List]  // Type constructors supported\n\n// Implicit derivation for generic code\ndef process[A](value: A)(implicit typeId: TypeId[A]): Unit = ???\n\n// Or using Scala 3 context bounds\ndef process[A: TypeId](value: A): Unit = ???\n\n// Use as map keys in type registries\nval registry: Map[TypeId[_], Binding[_]] = Map(\n  TypeId.of[String] -> stringBinding,\n  TypeId.of[List[Int]] -> listIntBinding\n)\n```\n\n### Cross-Version Support\n\n- **Scala 2.13**: Use `scala.reflect.macros` for compile-time derivation\n- **Scala 3.x (3.03.7+)**: Use `scala.quoted` macros\n\nThe runtime data model (`TypeId`, `TypeRepr`, etc.) should be shared across versions. Only the macro implementations differ.\n\n### Equals and HashCode Contract\n\n`TypeId` instances will be used as keys in `Map` and `Set` collections within type registries. The `equals` and `hashCode` implementations must satisfy the following requirements:\n\n#### Equality Semantics\n\n1. **Nominal identity for non-aliases**: Two `TypeId` instances referring to the same nominal type (same `fullName`) are equal, regardless of when/where the macro derived them.\n\n2. **Type alias transparency**: Type aliases should be equal to their underlying types after normalization.\n```scala\n   type Age = Int\n   TypeId.of[Age] == TypeId.of[Int]  // true (after normalization)\n```\n\n3. **Opaque type nominality**: Opaque types are *not* equal to their representation or to other opaque types.\n```scala\n   opaque type Email = String\n   opaque type UserId = String\n   TypeId.of[Email] == TypeId.of[String]  // false\n   TypeId.of[Email] == TypeId.of[UserId]  // false\n```\n\n4. **Applied types**: Two applied types are equal iff their type constructors are equal and all type arguments are equal.\n```scala\n   TypeId.of[List[Int]] == TypeId.of[List[Int]]      // true\n   TypeId.of[List[Int]] == TypeId.of[List[String]]  // false\n```\n\n5. **Structural types**: Two structural types are equal iff they have the same members (by name and type).\n\n6. **Compound types**: Order matters for intersections and unions (or they must be normalized to a canonical order).\n```scala\n   // Option A: Order-sensitive\n   TypeId.of[A & B] != TypeId.of[B & A]\n   \n   // Option B: Canonicalized (preferred)\n   TypeId.of[A & B] == TypeId.of[B & A]  // after sorting components\n```\n\n#### HashCode Requirements\n\n1. **Consistency**: `hashCode` must be consistent with `equals`equal objects must have equal hash codes.\n\n2. **Stability**: The same `TypeId` derived in different compilation units or at different times must produce the same `hashCode`.\n\n3. **Distribution**: Hash codes should be well-distributed to avoid collisions in hash maps.\n\n4. **Determinism**: `hashCode` must not depend on object identity, memory addresses, or other non-deterministic factors.\n\n#### Implementation Approach\n```scala\nsealed trait TypeId[A <: AnyKind] {\n  // ... other members ...\n\n  /** \n   * Equality based on normalized type structure.\n   * Type aliases are expanded before comparison.\n   */\n  override def equals(other: Any): Boolean = other match {\n    case that: TypeId[_] => TypeId.structurallyEqual(this, that)\n    case _ => false\n  }\n\n  /**\n   * Hash code based on normalized type structure.\n   * Must be consistent with equals.\n   */\n  override def hashCode(): Int = TypeId.structuralHash(this)\n}\n\nobject TypeId {\n  /**\n   * Compare two TypeIds for structural equality after normalization.\n   */\n  def structurallyEqual(a: TypeId[_], b: TypeId[_]): Boolean = {\n    // 1. Normalize both (expand aliases)\n    // 2. Compare structure recursively\n    // 3. For opaque types, compare by fullName only (nominal)\n    ???\n  }\n\n  /**\n   * Compute a stable hash code for a TypeId.\n   */\n  def structuralHash(id: TypeId[_]): Int = {\n    // 1. Normalize (expand aliases)\n    // 2. Compute hash from structural components\n    // 3. Must use stable values (fullName, not object identity)\n    ???\n  }\n}\n```\n\n#### Edge Cases\n\n- **Recursive types**: Must handle cycles without infinite loops in both `equals` and `hashCode`.\n- **Type parameters**: `TypeId.of[List]` (unapplied) must have different hash than `TypeId.of[List[Int]]` (applied).\n- **Path-dependent types**: `a.T` and `b.T` are equal only if `a` and `b` are the same stable path.\n- **Local types**: Types defined in local scopes need unique identification (e.g., include source location or synthetic index).\n\n### Key Operations\n```scala\ntrait TypeId[A <: AnyKind] {\n  def name: String\n  def fullName: String\n  def owner: Owner\n  def typeParams: List[TypeParam]\n  def parents: List[TypeRepr]\n  \n  // Core operations\n  def isSubtypeOf(other: TypeId[_]): Boolean\n  def isSupertypeOf(other: TypeId[_]): Boolean\n  def isEquivalentTo(other: TypeId[_]): Boolean\n  \n  // Equality (for use as map keys)\n  override def equals(other: Any): Boolean\n  override def hashCode(): Int\n}\n```\n\n## Attached Design Document\n\nSee the attached `TypeId-DataModel.md` for a comprehensive sketch of:\n\n- Core data structures (`TypeId`, `TypeRepr`, `TypeParam`, `Owner`, etc.)\n- Type expression representation (applied types, intersections, unions, match types, etc.)\n- Variance and bounds modeling\n- Substitution and normalization algorithms\n- Standard library type definitions\n\n> [!WARNING]\n> **The attached document is a design sketch, not production code.** Some details may be incorrect, incomplete, or require adjustment during implementation. It should be treated as a starting point for discussion and iteration, not a specification to implement verbatim.\n\n## Test Strategy\n\nComprehensive testing should validate four layers: **macro derivation correctness**, **data model completeness**, **type operation correctness**, and **equals/hashCode correctness**.\n\n### 1. Equals and HashCode Tests\n\nThese tests are critical since `TypeId` will be used as map keys.\n\n#### Basic Contract Tests\n```scala\ntest(\"equals is reflexive\") {\n  val id = TypeId.of[String]\n  assertTrue(id == id)\n  assertTrue(id.equals(id))\n}\n\ntest(\"equals is symmetric\") {\n  val id1 = TypeId.of[String]\n  val id2 = TypeId.of[String]\n  assertTrue(id1 == id2)\n  assertTrue(id2 == id1)\n}\n\ntest(\"equals is transitive\") {\n  val id1 = TypeId.of[String]\n  val id2 = TypeId.of[String]\n  val id3 = TypeId.of[String]\n  assertTrue(id1 == id2)\n  assertTrue(id2 == id3)\n  assertTrue(id1 == id3)\n}\n\ntest(\"hashCode is consistent with equals\") {\n  val id1 = TypeId.of[String]\n  val id2 = TypeId.of[String]\n  assertTrue(id1 == id2)\n  assertTrue(id1.hashCode == id2.hashCode)\n}\n\ntest(\"hashCode is stable across invocations\") {\n  val id = TypeId.of[List[Int]]\n  val hash1 = id.hashCode\n  val hash2 = id.hashCode\n  assertTrue(hash1 == hash2)\n}\n```\n\n#### Nominal Type Equality\n```scala\ntest(\"same nominal types are equal\") {\n  assertTrue(TypeId.of[String] == TypeId.of[String])\n  assertTrue(TypeId.of[Int] == TypeId.of[Int])\n  assertTrue(TypeId.of[List[Int]] == TypeId.of[List[Int]])\n}\n\ntest(\"different nominal types are not equal\") {\n  assertTrue(TypeId.of[String] != TypeId.of[Int])\n  assertTrue(TypeId.of[List[Int]] != TypeId.of[List[String]])\n  assertTrue(TypeId.of[List[Int]] != TypeId.of[Vector[Int]])\n}\n```\n\n#### Type Alias Equality\n```scala\ntest(\"type aliases equal their underlying types\") {\n  type Age = Int\n  type Name = String\n  \n  assertTrue(TypeId.of[Age] == TypeId.of[Int])\n  assertTrue(TypeId.of[Name] == TypeId.of[String])\n  assertTrue(TypeId.of[Age].hashCode == TypeId.of[Int].hashCode)\n}\n\ntest(\"chained type aliases resolve correctly\") {\n  type A = Int\n  type B = A\n  type C = B\n  \n  assertTrue(TypeId.of[C] == TypeId.of[Int])\n  assertTrue(TypeId.of[C] == TypeId.of[A])\n  assertTrue(TypeId.of[C] == TypeId.of[B])\n}\n\ntest(\"generic type aliases equal their expansion\") {\n  type MyList[A] = List[A]\n  \n  assertTrue(TypeId.of[MyList[Int]] == TypeId.of[List[Int]])\n  assertTrue(TypeId.of[MyList[String]] == TypeId.of[List[String]])\n}\n```\n\n#### Opaque Type Equality\n```scala\ntest(\"opaque types are not equal to their representation\") {\n  opaque type Email = String\n  \n  assertTrue(TypeId.of[Email] != TypeId.of[String])\n  assertTrue(TypeId.of[Email].hashCode != TypeId.of[String].hashCode) // likely but not guaranteed\n}\n\ntest(\"different opaque types are not equal even with same representation\") {\n  opaque type Email = String\n  opaque type UserId = String\n  \n  assertTrue(TypeId.of[Email] != TypeId.of[UserId])\n}\n\ntest(\"same opaque type is equal to itself\") {\n  opaque type Email = String\n  \n  assertTrue(TypeId.of[Email] == TypeId.of[Email])\n}\n```\n\n#### Applied Type Equality\n```scala\ntest(\"applied types with same constructor and args are equal\") {\n  assertTrue(TypeId.of[List[Int]] == TypeId.of[List[Int]])\n  assertTrue(TypeId.of[Map[String, Int]] == TypeId.of[Map[String, Int]])\n  assertTrue(TypeId.of[Either[String, Int]] == TypeId.of[Either[String, Int]])\n}\n\ntest(\"applied types with different args are not equal\") {\n  assertTrue(TypeId.of[List[Int]] != TypeId.of[List[String]])\n  assertTrue(TypeId.of[Map[String, Int]] != TypeId.of[Map[Int, String]])\n}\n\ntest(\"unapplied type constructor not equal to applied type\") {\n  assertTrue(TypeId.of[List] != TypeId.of[List[Int]])\n  assertTrue(TypeId.of[Map] != TypeId.of[Map[String, Int]])\n}\n```\n\n#### Compound Type Equality\n```scala\ntest(\"intersection types equality\") {\n  // Assuming canonicalized ordering\n  assertTrue(TypeId.of[Serializable & Comparable[String]] == TypeId.of[Serializable & Comparable[String]])\n}\n\ntest(\"union types equality\") {\n  assertTrue(TypeId.of[Int | String] == TypeId.of[Int | String])\n}\n```\n\n#### Map/Set Usage Tests\n```scala\ntest(\"TypeId works as Map key\") {\n  val map = Map[TypeId[_], String](\n    TypeId.of[String] -> \"string\",\n    TypeId.of[Int] -> \"int\",\n    TypeId.of[List[Int]] -> \"list-int\"\n  )\n  \n  assertTrue(map(TypeId.of[String]) == \"string\")\n  assertTrue(map(TypeId.of[Int]) == \"int\")\n  assertTrue(map(TypeId.of[List[Int]]) == \"list-int\")\n  assertTrue(map.get(TypeId.of[Double]).isEmpty)\n}\n\ntest(\"TypeId works as Map key with type aliases\") {\n  type Age = Int\n  \n  val map = Map[TypeId[_], String](\n    TypeId.of[Int] -> \"int\"\n  )\n  \n  // Should find the entry via alias\n  assertTrue(map(TypeId.of[Age]) == \"int\")\n}\n\ntest(\"TypeId works in Set\") {\n  val set = Set(\n    TypeId.of[String],\n    TypeId.of[Int],\n    TypeId.of[List[Int]]\n  )\n  \n  assertTrue(set.contains(TypeId.of[String]))\n  assertTrue(set.contains(TypeId.of[Int]))\n  assertTrue(!set.contains(TypeId.of[Double]))\n}\n\ntest(\"TypeId deduplication in Set\") {\n  type Age = Int\n  \n  val set = Set(\n    TypeId.of[Int],\n    TypeId.of[Age]  // Should deduplicate\n  )\n  \n  assertTrue(set.size == 1)\n}\n\ntest(\"mutable HashMap works with TypeId\") {\n  val map = scala.collection.mutable.HashMap[TypeId[_], String]()\n  \n  map(TypeId.of[String]) = \"string\"\n  map(TypeId.of[Int]) = \"int\"\n  \n  assertTrue(map(TypeId.of[String]) == \"string\")\n  \n  // Update via equal key\n  type Name = String\n  map(TypeId.of[Name]) = \"updated\"\n  assertTrue(map(TypeId.of[String]) == \"updated\")\n}\n```\n\n#### Cross-Compilation Equality\n```scala\ntest(\"TypeId equality is stable across compilation units\") {\n  // id1 derived in CompilationUnitA\n  val id1 = CompilationUnitA.stringTypeId\n  // id2 derived in CompilationUnitB  \n  val id2 = CompilationUnitB.stringTypeId\n  \n  assertTrue(id1 == id2)\n  assertTrue(id1.hashCode == id2.hashCode)\n}\n```\n\n### 2. Macro Derivation Tests\n\nVerify that the macro correctly captures type information for all supported type forms.\n\n#### Primitive and Basic Types\n```scala\ntest(\"derives primitives correctly\") {\n  assertTrue(TypeId.of[Int].name == \"Int\")\n  assertTrue(TypeId.of[String].fullName == \"java.lang.String\")\n  assertTrue(TypeId.of[Unit].isValueClass)\n}\n```\n\n#### Generic Types and Type Constructors\n```scala\ntest(\"derives type constructors\") {\n  val listId = TypeId.of[List]\n  assertTrue(listId.arity == 1)\n  assertTrue(listId.typeParams.head.variance == Variance.Covariant)\n}\n\ntest(\"derives applied types\") {\n  val listIntId = TypeId.of[List[Int]]\n  // Should capture that this is List applied to Int\n}\n\ntest(\"derives higher-kinded types\") {\n  val functorId = TypeId.of[Functor]  // Functor[F[_]]\n  assertTrue(functorId.typeParams.head.kind == Kind.`* -> *`)\n}\n```\n\n#### Type Aliases and Opaque Types\n```scala\ntype Age = Int\nopaque type Email = String\n\ntest(\"derives type aliases\") {\n  val ageId = TypeId.of[Age]\n  assertTrue(ageId.isAlias)\n  assertTrue(ageId.aliasedTo == Some(TypeRepr.Ref(TypeId.of[Int])))\n}\n\ntest(\"derives opaque types\") {\n  val emailId = TypeId.of[Email]\n  assertTrue(emailId.isOpaque)\n  // Representation should be captured\n}\n```\n\n#### Classes, Traits, Objects, Enums\n```scala\nsealed trait Animal\ncase class Dog(name: String) extends Animal\ncase object Cat extends Animal\n\nenum Color { case Red, Green, Blue, RGB(r: Int, g: Int, b: Int) }\n\ntest(\"derives sealed hierarchy\") {\n  val animalId = TypeId.of[Animal]\n  assertTrue(animalId.isSealed)\n  assertTrue(animalId.defKind match {\n    case TypeDefKind.Trait(true, subtypes) => subtypes.nonEmpty\n    case _ => false\n  })\n}\n\ntest(\"derives enums with cases\") {\n  val colorId = TypeId.of[Color]\n  assertTrue(colorId.enumCases.map(_.name) == List(\"Red\", \"Green\", \"Blue\", \"RGB\"))\n  assertTrue(colorId.enumCases.find(_.name == \"RGB\").exists(_.params.nonEmpty))\n}\n```\n\n#### Structural and Refinement Types\n```scala\ntest(\"derives structural types\") {\n  type Sized = { def size: Int }\n  val sizedId = TypeId.of[Sized]\n  // Should capture the structural member\n}\n```\n\n#### Compound Types\n```scala\ntest(\"derives intersection types\") {\n  val id = TypeId.of[String & Serializable]\n  // Should capture both components\n}\n\ntest(\"derives union types\") {\n  val id = TypeId.of[String | Int]\n  // Should capture both components\n}\n```\n\n#### Tuple Types (Including Named Tuples for Scala 3.5+)\n```scala\ntest(\"derives positional tuples\") {\n  val id = TypeId.of[(Int, String, Boolean)]\n  // Should capture element types\n}\n\ntest(\"derives named tuples\") {  // Scala 3.5+\n  val id = TypeId.of[(name: String, age: Int)]\n  // Should capture labels and types\n}\n```\n\n#### Function Types\n```scala\ntest(\"derives function types\") {\n  val id = TypeId.of[(Int, String) => Boolean]\n  // Should capture param types and result type\n}\n\ntest(\"derives context function types\") {  // Scala 3\n  val id = TypeId.of[(Int, String) ?=> Boolean]\n}\n\ntest(\"derives polymorphic function types\") {  // Scala 3\n  val id = TypeId.of[[A] => A => A]\n}\n```\n\n#### Path-Dependent and Singleton Types\n```scala\nobject Outer {\n  object Inner {\n    type T = Int\n  }\n  val inner: Inner.type = Inner\n}\n\ntest(\"derives path-dependent types\") {\n  val id = TypeId.of[Outer.Inner.T]\n  // Should capture the path\n}\n\ntest(\"derives singleton types\") {\n  val id = TypeId.of[Outer.Inner.type]\n}\n```\n\n#### Match Types (Scala 3)\n```scala\ntype Elem[X] = X match {\n  case String => Char\n  case Array[t] => t\n}\n\ntest(\"derives match types\") {\n  val id = TypeId.of[Elem]\n  // Should capture scrutinee, cases, and binders\n}\n```\n\n### 3. Data Model Completeness Tests\n\nVerify that round-tripping through the model preserves type information.\n```scala\ntest(\"TypeRepr substitution is correct\") {\n  val A = TypeParam(\"A\", 0)\n  val listOfA = TypeRepr.Applied(TypeRepr.Ref(listId), List(TypeRepr.ParamRef(A)))\n  val substituted = listOfA.substitute(Map(A -> TypeRepr.Ref(intId)))\n  assertTrue(substituted == TypeRepr.Applied(TypeRepr.Ref(listId), List(TypeRepr.Ref(intId))))\n}\n\ntest(\"normalization expands aliases\") {\n  type MyInt = Int\n  val myIntRepr = TypeRepr.Ref(TypeId.of[MyInt])\n  val normalized = TypeNormalization.normalize(myIntRepr)\n  assertTrue(normalized == TypeRepr.Ref(TypeId.of[Int]))\n}\n```\n\n### 4. Subtyping Tests\n\nVerify that `isSubtypeOf` correctly implements Scala's subtyping rules.\n\n#### Basic Subtyping\n```scala\ntest(\"Nothing is subtype of everything\") {\n  assertTrue(TypeId.of[Nothing].isSubtypeOf(TypeId.of[Int]))\n  assertTrue(TypeId.of[Nothing].isSubtypeOf(TypeId.of[String]))\n  assertTrue(TypeId.of[Nothing].isSubtypeOf(TypeId.of[Any]))\n}\n\ntest(\"everything is subtype of Any\") {\n  assertTrue(TypeId.of[Int].isSubtypeOf(TypeId.of[Any]))\n  assertTrue(TypeId.of[String].isSubtypeOf(TypeId.of[Any]))\n  assertTrue(TypeId.of[List[Int]].isSubtypeOf(TypeId.of[Any]))\n}\n\ntest(\"reflexivity\") {\n  assertTrue(TypeId.of[String].isSubtypeOf(TypeId.of[String]))\n  assertTrue(TypeId.of[List[Int]].isSubtypeOf(TypeId.of[List[Int]]))\n}\n```\n\n#### Variance-Aware Subtyping\n```scala\ntest(\"covariant type parameter subtyping\") {\n  // List is covariant: List[Dog] <: List[Animal]\n  assertTrue(TypeId.of[List[Dog]].isSubtypeOf(TypeId.of[List[Animal]]))\n  assertTrue(!TypeId.of[List[Animal]].isSubtypeOf(TypeId.of[List[Dog]]))\n}\n\ntest(\"contravariant type parameter subtyping\") {\n  // Function1 is contravariant in input: (Animal => Int) <: (Dog => Int)\n  assertTrue(TypeId.of[Animal => Int].isSubtypeOf(TypeId.of[Dog => Int]))\n  assertTrue(!TypeId.of[Dog => Int].isSubtypeOf(TypeId.of[Animal => Int]))\n}\n\ntest(\"invariant type parameter subtyping\") {\n  // Array is invariant\n  assertTrue(!TypeId.of[Array[Dog]].isSubtypeOf(TypeId.of[Array[Animal]]))\n  assertTrue(!TypeId.of[Array[Animal]].isSubtypeOf(TypeId.of[Array[Dog]]))\n}\n```\n\n#### Union and Intersection Types\n```scala\ntest(\"union type subtyping\") {\n  // A <: A | B and B <: A | B\n  assertTrue(TypeId.of[Int].isSubtypeOf(TypeId.of[Int | String]))\n  assertTrue(TypeId.of[String].isSubtypeOf(TypeId.of[Int | String]))\n  \n  // A | B <: C requires both A <: C and B <: C\n  assertTrue(!TypeId.of[Int | String].isSubtypeOf(TypeId.of[Int]))\n}\n\ntest(\"intersection type subtyping\") {\n  // A & B <: A and A & B <: B\n  assertTrue(TypeId.of[Serializable & Comparable[String]].isSubtypeOf(TypeId.of[Serializable]))\n  \n  // A <: B & C requires A <: B and A <: C\n}\n```\n\n#### Nominal Hierarchy Subtyping\n```scala\ntest(\"class hierarchy subtyping\") {\n  assertTrue(TypeId.of[Dog].isSubtypeOf(TypeId.of[Animal]))\n  assertTrue(TypeId.of[String].isSubtypeOf(TypeId.of[CharSequence]))\n}\n```\n\n#### Type Alias Transparency\n```scala\ntest(\"type aliases are transparent for subtyping\") {\n  type Age = Int\n  assertTrue(TypeId.of[Age].isSubtypeOf(TypeId.of[Int]))\n  assertTrue(TypeId.of[Int].isSubtypeOf(TypeId.of[Age]))\n  assertTrue(TypeId.of[Age].isEquivalentTo(TypeId.of[Int]))\n}\n```\n\n#### Opaque Type Nominality\n```scala\ntest(\"opaque types are nominally distinct\") {\n  opaque type Email = String\n  opaque type UserId = String\n  \n  assertTrue(!TypeId.of[Email].isSubtypeOf(TypeId.of[String]))  // Outside defining scope\n  assertTrue(!TypeId.of[Email].isSubtypeOf(TypeId.of[UserId]))\n}\n```\n\n### 5. Edge Cases and Regression Tests\n```scala\ntest(\"handles recursive types\") {\n  enum Tree[+A] {\n    case Leaf(value: A)\n    case Branch(left: Tree[A], right: Tree[A])\n  }\n  val treeId = TypeId.of[Tree]\n  // Should not stack overflow on equals/hashCode\n  val hash = treeId.hashCode  // Must terminate\n  assertTrue(treeId == treeId)    // Must terminate\n}\n\ntest(\"handles deeply nested generics\") {\n  val id = TypeId.of[List[Map[String, Option[Either[Int, List[String]]]]]]\n  // Should capture full structure\n  val hash = id.hashCode\n  assertTrue(id == TypeId.of[List[Map[String, Option[Either[Int, List[String]]]]]])\n}\n\ntest(\"handles local and anonymous types\") {\n  def foo() = {\n    class Local\n    TypeId.of[Local]\n  }\n  // Should handle gracefully\n}\n\ntest(\"handles Java types\") {\n  val id = TypeId.of[java.util.ArrayList[String]]\n  // Should interop correctly\n}\n```\n\n### 6. Cross-Compilation Tests\n\nRun the same test suite on both Scala 2.13 and Scala 3.x to ensure consistent behavior:\n```scala\n// In shared test sources\nclass TypeIdSpec extends AnyFunSuite {\n  // All tests above should pass on both Scala versions\n}\n```\n\nSpecific attention should be paid to:\n- Features that exist only in Scala 3 (union/intersection types, enums, match types, named tuples)\n- Features with different representations (Scala 2 existentials vs Scala 3 wildcards)\n- Macro API differences (should be invisible to users but implementation must handle both)\n- **Equality of TypeIds derived in Scala 2 vs Scala 3 for the same type** (if cross-published)\n\n## Acceptance Criteria\n\n- [ ] `TypeId.of[A]` works for all documented type forms on Scala 2.13\n- [ ] `TypeId.of[A]` works for all documented type forms on Scala 3.03.7\n- [ ] `implicit TypeId[A]` derivation works in generic contexts\n- [ ] `isSubtypeOf` correctly handles variance, unions, intersections, and nominal hierarchies\n- [ ] Type aliases are normalized correctly\n- [ ] Opaque types maintain nominal distinction\n- [ ] **`equals` and `hashCode` satisfy the Java contract**\n- [ ] **`TypeId` works correctly as `Map` and `Set` keys**\n- [ ] **Type aliases resolve to equal `TypeId` as their underlying types**\n- [ ] **Opaque types have distinct `TypeId` from their representation**\n- [ ] **`hashCode` is stable and deterministic across compilations**\n- [ ] All tests pass on both Scala versions\n- [ ] No runtime reflection is required (all information captured at compile time)\n\n# Sketch of TypeId\n\n# TypeId Data Model for Scala 3.x Type Registry\n\nA comprehensive data model for representing Scala 3 types and type constructors, designed to support:\n- Lossless type representation for serialization/deserialization frameworks\n- Subtype checking (`isSubtypeOf`)\n- Type equality checking\n- Type normalization (alias expansion)\n\n## Design Principles\n\n1. **Polykinded phantom types**: `TypeId[A <: AnyKind]` preserves Scala type information at compile time\n2. **Separation of identity and representation**: `TypeId` identifies types; `TypeRepr` represents type expressions\n3. **Complete metadata**: Capture everything a macro can know at compile time\n4. **Stability tracking**: Path-dependent types require knowing path stability\n\n---\n\n## Core Data Model\n\n### Variance\n```scala\nenum Variance {\n  case Invariant\n  case Covariant\n  case Contravariant\n\n  def symbol: String = this match {\n    case Invariant     => \"\"\n    case Covariant     => \"+\"\n    case Contravariant => \"-\"\n  }\n\n  /** Flip variance for contravariant positions */\n  def flip: Variance = this match {\n    case Invariant     => Invariant\n    case Covariant     => Contravariant\n    case Contravariant => Covariant\n  }\n}\n```\n\n### TypeBounds\n```scala\nfinal case class TypeBounds(\n  lower: Option[TypeRepr],  // >: bound\n  upper: Option[TypeRepr]   // <: bound\n) {\n  def isUnbounded: Boolean = lower.isEmpty && upper.isEmpty\n  \n  def hasLower: Boolean = lower.isDefined\n  def hasUpper: Boolean = upper.isDefined\n  \n  /** Combine bounds (intersection of constraints) */\n  def &(other: TypeBounds): TypeBounds = TypeBounds(\n    lower = (lower, other.lower) match {\n      case (Some(l1), Some(l2)) => Some(TypeRepr.Union(l1, l2))\n      case (Some(l), None) => Some(l)\n      case (None, Some(l)) => Some(l)\n      case (None, None) => None\n    },\n    upper = (upper, other.upper) match {\n      case (Some(u1), Some(u2)) => Some(TypeRepr.Intersection(u1, u2))\n      case (Some(u), None) => Some(u)\n      case (None, Some(u)) => Some(u)\n      case (None, None) => None\n    }\n  )\n}\n\nobject TypeBounds {\n  val empty: TypeBounds = TypeBounds(None, None)\n  \n  def upper(tpe: TypeRepr): TypeBounds = TypeBounds(None, Some(tpe))\n  def lower(tpe: TypeRepr): TypeBounds = TypeBounds(Some(tpe), None)\n  def exact(tpe: TypeRepr): TypeBounds = TypeBounds(Some(tpe), Some(tpe))\n}\n```\n\n### Kind\n\nRepresents the \"type of a type\" - distinguishing proper types from type constructors.\n```scala\nsealed trait Kind {\n  def arity: Int\n  def isProperType: Boolean = this == Kind.Type\n  def isHigherKinded: Boolean = !isProperType\n}\n\nobject Kind {\n  /** Proper type: Int, String, List[Int] */\n  case object Type extends Kind { \n    def arity: Int = 0 \n  }\n\n  /** Type constructor: List, Option, Map */\n  final case class Arrow(params: List[Kind], result: Kind) extends Kind {\n    def arity: Int = params.size\n  }\n\n  // Convenience constructors\n  val `* -> *`: Kind = Arrow(List(Type), Type)\n  val `* -> * -> *`: Kind = Arrow(List(Type, Type), Type)\n  val `(* -> *) -> *`: Kind = Arrow(List(`* -> *`), Type)\n  \n  def arity(n: Int): Kind = \n    if (n == 0) Type \n    else Arrow(List.fill(n)(Type), Type)\n}\n```\n\n### TypeParam\n\nComplete type parameter specification with all information needed for subtyping.\n```scala\nfinal case class TypeParam(\n  name: String,\n  index: Int,\n  variance: Variance = Variance.Invariant,\n  bounds: TypeBounds = TypeBounds.empty,\n  kind: Kind = Kind.Type\n) {\n  def isHigherKinded: Boolean = kind.isHigherKinded\n  def isCovariant: Boolean = variance == Variance.Covariant\n  def isContravariant: Boolean = variance == Variance.Contravariant\n  def isInvariant: Boolean = variance == Variance.Invariant\n}\n\nobject TypeParam {\n  def invariant(name: String, index: Int): TypeParam = \n    TypeParam(name, index, Variance.Invariant)\n    \n  def covariant(name: String, index: Int): TypeParam = \n    TypeParam(name, index, Variance.Covariant)\n    \n  def contravariant(name: String, index: Int): TypeParam = \n    TypeParam(name, index, Variance.Contravariant)\n}\n```\n\n---\n\n## Type Definition Classification\n\n### TypeDefKind\n\nClassifies what kind of type definition a `TypeId` represents.\n```scala\nsealed trait TypeDefKind\n\nobject TypeDefKind {\n  final case class Class(\n    isFinal: Boolean = false,\n    isAbstract: Boolean = false,\n    isCase: Boolean = false,\n    isValue: Boolean = false  // extends AnyVal\n  ) extends TypeDefKind\n\n  final case class Trait(\n    isSealed: Boolean = false,\n    knownSubtypes: List[TypeRepr] = Nil\n  ) extends TypeDefKind\n\n  /** Singleton object */\n  case object Object extends TypeDefKind\n\n  /** Scala 3 enum */\n  final case class Enum(\n    cases: List[EnumCaseInfo]\n  ) extends TypeDefKind\n\n  /** Individual enum case (when represented as its own type) */\n  final case class EnumCase(\n    parentEnum: TypeRepr,\n    ordinal: Int,\n    isObjectCase: Boolean  // case Red vs case RGB(...)\n  ) extends TypeDefKind\n\n  /** Type alias: type Foo = Bar */\n  case object TypeAlias extends TypeDefKind\n\n  /** Opaque type: opaque type Foo = Bar */\n  final case class OpaqueType(\n    publicBounds: TypeBounds  // Bounds visible outside defining scope\n  ) extends TypeDefKind\n\n  /** Abstract type member */\n  case object AbstractType extends TypeDefKind\n}\n\n/** Information about an enum case for serialization */\nfinal case class EnumCaseInfo(\n  name: String,\n  ordinal: Int,\n  params: List[EnumCaseParam],  // Empty for object cases\n  isObjectCase: Boolean\n) {\n  def arity: Int = params.size\n}\n\nfinal case class EnumCaseParam(\n  name: String,\n  tpe: TypeRepr\n)\n```\n\n---\n\n## Parameters and Clauses\n\n### ParamClause\n```scala\nsealed trait ParamClause {\n  def params: List[Param]\n  def isEmpty: Boolean = params.isEmpty\n  def size: Int = params.size\n}\n\nobject ParamClause {\n  final case class Regular(params: List[Param]) extends ParamClause\n  final case class Using(params: List[Param]) extends ParamClause\n  final case class Implicit(params: List[Param]) extends ParamClause\n  \n  val empty: ParamClause = Regular(Nil)\n}\n```\n\n### Param\n```scala\nfinal case class Param(\n  name: String,\n  tpe: TypeRepr,\n  hasDefault: Boolean = false,\n  isRepeated: Boolean = false  // varargs: A*\n)\n```\n\n---\n\n## Ownership and Paths\n\n### Owner\n\nRepresents the lexical owner of a type definition.\n```scala\nfinal case class Owner(segments: List[Owner.Segment]) {\n  def /(segment: Owner.Segment): Owner = Owner(segments :+ segment)\n  \n  def parent: Option[Owner] = \n    if (segments.isEmpty) None \n    else Some(Owner(segments.init))\n  \n  def isRoot: Boolean = segments.isEmpty\n  \n  def asString: String = segments.map(_.show).mkString(\".\")\n  \n  /** Check if this owner is a prefix of another */\n  def isPrefixOf(other: Owner): Boolean =\n    other.segments.startsWith(segments)\n}\n\nobject Owner {\n  sealed trait Segment {\n    def name: String\n    def show: String = name\n  }\n\n  final case class Package(name: String) extends Segment\n  final case class Term(name: String) extends Segment\n  final case class Type(name: String) extends Segment\n  final case class Local(index: Int) extends Segment {\n    def name: String = s\"<local$index>\"\n  }\n\n  val Root: Owner = Owner(Nil)\n  \n  def pkg(name: String): Owner = Owner(List(Package(name)))\n  def pkgs(names: String*): Owner = Owner(names.map(Package(_)).toList)\n}\n```\n\n### TermPath\n\nRepresents paths to terms, used for singleton and path-dependent types.\n```scala\nfinal case class TermPath(segments: List[TermPath.Segment]) {\n  def /(segment: TermPath.Segment): TermPath = \n    TermPath(segments :+ segment)\n  \n  def isStable: Boolean = segments.forall(_.isStable)\n  \n  def asString: String = segments.map(_.name).mkString(\".\")\n}\n\nobject TermPath {\n  sealed trait Segment {\n    def name: String\n    def isStable: Boolean\n  }\n\n  /** Package reference - always stable */\n  final case class Package(name: String) extends Segment {\n    def isStable: Boolean = true\n  }\n\n  /** Object/module reference - always stable */\n  final case class Module(name: String) extends Segment {\n    def isStable: Boolean = true\n  }\n\n  /** Val reference - stable */\n  final case class Val(name: String) extends Segment {\n    def isStable: Boolean = true\n  }\n\n  /** Lazy val reference - stable */\n  final case class LazyVal(name: String) extends Segment {\n    def isStable: Boolean = true\n  }\n\n  /** Var reference - NOT stable */\n  final case class Var(name: String) extends Segment {\n    def isStable: Boolean = false\n  }\n\n  /** Def/method reference - NOT stable */\n  final case class Def(name: String) extends Segment {\n    def isStable: Boolean = false\n  }\n\n  /** This reference */\n  final case class This(ownerName: String) extends Segment {\n    def name: String = s\"$ownerName.this\"\n    def isStable: Boolean = true\n  }\n\n  /** Super reference */\n  final case class Super(ownerName: String, mixinName: Option[String]) extends Segment {\n    def name: String = mixinName.fold(s\"$ownerName.super\")(m => s\"$ownerName.super[$m]\")\n    def isStable: Boolean = true\n  }\n\n  val empty: TermPath = TermPath(Nil)\n}\n```\n\n---\n\n## TypeId: Type Identity\n\nThe primary type for identifying types and type constructors.\n```scala\nsealed trait TypeId[A <: AnyKind] {\n  def name: String\n  def owner: Owner\n  def typeParams: List[TypeParam]\n  def defKind: TypeDefKind\n  def parents: List[TypeRepr]\n  def selfType: Option[TypeRepr]\n  def aliasedTo: Option[TypeRepr]      // For type aliases\n  def representation: Option[TypeRepr] // For opaque types\n  def annotations: List[Annotation]\n\n  // Derived properties\n  final def arity: Int = typeParams.size\n  \n  final def fullName: String =\n    if (owner.isRoot) name\n    else s\"${owner.asString}.$name\"\n\n  final def isProperType: Boolean = arity == 0\n  final def isTypeConstructor: Boolean = arity > 0\n\n  final def isClass: Boolean = defKind.isInstanceOf[TypeDefKind.Class]\n  final def isTrait: Boolean = defKind.isInstanceOf[TypeDefKind.Trait]\n  final def isObject: Boolean = defKind == TypeDefKind.Object\n  final def isEnum: Boolean = defKind.isInstanceOf[TypeDefKind.Enum]\n  final def isAlias: Boolean = defKind == TypeDefKind.TypeAlias\n  final def isOpaque: Boolean = defKind.isInstanceOf[TypeDefKind.OpaqueType]\n  final def isAbstract: Boolean = defKind == TypeDefKind.AbstractType\n\n  final def isSealed: Boolean = defKind match {\n    case TypeDefKind.Trait(isSealed, _) => isSealed\n    case _ => false\n  }\n\n  final def isCaseClass: Boolean = defKind match {\n    case TypeDefKind.Class(_, _, isCase, _) => isCase\n    case _ => false\n  }\n\n  final def isValueClass: Boolean = defKind match {\n    case TypeDefKind.Class(_, _, _, isValue) => isValue\n    case _ => false\n  }\n  \n  /** Get enum cases if this is an enum */\n  final def enumCases: List[EnumCaseInfo] = defKind match {\n    case TypeDefKind.Enum(cases) => cases\n    case _ => Nil\n  }\n}\n\nobject TypeId {\n  private final case class Impl[A <: AnyKind](\n    name: String,\n    owner: Owner,\n    typeParams: List[TypeParam],\n    defKind: TypeDefKind,\n    parents: List[TypeRepr],\n    selfType: Option[TypeRepr],\n    aliasedTo: Option[TypeRepr],\n    representation: Option[TypeRepr],\n    annotations: List[Annotation]\n  ) extends TypeId[A]\n\n  // ========== Smart Constructors ==========\n\n  def nominal[A <: AnyKind](\n    name: String,\n    owner: Owner,\n    typeParams: List[TypeParam] = Nil,\n    defKind: TypeDefKind,\n    parents: List[TypeRepr] = Nil,\n    selfType: Option[TypeRepr] = None,\n    annotations: List[Annotation] = Nil\n  ): TypeId[A] = Impl[A](\n    name, owner, typeParams, defKind,\n    parents, selfType, None, None, annotations\n  )\n\n  def alias[A <: AnyKind](\n    name: String,\n    owner: Owner,\n    typeParams: List[TypeParam] = Nil,\n    aliased: TypeRepr,\n    annotations: List[Annotation] = Nil\n  ): TypeId[A] = Impl[A](\n    name, owner, typeParams, TypeDefKind.TypeAlias,\n    Nil, None, Some(aliased), None, annotations\n  )\n\n  def opaque[A <: AnyKind](\n    name: String,\n    owner: Owner,\n    typeParams: List[TypeParam] = Nil,\n    representation: TypeRepr,\n    publicBounds: TypeBounds = TypeBounds.empty,\n    annotations: List[Annotation] = Nil\n  ): TypeId[A] = Impl[A](\n    name, owner, typeParams, TypeDefKind.OpaqueType(publicBounds),\n    Nil, None, None, Some(representation), annotations\n  )\n\n  // ========== Extractors ==========\n\n  object Nominal {\n    def unapply(id: TypeId[?]): Option[(String, Owner, List[TypeParam], TypeDefKind, List[TypeRepr])] =\n      if (id.aliasedTo.isEmpty && id.representation.isEmpty)\n        Some((id.name, id.owner, id.typeParams, id.defKind, id.parents))\n      else None\n  }\n\n  object Alias {\n    def unapply(id: TypeId[?]): Option[(String, Owner, List[TypeParam], TypeRepr)] =\n      id.aliasedTo.map(a => (id.name, id.owner, id.typeParams, a))\n  }\n\n  object Opaque {\n    def unapply(id: TypeId[?]): Option[(String, Owner, List[TypeParam], TypeRepr, TypeBounds)] =\n      (id.defKind, id.representation) match {\n        case (TypeDefKind.OpaqueType(bounds), Some(repr)) =>\n          Some((id.name, id.owner, id.typeParams, repr, bounds))\n        case _ => None\n      }\n  }\n\n  object Sealed {\n    def unapply(id: TypeId[?]): Option[(String, List[TypeRepr])] =\n      id.defKind match {\n        case TypeDefKind.Trait(true, subtypes) => Some((id.name, subtypes))\n        case _ => None\n      }\n  }\n  \n  object Enum {\n    def unapply(id: TypeId[?]): Option[(String, Owner, List[EnumCaseInfo])] =\n      id.defKind match {\n        case TypeDefKind.Enum(cases) => Some((id.name, id.owner, cases))\n        case _ => None\n      }\n  }\n}\n```\n\n---\n\n## TypeRepr: Type Expressions\n\nThe expression language for representing type structures.\n```scala\nsealed trait TypeRepr {\n  /** Substitute type parameters with concrete types */\n  def substitute(substitutions: Map[TypeParam, TypeRepr]): TypeRepr =\n    TypeRepr.substitute(this, substitutions)\n}\n\nobject TypeRepr {\n\n  // ==================== Type References ====================\n\n  /** Reference to a type by its TypeId */\n  final case class Ref(id: TypeId[? <: AnyKind]) extends TypeRepr\n\n  /** Reference to a type parameter */\n  final case class ParamRef(\n    param: TypeParam,\n    binderDepth: Int = 0  // De Bruijn index: 0 = innermost binder\n  ) extends TypeRepr\n\n  /** Path-dependent type: qualifier.Member */\n  final case class TypeSelect(\n    qualifier: TermPath,\n    memberName: String\n  ) extends TypeRepr {\n    def isStable: Boolean = qualifier.isStable\n  }\n\n  /** Type projection (deprecated but exists): Outer#Inner */\n  final case class TypeProjection(\n    prefix: TypeRepr,\n    memberName: String\n  ) extends TypeRepr\n\n  // ==================== Type Application ====================\n\n  /** Type constructor application: F[A, B] */\n  final case class Applied(\n    tycon: TypeRepr,\n    args: List[TypeRepr]\n  ) extends TypeRepr {\n    def arity: Int = args.size\n  }\n\n  // ==================== Type Constructors ====================\n\n  /** Type lambda: [X, Y] =>> F[X, Y] */\n  final case class TypeLambda(\n    params: List[TypeParam],\n    body: TypeRepr\n  ) extends TypeRepr {\n    def arity: Int = params.size\n  }\n\n  // ==================== Compound Types ====================\n\n  /** Intersection: A & B & C */\n  final case class Intersection(components: List[TypeRepr]) extends TypeRepr {\n    require(components.sizeIs >= 2, \"Intersection requires at least 2 types\")\n  }\n  \n  object Intersection {\n    def apply(left: TypeRepr, right: TypeRepr): Intersection =\n      (left, right) match {\n        case (Intersection(l), Intersection(r)) => Intersection(l ++ r)\n        case (Intersection(l), r) => Intersection(l :+ r)\n        case (l, Intersection(r)) => Intersection(l :: r)\n        case (l, r) => Intersection(List(l, r))\n      }\n  }\n\n  /** Union: A | B | C */\n  final case class Union(components: List[TypeRepr]) extends TypeRepr {\n    require(components.sizeIs >= 2, \"Union requires at least 2 types\")\n  }\n  \n  object Union {\n    def apply(left: TypeRepr, right: TypeRepr): Union =\n      (left, right) match {\n        case (Union(l), Union(r)) => Union(l ++ r)\n        case (Union(l), r) => Union(l :+ r)\n        case (l, Union(r)) => Union(l :: r)\n        case (l, r) => Union(List(l, r))\n      }\n  }\n\n  /** Structural/refinement type: { def foo: Int; type T } */\n  final case class Structural(\n    parents: List[TypeRepr],\n    members: List[Member]\n  ) extends TypeRepr\n\n  // ==================== Function Types ====================\n\n  /** Regular function: (A, B) => C */\n  final case class Function(\n    params: List[TypeRepr],\n    result: TypeRepr\n  ) extends TypeRepr {\n    def arity: Int = params.size\n  }\n\n  /** Context function: (A, B) ?=> C */\n  final case class ContextFunction(\n    params: List[TypeRepr],\n    result: TypeRepr\n  ) extends TypeRepr\n\n  /** Polymorphic function: [A] => A => A */\n  final case class PolyFunction(\n    typeParams: List[TypeParam],\n    result: TypeRepr\n  ) extends TypeRepr\n\n  /** Dependent function: (x: A) => x.T */\n  final case class DependentFunction(\n    params: List[Param],\n    result: TypeRepr  // May contain references to param names\n  ) extends TypeRepr\n\n  // ==================== Special Parameter Types ====================\n\n  /** By-name type: => A */\n  final case class ByName(underlying: TypeRepr) extends TypeRepr\n\n  /** Repeated/vararg type: A* */\n  final case class Repeated(underlying: TypeRepr) extends TypeRepr\n\n  // ==================== Tuple Types ====================\n\n  /** Tuple type with optional labels: (A, B) or (name: String, age: Int) */\n  final case class Tuple(elements: List[TupleElement]) extends TypeRepr {\n    def arity: Int = elements.size\n    def isNamed: Boolean = elements.exists(_.label.isDefined)\n    def isPositional: Boolean = elements.forall(_.label.isEmpty)\n    \n    def labels: List[Option[String]] = elements.map(_.label)\n    def types: List[TypeRepr] = elements.map(_.tpe)\n  }\n\n  final case class TupleElement(\n    label: Option[String],\n    tpe: TypeRepr\n  )\n  \n  object Tuple {\n    def positional(types: TypeRepr*): Tuple = \n      Tuple(types.map(t => TupleElement(None, t)).toList)\n      \n    def named(fields: (String, TypeRepr)*): Tuple =\n      Tuple(fields.map { case (n, t) => TupleElement(Some(n), t) }.toList)\n  }\n\n  // ==================== Singleton & Literal Types ====================\n\n  /** Singleton type: x.type */\n  final case class Singleton(path: TermPath) extends TypeRepr {\n    def isStable: Boolean = path.isStable\n  }\n\n  /** This type: this.type within a class */\n  final case class ThisType(owner: TypeId[? <: AnyKind]) extends TypeRepr\n\n  /** Super type reference */\n  final case class SuperType(\n    thisType: TypeRepr,\n    mixinTrait: Option[TypeRepr]\n  ) extends TypeRepr\n\n  /** Literal/constant type: 42, \"foo\", true */\n  final case class ConstantType(value: Constant) extends TypeRepr\n\n  // ==================== Match Types ====================\n\n  /** Match type: T match { case P => R; ... } */\n  final case class MatchType(\n    bound: TypeRepr,\n    scrutinee: TypeRepr,\n    cases: List[MatchTypeCase]\n  ) extends TypeRepr\n\n  final case class MatchTypeCase(\n    bindings: List[TypeParam],  // Captured type vars, e.g., `t` in `case Array[t] => t`\n    pattern: TypeRepr,\n    result: TypeRepr            // Can reference bindings via ParamRef\n  )\n\n  // ==================== Bounded/Wildcard Types ====================\n\n  /** Wildcard with bounds: ? <: Upper, ? >: Lower */\n  final case class Wildcard(bounds: TypeBounds) extends TypeRepr\n  \n  object Wildcard {\n    val unbounded: Wildcard = Wildcard(TypeBounds.empty)\n    def <:(upper: TypeRepr): Wildcard = Wildcard(TypeBounds.upper(upper))\n    def >:(lower: TypeRepr): Wildcard = Wildcard(TypeBounds.lower(lower))\n  }\n\n  // ==================== Recursive Types ====================\n\n  /** Recursive type: used for recursive type aliases */\n  final case class RecType(body: TypeRepr) extends TypeRepr\n\n  /** Reference to enclosing RecType */\n  case object RecThis extends TypeRepr\n\n  // ==================== Annotated Types ====================\n\n  /** Type with annotations: A @ann */\n  final case class Annotated(\n    underlying: TypeRepr,\n    annotations: List[Annotation]\n  ) extends TypeRepr\n\n  // ==================== Top, Bottom, and Special Types ====================\n\n  case object AnyType extends TypeRepr\n  case object AnyKindType extends TypeRepr\n  case object NothingType extends TypeRepr\n  case object NullType extends TypeRepr\n  case object UnitType extends TypeRepr\n\n  // ==================== Substitution ====================\n\n  def substitute(repr: TypeRepr, subs: Map[TypeParam, TypeRepr]): TypeRepr = {\n    def go(r: TypeRepr): TypeRepr = r match {\n      case ParamRef(param, 0) => subs.getOrElse(param, r)\n      case ParamRef(_, _) => r  // Different binder depth\n      case Ref(_) => r\n      case Applied(tycon, args) => Applied(go(tycon), args.map(go))\n      case TypeLambda(params, body) =>\n        // Shift substitutions to account for new binders\n        val shifted = subs.map { case (p, t) => p -> shiftBinderDepth(t, 1) }\n        TypeLambda(params, substitute(body, shifted))\n      case Intersection(comps) => Intersection(comps.map(go))\n      case Union(comps) => Union(comps.map(go))\n      case Structural(parents, members) =>\n        Structural(parents.map(go), members.map(substituteMember(_, subs)))\n      case Function(params, result) => Function(params.map(go), go(result))\n      case ContextFunction(params, result) => ContextFunction(params.map(go), go(result))\n      case PolyFunction(tps, result) => PolyFunction(tps, go(result))\n      case DependentFunction(params, result) =>\n        DependentFunction(params.map(p => p.copy(tpe = go(p.tpe))), go(result))\n      case ByName(u) => ByName(go(u))\n      case Repeated(u) => Repeated(go(u))\n      case Tuple(elems) => Tuple(elems.map(e => e.copy(tpe = go(e.tpe))))\n      case MatchType(bound, scrutinee, cases) =>\n        MatchType(go(bound), go(scrutinee), cases.map(substituteMatchCase(_, subs)))\n      case Wildcard(bounds) => Wildcard(substituteBounds(bounds, subs))\n      case RecType(body) => RecType(go(body))\n      case Annotated(underlying, anns) => Annotated(go(underlying), anns)\n      case TypeSelect(_, _) | TypeProjection(_, _) | Singleton(_) |\n           ThisType(_) | SuperType(_, _) | ConstantType(_) | RecThis |\n           AnyType | AnyKindType | NothingType | NullType | UnitType => r\n    }\n    go(repr)\n  }\n\n  private def shiftBinderDepth(repr: TypeRepr, delta: Int): TypeRepr = repr match {\n    case ParamRef(param, depth) => ParamRef(param, depth + delta)\n    case Applied(tycon, args) => Applied(shiftBinderDepth(tycon, delta), args.map(shiftBinderDepth(_, delta)))\n    // ... other cases follow same pattern\n    case other => other  // Simplified; full impl would recurse\n  }\n\n  private def substituteBounds(bounds: TypeBounds, subs: Map[TypeParam, TypeRepr]): TypeBounds =\n    TypeBounds(bounds.lower.map(substitute(_, subs)), bounds.upper.map(substitute(_, subs)))\n\n  private def substituteMatchCase(c: MatchTypeCase, subs: Map[TypeParam, TypeRepr]): MatchTypeCase = {\n    // Remove bindings from substitution map (they shadow outer params)\n    val shadowedSubs = subs -- c.bindings\n    MatchTypeCase(c.bindings, substitute(c.pattern, shadowedSubs), substitute(c.result, shadowedSubs))\n  }\n\n  private def substituteMember(m: Member, subs: Map[TypeParam, TypeRepr]): Member = m match {\n    case Member.Val(name, tpe, isMutable, targetName, annotations) =>\n      Member.Val(name, substitute(tpe, subs), isMutable, targetName, annotations)\n    case Member.Def(name, typeParams, paramClauses, result, targetName, annotations) =>\n      Member.Def(\n        name, typeParams,\n        paramClauses.map(substituteParamClause(_, subs)),\n        substitute(result, subs),\n        targetName, annotations\n      )\n    case Member.TypeMember(name, typeParams, bounds, alias, annotations) =>\n      Member.TypeMember(\n        name, typeParams,\n        substituteBounds(bounds, subs),\n        alias.map(substitute(_, subs)),\n        annotations\n      )\n  }\n\n  private def substituteParamClause(clause: ParamClause, subs: Map[TypeParam, TypeRepr]): ParamClause = {\n    def subParam(p: Param): Param = p.copy(tpe = substitute(p.tpe, subs))\n    clause match {\n      case ParamClause.Regular(params) => ParamClause.Regular(params.map(subParam))\n      case ParamClause.Using(params) => ParamClause.Using(params.map(subParam))\n      case ParamClause.Implicit(params) => ParamClause.Implicit(params.map(subParam))\n    }\n  }\n}\n```\n\n---\n\n## Members: For Structural Types\n```scala\nsealed trait Member\n\nobject Member {\n  final case class Val(\n    name: String,\n    tpe: TypeRepr,\n    isMutable: Boolean = false,\n    targetName: Option[String] = None,  // @targetName annotation\n    annotations: List[Annotation] = Nil\n  ) extends Member\n\n  final case class Def(\n    name: String,\n    typeParams: List[TypeParam] = Nil,\n    paramClauses: List[ParamClause] = Nil,\n    result: TypeRepr,\n    targetName: Option[String] = None,\n    annotations: List[Annotation] = Nil\n  ) extends Member {\n    def arity: Int = paramClauses.map(_.size).sum\n  }\n\n  final case class TypeMember(\n    name: String,\n    typeParams: List[TypeParam] = Nil,\n    bounds: TypeBounds = TypeBounds.empty,\n    alias: Option[TypeRepr] = None,  // Some = type alias, None = abstract\n    annotations: List[Annotation] = Nil\n  ) extends Member {\n    def isAbstract: Boolean = alias.isEmpty && bounds != TypeBounds.empty\n    def isAlias: Boolean = alias.isDefined\n  }\n}\n```\n\n---\n\n## Constants and Annotations\n\n### Constant\n```scala\nsealed trait Constant {\n  type Value\n  def value: Value\n}\n\nobject Constant {\n  final case class IntConst(value: Int) extends Constant { type Value = Int }\n  final case class LongConst(value: Long) extends Constant { type Value = Long }\n  final case class FloatConst(value: Float) extends Constant { type Value = Float }\n  final case class DoubleConst(value: Double) extends Constant { type Value = Double }\n  final case class BooleanConst(value: Boolean) extends Constant { type Value = Boolean }\n  final case class CharConst(value: Char) extends Constant { type Value = Char }\n  final case class StringConst(value: String) extends Constant { type Value = String }\n  final case class NullConst() extends Constant { type Value = Null; def value: Null = null }\n  final case class UnitConst() extends Constant { type Value = Unit; def value: Unit = () }\n  final case class ClassOfConst(tpe: TypeRepr) extends Constant { type Value = TypeRepr; def value: TypeRepr = tpe }\n}\n```\n\n### Annotation\n```scala\nfinal case class Annotation(\n  tpe: TypeRepr,\n  args: List[AnnotationArg]\n)\n\nsealed trait AnnotationArg\n\nobject AnnotationArg {\n  final case class ConstArg(value: Constant) extends AnnotationArg\n  final case class ArrayArg(elements: List[AnnotationArg]) extends AnnotationArg\n  final case class NestedArg(annotation: Annotation) extends AnnotationArg\n  final case class TypeArg(tpe: TypeRepr) extends AnnotationArg\n  final case class NamedArg(name: String, value: AnnotationArg) extends AnnotationArg\n}\n```\n\n---\n\n## Type Operations\n\n### Normalization\n\nExpands type aliases to their underlying types.\n```scala\nobject TypeNormalization {\n  \n  /**\n   * Normalize a type by expanding type aliases.\n   * Does NOT expand opaque types (they are nominally distinct).\n   */\n  def normalize(tpe: TypeRepr): TypeRepr = tpe match {\n    // Direct alias reference with no args\n    case TypeRepr.Ref(TypeId.Alias(_, _, Nil, aliased)) =>\n      normalize(aliased)\n    \n    // Applied alias: expand and substitute\n    case TypeRepr.Applied(TypeRepr.Ref(TypeId.Alias(_, _, params, aliased)), args) \n        if params.size == args.size =>\n      val subs = params.zip(args.map(normalize)).toMap\n      normalize(TypeRepr.substitute(aliased, subs))\n    \n    // Recurse into compound types\n    case TypeRepr.Applied(tycon, args) =>\n      TypeRepr.Applied(normalize(tycon), args.map(normalize))\n    \n    case TypeRepr.Intersection(comps) =>\n      TypeRepr.Intersection(comps.map(normalize))\n    \n    case TypeRepr.Union(comps) =>\n      TypeRepr.Union(comps.map(normalize))\n    \n    case TypeRepr.Function(params, result) =>\n      TypeRepr.Function(params.map(normalize), normalize(result))\n    \n    case TypeRepr.ContextFunction(params, result) =>\n      TypeRepr.ContextFunction(params.map(normalize), normalize(result))\n    \n    case TypeRepr.Tuple(elems) =>\n      TypeRepr.Tuple(elems.map(e => e.copy(tpe = normalize(e.tpe))))\n    \n    case TypeRepr.ByName(u) => TypeRepr.ByName(normalize(u))\n    case TypeRepr.Repeated(u) => TypeRepr.Repeated(normalize(u))\n    case TypeRepr.Annotated(u, anns) => TypeRepr.Annotated(normalize(u), anns)\n    case TypeRepr.Wildcard(bounds) => \n      TypeRepr.Wildcard(TypeBounds(bounds.lower.map(normalize), bounds.upper.map(normalize)))\n    \n    // Atoms don't change\n    case _ => tpe\n  }\n  \n  /**\n   * Get the underlying representation of an opaque type.\n   * Only valid within the opaque type's defining scope.\n   */\n  def unwrapOpaque(tpe: TypeRepr): Option[TypeRepr] = tpe match {\n    case TypeRepr.Ref(TypeId.Opaque(_, _, Nil, repr, _)) =>\n      Some(repr)\n    case TypeRepr.Applied(TypeRepr.Ref(TypeId.Opaque(_, _, params, repr, _)), args)\n        if params.size == args.size =>\n      val subs = params.zip(args).toMap\n      Some(TypeRepr.substitute(repr, subs))\n    case _ => None\n  }\n}\n```\n\n### Type Equality\n```scala\nobject TypeEquality {\n  \n  /**\n   * Check if two types are equal (after normalization).\n   * This is structural equality, not reference equality.\n   */\n  def areEqual(a: TypeRepr, b: TypeRepr): Boolean = {\n    val aNorm = TypeNormalization.normalize(a)\n    val bNorm = TypeNormalization.normalize(b)\n    structurallyEqual(aNorm, bNorm)\n  }\n  \n  private def structurallyEqual(a: TypeRepr, b: TypeRepr): Boolean = (a, b) match {\n    case (TypeRepr.Ref(idA), TypeRepr.Ref(idB)) =>\n      idA.fullName == idB.fullName\n    \n    case (TypeRepr.ParamRef(pA, dA), TypeRepr.ParamRef(pB, dB)) =>\n      pA.index == pB.index && dA == dB\n    \n    case (TypeRepr.Applied(tcA, argsA), TypeRepr.Applied(tcB, argsB)) =>\n      structurallyEqual(tcA, tcB) && \n        argsA.size == argsB.size &&\n        argsA.zip(argsB).forall { case (x, y) => structurallyEqual(x, y) }\n    \n    case (TypeRepr.Intersection(cA), TypeRepr.Intersection(cB)) =>\n      cA.size == cB.size && cA.zip(cB).forall { case (x, y) => structurallyEqual(x, y) }\n    \n    case (TypeRepr.Union(cA), TypeRepr.Union(cB)) =>\n      cA.size == cB.size && cA.zip(cB).forall { case (x, y) => structurallyEqual(x, y) }\n    \n    case (TypeRepr.Function(pA, rA), TypeRepr.Function(pB, rB)) =>\n      pA.size == pB.size &&\n        pA.zip(pB).forall { case (x, y) => structurallyEqual(x, y) } &&\n        structurallyEqual(rA, rB)\n    \n    case (TypeRepr.Tuple(eA), TypeRepr.Tuple(eB)) =>\n      eA.size == eB.size && eA.zip(eB).forall { case (x, y) => \n        x.label == y.label && structurallyEqual(x.tpe, y.tpe)\n      }\n    \n    case (TypeRepr.ConstantType(cA), TypeRepr.ConstantType(cB)) =>\n      cA == cB\n    \n    case (TypeRepr.AnyType, TypeRepr.AnyType) => true\n    case (TypeRepr.NothingType, TypeRepr.NothingType) => true\n    case (TypeRepr.NullType, TypeRepr.NullType) => true\n    case (TypeRepr.UnitType, TypeRepr.UnitType) => true\n    \n    // More cases for full coverage...\n    case _ => false\n  }\n}\n```\n\n### Subtyping\n```scala\nobject Subtyping {\n  \n  /**\n   * Context for subtyping calculations.\n   * Tracks assumptions to handle recursive types and avoid infinite loops.\n   */\n  final case class Context(\n    assumptions: Set[(TypeRepr, TypeRepr)] = Set.empty,\n    depth: Int = 0,\n    maxDepth: Int = 100\n  ) {\n    def assume(sub: TypeRepr, sup: TypeRepr): Context =\n      copy(assumptions = assumptions + ((sub, sup)))\n    \n    def isAssumed(sub: TypeRepr, sup: TypeRepr): Boolean =\n      assumptions.contains((sub, sup))\n    \n    def deeper: Context = copy(depth = depth + 1)\n    def tooDeep: Boolean = depth >= maxDepth\n  }\n  \n  /**\n   * Check if `sub` is a subtype of `sup`.\n   * \n   * Implements the Scala 3 subtyping rules including:\n   * - Reflexivity: A <: A\n   * - Top: A <: Any for all A\n   * - Bottom: Nothing <: A for all A  \n   * - Variance-aware generic subtyping\n   * - Union/intersection type rules\n   * - Structural subtyping\n   */\n  def isSubtype(sub: TypeRepr, sup: TypeRepr)(using ctx: Context = Context()): Boolean = ???\n  \n  /**\n   * Check if two types are equivalent (mutual subtypes).\n   */\n  def isEquivalent(a: TypeRepr, b: TypeRepr)(using ctx: Context = Context()): Boolean =\n    isSubtype(a, b) && isSubtype(b, a)\n  \n  /**\n   * Find the least upper bound (LUB) of two types.\n   * Returns the most specific type that is a supertype of both.\n   */\n  def lub(a: TypeRepr, b: TypeRepr): TypeRepr = ???\n  \n  /**\n   * Find the greatest lower bound (GLB) of two types.\n   * Returns the most general type that is a subtype of both.\n   */\n  def glb(a: TypeRepr, b: TypeRepr): TypeRepr = ???\n  \n  /**\n   * Check if a type conforms to given bounds.\n   */\n  def conformsToBounds(tpe: TypeRepr, bounds: TypeBounds)(using ctx: Context = Context()): Boolean = {\n    val lowerOk = bounds.lower.forall(lo => isSubtype(lo, tpe))\n    val upperOk = bounds.upper.forall(hi => isSubtype(tpe, hi))\n    lowerOk && upperOk\n  }\n  \n  /**\n   * Reduce a match type to its result, if possible.\n   * Returns None if the match type cannot be reduced (e.g., abstract scrutinee).\n   */\n  def reduceMatchType(mt: TypeRepr.MatchType)(using ctx: Context = Context()): Option[TypeRepr] = ???\n}\n```\n\n---\n\n## Standard Library Type Definitions\n\nPredefined `TypeId` instances for common types.\n```scala\nobject StandardTypes {\n  import TypeDefKind.*\n  \n  private val scalaOwner = Owner.pkg(\"scala\")\n  private val scalaCollectionImmutable = Owner.pkgs(\"scala\", \"collection\", \"immutable\")\n  private val javaLang = Owner.pkgs(\"java\", \"lang\")\n  \n  // ========== Primitives ==========\n  \n  val IntId: TypeId[Int] = TypeId.nominal[Int](\n    \"Int\", scalaOwner, Nil, Class(isFinal = true, isValue = true)\n  )\n  \n  val LongId: TypeId[Long] = TypeId.nominal[Long](\n    \"Long\", scalaOwner, Nil, Class(isFinal = true, isValue = true)\n  )\n  \n  val DoubleId: TypeId[Double] = TypeId.nominal[Double](\n    \"Double\", scalaOwner, Nil, Class(isFinal = true, isValue = true)\n  )\n  \n  val FloatId: TypeId[Float] = TypeId.nominal[Float](\n    \"Float\", scalaOwner, Nil, Class(isFinal = true, isValue = true)\n  )\n  \n  val BooleanId: TypeId[Boolean] = TypeId.nominal[Boolean](\n    \"Boolean\", scalaOwner, Nil, Class(isFinal = true, isValue = true)\n  )\n  \n  val CharId: TypeId[Char] = TypeId.nominal[Char](\n    \"Char\", scalaOwner, Nil, Class(isFinal = true, isValue = true)\n  )\n  \n  val ByteId: TypeId[Byte] = TypeId.nominal[Byte](\n    \"Byte\", scalaOwner, Nil, Class(isFinal = true, isValue = true)\n  )\n  \n  val ShortId: TypeId[Short] = TypeId.nominal[Short](\n    \"Short\", scalaOwner, Nil, Class(isFinal = true, isValue = true)\n  )\n  \n  val UnitId: TypeId[Unit] = TypeId.nominal[Unit](\n    \"Unit\", scalaOwner, Nil, Class(isFinal = true, isValue = true)\n  )\n  \n  // ========== Reference Types ==========\n  \n  val StringId: TypeId[String] = TypeId.nominal[String](\n    \"String\", javaLang, Nil, Class(isFinal = true)\n  )\n  \n  val AnyId: TypeId[Any] = TypeId.nominal[Any](\n    \"Any\", scalaOwner, Nil, Class(isAbstract = true)\n  )\n  \n  val AnyRefId: TypeId[AnyRef] = TypeId.nominal[AnyRef](\n    \"AnyRef\", scalaOwner, Nil, Class(isAbstract = true),\n    parents = List(TypeRepr.Ref(AnyId))\n  )\n  \n  val AnyValId: TypeId[AnyVal] = TypeId.nominal[AnyVal](\n    \"AnyVal\", scalaOwner, Nil, Class(isAbstract = true),\n    parents = List(TypeRepr.Ref(AnyId))\n  )\n  \n  val NothingId: TypeId[Nothing] = TypeId.nominal[Nothing](\n    \"Nothing\", scalaOwner, Nil, Class(isFinal = true, isAbstract = true)\n  )\n  \n  val NullId: TypeId[Null] = TypeId.nominal[Null](\n    \"Null\", scalaOwner, Nil, Class(isFinal = true)\n  )\n  \n  // ========== Collection Type Constructors ==========\n  \n  private val A = TypeParam.covariant(\"A\", 0)\n  private val K = TypeParam.invariant(\"K\", 0)\n  private val V = TypeParam.covariant(\"V\", 1)\n  \n  val ListId: TypeId[List] = TypeId.nominal[List](\n    \"List\", scalaCollectionImmutable, List(A), Trait(isSealed = true)\n  )\n  \n  val VectorId: TypeId[Vector] = TypeId.nominal[Vector](\n    \"Vector\", scalaCollectionImmutable, List(A), Class(isFinal = true)\n  )\n  \n  val SetId: TypeId[Set] = TypeId.nominal[Set](\n    \"Set\", scalaCollectionImmutable, List(A), Trait()\n  )\n  \n  val MapId: TypeId[Map] = TypeId.nominal[Map](\n    \"Map\", scalaCollectionImmutable, List(K, V), Trait()\n  )\n  \n  val OptionId: TypeId[Option] = TypeId.nominal[Option](\n    \"Option\", scalaOwner, List(A), Trait(isSealed = true)\n  )\n  \n  val EitherA = TypeParam.covariant(\"A\", 0)\n  val EitherB = TypeParam.covariant(\"B\", 1)\n  val EitherId: TypeId[Either] = TypeId.nominal[Either](\n    \"Either\", scalaOwner, List(EitherA, EitherB), Trait(isSealed = true)\n  )\n  \n  // ========== Tuple Type Constructors ==========\n  \n  val EmptyTupleId: TypeId[EmptyTuple] = TypeId.nominal[EmptyTuple](\n    \"EmptyTuple\", scalaOwner, Nil, Object\n  )\n  \n  val TupleConsH = TypeParam.covariant(\"H\", 0)\n  val TupleConsT = TypeParam.covariant(\"T\", 1, bounds = TypeBounds.upper(TypeRepr.Ref(???))) // <: Tuple\n  val TupleConsId: TypeId[*:] = TypeId.nominal[*:](\n    \"*:\", scalaOwner, List(TupleConsH, TupleConsT), Class(isFinal = true, isCase = true)\n  )\n  \n  // ========== Convenience TypeRepr Builders ==========\n  \n  def int: TypeRepr = TypeRepr.Ref(IntId)\n  def long: TypeRepr = TypeRepr.Ref(LongId)\n  def double: TypeRepr = TypeRepr.Ref(DoubleId)\n  def float: TypeRepr = TypeRepr.Ref(FloatId)\n  def boolean: TypeRepr = TypeRepr.Ref(BooleanId)\n  def string: TypeRepr = TypeRepr.Ref(StringId)\n  def unit: TypeRepr = TypeRepr.UnitType\n  def any: TypeRepr = TypeRepr.AnyType\n  def nothing: TypeRepr = TypeRepr.NothingType\n  \n  def list(elem: TypeRepr): TypeRepr = TypeRepr.Applied(TypeRepr.Ref(ListId), List(elem))\n  def option(elem: TypeRepr): TypeRepr = TypeRepr.Applied(TypeRepr.Ref(OptionId), List(elem))\n  def map(key: TypeRepr, value: TypeRepr): TypeRepr = TypeRepr.Applied(TypeRepr.Ref(MapId), List(key, value))\n  def either(left: TypeRepr, right: TypeRepr): TypeRepr = TypeRepr.Applied(TypeRepr.Ref(EitherId), List(left, right))\n}\n```\n\n---\n\n## Example Usage\n```scala\nobject Examples {\n  import TypeRepr.*\n  import StandardTypes.*\n  \n  // ========== Simple Types ==========\n  \n  val intType: TypeRepr = int\n  val stringType: TypeRepr = string\n  val listOfInt: TypeRepr = list(int)\n  val mapStringToInt: TypeRepr = map(string, int)\n  \n  // ========== Named Tuple ==========\n  \n  // (name: String, age: Int)\n  val personTuple: TypeRepr = Tuple.named(\n    \"name\" -> string,\n    \"age\" -> int\n  )\n  \n  // ========== Type Alias ==========\n  \n  // type Age = Int\n  val AgeId: TypeId[Int] = TypeId.alias[Int](\n    \"Age\",\n    Owner.pkg(\"myapp\"),\n    Nil,\n    int\n  )\n  \n  // type StringMap[V] = Map[String, V]\n  val V = TypeParam.covariant(\"V\", 0)\n  val StringMapId: TypeId[Map[String, *]] = TypeId.alias[Map[String, *]](\n    \"StringMap\",\n    Owner.pkg(\"myapp\"),\n    List(V),\n    Applied(Ref(MapId), List(string, ParamRef(V)))\n  )\n  \n  // ========== Opaque Type ==========\n  \n  // opaque type Email = String\n  val EmailId: TypeId[String] = TypeId.opaque[String](\n    \"Email\",\n    Owner.pkg(\"myapp\"),\n    Nil,\n    string\n  )\n  \n  // ========== Enum ==========\n  \n  val ColorId: TypeId[?] = TypeId.nominal(\n    \"Color\",\n    Owner.pkg(\"myapp\"),\n    Nil,\n    TypeDefKind.Enum(List(\n      EnumCaseInfo(\"Red\", 0, Nil, isObjectCase = true),\n      EnumCaseInfo(\"Green\", 1, Nil, isObjectCase = true),\n      EnumCaseInfo(\"Blue\", 2, Nil, isObjectCase = true),\n      EnumCaseInfo(\"RGB\", 3, List(\n        EnumCaseParam(\"r\", int),\n        EnumCaseParam(\"g\", int),\n        EnumCaseParam(\"b\", int)\n      ), isObjectCase = false)\n    ))\n  )\n  \n  // ========== Match Type ==========\n  \n  // type Elem[X] = X match { case String => Char; case Array[t] => t }\n  val X = TypeParam.invariant(\"X\", 0)\n  val t = TypeParam.invariant(\"t\", 0)\n  \n  val ElemId: TypeId[?] = TypeId.alias(\n    \"Elem\",\n    Owner.pkg(\"myapp\"),\n    List(X),\n    MatchType(\n      bound = any,\n      scrutinee = ParamRef(X),\n      cases = List(\n        MatchTypeCase(Nil, string, Ref(CharId)),\n        MatchTypeCase(\n          List(t),\n          Applied(Ref(???), List(ParamRef(t))), // Array[t]\n          ParamRef(t)\n        )\n      )\n    )\n  )\n  \n  // ========== Structural Type ==========\n  \n  // { def size: Int; val name: String }\n  val sizedNamed: TypeRepr = Structural(\n    parents = Nil,\n    members = List(\n      Member.Def(\"size\", Nil, Nil, int),\n      Member.Val(\"name\", string)\n    )\n  )\n  \n  // ========== Path-Dependent Type ==========\n  \n  // myModule.Inner.T\n  val pathDependent: TypeRepr = TypeSelect(\n    TermPath(List(\n      TermPath.Package(\"myapp\"),\n      TermPath.Module(\"myModule\"),\n      TermPath.Module(\"Inner\")\n    )),\n    \"T\"\n  )\n  \n  // ========== Intersection & Union ==========\n  \n  // String & { def foo: Int }\n  val stringWithFoo: TypeRepr = Intersection(\n    string,\n    Structural(Nil, List(Member.Def(\"foo\", Nil, Nil, int)))\n  )\n  \n  // String | Int\n  val stringOrInt: TypeRepr = Union(string, int)\n  \n  // ========== Function Types ==========\n  \n  // (Int, String) => Boolean\n  val func: TypeRepr = Function(List(int, string), boolean)\n  \n  // (Int, String) ?=> Boolean (context function)\n  val ctxFunc: TypeRepr = ContextFunction(List(int, string), boolean)\n  \n  // [A] => A => A (polymorphic function)\n  val polyFunc: TypeRepr = PolyFunction(\n    List(TypeParam.invariant(\"A\", 0)),\n    Function(List(ParamRef(TypeParam.invariant(\"A\", 0))), ParamRef(TypeParam.invariant(\"A\", 0)))\n  )\n}\n```\n\n---\n\n## Macro Derivation (Sketch)\n```scala\nimport scala.quoted.*\n\nobject TypeIdMacros {\n  \n  /**\n   * Derive a TypeId for any type or type constructor at compile time.\n   * Captures all type information available to the compiler.\n   */\n  inline def derive[A <: AnyKind]: TypeId[A] = ${ deriveMacro[A] }\n  \n  def deriveMacro[A <: AnyKind: Type](using Quotes): Expr[TypeId[A]] = {\n    import quotes.reflect.*\n    \n    val tpe = TypeRepr.of[A]\n    \n    // Extract type information from compiler\n    // ... implementation details ...\n    \n    ???\n  }\n  \n  /**\n   * Derive a TypeRepr for a concrete type at compile time.\n   */\n  inline def typeRepr[A]: TypeRepr = ${ typeReprMacro[A] }\n  \n  def typeReprMacro[A: Type](using Quotes): Expr[TypeRepr] = ???\n}\n```\n\n---\n\n## Open Questions / Future Work\n\n1. **Recursive type handling**: The `RecType`/`RecThis` encoding may need refinement for complex recursive types.\n\n2. **Match type reduction**: Full implementation requires tracking what patterns are \"provably disjoint.\"\n\n3. **Structural subtyping**: Member-by-member comparison with proper handling of overloaded methods.\n\n4. **Scala 2 compatibility**: Some constructs (existentials, compound types) may need additional representation.\n\n5. **Serialization format**: The data model is designed for runtime use; a compact serialization format (e.g., protobuf schema) would be a natural next step.",
                  "html_url": "https://github.com/zio/zio-blocks/issues/471"
                },
                "type": "github"
              },
              "hash": "zio/zio-blocks#471",
              "body": "# Design and Implement `TypeId` for Type Registry\n\n## Goal\n\nDesign and implement a `TypeId[A]` data structure that can faithfully represent any Scala type or type constructor, capturing sufficient metadata to support:\n\n- **Type identity**: Uniquely identifying types across serialization boundaries\n- **Subtype checking**: Implementing `isSubtypeOf` directly on `TypeId` without runtime reflection\n- **Type equality**: Determining structural and nominal type equivalence\n- **Map/Set keys**: Using `TypeId` as keys in type registries (requires correct `equals`/`hashCode`)\n- **Macro derivation**: Derivation of `TypeId` for any type or type constructor, source-compatible across Scala 2/3\n\nThe data type must be used to wholly replace `TypeName` in the source code of ZIO Blocks.\n\n## Requirements\n\n### API Surface\n```scala\n// Explicit derivation\nval stringId: TypeId[String] = TypeId.of[String]\nval listId: TypeId[List] = TypeId.of[List]  // Type constructors supported\n\n// Implicit derivation for generic code\ndef process[A](value: A)(implicit typeId: TypeId[A]): Unit = ???\n\n// Or using Scala 3 context bounds\ndef process[A: TypeId](value: A): Unit = ???\n\n// Use as map keys in type registries\nval registry: Map[TypeId[_], Binding[_]] = Map(\n  TypeId.of[String] -> stringBinding,\n  TypeId.of[List[Int]] -> listIntBinding\n)\n```\n\n### Cross-Version Support\n\n- **Scala 2.13**: Use `scala.reflect.macros` for compile-time derivation\n- **Scala 3.x (3.03.7+)**: Use `scala.quoted` macros\n\nThe runtime data model (`TypeId`, `TypeRepr`, etc.) should be shared across versions. Only the macro implementations differ.\n\n### Equals and HashCode Contract\n\n`TypeId` instances will be used as keys in `Map` and `Set` collections within type registries. The `equals` and `hashCode` implementations must satisfy the following requirements:\n\n#### Equality Semantics\n\n1. **Nominal identity for non-aliases**: Two `TypeId` instances referring to the same nominal type (same `fullName`) are equal, regardless of when/where the macro derived them.\n\n2. **Type alias transparency**: Type aliases should be equal to their underlying types after normalization.\n```scala\n   type Age = Int\n   TypeId.of[Age] == TypeId.of[Int]  // true (after normalization)\n```\n\n3. **Opaque type nominality**: Opaque types are *not* equal to their representation or to other opaque types.\n```scala\n   opaque type Email = String\n   opaque type UserId = String\n   TypeId.of[Email] == TypeId.of[String]  // false\n   TypeId.of[Email] == TypeId.of[UserId]  // false\n```\n\n4. **Applied types**: Two applied types are equal iff their type constructors are equal and all type arguments are equal.\n```scala\n   TypeId.of[List[Int]] == TypeId.of[List[Int]]      // true\n   TypeId.of[List[Int]] == TypeId.of[List[String]]  // false\n```\n\n5. **Structural types**: Two structural types are equal iff they have the same members (by name and type).\n\n6. **Compound types**: Order matters for intersections and unions (or they must be normalized to a canonical order).\n```scala\n   // Option A: Order-sensitive\n   TypeId.of[A & B] != TypeId.of[B & A]\n   \n   // Option B: Canonicalized (preferred)\n   TypeId.of[A & B] == TypeId.of[B & A]  // after sorting components\n```\n\n#### HashCode Requirements\n\n1. **Consistency**: `hashCode` must be consistent with `equals`equal objects must have equal hash codes.\n\n2. **Stability**: The same `TypeId` derived in different compilation units or at different times must produce the same `hashCode`.\n\n3. **Distribution**: Hash codes should be well-distributed to avoid collisions in hash maps.\n\n4. **Determinism**: `hashCode` must not depend on object identity, memory addresses, or other non-deterministic factors.\n\n#### Implementation Approach\n```scala\nsealed trait TypeId[A <: AnyKind] {\n  // ... other members ...\n\n  /** \n   * Equality based on normalized type structure.\n   * Type aliases are expanded before comparison.\n   */\n  override def equals(other: Any): Boolean = other match {\n    case that: TypeId[_] => TypeId.structurallyEqual(this, that)\n    case _ => false\n  }\n\n  /**\n   * Hash code based on normalized type structure.\n   * Must be consistent with equals.\n   */\n  override def hashCode(): Int = TypeId.structuralHash(this)\n}\n\nobject TypeId {\n  /**\n   * Compare two TypeIds for structural equality after normalization.\n   */\n  def structurallyEqual(a: TypeId[_], b: TypeId[_]): Boolean = {\n    // 1. Normalize both (expand aliases)\n    // 2. Compare structure recursively\n    // 3. For opaque types, compare by fullName only (nominal)\n    ???\n  }\n\n  /**\n   * Compute a stable hash code for a TypeId.\n   */\n  def structuralHash(id: TypeId[_]): Int = {\n    // 1. Normalize (expand aliases)\n    // 2. Compute hash from structural components\n    // 3. Must use stable values (fullName, not object identity)\n    ???\n  }\n}\n```\n\n#### Edge Cases\n\n- **Recursive types**: Must handle cycles without infinite loops in both `equals` and `hashCode`.\n- **Type parameters**: `TypeId.of[List]` (unapplied) must have different hash than `TypeId.of[List[Int]]` (applied).\n- **Path-dependent types**: `a.T` and `b.T` are equal only if `a` and `b` are the same stable path.\n- **Local types**: Types defined in local scopes need unique identification (e.g., include source location or synthetic index).\n\n### Key Operations\n```scala\ntrait TypeId[A <: AnyKind] {\n  def name: String\n  def fullName: String\n  def owner: Owner\n  def typeParams: List[TypeParam]\n  def parents: List[TypeRepr]\n  \n  // Core operations\n  def isSubtypeOf(other: TypeId[_]): Boolean\n  def isSupertypeOf(other: TypeId[_]): Boolean\n  def isEquivalentTo(other: TypeId[_]): Boolean\n  \n  // Equality (for use as map keys)\n  override def equals(other: Any): Boolean\n  override def hashCode(): Int\n}\n```\n\n## Attached Design Document\n\nSee the attached `TypeId-DataModel.md` for a comprehensive sketch of:\n\n- Core data structures (`TypeId`, `TypeRepr`, `TypeParam`, `Owner`, etc.)\n- Type expression representation (applied types, intersections, unions, match types, etc.)\n- Variance and bounds modeling\n- Substitution and normalization algorithms\n- Standard library type definitions\n\n> [!WARNING]\n> **The attached document is a design sketch, not production code.** Some details may be incorrect, incomplete, or require adjustment during implementation. It should be treated as a starting point for discussion and iteration, not a specification to implement verbatim.\n\n## Test Strategy\n\nComprehensive testing should validate four layers: **macro derivation correctness**, **data model completeness**, **type operation correctness**, and **equals/hashCode correctness**.\n\n### 1. Equals and HashCode Tests\n\nThese tests are critical since `TypeId` will be used as map keys.\n\n#### Basic Contract Tests\n```scala\ntest(\"equals is reflexive\") {\n  val id = TypeId.of[String]\n  assertTrue(id == id)\n  assertTrue(id.equals(id))\n}\n\ntest(\"equals is symmetric\") {\n  val id1 = TypeId.of[String]\n  val id2 = TypeId.of[String]\n  assertTrue(id1 == id2)\n  assertTrue(id2 == id1)\n}\n\ntest(\"equals is transitive\") {\n  val id1 = TypeId.of[String]\n  val id2 = TypeId.of[String]\n  val id3 = TypeId.of[String]\n  assertTrue(id1 == id2)\n  assertTrue(id2 == id3)\n  assertTrue(id1 == id3)\n}\n\ntest(\"hashCode is consistent with equals\") {\n  val id1 = TypeId.of[String]\n  val id2 = TypeId.of[String]\n  assertTrue(id1 == id2)\n  assertTrue(id1.hashCode == id2.hashCode)\n}\n\ntest(\"hashCode is stable across invocations\") {\n  val id = TypeId.of[List[Int]]\n  val hash1 = id.hashCode\n  val hash2 = id.hashCode\n  assertTrue(hash1 == hash2)\n}\n```\n\n#### Nominal Type Equality\n```scala\ntest(\"same nominal types are equal\") {\n  assertTrue(TypeId.of[String] == TypeId.of[String])\n  assertTrue(TypeId.of[Int] == TypeId.of[Int])\n  assertTrue(TypeId.of[List[Int]] == TypeId.of[List[Int]])\n}\n\ntest(\"different nominal types are not equal\") {\n  assertTrue(TypeId.of[String] != TypeId.of[Int])\n  assertTrue(TypeId.of[List[Int]] != TypeId.of[List[String]])\n  assertTrue(TypeId.of[List[Int]] != TypeId.of[Vector[Int]])\n}\n```\n\n#### Type Alias Equality\n```scala\ntest(\"type aliases equal their underlying types\") {\n  type Age = Int\n  type Name = String\n  \n  assertTrue(TypeId.of[Age] == TypeId.of[Int])\n  assertTrue(TypeId.of[Name] == TypeId.of[String])\n  assertTrue(TypeId.of[Age].hashCode == TypeId.of[Int].hashCode)\n}\n\ntest(\"chained type aliases resolve correctly\") {\n  type A = Int\n  type B = A\n  type C = B\n  \n  assertTrue(TypeId.of[C] == TypeId.of[Int])\n  assertTrue(TypeId.of[C] == TypeId.of[A])\n  assertTrue(TypeId.of[C] == TypeId.of[B])\n}\n\ntest(\"generic type aliases equal their expansion\") {\n  type MyList[A] = List[A]\n  \n  assertTrue(TypeId.of[MyList[Int]] == TypeId.of[List[Int]])\n  assertTrue(TypeId.of[MyList[String]] == TypeId.of[List[String]])\n}\n```\n\n#### Opaque Type Equality\n```scala\ntest(\"opaque types are not equal to their representation\") {\n  opaque type Email = String\n  \n  assertTrue(TypeId.of[Email] != TypeId.of[String])\n  assertTrue(TypeId.of[Email].hashCode != TypeId.of[String].hashCode) // likely but not guaranteed\n}\n\ntest(\"different opaque types are not equal even with same representation\") {\n  opaque type Email = String\n  opaque type UserId = String\n  \n  assertTrue(TypeId.of[Email] != TypeId.of[UserId])\n}\n\ntest(\"same opaque type is equal to itself\") {\n  opaque type Email = String\n  \n  assertTrue(TypeId.of[Email] == TypeId.of[Email])\n}\n```\n\n#### Applied Type Equality\n```scala\ntest(\"applied types with same constructor and args are equal\") {\n  assertTrue(TypeId.of[List[Int]] == TypeId.of[List[Int]])\n  assertTrue(TypeId.of[Map[String, Int]] == TypeId.of[Map[String, Int]])\n  assertTrue(TypeId.of[Either[String, Int]] == TypeId.of[Either[String, Int]])\n}\n\ntest(\"applied types with different args are not equal\") {\n  assertTrue(TypeId.of[List[Int]] != TypeId.of[List[String]])\n  assertTrue(TypeId.of[Map[String, Int]] != TypeId.of[Map[Int, String]])\n}\n\ntest(\"unapplied type constructor not equal to applied type\") {\n  assertTrue(TypeId.of[List] != TypeId.of[List[Int]])\n  assertTrue(TypeId.of[Map] != TypeId.of[Map[String, Int]])\n}\n```\n\n#### Compound Type Equality\n```scala\ntest(\"intersection types equality\") {\n  // Assuming canonicalized ordering\n  assertTrue(TypeId.of[Serializable & Comparable[String]] == TypeId.of[Serializable & Comparable[String]])\n}\n\ntest(\"union types equality\") {\n  assertTrue(TypeId.of[Int | String] == TypeId.of[Int | String])\n}\n```\n\n#### Map/Set Usage Tests\n```scala\ntest(\"TypeId works as Map key\") {\n  val map = Map[TypeId[_], String](\n    TypeId.of[String] -> \"string\",\n    TypeId.of[Int] -> \"int\",\n    TypeId.of[List[Int]] -> \"list-int\"\n  )\n  \n  assertTrue(map(TypeId.of[String]) == \"string\")\n  assertTrue(map(TypeId.of[Int]) == \"int\")\n  assertTrue(map(TypeId.of[List[Int]]) == \"list-int\")\n  assertTrue(map.get(TypeId.of[Double]).isEmpty)\n}\n\ntest(\"TypeId works as Map key with type aliases\") {\n  type Age = Int\n  \n  val map = Map[TypeId[_], String](\n    TypeId.of[Int] -> \"int\"\n  )\n  \n  // Should find the entry via alias\n  assertTrue(map(TypeId.of[Age]) == \"int\")\n}\n\ntest(\"TypeId works in Set\") {\n  val set = Set(\n    TypeId.of[String],\n    TypeId.of[Int],\n    TypeId.of[List[Int]]\n  )\n  \n  assertTrue(set.contains(TypeId.of[String]))\n  assertTrue(set.contains(TypeId.of[Int]))\n  assertTrue(!set.contains(TypeId.of[Double]))\n}\n\ntest(\"TypeId deduplication in Set\") {\n  type Age = Int\n  \n  val set = Set(\n    TypeId.of[Int],\n    TypeId.of[Age]  // Should deduplicate\n  )\n  \n  assertTrue(set.size == 1)\n}\n\ntest(\"mutable HashMap works with TypeId\") {\n  val map = scala.collection.mutable.HashMap[TypeId[_], String]()\n  \n  map(TypeId.of[String]) = \"string\"\n  map(TypeId.of[Int]) = \"int\"\n  \n  assertTrue(map(TypeId.of[String]) == \"string\")\n  \n  // Update via equal key\n  type Name = String\n  map(TypeId.of[Name]) = \"updated\"\n  assertTrue(map(TypeId.of[String]) == \"updated\")\n}\n```\n\n#### Cross-Compilation Equality\n```scala\ntest(\"TypeId equality is stable across compilation units\") {\n  // id1 derived in CompilationUnitA\n  val id1 = CompilationUnitA.stringTypeId\n  // id2 derived in CompilationUnitB  \n  val id2 = CompilationUnitB.stringTypeId\n  \n  assertTrue(id1 == id2)\n  assertTrue(id1.hashCode == id2.hashCode)\n}\n```\n\n### 2. Macro Derivation Tests\n\nVerify that the macro correctly captures type information for all supported type forms.\n\n#### Primitive and Basic Types\n```scala\ntest(\"derives primitives correctly\") {\n  assertTrue(TypeId.of[Int].name == \"Int\")\n  assertTrue(TypeId.of[String].fullName == \"java.lang.String\")\n  assertTrue(TypeId.of[Unit].isValueClass)\n}\n```\n\n#### Generic Types and Type Constructors\n```scala\ntest(\"derives type constructors\") {\n  val listId = TypeId.of[List]\n  assertTrue(listId.arity == 1)\n  assertTrue(listId.typeParams.head.variance == Variance.Covariant)\n}\n\ntest(\"derives applied types\") {\n  val listIntId = TypeId.of[List[Int]]\n  // Should capture that this is List applied to Int\n}\n\ntest(\"derives higher-kinded types\") {\n  val functorId = TypeId.of[Functor]  // Functor[F[_]]\n  assertTrue(functorId.typeParams.head.kind == Kind.`* -> *`)\n}\n```\n\n#### Type Aliases and Opaque Types\n```scala\ntype Age = Int\nopaque type Email = String\n\ntest(\"derives type aliases\") {\n  val ageId = TypeId.of[Age]\n  assertTrue(ageId.isAlias)\n  assertTrue(ageId.aliasedTo == Some(TypeRepr.Ref(TypeId.of[Int])))\n}\n\ntest(\"derives opaque types\") {\n  val emailId = TypeId.of[Email]\n  assertTrue(emailId.isOpaque)\n  // Representation should be captured\n}\n```\n\n#### Classes, Traits, Objects, Enums\n```scala\nsealed trait Animal\ncase class Dog(name: String) extends Animal\ncase object Cat extends Animal\n\nenum Color { case Red, Green, Blue, RGB(r: Int, g: Int, b: Int) }\n\ntest(\"derives sealed hierarchy\") {\n  val animalId = TypeId.of[Animal]\n  assertTrue(animalId.isSealed)\n  assertTrue(animalId.defKind match {\n    case TypeDefKind.Trait(true, subtypes) => subtypes.nonEmpty\n    case _ => false\n  })\n}\n\ntest(\"derives enums with cases\") {\n  val colorId = TypeId.of[Color]\n  assertTrue(colorId.enumCases.map(_.name) == List(\"Red\", \"Green\", \"Blue\", \"RGB\"))\n  assertTrue(colorId.enumCases.find(_.name == \"RGB\").exists(_.params.nonEmpty))\n}\n```\n\n#### Structural and Refinement Types\n```scala\ntest(\"derives structural types\") {\n  type Sized = { def size: Int }\n  val sizedId = TypeId.of[Sized]\n  // Should capture the structural member\n}\n```\n\n#### Compound Types\n```scala\ntest(\"derives intersection types\") {\n  val id = TypeId.of[String & Serializable]\n  // Should capture both components\n}\n\ntest(\"derives union types\") {\n  val id = TypeId.of[String | Int]\n  // Should capture both components\n}\n```\n\n#### Tuple Types (Including Named Tuples for Scala 3.5+)\n```scala\ntest(\"derives positional tuples\") {\n  val id = TypeId.of[(Int, String, Boolean)]\n  // Should capture element types\n}\n\ntest(\"derives named tuples\") {  // Scala 3.5+\n  val id = TypeId.of[(name: String, age: Int)]\n  // Should capture labels and types\n}\n```\n\n#### Function Types\n```scala\ntest(\"derives function types\") {\n  val id = TypeId.of[(Int, String) => Boolean]\n  // Should capture param types and result type\n}\n\ntest(\"derives context function types\") {  // Scala 3\n  val id = TypeId.of[(Int, String) ?=> Boolean]\n}\n\ntest(\"derives polymorphic function types\") {  // Scala 3\n  val id = TypeId.of[[A] => A => A]\n}\n```\n\n#### Path-Dependent and Singleton Types\n```scala\nobject Outer {\n  object Inner {\n    type T = Int\n  }\n  val inner: Inner.type = Inner\n}\n\ntest(\"derives path-dependent types\") {\n  val id = TypeId.of[Outer.Inner.T]\n  // Should capture the path\n}\n\ntest(\"derives singleton types\") {\n  val id = TypeId.of[Outer.Inner.type]\n}\n```\n\n#### Match Types (Scala 3)\n```scala\ntype Elem[X] = X match {\n  case String => Char\n  case Array[t] => t\n}\n\ntest(\"derives match types\") {\n  val id = TypeId.of[Elem]\n  // Should capture scrutinee, cases, and binders\n}\n```\n\n### 3. Data Model Completeness Tests\n\nVerify that round-tripping through the model preserves type information.\n```scala\ntest(\"TypeRepr substitution is correct\") {\n  val A = TypeParam(\"A\", 0)\n  val listOfA = TypeRepr.Applied(TypeRepr.Ref(listId), List(TypeRepr.ParamRef(A)))\n  val substituted = listOfA.substitute(Map(A -> TypeRepr.Ref(intId)))\n  assertTrue(substituted == TypeRepr.Applied(TypeRepr.Ref(listId), List(TypeRepr.Ref(intId))))\n}\n\ntest(\"normalization expands aliases\") {\n  type MyInt = Int\n  val myIntRepr = TypeRepr.Ref(TypeId.of[MyInt])\n  val normalized = TypeNormalization.normalize(myIntRepr)\n  assertTrue(normalized == TypeRepr.Ref(TypeId.of[Int]))\n}\n```\n\n### 4. Subtyping Tests\n\nVerify that `isSubtypeOf` correctly implements Scala's subtyping rules.\n\n#### Basic Subtyping\n```scala\ntest(\"Nothing is subtype of everything\") {\n  assertTrue(TypeId.of[Nothing].isSubtypeOf(TypeId.of[Int]))\n  assertTrue(TypeId.of[Nothing].isSubtypeOf(TypeId.of[String]))\n  assertTrue(TypeId.of[Nothing].isSubtypeOf(TypeId.of[Any]))\n}\n\ntest(\"everything is subtype of Any\") {\n  assertTrue(TypeId.of[Int].isSubtypeOf(TypeId.of[Any]))\n  assertTrue(TypeId.of[String].isSubtypeOf(TypeId.of[Any]))\n  assertTrue(TypeId.of[List[Int]].isSubtypeOf(TypeId.of[Any]))\n}\n\ntest(\"reflexivity\") {\n  assertTrue(TypeId.of[String].isSubtypeOf(TypeId.of[String]))\n  assertTrue(TypeId.of[List[Int]].isSubtypeOf(TypeId.of[List[Int]]))\n}\n```\n\n#### Variance-Aware Subtyping\n```scala\ntest(\"covariant type parameter subtyping\") {\n  // List is covariant: List[Dog] <: List[Animal]\n  assertTrue(TypeId.of[List[Dog]].isSubtypeOf(TypeId.of[List[Animal]]))\n  assertTrue(!TypeId.of[List[Animal]].isSubtypeOf(TypeId.of[List[Dog]]))\n}\n\ntest(\"contravariant type parameter subtyping\") {\n  // Function1 is contravariant in input: (Animal => Int) <: (Dog => Int)\n  assertTrue(TypeId.of[Animal => Int].isSubtypeOf(TypeId.of[Dog => Int]))\n  assertTrue(!TypeId.of[Dog => Int].isSubtypeOf(TypeId.of[Animal => Int]))\n}\n\ntest(\"invariant type parameter subtyping\") {\n  // Array is invariant\n  assertTrue(!TypeId.of[Array[Dog]].isSubtypeOf(TypeId.of[Array[Animal]]))\n  assertTrue(!TypeId.of[Array[Animal]].isSubtypeOf(TypeId.of[Array[Dog]]))\n}\n```\n\n#### Union and Intersection Types\n```scala\ntest(\"union type subtyping\") {\n  // A <: A | B and B <: A | B\n  assertTrue(TypeId.of[Int].isSubtypeOf(TypeId.of[Int | String]))\n  assertTrue(TypeId.of[String].isSubtypeOf(TypeId.of[Int | String]))\n  \n  // A | B <: C requires both A <: C and B <: C\n  assertTrue(!TypeId.of[Int | String].isSubtypeOf(TypeId.of[Int]))\n}\n\ntest(\"intersection type subtyping\") {\n  // A & B <: A and A & B <: B\n  assertTrue(TypeId.of[Serializable & Comparable[String]].isSubtypeOf(TypeId.of[Serializable]))\n  \n  // A <: B & C requires A <: B and A <: C\n}\n```\n\n#### Nominal Hierarchy Subtyping\n```scala\ntest(\"class hierarchy subtyping\") {\n  assertTrue(TypeId.of[Dog].isSubtypeOf(TypeId.of[Animal]))\n  assertTrue(TypeId.of[String].isSubtypeOf(TypeId.of[CharSequence]))\n}\n```\n\n#### Type Alias Transparency\n```scala\ntest(\"type aliases are transparent for subtyping\") {\n  type Age = Int\n  assertTrue(TypeId.of[Age].isSubtypeOf(TypeId.of[Int]))\n  assertTrue(TypeId.of[Int].isSubtypeOf(TypeId.of[Age]))\n  assertTrue(TypeId.of[Age].isEquivalentTo(TypeId.of[Int]))\n}\n```\n\n#### Opaque Type Nominality\n```scala\ntest(\"opaque types are nominally distinct\") {\n  opaque type Email = String\n  opaque type UserId = String\n  \n  assertTrue(!TypeId.of[Email].isSubtypeOf(TypeId.of[String]))  // Outside defining scope\n  assertTrue(!TypeId.of[Email].isSubtypeOf(TypeId.of[UserId]))\n}\n```\n\n### 5. Edge Cases and Regression Tests\n```scala\ntest(\"handles recursive types\") {\n  enum Tree[+A] {\n    case Leaf(value: A)\n    case Branch(left: Tree[A], right: Tree[A])\n  }\n  val treeId = TypeId.of[Tree]\n  // Should not stack overflow on equals/hashCode\n  val hash = treeId.hashCode  // Must terminate\n  assertTrue(treeId == treeId)    // Must terminate\n}\n\ntest(\"handles deeply nested generics\") {\n  val id = TypeId.of[List[Map[String, Option[Either[Int, List[String]]]]]]\n  // Should capture full structure\n  val hash = id.hashCode\n  assertTrue(id == TypeId.of[List[Map[String, Option[Either[Int, List[String]]]]]])\n}\n\ntest(\"handles local and anonymous types\") {\n  def foo() = {\n    class Local\n    TypeId.of[Local]\n  }\n  // Should handle gracefully\n}\n\ntest(\"handles Java types\") {\n  val id = TypeId.of[java.util.ArrayList[String]]\n  // Should interop correctly\n}\n```\n\n### 6. Cross-Compilation Tests\n\nRun the same test suite on both Scala 2.13 and Scala 3.x to ensure consistent behavior:\n```scala\n// In shared test sources\nclass TypeIdSpec extends AnyFunSuite {\n  // All tests above should pass on both Scala versions\n}\n```\n\nSpecific attention should be paid to:\n- Features that exist only in Scala 3 (union/intersection types, enums, match types, named tuples)\n- Features with different representations (Scala 2 existentials vs Scala 3 wildcards)\n- Macro API differences (should be invisible to users but implementation must handle both)\n- **Equality of TypeIds derived in Scala 2 vs Scala 3 for the same type** (if cross-published)\n\n## Acceptance Criteria\n\n- [ ] `TypeId.of[A]` works for all documented type forms on Scala 2.13\n- [ ] `TypeId.of[A]` works for all documented type forms on Scala 3.03.7\n- [ ] `implicit TypeId[A]` derivation works in generic contexts\n- [ ] `isSubtypeOf` correctly handles variance, unions, intersections, and nominal hierarchies\n- [ ] Type aliases are normalized correctly\n- [ ] Opaque types maintain nominal distinction\n- [ ] **`equals` and `hashCode` satisfy the Java contract**\n- [ ] **`TypeId` works correctly as `Map` and `Set` keys**\n- [ ] **Type aliases resolve to equal `TypeId` as their underlying types**\n- [ ] **Opaque types have distinct `TypeId` from their representation**\n- [ ] **`hashCode` is stable and deterministic across compilations**\n- [ ] All tests pass on both Scala versions\n- [ ] No runtime reflection is required (all information captured at compile time)\n\n# Sketch of TypeId\n\n# TypeId Data Model for Scala 3.x Type Registry\n\nA comprehensive data model for representing Scala 3 types and type constructors, designed to support:\n- Lossless type representation for serialization/deserialization frameworks\n- Subtype checking (`isSubtypeOf`)\n- Type equality checking\n- Type normalization (alias expansion)\n\n## Design Principles\n\n1. **Polykinded phantom types**: `TypeId[A <: AnyKind]` preserves Scala type information at compile time\n2. **Separation of identity and representation**: `TypeId` identifies types; `TypeRepr` represents type expressions\n3. **Complete metadata**: Capture everything a macro can know at compile time\n4. **Stability tracking**: Path-dependent types require knowing path stability\n\n---\n\n## Core Data Model\n\n### Variance\n```scala\nenum Variance {\n  case Invariant\n  case Covariant\n  case Contravariant\n\n  def symbol: String = this match {\n    case Invariant     => \"\"\n    case Covariant     => \"+\"\n    case Contravariant => \"-\"\n  }\n\n  /** Flip variance for contravariant positions */\n  def flip: Variance = this match {\n    case Invariant     => Invariant\n    case Covariant     => Contravariant\n    case Contravariant => Covariant\n  }\n}\n```\n\n### TypeBounds\n```scala\nfinal case class TypeBounds(\n  lower: Option[TypeRepr],  // >: bound\n  upper: Option[TypeRepr]   // <: bound\n) {\n  def isUnbounded: Boolean = lower.isEmpty && upper.isEmpty\n  \n  def hasLower: Boolean = lower.isDefined\n  def hasUpper: Boolean = upper.isDefined\n  \n  /** Combine bounds (intersection of constraints) */\n  def &(other: TypeBounds): TypeBounds = TypeBounds(\n    lower = (lower, other.lower) match {\n      case (Some(l1), Some(l2)) => Some(TypeRepr.Union(l1, l2))\n      case (Some(l), None) => Some(l)\n      case (None, Some(l)) => Some(l)\n      case (None, None) => None\n    },\n    upper = (upper, other.upper) match {\n      case (Some(u1), Some(u2)) => Some(TypeRepr.Intersection(u1, u2))\n      case (Some(u), None) => Some(u)\n      case (None, Some(u)) => Some(u)\n      case (None, None) => None\n    }\n  )\n}\n\nobject TypeBounds {\n  val empty: TypeBounds = TypeBounds(None, None)\n  \n  def upper(tpe: TypeRepr): TypeBounds = TypeBounds(None, Some(tpe))\n  def lower(tpe: TypeRepr): TypeBounds = TypeBounds(Some(tpe), None)\n  def exact(tpe: TypeRepr): TypeBounds = TypeBounds(Some(tpe), Some(tpe))\n}\n```\n\n### Kind\n\nRepresents the \"type of a type\" - distinguishing proper types from type constructors.\n```scala\nsealed trait Kind {\n  def arity: Int\n  def isProperType: Boolean = this == Kind.Type\n  def isHigherKinded: Boolean = !isProperType\n}\n\nobject Kind {\n  /** Proper type: Int, String, List[Int] */\n  case object Type extends Kind { \n    def arity: Int = 0 \n  }\n\n  /** Type constructor: List, Option, Map */\n  final case class Arrow(params: List[Kind], result: Kind) extends Kind {\n    def arity: Int = params.size\n  }\n\n  // Convenience constructors\n  val `* -> *`: Kind = Arrow(List(Type), Type)\n  val `* -> * -> *`: Kind = Arrow(List(Type, Type), Type)\n  val `(* -> *) -> *`: Kind = Arrow(List(`* -> *`), Type)\n  \n  def arity(n: Int): Kind = \n    if (n == 0) Type \n    else Arrow(List.fill(n)(Type), Type)\n}\n```\n\n### TypeParam\n\nComplete type parameter specification with all information needed for subtyping.\n```scala\nfinal case class TypeParam(\n  name: String,\n  index: Int,\n  variance: Variance = Variance.Invariant,\n  bounds: TypeBounds = TypeBounds.empty,\n  kind: Kind = Kind.Type\n) {\n  def isHigherKinded: Boolean = kind.isHigherKinded\n  def isCovariant: Boolean = variance == Variance.Covariant\n  def isContravariant: Boolean = variance == Variance.Contravariant\n  def isInvariant: Boolean = variance == Variance.Invariant\n}\n\nobject TypeParam {\n  def invariant(name: String, index: Int): TypeParam = \n    TypeParam(name, index, Variance.Invariant)\n    \n  def covariant(name: String, index: Int): TypeParam = \n    TypeParam(name, index, Variance.Covariant)\n    \n  def contravariant(name: String, index: Int): TypeParam = \n    TypeParam(name, index, Variance.Contravariant)\n}\n```\n\n---\n\n## Type Definition Classification\n\n### TypeDefKind\n\nClassifies what kind of type definition a `TypeId` represents.\n```scala\nsealed trait TypeDefKind\n\nobject TypeDefKind {\n  final case class Class(\n    isFinal: Boolean = false,\n    isAbstract: Boolean = false,\n    isCase: Boolean = false,\n    isValue: Boolean = false  // extends AnyVal\n  ) extends TypeDefKind\n\n  final case class Trait(\n    isSealed: Boolean = false,\n    knownSubtypes: List[TypeRepr] = Nil\n  ) extends TypeDefKind\n\n  /** Singleton object */\n  case object Object extends TypeDefKind\n\n  /** Scala 3 enum */\n  final case class Enum(\n    cases: List[EnumCaseInfo]\n  ) extends TypeDefKind\n\n  /** Individual enum case (when represented as its own type) */\n  final case class EnumCase(\n    parentEnum: TypeRepr,\n    ordinal: Int,\n    isObjectCase: Boolean  // case Red vs case RGB(...)\n  ) extends TypeDefKind\n\n  /** Type alias: type Foo = Bar */\n  case object TypeAlias extends TypeDefKind\n\n  /** Opaque type: opaque type Foo = Bar */\n  final case class OpaqueType(\n    publicBounds: TypeBounds  // Bounds visible outside defining scope\n  ) extends TypeDefKind\n\n  /** Abstract type member */\n  case object AbstractType extends TypeDefKind\n}\n\n/** Information about an enum case for serialization */\nfinal case class EnumCaseInfo(\n  name: String,\n  ordinal: Int,\n  params: List[EnumCaseParam],  // Empty for object cases\n  isObjectCase: Boolean\n) {\n  def arity: Int = params.size\n}\n\nfinal case class EnumCaseParam(\n  name: String,\n  tpe: TypeRepr\n)\n```\n\n---\n\n## Parameters and Clauses\n\n### ParamClause\n```scala\nsealed trait ParamClause {\n  def params: List[Param]\n  def isEmpty: Boolean = params.isEmpty\n  def size: Int = params.size\n}\n\nobject ParamClause {\n  final case class Regular(params: List[Param]) extends ParamClause\n  final case class Using(params: List[Param]) extends ParamClause\n  final case class Implicit(params: List[Param]) extends ParamClause\n  \n  val empty: ParamClause = Regular(Nil)\n}\n```\n\n### Param\n```scala\nfinal case class Param(\n  name: String,\n  tpe: TypeRepr,\n  hasDefault: Boolean = false,\n  isRepeated: Boolean = false  // varargs: A*\n)\n```\n\n---\n\n## Ownership and Paths\n\n### Owner\n\nRepresents the lexical owner of a type definition.\n```scala\nfinal case class Owner(segments: List[Owner.Segment]) {\n  def /(segment: Owner.Segment): Owner = Owner(segments :+ segment)\n  \n  def parent: Option[Owner] = \n    if (segments.isEmpty) None \n    else Some(Owner(segments.init))\n  \n  def isRoot: Boolean = segments.isEmpty\n  \n  def asString: String = segments.map(_.show).mkString(\".\")\n  \n  /** Check if this owner is a prefix of another */\n  def isPrefixOf(other: Owner): Boolean =\n    other.segments.startsWith(segments)\n}\n\nobject Owner {\n  sealed trait Segment {\n    def name: String\n    def show: String = name\n  }\n\n  final case class Package(name: String) extends Segment\n  final case class Term(name: String) extends Segment\n  final case class Type(name: String) extends Segment\n  final case class Local(index: Int) extends Segment {\n    def name: String = s\"<local$index>\"\n  }\n\n  val Root: Owner = Owner(Nil)\n  \n  def pkg(name: String): Owner = Owner(List(Package(name)))\n  def pkgs(names: String*): Owner = Owner(names.map(Package(_)).toList)\n}\n```\n\n### TermPath\n\nRepresents paths to terms, used for singleton and path-dependent types.\n```scala\nfinal case class TermPath(segments: List[TermPath.Segment]) {\n  def /(segment: TermPath.Segment): TermPath = \n    TermPath(segments :+ segment)\n  \n  def isStable: Boolean = segments.forall(_.isStable)\n  \n  def asString: String = segments.map(_.name).mkString(\".\")\n}\n\nobject TermPath {\n  sealed trait Segment {\n    def name: String\n    def isStable: Boolean\n  }\n\n  /** Package reference - always stable */\n  final case class Package(name: String) extends Segment {\n    def isStable: Boolean = true\n  }\n\n  /** Object/module reference - always stable */\n  final case class Module(name: String) extends Segment {\n    def isStable: Boolean = true\n  }\n\n  /** Val reference - stable */\n  final case class Val(name: String) extends Segment {\n    def isStable: Boolean = true\n  }\n\n  /** Lazy val reference - stable */\n  final case class LazyVal(name: String) extends Segment {\n    def isStable: Boolean = true\n  }\n\n  /** Var reference - NOT stable */\n  final case class Var(name: String) extends Segment {\n    def isStable: Boolean = false\n  }\n\n  /** Def/method reference - NOT stable */\n  final case class Def(name: String) extends Segment {\n    def isStable: Boolean = false\n  }\n\n  /** This reference */\n  final case class This(ownerName: String) extends Segment {\n    def name: String = s\"$ownerName.this\"\n    def isStable: Boolean = true\n  }\n\n  /** Super reference */\n  final case class Super(ownerName: String, mixinName: Option[String]) extends Segment {\n    def name: String = mixinName.fold(s\"$ownerName.super\")(m => s\"$ownerName.super[$m]\")\n    def isStable: Boolean = true\n  }\n\n  val empty: TermPath = TermPath(Nil)\n}\n```\n\n---\n\n## TypeId: Type Identity\n\nThe primary type for identifying types and type constructors.\n```scala\nsealed trait TypeId[A <: AnyKind] {\n  def name: String\n  def owner: Owner\n  def typeParams: List[TypeParam]\n  def defKind: TypeDefKind\n  def parents: List[TypeRepr]\n  def selfType: Option[TypeRepr]\n  def aliasedTo: Option[TypeRepr]      // For type aliases\n  def representation: Option[TypeRepr] // For opaque types\n  def annotations: List[Annotation]\n\n  // Derived properties\n  final def arity: Int = typeParams.size\n  \n  final def fullName: String =\n    if (owner.isRoot) name\n    else s\"${owner.asString}.$name\"\n\n  final def isProperType: Boolean = arity == 0\n  final def isTypeConstructor: Boolean = arity > 0\n\n  final def isClass: Boolean = defKind.isInstanceOf[TypeDefKind.Class]\n  final def isTrait: Boolean = defKind.isInstanceOf[TypeDefKind.Trait]\n  final def isObject: Boolean = defKind == TypeDefKind.Object\n  final def isEnum: Boolean = defKind.isInstanceOf[TypeDefKind.Enum]\n  final def isAlias: Boolean = defKind == TypeDefKind.TypeAlias\n  final def isOpaque: Boolean = defKind.isInstanceOf[TypeDefKind.OpaqueType]\n  final def isAbstract: Boolean = defKind == TypeDefKind.AbstractType\n\n  final def isSealed: Boolean = defKind match {\n    case TypeDefKind.Trait(isSealed, _) => isSealed\n    case _ => false\n  }\n\n  final def isCaseClass: Boolean = defKind match {\n    case TypeDefKind.Class(_, _, isCase, _) => isCase\n    case _ => false\n  }\n\n  final def isValueClass: Boolean = defKind match {\n    case TypeDefKind.Class(_, _, _, isValue) => isValue\n    case _ => false\n  }\n  \n  /** Get enum cases if this is an enum */\n  final def enumCases: List[EnumCaseInfo] = defKind match {\n    case TypeDefKind.Enum(cases) => cases\n    case _ => Nil\n  }\n}\n\nobject TypeId {\n  private final case class Impl[A <: AnyKind](\n    name: String,\n    owner: Owner,\n    typeParams: List[TypeParam],\n    defKind: TypeDefKind,\n    parents: List[TypeRepr],\n    selfType: Option[TypeRepr],\n    aliasedTo: Option[TypeRepr],\n    representation: Option[TypeRepr],\n    annotations: List[Annotation]\n  ) extends TypeId[A]\n\n  // ========== Smart Constructors ==========\n\n  def nominal[A <: AnyKind](\n    name: String,\n    owner: Owner,\n    typeParams: List[TypeParam] = Nil,\n    defKind: TypeDefKind,\n    parents: List[TypeRepr] = Nil,\n    selfType: Option[TypeRepr] = None,\n    annotations: List[Annotation] = Nil\n  ): TypeId[A] = Impl[A](\n    name, owner, typeParams, defKind,\n    parents, selfType, None, None, annotations\n  )\n\n  def alias[A <: AnyKind](\n    name: String,\n    owner: Owner,\n    typeParams: List[TypeParam] = Nil,\n    aliased: TypeRepr,\n    annotations: List[Annotation] = Nil\n  ): TypeId[A] = Impl[A](\n    name, owner, typeParams, TypeDefKind.TypeAlias,\n    Nil, None, Some(aliased), None, annotations\n  )\n\n  def opaque[A <: AnyKind](\n    name: String,\n    owner: Owner,\n    typeParams: List[TypeParam] = Nil,\n    representation: TypeRepr,\n    publicBounds: TypeBounds = TypeBounds.empty,\n    annotations: List[Annotation] = Nil\n  ): TypeId[A] = Impl[A](\n    name, owner, typeParams, TypeDefKind.OpaqueType(publicBounds),\n    Nil, None, None, Some(representation), annotations\n  )\n\n  // ========== Extractors ==========\n\n  object Nominal {\n    def unapply(id: TypeId[?]): Option[(String, Owner, List[TypeParam], TypeDefKind, List[TypeRepr])] =\n      if (id.aliasedTo.isEmpty && id.representation.isEmpty)\n        Some((id.name, id.owner, id.typeParams, id.defKind, id.parents))\n      else None\n  }\n\n  object Alias {\n    def unapply(id: TypeId[?]): Option[(String, Owner, List[TypeParam], TypeRepr)] =\n      id.aliasedTo.map(a => (id.name, id.owner, id.typeParams, a))\n  }\n\n  object Opaque {\n    def unapply(id: TypeId[?]): Option[(String, Owner, List[TypeParam], TypeRepr, TypeBounds)] =\n      (id.defKind, id.representation) match {\n        case (TypeDefKind.OpaqueType(bounds), Some(repr)) =>\n          Some((id.name, id.owner, id.typeParams, repr, bounds))\n        case _ => None\n      }\n  }\n\n  object Sealed {\n    def unapply(id: TypeId[?]): Option[(String, List[TypeRepr])] =\n      id.defKind match {\n        case TypeDefKind.Trait(true, subtypes) => Some((id.name, subtypes))\n        case _ => None\n      }\n  }\n  \n  object Enum {\n    def unapply(id: TypeId[?]): Option[(String, Owner, List[EnumCaseInfo])] =\n      id.defKind match {\n        case TypeDefKind.Enum(cases) => Some((id.name, id.owner, cases))\n        case _ => None\n      }\n  }\n}\n```\n\n---\n\n## TypeRepr: Type Expressions\n\nThe expression language for representing type structures.\n```scala\nsealed trait TypeRepr {\n  /** Substitute type parameters with concrete types */\n  def substitute(substitutions: Map[TypeParam, TypeRepr]): TypeRepr =\n    TypeRepr.substitute(this, substitutions)\n}\n\nobject TypeRepr {\n\n  // ==================== Type References ====================\n\n  /** Reference to a type by its TypeId */\n  final case class Ref(id: TypeId[? <: AnyKind]) extends TypeRepr\n\n  /** Reference to a type parameter */\n  final case class ParamRef(\n    param: TypeParam,\n    binderDepth: Int = 0  // De Bruijn index: 0 = innermost binder\n  ) extends TypeRepr\n\n  /** Path-dependent type: qualifier.Member */\n  final case class TypeSelect(\n    qualifier: TermPath,\n    memberName: String\n  ) extends TypeRepr {\n    def isStable: Boolean = qualifier.isStable\n  }\n\n  /** Type projection (deprecated but exists): Outer#Inner */\n  final case class TypeProjection(\n    prefix: TypeRepr,\n    memberName: String\n  ) extends TypeRepr\n\n  // ==================== Type Application ====================\n\n  /** Type constructor application: F[A, B] */\n  final case class Applied(\n    tycon: TypeRepr,\n    args: List[TypeRepr]\n  ) extends TypeRepr {\n    def arity: Int = args.size\n  }\n\n  // ==================== Type Constructors ====================\n\n  /** Type lambda: [X, Y] =>> F[X, Y] */\n  final case class TypeLambda(\n    params: List[TypeParam],\n    body: TypeRepr\n  ) extends TypeRepr {\n    def arity: Int = params.size\n  }\n\n  // ==================== Compound Types ====================\n\n  /** Intersection: A & B & C */\n  final case class Intersection(components: List[TypeRepr]) extends TypeRepr {\n    require(components.sizeIs >= 2, \"Intersection requires at least 2 types\")\n  }\n  \n  object Intersection {\n    def apply(left: TypeRepr, right: TypeRepr): Intersection =\n      (left, right) match {\n        case (Intersection(l), Intersection(r)) => Intersection(l ++ r)\n        case (Intersection(l), r) => Intersection(l :+ r)\n        case (l, Intersection(r)) => Intersection(l :: r)\n        case (l, r) => Intersection(List(l, r))\n      }\n  }\n\n  /** Union: A | B | C */\n  final case class Union(components: List[TypeRepr]) extends TypeRepr {\n    require(components.sizeIs >= 2, \"Union requires at least 2 types\")\n  }\n  \n  object Union {\n    def apply(left: TypeRepr, right: TypeRepr): Union =\n      (left, right) match {\n        case (Union(l), Union(r)) => Union(l ++ r)\n        case (Union(l), r) => Union(l :+ r)\n        case (l, Union(r)) => Union(l :: r)\n        case (l, r) => Union(List(l, r))\n      }\n  }\n\n  /** Structural/refinement type: { def foo: Int; type T } */\n  final case class Structural(\n    parents: List[TypeRepr],\n    members: List[Member]\n  ) extends TypeRepr\n\n  // ==================== Function Types ====================\n\n  /** Regular function: (A, B) => C */\n  final case class Function(\n    params: List[TypeRepr],\n    result: TypeRepr\n  ) extends TypeRepr {\n    def arity: Int = params.size\n  }\n\n  /** Context function: (A, B) ?=> C */\n  final case class ContextFunction(\n    params: List[TypeRepr],\n    result: TypeRepr\n  ) extends TypeRepr\n\n  /** Polymorphic function: [A] => A => A */\n  final case class PolyFunction(\n    typeParams: List[TypeParam],\n    result: TypeRepr\n  ) extends TypeRepr\n\n  /** Dependent function: (x: A) => x.T */\n  final case class DependentFunction(\n    params: List[Param],\n    result: TypeRepr  // May contain references to param names\n  ) extends TypeRepr\n\n  // ==================== Special Parameter Types ====================\n\n  /** By-name type: => A */\n  final case class ByName(underlying: TypeRepr) extends TypeRepr\n\n  /** Repeated/vararg type: A* */\n  final case class Repeated(underlying: TypeRepr) extends TypeRepr\n\n  // ==================== Tuple Types ====================\n\n  /** Tuple type with optional labels: (A, B) or (name: String, age: Int) */\n  final case class Tuple(elements: List[TupleElement]) extends TypeRepr {\n    def arity: Int = elements.size\n    def isNamed: Boolean = elements.exists(_.label.isDefined)\n    def isPositional: Boolean = elements.forall(_.label.isEmpty)\n    \n    def labels: List[Option[String]] = elements.map(_.label)\n    def types: List[TypeRepr] = elements.map(_.tpe)\n  }\n\n  final case class TupleElement(\n    label: Option[String],\n    tpe: TypeRepr\n  )\n  \n  object Tuple {\n    def positional(types: TypeRepr*): Tuple = \n      Tuple(types.map(t => TupleElement(None, t)).toList)\n      \n    def named(fields: (String, TypeRepr)*): Tuple =\n      Tuple(fields.map { case (n, t) => TupleElement(Some(n), t) }.toList)\n  }\n\n  // ==================== Singleton & Literal Types ====================\n\n  /** Singleton type: x.type */\n  final case class Singleton(path: TermPath) extends TypeRepr {\n    def isStable: Boolean = path.isStable\n  }\n\n  /** This type: this.type within a class */\n  final case class ThisType(owner: TypeId[? <: AnyKind]) extends TypeRepr\n\n  /** Super type reference */\n  final case class SuperType(\n    thisType: TypeRepr,\n    mixinTrait: Option[TypeRepr]\n  ) extends TypeRepr\n\n  /** Literal/constant type: 42, \"foo\", true */\n  final case class ConstantType(value: Constant) extends TypeRepr\n\n  // ==================== Match Types ====================\n\n  /** Match type: T match { case P => R; ... } */\n  final case class MatchType(\n    bound: TypeRepr,\n    scrutinee: TypeRepr,\n    cases: List[MatchTypeCase]\n  ) extends TypeRepr\n\n  final case class MatchTypeCase(\n    bindings: List[TypeParam],  // Captured type vars, e.g., `t` in `case Array[t] => t`\n    pattern: TypeRepr,\n    result: TypeRepr            // Can reference bindings via ParamRef\n  )\n\n  // ==================== Bounded/Wildcard Types ====================\n\n  /** Wildcard with bounds: ? <: Upper, ? >: Lower */\n  final case class Wildcard(bounds: TypeBounds) extends TypeRepr\n  \n  object Wildcard {\n    val unbounded: Wildcard = Wildcard(TypeBounds.empty)\n    def <:(upper: TypeRepr): Wildcard = Wildcard(TypeBounds.upper(upper))\n    def >:(lower: TypeRepr): Wildcard = Wildcard(TypeBounds.lower(lower))\n  }\n\n  // ==================== Recursive Types ====================\n\n  /** Recursive type: used for recursive type aliases */\n  final case class RecType(body: TypeRepr) extends TypeRepr\n\n  /** Reference to enclosing RecType */\n  case object RecThis extends TypeRepr\n\n  // ==================== Annotated Types ====================\n\n  /** Type with annotations: A @ann */\n  final case class Annotated(\n    underlying: TypeRepr,\n    annotations: List[Annotation]\n  ) extends TypeRepr\n\n  // ==================== Top, Bottom, and Special Types ====================\n\n  case object AnyType extends TypeRepr\n  case object AnyKindType extends TypeRepr\n  case object NothingType extends TypeRepr\n  case object NullType extends TypeRepr\n  case object UnitType extends TypeRepr\n\n  // ==================== Substitution ====================\n\n  def substitute(repr: TypeRepr, subs: Map[TypeParam, TypeRepr]): TypeRepr = {\n    def go(r: TypeRepr): TypeRepr = r match {\n      case ParamRef(param, 0) => subs.getOrElse(param, r)\n      case ParamRef(_, _) => r  // Different binder depth\n      case Ref(_) => r\n      case Applied(tycon, args) => Applied(go(tycon), args.map(go))\n      case TypeLambda(params, body) =>\n        // Shift substitutions to account for new binders\n        val shifted = subs.map { case (p, t) => p -> shiftBinderDepth(t, 1) }\n        TypeLambda(params, substitute(body, shifted))\n      case Intersection(comps) => Intersection(comps.map(go))\n      case Union(comps) => Union(comps.map(go))\n      case Structural(parents, members) =>\n        Structural(parents.map(go), members.map(substituteMember(_, subs)))\n      case Function(params, result) => Function(params.map(go), go(result))\n      case ContextFunction(params, result) => ContextFunction(params.map(go), go(result))\n      case PolyFunction(tps, result) => PolyFunction(tps, go(result))\n      case DependentFunction(params, result) =>\n        DependentFunction(params.map(p => p.copy(tpe = go(p.tpe))), go(result))\n      case ByName(u) => ByName(go(u))\n      case Repeated(u) => Repeated(go(u))\n      case Tuple(elems) => Tuple(elems.map(e => e.copy(tpe = go(e.tpe))))\n      case MatchType(bound, scrutinee, cases) =>\n        MatchType(go(bound), go(scrutinee), cases.map(substituteMatchCase(_, subs)))\n      case Wildcard(bounds) => Wildcard(substituteBounds(bounds, subs))\n      case RecType(body) => RecType(go(body))\n      case Annotated(underlying, anns) => Annotated(go(underlying), anns)\n      case TypeSelect(_, _) | TypeProjection(_, _) | Singleton(_) |\n           ThisType(_) | SuperType(_, _) | ConstantType(_) | RecThis |\n           AnyType | AnyKindType | NothingType | NullType | UnitType => r\n    }\n    go(repr)\n  }\n\n  private def shiftBinderDepth(repr: TypeRepr, delta: Int): TypeRepr = repr match {\n    case ParamRef(param, depth) => ParamRef(param, depth + delta)\n    case Applied(tycon, args) => Applied(shiftBinderDepth(tycon, delta), args.map(shiftBinderDepth(_, delta)))\n    // ... other cases follow same pattern\n    case other => other  // Simplified; full impl would recurse\n  }\n\n  private def substituteBounds(bounds: TypeBounds, subs: Map[TypeParam, TypeRepr]): TypeBounds =\n    TypeBounds(bounds.lower.map(substitute(_, subs)), bounds.upper.map(substitute(_, subs)))\n\n  private def substituteMatchCase(c: MatchTypeCase, subs: Map[TypeParam, TypeRepr]): MatchTypeCase = {\n    // Remove bindings from substitution map (they shadow outer params)\n    val shadowedSubs = subs -- c.bindings\n    MatchTypeCase(c.bindings, substitute(c.pattern, shadowedSubs), substitute(c.result, shadowedSubs))\n  }\n\n  private def substituteMember(m: Member, subs: Map[TypeParam, TypeRepr]): Member = m match {\n    case Member.Val(name, tpe, isMutable, targetName, annotations) =>\n      Member.Val(name, substitute(tpe, subs), isMutable, targetName, annotations)\n    case Member.Def(name, typeParams, paramClauses, result, targetName, annotations) =>\n      Member.Def(\n        name, typeParams,\n        paramClauses.map(substituteParamClause(_, subs)),\n        substitute(result, subs),\n        targetName, annotations\n      )\n    case Member.TypeMember(name, typeParams, bounds, alias, annotations) =>\n      Member.TypeMember(\n        name, typeParams,\n        substituteBounds(bounds, subs),\n        alias.map(substitute(_, subs)),\n        annotations\n      )\n  }\n\n  private def substituteParamClause(clause: ParamClause, subs: Map[TypeParam, TypeRepr]): ParamClause = {\n    def subParam(p: Param): Param = p.copy(tpe = substitute(p.tpe, subs))\n    clause match {\n      case ParamClause.Regular(params) => ParamClause.Regular(params.map(subParam))\n      case ParamClause.Using(params) => ParamClause.Using(params.map(subParam))\n      case ParamClause.Implicit(params) => ParamClause.Implicit(params.map(subParam))\n    }\n  }\n}\n```\n\n---\n\n## Members: For Structural Types\n```scala\nsealed trait Member\n\nobject Member {\n  final case class Val(\n    name: String,\n    tpe: TypeRepr,\n    isMutable: Boolean = false,\n    targetName: Option[String] = None,  // @targetName annotation\n    annotations: List[Annotation] = Nil\n  ) extends Member\n\n  final case class Def(\n    name: String,\n    typeParams: List[TypeParam] = Nil,\n    paramClauses: List[ParamClause] = Nil,\n    result: TypeRepr,\n    targetName: Option[String] = None,\n    annotations: List[Annotation] = Nil\n  ) extends Member {\n    def arity: Int = paramClauses.map(_.size).sum\n  }\n\n  final case class TypeMember(\n    name: String,\n    typeParams: List[TypeParam] = Nil,\n    bounds: TypeBounds = TypeBounds.empty,\n    alias: Option[TypeRepr] = None,  // Some = type alias, None = abstract\n    annotations: List[Annotation] = Nil\n  ) extends Member {\n    def isAbstract: Boolean = alias.isEmpty && bounds != TypeBounds.empty\n    def isAlias: Boolean = alias.isDefined\n  }\n}\n```\n\n---\n\n## Constants and Annotations\n\n### Constant\n```scala\nsealed trait Constant {\n  type Value\n  def value: Value\n}\n\nobject Constant {\n  final case class IntConst(value: Int) extends Constant { type Value = Int }\n  final case class LongConst(value: Long) extends Constant { type Value = Long }\n  final case class FloatConst(value: Float) extends Constant { type Value = Float }\n  final case class DoubleConst(value: Double) extends Constant { type Value = Double }\n  final case class BooleanConst(value: Boolean) extends Constant { type Value = Boolean }\n  final case class CharConst(value: Char) extends Constant { type Value = Char }\n  final case class StringConst(value: String) extends Constant { type Value = String }\n  final case class NullConst() extends Constant { type Value = Null; def value: Null = null }\n  final case class UnitConst() extends Constant { type Value = Unit; def value: Unit = () }\n  final case class ClassOfConst(tpe: TypeRepr) extends Constant { type Value = TypeRepr; def value: TypeRepr = tpe }\n}\n```\n\n### Annotation\n```scala\nfinal case class Annotation(\n  tpe: TypeRepr,\n  args: List[AnnotationArg]\n)\n\nsealed trait AnnotationArg\n\nobject AnnotationArg {\n  final case class ConstArg(value: Constant) extends AnnotationArg\n  final case class ArrayArg(elements: List[AnnotationArg]) extends AnnotationArg\n  final case class NestedArg(annotation: Annotation) extends AnnotationArg\n  final case class TypeArg(tpe: TypeRepr) extends AnnotationArg\n  final case class NamedArg(name: String, value: AnnotationArg) extends AnnotationArg\n}\n```\n\n---\n\n## Type Operations\n\n### Normalization\n\nExpands type aliases to their underlying types.\n```scala\nobject TypeNormalization {\n  \n  /**\n   * Normalize a type by expanding type aliases.\n   * Does NOT expand opaque types (they are nominally distinct).\n   */\n  def normalize(tpe: TypeRepr): TypeRepr = tpe match {\n    // Direct alias reference with no args\n    case TypeRepr.Ref(TypeId.Alias(_, _, Nil, aliased)) =>\n      normalize(aliased)\n    \n    // Applied alias: expand and substitute\n    case TypeRepr.Applied(TypeRepr.Ref(TypeId.Alias(_, _, params, aliased)), args) \n        if params.size == args.size =>\n      val subs = params.zip(args.map(normalize)).toMap\n      normalize(TypeRepr.substitute(aliased, subs))\n    \n    // Recurse into compound types\n    case TypeRepr.Applied(tycon, args) =>\n      TypeRepr.Applied(normalize(tycon), args.map(normalize))\n    \n    case TypeRepr.Intersection(comps) =>\n      TypeRepr.Intersection(comps.map(normalize))\n    \n    case TypeRepr.Union(comps) =>\n      TypeRepr.Union(comps.map(normalize))\n    \n    case TypeRepr.Function(params, result) =>\n      TypeRepr.Function(params.map(normalize), normalize(result))\n    \n    case TypeRepr.ContextFunction(params, result) =>\n      TypeRepr.ContextFunction(params.map(normalize), normalize(result))\n    \n    case TypeRepr.Tuple(elems) =>\n      TypeRepr.Tuple(elems.map(e => e.copy(tpe = normalize(e.tpe))))\n    \n    case TypeRepr.ByName(u) => TypeRepr.ByName(normalize(u))\n    case TypeRepr.Repeated(u) => TypeRepr.Repeated(normalize(u))\n    case TypeRepr.Annotated(u, anns) => TypeRepr.Annotated(normalize(u), anns)\n    case TypeRepr.Wildcard(bounds) => \n      TypeRepr.Wildcard(TypeBounds(bounds.lower.map(normalize), bounds.upper.map(normalize)))\n    \n    // Atoms don't change\n    case _ => tpe\n  }\n  \n  /**\n   * Get the underlying representation of an opaque type.\n   * Only valid within the opaque type's defining scope.\n   */\n  def unwrapOpaque(tpe: TypeRepr): Option[TypeRepr] = tpe match {\n    case TypeRepr.Ref(TypeId.Opaque(_, _, Nil, repr, _)) =>\n      Some(repr)\n    case TypeRepr.Applied(TypeRepr.Ref(TypeId.Opaque(_, _, params, repr, _)), args)\n        if params.size == args.size =>\n      val subs = params.zip(args).toMap\n      Some(TypeRepr.substitute(repr, subs))\n    case _ => None\n  }\n}\n```\n\n### Type Equality\n```scala\nobject TypeEquality {\n  \n  /**\n   * Check if two types are equal (after normalization).\n   * This is structural equality, not reference equality.\n   */\n  def areEqual(a: TypeRepr, b: TypeRepr): Boolean = {\n    val aNorm = TypeNormalization.normalize(a)\n    val bNorm = TypeNormalization.normalize(b)\n    structurallyEqual(aNorm, bNorm)\n  }\n  \n  private def structurallyEqual(a: TypeRepr, b: TypeRepr): Boolean = (a, b) match {\n    case (TypeRepr.Ref(idA), TypeRepr.Ref(idB)) =>\n      idA.fullName == idB.fullName\n    \n    case (TypeRepr.ParamRef(pA, dA), TypeRepr.ParamRef(pB, dB)) =>\n      pA.index == pB.index && dA == dB\n    \n    case (TypeRepr.Applied(tcA, argsA), TypeRepr.Applied(tcB, argsB)) =>\n      structurallyEqual(tcA, tcB) && \n        argsA.size == argsB.size &&\n        argsA.zip(argsB).forall { case (x, y) => structurallyEqual(x, y) }\n    \n    case (TypeRepr.Intersection(cA), TypeRepr.Intersection(cB)) =>\n      cA.size == cB.size && cA.zip(cB).forall { case (x, y) => structurallyEqual(x, y) }\n    \n    case (TypeRepr.Union(cA), TypeRepr.Union(cB)) =>\n      cA.size == cB.size && cA.zip(cB).forall { case (x, y) => structurallyEqual(x, y) }\n    \n    case (TypeRepr.Function(pA, rA), TypeRepr.Function(pB, rB)) =>\n      pA.size == pB.size &&\n        pA.zip(pB).forall { case (x, y) => structurallyEqual(x, y) } &&\n        structurallyEqual(rA, rB)\n    \n    case (TypeRepr.Tuple(eA), TypeRepr.Tuple(eB)) =>\n      eA.size == eB.size && eA.zip(eB).forall { case (x, y) => \n        x.label == y.label && structurallyEqual(x.tpe, y.tpe)\n      }\n    \n    case (TypeRepr.ConstantType(cA), TypeRepr.ConstantType(cB)) =>\n      cA == cB\n    \n    case (TypeRepr.AnyType, TypeRepr.AnyType) => true\n    case (TypeRepr.NothingType, TypeRepr.NothingType) => true\n    case (TypeRepr.NullType, TypeRepr.NullType) => true\n    case (TypeRepr.UnitType, TypeRepr.UnitType) => true\n    \n    // More cases for full coverage...\n    case _ => false\n  }\n}\n```\n\n### Subtyping\n```scala\nobject Subtyping {\n  \n  /**\n   * Context for subtyping calculations.\n   * Tracks assumptions to handle recursive types and avoid infinite loops.\n   */\n  final case class Context(\n    assumptions: Set[(TypeRepr, TypeRepr)] = Set.empty,\n    depth: Int = 0,\n    maxDepth: Int = 100\n  ) {\n    def assume(sub: TypeRepr, sup: TypeRepr): Context =\n      copy(assumptions = assumptions + ((sub, sup)))\n    \n    def isAssumed(sub: TypeRepr, sup: TypeRepr): Boolean =\n      assumptions.contains((sub, sup))\n    \n    def deeper: Context = copy(depth = depth + 1)\n    def tooDeep: Boolean = depth >= maxDepth\n  }\n  \n  /**\n   * Check if `sub` is a subtype of `sup`.\n   * \n   * Implements the Scala 3 subtyping rules including:\n   * - Reflexivity: A <: A\n   * - Top: A <: Any for all A\n   * - Bottom: Nothing <: A for all A  \n   * - Variance-aware generic subtyping\n   * - Union/intersection type rules\n   * - Structural subtyping\n   */\n  def isSubtype(sub: TypeRepr, sup: TypeRepr)(using ctx: Context = Context()): Boolean = ???\n  \n  /**\n   * Check if two types are equivalent (mutual subtypes).\n   */\n  def isEquivalent(a: TypeRepr, b: TypeRepr)(using ctx: Context = Context()): Boolean =\n    isSubtype(a, b) && isSubtype(b, a)\n  \n  /**\n   * Find the least upper bound (LUB) of two types.\n   * Returns the most specific type that is a supertype of both.\n   */\n  def lub(a: TypeRepr, b: TypeRepr): TypeRepr = ???\n  \n  /**\n   * Find the greatest lower bound (GLB) of two types.\n   * Returns the most general type that is a subtype of both.\n   */\n  def glb(a: TypeRepr, b: TypeRepr): TypeRepr = ???\n  \n  /**\n   * Check if a type conforms to given bounds.\n   */\n  def conformsToBounds(tpe: TypeRepr, bounds: TypeBounds)(using ctx: Context = Context()): Boolean = {\n    val lowerOk = bounds.lower.forall(lo => isSubtype(lo, tpe))\n    val upperOk = bounds.upper.forall(hi => isSubtype(tpe, hi))\n    lowerOk && upperOk\n  }\n  \n  /**\n   * Reduce a match type to its result, if possible.\n   * Returns None if the match type cannot be reduced (e.g., abstract scrutinee).\n   */\n  def reduceMatchType(mt: TypeRepr.MatchType)(using ctx: Context = Context()): Option[TypeRepr] = ???\n}\n```\n\n---\n\n## Standard Library Type Definitions\n\nPredefined `TypeId` instances for common types.\n```scala\nobject StandardTypes {\n  import TypeDefKind.*\n  \n  private val scalaOwner = Owner.pkg(\"scala\")\n  private val scalaCollectionImmutable = Owner.pkgs(\"scala\", \"collection\", \"immutable\")\n  private val javaLang = Owner.pkgs(\"java\", \"lang\")\n  \n  // ========== Primitives ==========\n  \n  val IntId: TypeId[Int] = TypeId.nominal[Int](\n    \"Int\", scalaOwner, Nil, Class(isFinal = true, isValue = true)\n  )\n  \n  val LongId: TypeId[Long] = TypeId.nominal[Long](\n    \"Long\", scalaOwner, Nil, Class(isFinal = true, isValue = true)\n  )\n  \n  val DoubleId: TypeId[Double] = TypeId.nominal[Double](\n    \"Double\", scalaOwner, Nil, Class(isFinal = true, isValue = true)\n  )\n  \n  val FloatId: TypeId[Float] = TypeId.nominal[Float](\n    \"Float\", scalaOwner, Nil, Class(isFinal = true, isValue = true)\n  )\n  \n  val BooleanId: TypeId[Boolean] = TypeId.nominal[Boolean](\n    \"Boolean\", scalaOwner, Nil, Class(isFinal = true, isValue = true)\n  )\n  \n  val CharId: TypeId[Char] = TypeId.nominal[Char](\n    \"Char\", scalaOwner, Nil, Class(isFinal = true, isValue = true)\n  )\n  \n  val ByteId: TypeId[Byte] = TypeId.nominal[Byte](\n    \"Byte\", scalaOwner, Nil, Class(isFinal = true, isValue = true)\n  )\n  \n  val ShortId: TypeId[Short] = TypeId.nominal[Short](\n    \"Short\", scalaOwner, Nil, Class(isFinal = true, isValue = true)\n  )\n  \n  val UnitId: TypeId[Unit] = TypeId.nominal[Unit](\n    \"Unit\", scalaOwner, Nil, Class(isFinal = true, isValue = true)\n  )\n  \n  // ========== Reference Types ==========\n  \n  val StringId: TypeId[String] = TypeId.nominal[String](\n    \"String\", javaLang, Nil, Class(isFinal = true)\n  )\n  \n  val AnyId: TypeId[Any] = TypeId.nominal[Any](\n    \"Any\", scalaOwner, Nil, Class(isAbstract = true)\n  )\n  \n  val AnyRefId: TypeId[AnyRef] = TypeId.nominal[AnyRef](\n    \"AnyRef\", scalaOwner, Nil, Class(isAbstract = true),\n    parents = List(TypeRepr.Ref(AnyId))\n  )\n  \n  val AnyValId: TypeId[AnyVal] = TypeId.nominal[AnyVal](\n    \"AnyVal\", scalaOwner, Nil, Class(isAbstract = true),\n    parents = List(TypeRepr.Ref(AnyId))\n  )\n  \n  val NothingId: TypeId[Nothing] = TypeId.nominal[Nothing](\n    \"Nothing\", scalaOwner, Nil, Class(isFinal = true, isAbstract = true)\n  )\n  \n  val NullId: TypeId[Null] = TypeId.nominal[Null](\n    \"Null\", scalaOwner, Nil, Class(isFinal = true)\n  )\n  \n  // ========== Collection Type Constructors ==========\n  \n  private val A = TypeParam.covariant(\"A\", 0)\n  private val K = TypeParam.invariant(\"K\", 0)\n  private val V = TypeParam.covariant(\"V\", 1)\n  \n  val ListId: TypeId[List] = TypeId.nominal[List](\n    \"List\", scalaCollectionImmutable, List(A), Trait(isSealed = true)\n  )\n  \n  val VectorId: TypeId[Vector] = TypeId.nominal[Vector](\n    \"Vector\", scalaCollectionImmutable, List(A), Class(isFinal = true)\n  )\n  \n  val SetId: TypeId[Set] = TypeId.nominal[Set](\n    \"Set\", scalaCollectionImmutable, List(A), Trait()\n  )\n  \n  val MapId: TypeId[Map] = TypeId.nominal[Map](\n    \"Map\", scalaCollectionImmutable, List(K, V), Trait()\n  )\n  \n  val OptionId: TypeId[Option] = TypeId.nominal[Option](\n    \"Option\", scalaOwner, List(A), Trait(isSealed = true)\n  )\n  \n  val EitherA = TypeParam.covariant(\"A\", 0)\n  val EitherB = TypeParam.covariant(\"B\", 1)\n  val EitherId: TypeId[Either] = TypeId.nominal[Either](\n    \"Either\", scalaOwner, List(EitherA, EitherB), Trait(isSealed = true)\n  )\n  \n  // ========== Tuple Type Constructors ==========\n  \n  val EmptyTupleId: TypeId[EmptyTuple] = TypeId.nominal[EmptyTuple](\n    \"EmptyTuple\", scalaOwner, Nil, Object\n  )\n  \n  val TupleConsH = TypeParam.covariant(\"H\", 0)\n  val TupleConsT = TypeParam.covariant(\"T\", 1, bounds = TypeBounds.upper(TypeRepr.Ref(???))) // <: Tuple\n  val TupleConsId: TypeId[*:] = TypeId.nominal[*:](\n    \"*:\", scalaOwner, List(TupleConsH, TupleConsT), Class(isFinal = true, isCase = true)\n  )\n  \n  // ========== Convenience TypeRepr Builders ==========\n  \n  def int: TypeRepr = TypeRepr.Ref(IntId)\n  def long: TypeRepr = TypeRepr.Ref(LongId)\n  def double: TypeRepr = TypeRepr.Ref(DoubleId)\n  def float: TypeRepr = TypeRepr.Ref(FloatId)\n  def boolean: TypeRepr = TypeRepr.Ref(BooleanId)\n  def string: TypeRepr = TypeRepr.Ref(StringId)\n  def unit: TypeRepr = TypeRepr.UnitType\n  def any: TypeRepr = TypeRepr.AnyType\n  def nothing: TypeRepr = TypeRepr.NothingType\n  \n  def list(elem: TypeRepr): TypeRepr = TypeRepr.Applied(TypeRepr.Ref(ListId), List(elem))\n  def option(elem: TypeRepr): TypeRepr = TypeRepr.Applied(TypeRepr.Ref(OptionId), List(elem))\n  def map(key: TypeRepr, value: TypeRepr): TypeRepr = TypeRepr.Applied(TypeRepr.Ref(MapId), List(key, value))\n  def either(left: TypeRepr, right: TypeRepr): TypeRepr = TypeRepr.Applied(TypeRepr.Ref(EitherId), List(left, right))\n}\n```\n\n---\n\n## Example Usage\n```scala\nobject Examples {\n  import TypeRepr.*\n  import StandardTypes.*\n  \n  // ========== Simple Types ==========\n  \n  val intType: TypeRepr = int\n  val stringType: TypeRepr = string\n  val listOfInt: TypeRepr = list(int)\n  val mapStringToInt: TypeRepr = map(string, int)\n  \n  // ========== Named Tuple ==========\n  \n  // (name: String, age: Int)\n  val personTuple: TypeRepr = Tuple.named(\n    \"name\" -> string,\n    \"age\" -> int\n  )\n  \n  // ========== Type Alias ==========\n  \n  // type Age = Int\n  val AgeId: TypeId[Int] = TypeId.alias[Int](\n    \"Age\",\n    Owner.pkg(\"myapp\"),\n    Nil,\n    int\n  )\n  \n  // type StringMap[V] = Map[String, V]\n  val V = TypeParam.covariant(\"V\", 0)\n  val StringMapId: TypeId[Map[String, *]] = TypeId.alias[Map[String, *]](\n    \"StringMap\",\n    Owner.pkg(\"myapp\"),\n    List(V),\n    Applied(Ref(MapId), List(string, ParamRef(V)))\n  )\n  \n  // ========== Opaque Type ==========\n  \n  // opaque type Email = String\n  val EmailId: TypeId[String] = TypeId.opaque[String](\n    \"Email\",\n    Owner.pkg(\"myapp\"),\n    Nil,\n    string\n  )\n  \n  // ========== Enum ==========\n  \n  val ColorId: TypeId[?] = TypeId.nominal(\n    \"Color\",\n    Owner.pkg(\"myapp\"),\n    Nil,\n    TypeDefKind.Enum(List(\n      EnumCaseInfo(\"Red\", 0, Nil, isObjectCase = true),\n      EnumCaseInfo(\"Green\", 1, Nil, isObjectCase = true),\n      EnumCaseInfo(\"Blue\", 2, Nil, isObjectCase = true),\n      EnumCaseInfo(\"RGB\", 3, List(\n        EnumCaseParam(\"r\", int),\n        EnumCaseParam(\"g\", int),\n        EnumCaseParam(\"b\", int)\n      ), isObjectCase = false)\n    ))\n  )\n  \n  // ========== Match Type ==========\n  \n  // type Elem[X] = X match { case String => Char; case Array[t] => t }\n  val X = TypeParam.invariant(\"X\", 0)\n  val t = TypeParam.invariant(\"t\", 0)\n  \n  val ElemId: TypeId[?] = TypeId.alias(\n    \"Elem\",\n    Owner.pkg(\"myapp\"),\n    List(X),\n    MatchType(\n      bound = any,\n      scrutinee = ParamRef(X),\n      cases = List(\n        MatchTypeCase(Nil, string, Ref(CharId)),\n        MatchTypeCase(\n          List(t),\n          Applied(Ref(???), List(ParamRef(t))), // Array[t]\n          ParamRef(t)\n        )\n      )\n    )\n  )\n  \n  // ========== Structural Type ==========\n  \n  // { def size: Int; val name: String }\n  val sizedNamed: TypeRepr = Structural(\n    parents = Nil,\n    members = List(\n      Member.Def(\"size\", Nil, Nil, int),\n      Member.Val(\"name\", string)\n    )\n  )\n  \n  // ========== Path-Dependent Type ==========\n  \n  // myModule.Inner.T\n  val pathDependent: TypeRepr = TypeSelect(\n    TermPath(List(\n      TermPath.Package(\"myapp\"),\n      TermPath.Module(\"myModule\"),\n      TermPath.Module(\"Inner\")\n    )),\n    \"T\"\n  )\n  \n  // ========== Intersection & Union ==========\n  \n  // String & { def foo: Int }\n  val stringWithFoo: TypeRepr = Intersection(\n    string,\n    Structural(Nil, List(Member.Def(\"foo\", Nil, Nil, int)))\n  )\n  \n  // String | Int\n  val stringOrInt: TypeRepr = Union(string, int)\n  \n  // ========== Function Types ==========\n  \n  // (Int, String) => Boolean\n  val func: TypeRepr = Function(List(int, string), boolean)\n  \n  // (Int, String) ?=> Boolean (context function)\n  val ctxFunc: TypeRepr = ContextFunction(List(int, string), boolean)\n  \n  // [A] => A => A (polymorphic function)\n  val polyFunc: TypeRepr = PolyFunction(\n    List(TypeParam.invariant(\"A\", 0)),\n    Function(List(ParamRef(TypeParam.invariant(\"A\", 0))), ParamRef(TypeParam.invariant(\"A\", 0)))\n  )\n}\n```\n\n---\n\n## Macro Derivation (Sketch)\n```scala\nimport scala.quoted.*\n\nobject TypeIdMacros {\n  \n  /**\n   * Derive a TypeId for any type or type constructor at compile time.\n   * Captures all type information available to the compiler.\n   */\n  inline def derive[A <: AnyKind]: TypeId[A] = ${ deriveMacro[A] }\n  \n  def deriveMacro[A <: AnyKind: Type](using Quotes): Expr[TypeId[A]] = {\n    import quotes.reflect.*\n    \n    val tpe = TypeRepr.of[A]\n    \n    // Extract type information from compiler\n    // ... implementation details ...\n    \n    ???\n  }\n  \n  /**\n   * Derive a TypeRepr for a concrete type at compile time.\n   */\n  inline def typeRepr[A]: TypeRepr = ${ typeReprMacro[A] }\n  \n  def typeReprMacro[A: Type](using Quotes): Expr[TypeRepr] = ???\n}\n```\n\n---\n\n## Open Questions / Future Work\n\n1. **Recursive type handling**: The `RecType`/`RecThis` encoding may need refinement for complex recursive types.\n\n2. **Match type reduction**: Full implementation requires tracking what patterns are \"provably disjoint.\"\n\n3. **Structural subtyping**: Member-by-member comparison with proper handling of overloaded methods.\n\n4. **Scala 2 compatibility**: Some constructs (existentials, compound types) may need additional representation.\n\n5. **Serialization format**: The data model is designed for runtime use; a compact serialization format (e.g., protobuf schema) would be a natural next step.",
              "url": "https://github.com/zio/zio-blocks/issues/471",
              "tech": [],
              "repo_name": "zio-blocks",
              "repo_owner": "zio",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "ZIO#3472",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "ZIO",
              "id": "generated-ZIO",
              "name": "ZIO",
              "description": "",
              "members": [],
              "display_name": "ZIO",
              "created_at": "2026-01-24T11:31:19.767Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/ZIO?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "zio",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-24T11:31:19.767Z",
            "created_at": "2026-01-24T11:31:19.767Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-ZIO#3472",
              "status": "open",
              "type": "issue",
              "number": 3472,
              "title": "Split into multiple modules",
              "source": {
                "data": {
                  "id": "source-ZIO#3472",
                  "user": {
                    "login": "987Nabil",
                    "id": 7283535,
                    "node_id": "MDQ6VXNlcjcyODM1MzU=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/7283535?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/987Nabil",
                    "html_url": "https://github.com/987Nabil",
                    "followers_url": "https://api.github.com/users/987Nabil/followers",
                    "following_url": "https://api.github.com/users/987Nabil/following{/other_user}",
                    "gists_url": "https://api.github.com/users/987Nabil/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/987Nabil/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/987Nabil/subscriptions",
                    "organizations_url": "https://api.github.com/users/987Nabil/orgs",
                    "repos_url": "https://api.github.com/users/987Nabil/repos",
                    "events_url": "https://api.github.com/users/987Nabil/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/987Nabil/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Split into multiple modules",
                  "body": "Currently, the zio-http artifact contains a lot of different parts of zio-http exclusively. They are not separate maven artifacts.\n\nWe want to change this, to support future changes/features.\n\nThere should be at least these modules that are published into maven. \n\n1. core\n2. endpoint\n3. netty\n\nShould we have client and server in different modules?",
                  "html_url": "https://github.com/zio/zio-http/issues/3472"
                },
                "type": "github"
              },
              "hash": "zio/zio-http#3472",
              "body": "Currently, the zio-http artifact contains a lot of different parts of zio-http exclusively. They are not separate maven artifacts.\n\nWe want to change this, to support future changes/features.\n\nThere should be at least these modules that are published into maven. \n\n1. core\n2. endpoint\n3. netty\n\nShould we have client and server in different modules?",
              "url": "https://github.com/zio/zio-http/issues/3472",
              "tech": [],
              "repo_name": "zio-http",
              "repo_owner": "zio",
              "forge": "github"
            },
            "timeouts_disabled": false
          }
        ],
        "next_cursor": null
      }
    }
  }
}