{
  "result": {
    "data": {
      "json": {
        "items": [
          {
            "id": "qdrant#3322",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "qdrant",
              "id": "generated-qdrant",
              "name": "Qdrant",
              "description": "",
              "members": [],
              "display_name": "Qdrant",
              "created_at": "2026-01-23T05:51:28.440Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/qdrant?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "qdrant",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-23T05:51:28.440Z",
            "created_at": "2026-01-23T05:51:28.440Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-qdrant#3322",
              "status": "open",
              "type": "issue",
              "number": 3322,
              "title": "Per-collection metrics for Prometheus",
              "source": {
                "data": {
                  "id": "source-qdrant#3322",
                  "user": {
                    "login": "generall",
                    "id": 1935623,
                    "node_id": "MDQ6VXNlcjE5MzU2MjM=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1935623?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/generall",
                    "html_url": "https://github.com/generall",
                    "followers_url": "https://api.github.com/users/generall/followers",
                    "following_url": "https://api.github.com/users/generall/following{/other_user}",
                    "gists_url": "https://api.github.com/users/generall/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/generall/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/generall/subscriptions",
                    "organizations_url": "https://api.github.com/users/generall/orgs",
                    "repos_url": "https://api.github.com/users/generall/repos",
                    "events_url": "https://api.github.com/users/generall/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/generall/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Per-collection metrics for Prometheus",
                  "body": "**Is your feature request related to a problem? Please describe.**\r\n\r\nCurrently, all metrics in `/metrics` are global, meaning that it’s impossible to see differences per collection.\r\n\r\nIn addition to that, all our metrics should have per-collection granularity to allow better aggregation in Prometheus, including:\r\n\r\n- point/vector counts\r\n- REST/gRPC requests\r\n\r\n**Describe the solution you'd like**\r\n\r\nExample:\r\n```\r\ngrpc_responses_min_duration_seconds{endpoint=\"/qdrant.Points/Upsert\"} 0.000046\r\ngrpc_responses_min_duration_seconds{endpoint=\"/qdrant.Points/Upsert\",collection=\"my-collection\"} 0.000049\r\ngrpc_responses_min_duration_seconds{endpoint=\"/qdrant.Points/Upsert\",collection=\"my-collection-2\"} 0.000046\r\n```\r\n\r\n**Describe alternatives you've considered**\r\n\r\nCreate dedicated endpoint for each collection `/collections/my-collecton/metrics`\r\nbut feedback from DevOps on this idea was negative.\r\n\r\n**Additional context**\r\n\r\nIt might be beneficial to allow users to disable per-collection output. It is especially relevant if there are a lot of collections and metric response could become huge. But this is a nice-to-have requirement.\r\n\r\n\r\n---\r\n\r\nNote for contributors: Please consider this as tracking issue. If you think that it would be beneficial to split the task into multiple smaller PRs, please you are welcome to do so. Bounty will be rewarded for each PR independently\r\n\r\n",
                  "html_url": "https://github.com/qdrant/qdrant/issues/3322"
                },
                "type": "github"
              },
              "hash": "qdrant/qdrant#3322",
              "body": "**Is your feature request related to a problem? Please describe.**\r\n\r\nCurrently, all metrics in `/metrics` are global, meaning that it’s impossible to see differences per collection.\r\n\r\nIn addition to that, all our metrics should have per-collection granularity to allow better aggregation in Prometheus, including:\r\n\r\n- point/vector counts\r\n- REST/gRPC requests\r\n\r\n**Describe the solution you'd like**\r\n\r\nExample:\r\n```\r\ngrpc_responses_min_duration_seconds{endpoint=\"/qdrant.Points/Upsert\"} 0.000046\r\ngrpc_responses_min_duration_seconds{endpoint=\"/qdrant.Points/Upsert\",collection=\"my-collection\"} 0.000049\r\ngrpc_responses_min_duration_seconds{endpoint=\"/qdrant.Points/Upsert\",collection=\"my-collection-2\"} 0.000046\r\n```\r\n\r\n**Describe alternatives you've considered**\r\n\r\nCreate dedicated endpoint for each collection `/collections/my-collecton/metrics`\r\nbut feedback from DevOps on this idea was negative.\r\n\r\n**Additional context**\r\n\r\nIt might be beneficial to allow users to disable per-collection output. It is especially relevant if there are a lot of collections and metric response could become huge. But this is a nice-to-have requirement.\r\n\r\n\r\n---\r\n\r\nNote for contributors: Please consider this as tracking issue. If you think that it would be beneficial to split the task into multiple smaller PRs, please you are welcome to do so. Bounty will be rewarded for each PR independently\r\n\r\n",
              "url": "https://github.com/qdrant/qdrant/issues/3322",
              "tech": [],
              "repo_name": "qdrant",
              "repo_owner": "qdrant",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "onyx-dot-app#2281",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "onyx-dot-app",
              "id": "generated-onyx-dot-app",
              "name": "Onyx-dot-app",
              "description": "",
              "members": [],
              "display_name": "Onyx-dot-app",
              "created_at": "2026-01-23T05:51:28.618Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/onyx-dot-app?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "danswer-ai",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-23T05:51:28.618Z",
            "created_at": "2026-01-23T05:51:28.618Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-onyx-dot-app#2281",
              "status": "open",
              "type": "issue",
              "number": 2281,
              "title": "Jira Service Management Connector",
              "source": {
                "data": {
                  "id": "source-onyx-dot-app#2281",
                  "user": {
                    "login": "Weves",
                    "id": 25087905,
                    "node_id": "MDQ6VXNlcjI1MDg3OTA1",
                    "avatar_url": "https://avatars.githubusercontent.com/u/25087905?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/Weves",
                    "html_url": "https://github.com/Weves",
                    "followers_url": "https://api.github.com/users/Weves/followers",
                    "following_url": "https://api.github.com/users/Weves/following{/other_user}",
                    "gists_url": "https://api.github.com/users/Weves/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/Weves/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/Weves/subscriptions",
                    "organizations_url": "https://api.github.com/users/Weves/orgs",
                    "repos_url": "https://api.github.com/users/Weves/repos",
                    "events_url": "https://api.github.com/users/Weves/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/Weves/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Jira Service Management Connector",
                  "body": "Pull in all tickets from a specified [Jira Service Management](https://www.atlassian.com/software/jira/service-management) project. \r\n\r\nCheckout the connector creation README here for more details on the best way to add new connectors: https://github.com/danswer-ai/danswer/blob/main/backend/danswer/connectors/README.md. ",
                  "html_url": "https://github.com/onyx-dot-app/onyx/issues/2281"
                },
                "type": "github"
              },
              "hash": "danswer-ai/danswer#2281",
              "body": "Pull in all tickets from a specified [Jira Service Management](https://www.atlassian.com/software/jira/service-management) project. \r\n\r\nCheckout the connector creation README here for more details on the best way to add new connectors: https://github.com/danswer-ai/danswer/blob/main/backend/danswer/connectors/README.md. ",
              "url": "https://github.com/onyx-dot-app/onyx/issues/2281",
              "tech": [],
              "repo_name": "danswer",
              "repo_owner": "danswer-ai",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "golemcloud#275",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "golemcloud",
              "id": "generated-golemcloud",
              "name": "Golemcloud",
              "description": "",
              "members": [],
              "display_name": "Golemcloud",
              "created_at": "2026-01-23T05:51:28.544Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/golemcloud?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "golemcloud",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-23T05:51:28.617Z",
            "created_at": "2026-01-23T05:51:28.617Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [
              "go"
            ],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-golemcloud#275",
              "status": "open",
              "type": "issue",
              "number": 275,
              "title": "Incorporate MCP Server into Golem CLI",
              "source": {
                "data": {
                  "id": "source-golemcloud#275",
                  "user": {
                    "login": "jdegoes",
                    "id": 156745,
                    "node_id": "MDQ6VXNlcjE1Njc0NQ==",
                    "avatar_url": "https://avatars.githubusercontent.com/u/156745?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/jdegoes",
                    "html_url": "https://github.com/jdegoes",
                    "followers_url": "https://api.github.com/users/jdegoes/followers",
                    "following_url": "https://api.github.com/users/jdegoes/following{/other_user}",
                    "gists_url": "https://api.github.com/users/jdegoes/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/jdegoes/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/jdegoes/subscriptions",
                    "organizations_url": "https://api.github.com/users/jdegoes/orgs",
                    "repos_url": "https://api.github.com/users/jdegoes/repos",
                    "events_url": "https://api.github.com/users/jdegoes/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/jdegoes/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Incorporate MCP Server into Golem CLI",
                  "body": "With a new command, Golem CLI enters serve mode:\n\n```bash\n%> golem-cli --serve --serve-port 1232\n%> golem-cli running MCP Server at port 1232\n```\n\nIn this mode, Golem CLI creates an MCP Server that exposes different commands as different tools, and exposes relevant resources (the manifest file in the current, ancestor, and children directories) as resources.\n\nWhen this ticket is completed, it should be possible to use an agent such as Claude Code to perform anything that Golem CLI can do. Moreover, all individual tools and resources must be end-to-end tested with an MCP Client that interacts with the MCP Server.\n\n[This library](https://github.com/rust-mcp-stack/rust-mcp-sdk) looks like the one to use for Rust, but perhaps there are better options available.",
                  "html_url": "https://github.com/golemcloud/golem/issues/1926"
                },
                "type": "github"
              },
              "hash": "golemcloud/golem-cli#275",
              "body": "With a new command, Golem CLI enters serve mode:\n\n```bash\n%> golem-cli --serve --serve-port 1232\n%> golem-cli running MCP Server at port 1232\n```\n\nIn this mode, Golem CLI creates an MCP Server that exposes different commands as different tools, and exposes relevant resources (the manifest file in the current, ancestor, and children directories) as resources.\n\nWhen this ticket is completed, it should be possible to use an agent such as Claude Code to perform anything that Golem CLI can do. Moreover, all individual tools and resources must be end-to-end tested with an MCP Client that interacts with the MCP Server.\n\n[This library](https://github.com/rust-mcp-stack/rust-mcp-sdk) looks like the one to use for Rust, but perhaps there are better options available.",
              "url": "https://github.com/golemcloud/golem/issues/1926",
              "tech": [
                "go"
              ],
              "repo_name": "golem-cli",
              "repo_owner": "golemcloud",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "golemcloud#23",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "golemcloud",
              "id": "generated-golemcloud",
              "name": "Golemcloud",
              "description": "",
              "members": [],
              "display_name": "Golemcloud",
              "created_at": "2026-01-23T05:51:28.969Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/golemcloud?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "golemcloud",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-23T05:51:28.969Z",
            "created_at": "2026-01-23T05:51:28.969Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [
              "go"
            ],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-golemcloud#23",
              "status": "open",
              "type": "issue",
              "number": 23,
              "title": "Implement Durable Text-to-Speech Provider Components for golem:tts WIT Interface",
              "source": {
                "data": {
                  "id": "source-golemcloud#23",
                  "user": {
                    "login": "jdegoes",
                    "id": 156745,
                    "node_id": "MDQ6VXNlcjE1Njc0NQ==",
                    "avatar_url": "https://avatars.githubusercontent.com/u/156745?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/jdegoes",
                    "html_url": "https://github.com/jdegoes",
                    "followers_url": "https://api.github.com/users/jdegoes/followers",
                    "following_url": "https://api.github.com/users/jdegoes/following{/other_user}",
                    "gists_url": "https://api.github.com/users/jdegoes/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/jdegoes/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/jdegoes/subscriptions",
                    "organizations_url": "https://api.github.com/users/jdegoes/orgs",
                    "repos_url": "https://api.github.com/users/jdegoes/repos",
                    "events_url": "https://api.github.com/users/jdegoes/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/jdegoes/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Implement Durable Text-to-Speech Provider Components for golem:tts WIT Interface",
                  "body": "I have attached to this ticket a WIT file that describes a generic interface for text-to-speech operations. This interface can be implemented by various providers, either by emulating features not present in a given provider, utilizing the provider's native support for a feature, or indicating an error if a particular combination is not natively supported by a provider.\n\nThe intent of this WIT specification is to allow developers of WASM components (on wasmCloud, Spin, or Golem) to leverage text-to-speech capabilities to build voice-powered applications, accessibility services, and audio content generation systems in a portable and provider-agnostic fashion.\n\nThis ticket involves constructing implementations of this WIT interface for the following providers:\n\n- **ElevenLabs**: The leading AI voice synthesis platform with comprehensive voice cloning, real-time streaming, voice conversion, and sound effects generation capabilities.\n- **AWS Polly**: Amazon's enterprise text-to-speech service with extensive language support, custom lexicons, speech marks, and asynchronous synthesis for long-form content.\n- **Google Cloud Text-to-Speech**: Google's neural voice synthesis service with WaveNet and Neural2 voices, device optimization profiles, and streaming synthesis capabilities.\n- **Deepgram Aura**: High-performance real-time TTS with session-based streaming, low-latency neural voices, and conversational AI optimization.\n\nThese implementations must be written in Rust and compilable to WASM Components (WASI 0.23 only, since Golem does not yet support WASI 0.3). The standard Rust toolchain for WASM component development can be employed (see cargo component and the Rust examples of components in this and other Golem repositories).\n\nAdditionally, these implementations should incorporate custom durability semantics using the Golem durability API and the Golem host API. This approach ensures that durability is managed at the level of individual TTS operations (voice synthesis, streaming session creation, voice cloning, batch processing), providing a higher-level and clearer operation log, which aids in debugging and monitoring. See golem:llm and golem:embed for more details and durable implementations in this same repository.\n\nThe final deliverables associated with this ticket are:\n\n- **ElevenLabs implementation**: A WASM Component (WASI 0.23), named `tts-elevenlabs.wasm`, with a full test suite and custom durability implementation at the level of TTS operations.\n- **AWS Polly implementation**: A WASM Component (WASI 0.23), named `tts-polly.wasm`, with a full test suite and custom durability implementation at the level of TTS operations.\n- **Google Cloud TTS implementation**: A WASM Component (WASI 0.23), named `tts-google.wasm`, with a full test suite and custom durability implementation at the level of TTS operations.\n- **Deepgram Aura implementation**: A WASM Component (WASI 0.23), named `tts-deepgram.wasm`, with a full test suite and custom durability implementation at the level of TTS operations.\n\n**Note**: If you have a strong recommendation to swap out one or two of these with other popular / common TTS providers (such as Azure Cognitive Services Speech, IBM Watson Text to Speech, or OpenAI TTS), then as long as you get permission beforehand, that's okay with me. However, we definitely need ElevenLabs and AWS Polly.\n\nThese components will require runtime configuration, notably API keys, endpoint URLs, authentication credentials, and provider-specific settings. For configuring this information, the components can use environment variables for now (in the future, they will use wasi-runtime-config, but Golem does not support this yet, whereas Golem has good support for environment variables).\n\nMoreover, the Rust components need to be tested within Golem to ensure compatibility with Golem 1.2.x.\n\nThis WIT has been designed by examining and comparing the APIs of ElevenLabs, AWS Polly, Google Cloud TTS, Azure Speech Services, OpenAI TTS, and Deepgram Aura. However, given there are no implementations, it is possible the provided WIT is not the optimal abstraction across all these providers. Therefore, deviations from the proposed design can be made. However, to be accepted, any deviation must be fully justified and deemed by Golem core contributors to be an improvement from the original specification.\n\n## Implementation Guidelines\n\nEach provider implementation should handle the following key mapping considerations:\n\n- **Voice Management**: Map the unified voice resource to provider-specific voice identifiers, handle voice discovery and metadata appropriately for each provider's voice catalog structure\n- **Audio Format Conversion**: Implement native audio format support where available, or provide format conversion for unsupported output formats using audio processing libraries\n- **Streaming Implementation**: Utilize native streaming APIs where supported (ElevenLabs, Deepgram), or implement chunk-based synthesis for providers without native streaming support\n- **Authentication Handling**: Implement appropriate authentication mechanisms (API keys, OAuth, service accounts) per provider requirements\n- **Feature Availability**: Route advanced features (voice cloning, sound effects, speech marks) through provider-native APIs where supported, or return `unsupported-operation` errors for unavailable features\n- **Error Mapping**: Map provider-specific HTTP errors and API responses to the unified `tts-error` enumeration with appropriate context preservation\n- **Rate Limiting**: Handle provider-specific rate limits and quota management, implementing appropriate retry logic and error reporting\n- **Long-form Content**: Implement efficient handling of long-form synthesis using provider-native async operations (AWS Polly) or intelligent chunking strategies\n\n## Testing Requirements\n\nEach implementation must include comprehensive test suites covering:\n- Basic synthesis operations (text-to-speech with various voices and configurations)\n- Voice discovery and metadata retrieval\n- Streaming synthesis lifecycle (session creation, chunk processing, cleanup)\n- Advanced feature testing (voice cloning, sound effects, custom pronunciations where supported)\n- Audio format validation and quality verification\n- Authentication and authorization scenarios\n- Error handling for unsupported operations and malformed inputs\n- Rate limiting and quota management behavior\n- Connection management and retry logic\n- Long-form content synthesis (>5000 characters)\n- Durability semantics verification across operation boundaries\n- Provider-specific feature utilization (lexicons for Polly, voice settings for ElevenLabs, etc.)\n\n## Configuration Requirements\n\nEach implementation should support the following environment variables:\n\n### Common Configuration\n- `TTS_PROVIDER_ENDPOINT`: Custom endpoint URL (for enterprise/regional deployments)\n- `TTS_PROVIDER_TIMEOUT`: Request timeout in seconds (default: 30)\n- `TTS_PROVIDER_MAX_RETRIES`: Maximum retry attempts (default: 3)\n- `TTS_PROVIDER_LOG_LEVEL`: Logging verbosity (debug, info, warn, error)\n\n### Provider-Specific Configuration\n- **ElevenLabs**: `ELEVENLABS_API_KEY`, `ELEVENLABS_MODEL_VERSION`\n- **AWS Polly**: `AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`, `AWS_REGION`, `AWS_SESSION_TOKEN`\n- **Google Cloud**: `GOOGLE_APPLICATION_CREDENTIALS`, `GOOGLE_CLOUD_PROJECT`\n- **Deepgram**: `DEEPGRAM_API_KEY`, `DEEPGRAM_API_VERSION`\n\n```wit\npackage golem:tts@1.0.0;\n\n/// Core types and error handling for universal text-to-speech\ninterface types {\n    /// Comprehensive error types covering all TTS operations\n    variant tts-error {\n        /// Input validation errors\n        invalid-text(string),\n        text-too-long(u32),\n        invalid-ssml(string),\n        unsupported-language(string),\n        \n        /// Voice and model errors\n        voice-not-found(string),\n        model-not-found(string),\n        voice-unavailable(string),\n        \n        /// Authentication and authorization\n        unauthorized(string),\n        access-denied(string),\n        \n        /// Resource and quota limits\n        quota-exceeded(quota-info),\n        rate-limited(u32),\n        insufficient-credits,\n        \n        /// Operation errors\n        synthesis-failed(string),\n        unsupported-operation(string),\n        invalid-configuration(string),\n        \n        /// Service errors\n        service-unavailable(string),\n        network-error(string),\n        internal-error(string),\n        \n        /// Storage errors (for async operations)\n        invalid-storage-location(string),\n        storage-access-denied(string),\n    }\n\n    record quota-info {\n        used: u32,\n        limit: u32,\n        reset-time: u64,\n        unit: quota-unit,\n    }\n\n    enum quota-unit {\n        characters,\n        requests,\n        seconds,\n        credits,\n    }\n\n    /// Language identification using BCP 47 codes\n    type language-code = string;\n\n    /// Voice gender classification\n    enum voice-gender {\n        male,\n        female,\n        neutral,\n    }\n\n    /// Voice quality tiers\n    enum voice-quality {\n        standard,\n        premium,\n        neural,\n        studio,\n    }\n\n    /// Text input types\n    enum text-type {\n        plain,\n        ssml,\n    }\n\n    /// Audio output formats\n    enum audio-format {\n        mp3,\n        wav,\n        pcm,\n        ogg-opus,\n        aac,\n        flac,\n        mulaw,\n        alaw,\n    }\n\n    /// Audio quality settings\n    record audio-config {\n        format: audio-format,\n        sample-rate: option<u32>,\n        bit-rate: option<u32>,\n        channels: option<u8>,\n    }\n\n    /// Voice synthesis parameters\n    record voice-settings {\n        /// Speaking rate (0.25 to 4.0, default 1.0)\n        speed: option<f32>,\n        /// Pitch adjustment in semitones (-20.0 to 20.0, default 0.0)\n        pitch: option<f32>,\n        /// Volume gain in dB (-96.0 to 16.0, default 0.0)\n        volume: option<f32>,\n        /// Voice stability (0.0 to 1.0, provider-specific)\n        stability: option<f32>,\n        /// Similarity to original (0.0 to 1.0, provider-specific)\n        similarity: option<f32>,\n        /// Style exaggeration (0.0 to 1.0, provider-specific)\n        style: option<f32>,\n    }\n\n    /// Audio effects and device optimization\n    flags audio-effects {\n        telephone-quality,\n        headphone-optimized,\n        speaker-optimized,\n        car-audio-optimized,\n        noise-reduction,\n        bass-boost,\n        treble-boost,\n    }\n\n    /// Input text with metadata\n    record text-input {\n        content: string,\n        text-type: text-type,\n        language: option<language-code>,\n    }\n\n    /// Complete synthesis result\n    record synthesis-result {\n        audio-data: list<u8>,\n        metadata: synthesis-metadata,\n    }\n\n    /// Metadata about synthesized audio\n    record synthesis-metadata {\n        duration-seconds: f32,\n        character-count: u32,\n        word-count: u32,\n        audio-size-bytes: u32,\n        request-id: string,\n        provider-info: option<string>,\n    }\n\n    /// Streaming audio chunk\n    record audio-chunk {\n        data: list<u8>,\n        sequence-number: u32,\n        is-final: bool,\n        timing-info: option<timing-info>,\n    }\n\n    /// Timing and synchronization information\n    record timing-info {\n        start-time-seconds: f32,\n        end-time-seconds: option<f32>,\n        text-offset: option<u32>,\n        mark-type: option<timing-mark-type>,\n    }\n\n    enum timing-mark-type {\n        word,\n        sentence,\n        paragraph,\n        ssml-mark,\n        viseme,\n    }\n\n\n}\n\n/// Voice discovery and management\ninterface voices {\n    use types.{tts-error, language-code, voice-gender, voice-quality};\n\n    /// Represents a voice that can be used for speech synthesis\n    resource voice {\n        /// Get voice identification\n        get-id: func() -> string;\n        get-name: func() -> string;\n        get-provider-id: func() -> option<string>;\n        \n        /// Get voice characteristics\n        get-language: func() -> language-code;\n        get-additional-languages: func() -> list<language-code>;\n        get-gender: func() -> voice-gender;\n        get-quality: func() -> voice-quality;\n        get-description: func() -> option<string>;\n        \n        /// Voice capabilities\n        supports-ssml: func() -> bool;\n        get-sample-rates: func() -> list<u32>;\n        get-supported-formats: func() -> list<types.audio-format>;\n        \n        /// Voice management (may return unsupported-operation)\n        update-settings: func(settings: types.voice-settings) -> result<_, tts-error>;\n        delete: func() -> result<_, tts-error>;\n        clone: func() -> result<voice, tts-error>;\n        \n        /// Preview voice with sample text\n        preview: func(text: string) -> result<list<u8>, tts-error>;\n    }\n\n    /// Voice search and filtering\n    record voice-filter {\n        language: option<language-code>,\n        gender: option<voice-gender>,\n        quality: option<voice-quality>,\n        supports-ssml: option<bool>,\n        provider: option<string>,\n        search-query: option<string>,\n    }\n\n    /// Detailed voice information\n    record voice-info {\n        id: string,\n        name: string,\n        language: language-code,\n        additional-languages: list<language-code>,\n        gender: voice-gender,\n        quality: voice-quality,\n        description: option<string>,\n        provider: string,\n        sample-rate: u32,\n        is-custom: bool,\n        is-cloned: bool,\n        preview-url: option<string>,\n        use-cases: list<string>,\n    }\n\n    /// Resource-based iterator for voice results\n    resource voice-results {\n        /// Check if more voices are available\n        has-more: func() -> bool;\n        \n        /// Get next batch of voices\n        get-next: func() -> result<list<voice-info>, tts-error>;\n        \n        /// Get total count if available\n        get-total-count: func() -> option<u32>;\n    }\n\n    /// List available voices with filtering and pagination\n    list-voices: func(\n        filter: option<voice-filter>\n    ) -> result<voice-results, tts-error>;\n\n    /// Get specific voice by ID\n    get-voice: func(voice-id: string) -> result<voice, tts-error>;\n\n    /// Search voices by characteristics\n    search-voices: func(\n        query: string,\n        filter: option<voice-filter>\n    ) -> result<list<voice-info>, tts-error>;\n\n    /// Get supported languages\n    list-languages: func() -> result<list<language-info>, tts-error>;\n\n    record language-info {\n        code: language-code,\n        name: string,\n        native-name: string,\n        voice-count: u32,\n    }\n}\n\n/// Core text-to-speech synthesis operations\ninterface synthesis {\n    use types.{\n        text-input, audio-config, voice-settings, audio-effects,\n        synthesis-result, tts-error, timing-info\n    };\n    use voices.{voice};\n\n    /// Synthesis configuration options\n    record synthesis-options {\n        audio-config: option<audio-config>,\n        voice-settings: option<voice-settings>,\n        audio-effects: option<audio-effects>,\n        enable-timing: option<bool>,\n        enable-word-timing: option<bool>,\n        seed: option<u32>,\n        model-version: option<string>,\n        context: option<synthesis-context>,\n    }\n\n    /// Context for better synthesis quality\n    record synthesis-context {\n        previous-text: option<string>,\n        next-text: option<string>,\n        topic: option<string>,\n        emotion: option<string>,\n        speaking-style: option<string>,\n    }\n\n    /// Convert text to speech (removed async)\n    synthesize: func(\n        input: text-input,\n        voice: borrow<voice>,\n        options: option<synthesis-options>\n    ) -> result<synthesis-result, tts-error>;\n\n    /// Batch synthesis for multiple inputs (removed async)\n    synthesize-batch: func(\n        inputs: list<text-input>,\n        voice: borrow<voice>,\n        options: option<synthesis-options>\n    ) -> result<list<synthesis-result>, tts-error>;\n\n    /// Get timing information without audio synthesis\n    get-timing-marks: func(\n        input: text-input,\n        voice: borrow<voice>\n    ) -> result<list<timing-info>, tts-error>;\n\n    /// Validate text before synthesis\n    validate-input: func(\n        input: text-input,\n        voice: borrow<voice>\n    ) -> result<validation-result, tts-error>;\n\n    record validation-result {\n        is-valid: bool,\n        character-count: u32,\n        estimated-duration: option<f32>,\n        warnings: list<string>,\n        errors: list<string>,\n    }\n}\n\n/// Real-time streaming synthesis\ninterface streaming {\n    use types.{\n        text-input, audio-config, voice-settings, audio-chunk,\n        tts-error, timing-info\n    };\n    use voices.{voice};\n    use synthesis.{synthesis-options};\n\n    /// Streaming synthesis session\n    resource synthesis-stream {\n        /// Send text for synthesis (can be called multiple times)\n        send-text: func(input: text-input) -> result<_, tts-error>;\n        \n        /// Signal end of input and flush remaining audio\n        finish: func() -> result<_, tts-error>;\n        \n        /// Receive next audio chunk (non-blocking)\n        receive-chunk: func() -> result<option<audio-chunk>, tts-error>;\n        \n        /// Check if more chunks are available\n        has-pending-audio: func() -> bool;\n        \n        /// Get current stream status\n        get-status: func() -> stream-status;\n        \n        /// Close stream and clean up resources\n        close: func();\n    }\n\n    enum stream-status {\n        ready,\n        processing,\n        finished,\n        error,\n        closed,\n    }\n\n    /// Create streaming synthesis session\n    create-stream: func(\n        voice: borrow<voice>,\n        options: option<synthesis-options>\n    ) -> result<synthesis-stream, tts-error>;\n\n    /// Real-time voice conversion streaming\n    create-voice-conversion-stream: func(\n        target-voice: borrow<voice>,\n        options: option<synthesis-options>\n    ) -> result<voice-conversion-stream, tts-error>;\n\n    resource voice-conversion-stream {\n        /// Send input audio chunks\n        send-audio: func(audio-data: list<u8>) -> result<_, tts-error>;\n        \n        /// Receive converted audio chunks\n        receive-converted: func() -> result<option<audio-chunk>, tts-error>;\n        \n        finish: func() -> result<_, tts-error>;\n        close: func();\n    }\n}\n\n/// Advanced TTS features and voice manipulation\ninterface advanced {\n    use types.{tts-error, audio-config, language-code};\n    use voices.{voice};\n\n    /// Voice cloning and creation (removed async)\n    create-voice-clone: func(\n        name: string,\n        audio-samples: list<audio-sample>,\n        description: option<string>\n    ) -> result<voice, tts-error>;\n\n    record audio-sample {\n        data: list<u8>,\n        transcript: option<string>,\n        quality-rating: option<u8>,\n    }\n\n    /// Design synthetic voice (removed async)\n    design-voice: func(\n        name: string,\n        characteristics: voice-design-params\n    ) -> result<voice, tts-error>;\n\n    record voice-design-params {\n        gender: types.voice-gender,\n        age-category: age-category,\n        accent: string,\n        personality-traits: list<string>,\n        reference-voice: option<string>,\n    }\n\n    enum age-category {\n        child,\n        young-adult,\n        middle-aged,\n        elderly,\n    }\n\n    /// Voice-to-voice conversion (removed async)\n    convert-voice: func(\n        input-audio: list<u8>,\n        target-voice: borrow<voice>,\n        preserve-timing: option<bool>\n    ) -> result<list<u8>, tts-error>;\n\n    /// Generate sound effects from text description (removed async)\n    generate-sound-effect: func(\n        description: string,\n        duration-seconds: option<f32>,\n        style-influence: option<f32>\n    ) -> result<list<u8>, tts-error>;\n\n    /// Custom pronunciation management\n    resource pronunciation-lexicon {\n        get-name: func() -> string;\n        get-language: func() -> language-code;\n        get-entry-count: func() -> u32;\n        \n        /// Add pronunciation rule\n        add-entry: func(word: string, pronunciation: string) -> result<_, tts-error>;\n        \n        /// Remove pronunciation rule\n        remove-entry: func(word: string) -> result<_, tts-error>;\n        \n        /// Export lexicon content\n        export-content: func() -> result<string, tts-error>;\n    }\n\n    /// Create custom pronunciation lexicon\n    create-lexicon: func(\n        name: string,\n        language: language-code,\n        entries: option<list<pronunciation-entry>>\n    ) -> result<pronunciation-lexicon, tts-error>;\n\n    record pronunciation-entry {\n        word: string,\n        pronunciation: string,\n        part-of-speech: option<string>,\n    }\n\n    /// Long-form content synthesis with optimization (removed async)\n    synthesize-long-form: func(\n        content: string,\n        voice: borrow<voice>,\n        output-location: string,\n        chapter-breaks: option<list<u32>>\n    ) -> result<long-form-operation, tts-error>;\n\n    resource long-form-operation {\n        get-status: func() -> operation-status;\n        get-progress: func() -> f32;\n        cancel: func() -> result<_, tts-error>;\n        get-result: func() -> result<long-form-result, tts-error>;\n    }\n\n    enum operation-status {\n        pending,\n        processing,\n        completed,\n        failed,\n        cancelled,\n    }\n\n    record long-form-result {\n        output-location: string,\n        total-duration: f32,\n        chapter-durations: option<list<f32>>,\n        metadata: types.synthesis-metadata,\n    }\n}\n```",
                  "html_url": "https://github.com/golemcloud/golem-ai/issues/23"
                },
                "type": "github"
              },
              "hash": "golemcloud/golem-ai#23",
              "body": "I have attached to this ticket a WIT file that describes a generic interface for text-to-speech operations. This interface can be implemented by various providers, either by emulating features not present in a given provider, utilizing the provider's native support for a feature, or indicating an error if a particular combination is not natively supported by a provider.\n\nThe intent of this WIT specification is to allow developers of WASM components (on wasmCloud, Spin, or Golem) to leverage text-to-speech capabilities to build voice-powered applications, accessibility services, and audio content generation systems in a portable and provider-agnostic fashion.\n\nThis ticket involves constructing implementations of this WIT interface for the following providers:\n\n- **ElevenLabs**: The leading AI voice synthesis platform with comprehensive voice cloning, real-time streaming, voice conversion, and sound effects generation capabilities.\n- **AWS Polly**: Amazon's enterprise text-to-speech service with extensive language support, custom lexicons, speech marks, and asynchronous synthesis for long-form content.\n- **Google Cloud Text-to-Speech**: Google's neural voice synthesis service with WaveNet and Neural2 voices, device optimization profiles, and streaming synthesis capabilities.\n- **Deepgram Aura**: High-performance real-time TTS with session-based streaming, low-latency neural voices, and conversational AI optimization.\n\nThese implementations must be written in Rust and compilable to WASM Components (WASI 0.23 only, since Golem does not yet support WASI 0.3). The standard Rust toolchain for WASM component development can be employed (see cargo component and the Rust examples of components in this and other Golem repositories).\n\nAdditionally, these implementations should incorporate custom durability semantics using the Golem durability API and the Golem host API. This approach ensures that durability is managed at the level of individual TTS operations (voice synthesis, streaming session creation, voice cloning, batch processing), providing a higher-level and clearer operation log, which aids in debugging and monitoring. See golem:llm and golem:embed for more details and durable implementations in this same repository.\n\nThe final deliverables associated with this ticket are:\n\n- **ElevenLabs implementation**: A WASM Component (WASI 0.23), named `tts-elevenlabs.wasm`, with a full test suite and custom durability implementation at the level of TTS operations.\n- **AWS Polly implementation**: A WASM Component (WASI 0.23), named `tts-polly.wasm`, with a full test suite and custom durability implementation at the level of TTS operations.\n- **Google Cloud TTS implementation**: A WASM Component (WASI 0.23), named `tts-google.wasm`, with a full test suite and custom durability implementation at the level of TTS operations.\n- **Deepgram Aura implementation**: A WASM Component (WASI 0.23), named `tts-deepgram.wasm`, with a full test suite and custom durability implementation at the level of TTS operations.\n\n**Note**: If you have a strong recommendation to swap out one or two of these with other popular / common TTS providers (such as Azure Cognitive Services Speech, IBM Watson Text to Speech, or OpenAI TTS), then as long as you get permission beforehand, that's okay with me. However, we definitely need ElevenLabs and AWS Polly.\n\nThese components will require runtime configuration, notably API keys, endpoint URLs, authentication credentials, and provider-specific settings. For configuring this information, the components can use environment variables for now (in the future, they will use wasi-runtime-config, but Golem does not support this yet, whereas Golem has good support for environment variables).\n\nMoreover, the Rust components need to be tested within Golem to ensure compatibility with Golem 1.2.x.\n\nThis WIT has been designed by examining and comparing the APIs of ElevenLabs, AWS Polly, Google Cloud TTS, Azure Speech Services, OpenAI TTS, and Deepgram Aura. However, given there are no implementations, it is possible the provided WIT is not the optimal abstraction across all these providers. Therefore, deviations from the proposed design can be made. However, to be accepted, any deviation must be fully justified and deemed by Golem core contributors to be an improvement from the original specification.\n\n## Implementation Guidelines\n\nEach provider implementation should handle the following key mapping considerations:\n\n- **Voice Management**: Map the unified voice resource to provider-specific voice identifiers, handle voice discovery and metadata appropriately for each provider's voice catalog structure\n- **Audio Format Conversion**: Implement native audio format support where available, or provide format conversion for unsupported output formats using audio processing libraries\n- **Streaming Implementation**: Utilize native streaming APIs where supported (ElevenLabs, Deepgram), or implement chunk-based synthesis for providers without native streaming support\n- **Authentication Handling**: Implement appropriate authentication mechanisms (API keys, OAuth, service accounts) per provider requirements\n- **Feature Availability**: Route advanced features (voice cloning, sound effects, speech marks) through provider-native APIs where supported, or return `unsupported-operation` errors for unavailable features\n- **Error Mapping**: Map provider-specific HTTP errors and API responses to the unified `tts-error` enumeration with appropriate context preservation\n- **Rate Limiting**: Handle provider-specific rate limits and quota management, implementing appropriate retry logic and error reporting\n- **Long-form Content**: Implement efficient handling of long-form synthesis using provider-native async operations (AWS Polly) or intelligent chunking strategies\n\n## Testing Requirements\n\nEach implementation must include comprehensive test suites covering:\n- Basic synthesis operations (text-to-speech with various voices and configurations)\n- Voice discovery and metadata retrieval\n- Streaming synthesis lifecycle (session creation, chunk processing, cleanup)\n- Advanced feature testing (voice cloning, sound effects, custom pronunciations where supported)\n- Audio format validation and quality verification\n- Authentication and authorization scenarios\n- Error handling for unsupported operations and malformed inputs\n- Rate limiting and quota management behavior\n- Connection management and retry logic\n- Long-form content synthesis (>5000 characters)\n- Durability semantics verification across operation boundaries\n- Provider-specific feature utilization (lexicons for Polly, voice settings for ElevenLabs, etc.)\n\n## Configuration Requirements\n\nEach implementation should support the following environment variables:\n\n### Common Configuration\n- `TTS_PROVIDER_ENDPOINT`: Custom endpoint URL (for enterprise/regional deployments)\n- `TTS_PROVIDER_TIMEOUT`: Request timeout in seconds (default: 30)\n- `TTS_PROVIDER_MAX_RETRIES`: Maximum retry attempts (default: 3)\n- `TTS_PROVIDER_LOG_LEVEL`: Logging verbosity (debug, info, warn, error)\n\n### Provider-Specific Configuration\n- **ElevenLabs**: `ELEVENLABS_API_KEY`, `ELEVENLABS_MODEL_VERSION`\n- **AWS Polly**: `AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`, `AWS_REGION`, `AWS_SESSION_TOKEN`\n- **Google Cloud**: `GOOGLE_APPLICATION_CREDENTIALS`, `GOOGLE_CLOUD_PROJECT`\n- **Deepgram**: `DEEPGRAM_API_KEY`, `DEEPGRAM_API_VERSION`\n\n```wit\npackage golem:tts@1.0.0;\n\n/// Core types and error handling for universal text-to-speech\ninterface types {\n    /// Comprehensive error types covering all TTS operations\n    variant tts-error {\n        /// Input validation errors\n        invalid-text(string),\n        text-too-long(u32),\n        invalid-ssml(string),\n        unsupported-language(string),\n        \n        /// Voice and model errors\n        voice-not-found(string),\n        model-not-found(string),\n        voice-unavailable(string),\n        \n        /// Authentication and authorization\n        unauthorized(string),\n        access-denied(string),\n        \n        /// Resource and quota limits\n        quota-exceeded(quota-info),\n        rate-limited(u32),\n        insufficient-credits,\n        \n        /// Operation errors\n        synthesis-failed(string),\n        unsupported-operation(string),\n        invalid-configuration(string),\n        \n        /// Service errors\n        service-unavailable(string),\n        network-error(string),\n        internal-error(string),\n        \n        /// Storage errors (for async operations)\n        invalid-storage-location(string),\n        storage-access-denied(string),\n    }\n\n    record quota-info {\n        used: u32,\n        limit: u32,\n        reset-time: u64,\n        unit: quota-unit,\n    }\n\n    enum quota-unit {\n        characters,\n        requests,\n        seconds,\n        credits,\n    }\n\n    /// Language identification using BCP 47 codes\n    type language-code = string;\n\n    /// Voice gender classification\n    enum voice-gender {\n        male,\n        female,\n        neutral,\n    }\n\n    /// Voice quality tiers\n    enum voice-quality {\n        standard,\n        premium,\n        neural,\n        studio,\n    }\n\n    /// Text input types\n    enum text-type {\n        plain,\n        ssml,\n    }\n\n    /// Audio output formats\n    enum audio-format {\n        mp3,\n        wav,\n        pcm,\n        ogg-opus,\n        aac,\n        flac,\n        mulaw,\n        alaw,\n    }\n\n    /// Audio quality settings\n    record audio-config {\n        format: audio-format,\n        sample-rate: option<u32>,\n        bit-rate: option<u32>,\n        channels: option<u8>,\n    }\n\n    /// Voice synthesis parameters\n    record voice-settings {\n        /// Speaking rate (0.25 to 4.0, default 1.0)\n        speed: option<f32>,\n        /// Pitch adjustment in semitones (-20.0 to 20.0, default 0.0)\n        pitch: option<f32>,\n        /// Volume gain in dB (-96.0 to 16.0, default 0.0)\n        volume: option<f32>,\n        /// Voice stability (0.0 to 1.0, provider-specific)\n        stability: option<f32>,\n        /// Similarity to original (0.0 to 1.0, provider-specific)\n        similarity: option<f32>,\n        /// Style exaggeration (0.0 to 1.0, provider-specific)\n        style: option<f32>,\n    }\n\n    /// Audio effects and device optimization\n    flags audio-effects {\n        telephone-quality,\n        headphone-optimized,\n        speaker-optimized,\n        car-audio-optimized,\n        noise-reduction,\n        bass-boost,\n        treble-boost,\n    }\n\n    /// Input text with metadata\n    record text-input {\n        content: string,\n        text-type: text-type,\n        language: option<language-code>,\n    }\n\n    /// Complete synthesis result\n    record synthesis-result {\n        audio-data: list<u8>,\n        metadata: synthesis-metadata,\n    }\n\n    /// Metadata about synthesized audio\n    record synthesis-metadata {\n        duration-seconds: f32,\n        character-count: u32,\n        word-count: u32,\n        audio-size-bytes: u32,\n        request-id: string,\n        provider-info: option<string>,\n    }\n\n    /// Streaming audio chunk\n    record audio-chunk {\n        data: list<u8>,\n        sequence-number: u32,\n        is-final: bool,\n        timing-info: option<timing-info>,\n    }\n\n    /// Timing and synchronization information\n    record timing-info {\n        start-time-seconds: f32,\n        end-time-seconds: option<f32>,\n        text-offset: option<u32>,\n        mark-type: option<timing-mark-type>,\n    }\n\n    enum timing-mark-type {\n        word,\n        sentence,\n        paragraph,\n        ssml-mark,\n        viseme,\n    }\n\n\n}\n\n/// Voice discovery and management\ninterface voices {\n    use types.{tts-error, language-code, voice-gender, voice-quality};\n\n    /// Represents a voice that can be used for speech synthesis\n    resource voice {\n        /// Get voice identification\n        get-id: func() -> string;\n        get-name: func() -> string;\n        get-provider-id: func() -> option<string>;\n        \n        /// Get voice characteristics\n        get-language: func() -> language-code;\n        get-additional-languages: func() -> list<language-code>;\n        get-gender: func() -> voice-gender;\n        get-quality: func() -> voice-quality;\n        get-description: func() -> option<string>;\n        \n        /// Voice capabilities\n        supports-ssml: func() -> bool;\n        get-sample-rates: func() -> list<u32>;\n        get-supported-formats: func() -> list<types.audio-format>;\n        \n        /// Voice management (may return unsupported-operation)\n        update-settings: func(settings: types.voice-settings) -> result<_, tts-error>;\n        delete: func() -> result<_, tts-error>;\n        clone: func() -> result<voice, tts-error>;\n        \n        /// Preview voice with sample text\n        preview: func(text: string) -> result<list<u8>, tts-error>;\n    }\n\n    /// Voice search and filtering\n    record voice-filter {\n        language: option<language-code>,\n        gender: option<voice-gender>,\n        quality: option<voice-quality>,\n        supports-ssml: option<bool>,\n        provider: option<string>,\n        search-query: option<string>,\n    }\n\n    /// Detailed voice information\n    record voice-info {\n        id: string,\n        name: string,\n        language: language-code,\n        additional-languages: list<language-code>,\n        gender: voice-gender,\n        quality: voice-quality,\n        description: option<string>,\n        provider: string,\n        sample-rate: u32,\n        is-custom: bool,\n        is-cloned: bool,\n        preview-url: option<string>,\n        use-cases: list<string>,\n    }\n\n    /// Resource-based iterator for voice results\n    resource voice-results {\n        /// Check if more voices are available\n        has-more: func() -> bool;\n        \n        /// Get next batch of voices\n        get-next: func() -> result<list<voice-info>, tts-error>;\n        \n        /// Get total count if available\n        get-total-count: func() -> option<u32>;\n    }\n\n    /// List available voices with filtering and pagination\n    list-voices: func(\n        filter: option<voice-filter>\n    ) -> result<voice-results, tts-error>;\n\n    /// Get specific voice by ID\n    get-voice: func(voice-id: string) -> result<voice, tts-error>;\n\n    /// Search voices by characteristics\n    search-voices: func(\n        query: string,\n        filter: option<voice-filter>\n    ) -> result<list<voice-info>, tts-error>;\n\n    /// Get supported languages\n    list-languages: func() -> result<list<language-info>, tts-error>;\n\n    record language-info {\n        code: language-code,\n        name: string,\n        native-name: string,\n        voice-count: u32,\n    }\n}\n\n/// Core text-to-speech synthesis operations\ninterface synthesis {\n    use types.{\n        text-input, audio-config, voice-settings, audio-effects,\n        synthesis-result, tts-error, timing-info\n    };\n    use voices.{voice};\n\n    /// Synthesis configuration options\n    record synthesis-options {\n        audio-config: option<audio-config>,\n        voice-settings: option<voice-settings>,\n        audio-effects: option<audio-effects>,\n        enable-timing: option<bool>,\n        enable-word-timing: option<bool>,\n        seed: option<u32>,\n        model-version: option<string>,\n        context: option<synthesis-context>,\n    }\n\n    /// Context for better synthesis quality\n    record synthesis-context {\n        previous-text: option<string>,\n        next-text: option<string>,\n        topic: option<string>,\n        emotion: option<string>,\n        speaking-style: option<string>,\n    }\n\n    /// Convert text to speech (removed async)\n    synthesize: func(\n        input: text-input,\n        voice: borrow<voice>,\n        options: option<synthesis-options>\n    ) -> result<synthesis-result, tts-error>;\n\n    /// Batch synthesis for multiple inputs (removed async)\n    synthesize-batch: func(\n        inputs: list<text-input>,\n        voice: borrow<voice>,\n        options: option<synthesis-options>\n    ) -> result<list<synthesis-result>, tts-error>;\n\n    /// Get timing information without audio synthesis\n    get-timing-marks: func(\n        input: text-input,\n        voice: borrow<voice>\n    ) -> result<list<timing-info>, tts-error>;\n\n    /// Validate text before synthesis\n    validate-input: func(\n        input: text-input,\n        voice: borrow<voice>\n    ) -> result<validation-result, tts-error>;\n\n    record validation-result {\n        is-valid: bool,\n        character-count: u32,\n        estimated-duration: option<f32>,\n        warnings: list<string>,\n        errors: list<string>,\n    }\n}\n\n/// Real-time streaming synthesis\ninterface streaming {\n    use types.{\n        text-input, audio-config, voice-settings, audio-chunk,\n        tts-error, timing-info\n    };\n    use voices.{voice};\n    use synthesis.{synthesis-options};\n\n    /// Streaming synthesis session\n    resource synthesis-stream {\n        /// Send text for synthesis (can be called multiple times)\n        send-text: func(input: text-input) -> result<_, tts-error>;\n        \n        /// Signal end of input and flush remaining audio\n        finish: func() -> result<_, tts-error>;\n        \n        /// Receive next audio chunk (non-blocking)\n        receive-chunk: func() -> result<option<audio-chunk>, tts-error>;\n        \n        /// Check if more chunks are available\n        has-pending-audio: func() -> bool;\n        \n        /// Get current stream status\n        get-status: func() -> stream-status;\n        \n        /// Close stream and clean up resources\n        close: func();\n    }\n\n    enum stream-status {\n        ready,\n        processing,\n        finished,\n        error,\n        closed,\n    }\n\n    /// Create streaming synthesis session\n    create-stream: func(\n        voice: borrow<voice>,\n        options: option<synthesis-options>\n    ) -> result<synthesis-stream, tts-error>;\n\n    /// Real-time voice conversion streaming\n    create-voice-conversion-stream: func(\n        target-voice: borrow<voice>,\n        options: option<synthesis-options>\n    ) -> result<voice-conversion-stream, tts-error>;\n\n    resource voice-conversion-stream {\n        /// Send input audio chunks\n        send-audio: func(audio-data: list<u8>) -> result<_, tts-error>;\n        \n        /// Receive converted audio chunks\n        receive-converted: func() -> result<option<audio-chunk>, tts-error>;\n        \n        finish: func() -> result<_, tts-error>;\n        close: func();\n    }\n}\n\n/// Advanced TTS features and voice manipulation\ninterface advanced {\n    use types.{tts-error, audio-config, language-code};\n    use voices.{voice};\n\n    /// Voice cloning and creation (removed async)\n    create-voice-clone: func(\n        name: string,\n        audio-samples: list<audio-sample>,\n        description: option<string>\n    ) -> result<voice, tts-error>;\n\n    record audio-sample {\n        data: list<u8>,\n        transcript: option<string>,\n        quality-rating: option<u8>,\n    }\n\n    /// Design synthetic voice (removed async)\n    design-voice: func(\n        name: string,\n        characteristics: voice-design-params\n    ) -> result<voice, tts-error>;\n\n    record voice-design-params {\n        gender: types.voice-gender,\n        age-category: age-category,\n        accent: string,\n        personality-traits: list<string>,\n        reference-voice: option<string>,\n    }\n\n    enum age-category {\n        child,\n        young-adult,\n        middle-aged,\n        elderly,\n    }\n\n    /// Voice-to-voice conversion (removed async)\n    convert-voice: func(\n        input-audio: list<u8>,\n        target-voice: borrow<voice>,\n        preserve-timing: option<bool>\n    ) -> result<list<u8>, tts-error>;\n\n    /// Generate sound effects from text description (removed async)\n    generate-sound-effect: func(\n        description: string,\n        duration-seconds: option<f32>,\n        style-influence: option<f32>\n    ) -> result<list<u8>, tts-error>;\n\n    /// Custom pronunciation management\n    resource pronunciation-lexicon {\n        get-name: func() -> string;\n        get-language: func() -> language-code;\n        get-entry-count: func() -> u32;\n        \n        /// Add pronunciation rule\n        add-entry: func(word: string, pronunciation: string) -> result<_, tts-error>;\n        \n        /// Remove pronunciation rule\n        remove-entry: func(word: string) -> result<_, tts-error>;\n        \n        /// Export lexicon content\n        export-content: func() -> result<string, tts-error>;\n    }\n\n    /// Create custom pronunciation lexicon\n    create-lexicon: func(\n        name: string,\n        language: language-code,\n        entries: option<list<pronunciation-entry>>\n    ) -> result<pronunciation-lexicon, tts-error>;\n\n    record pronunciation-entry {\n        word: string,\n        pronunciation: string,\n        part-of-speech: option<string>,\n    }\n\n    /// Long-form content synthesis with optimization (removed async)\n    synthesize-long-form: func(\n        content: string,\n        voice: borrow<voice>,\n        output-location: string,\n        chapter-breaks: option<list<u32>>\n    ) -> result<long-form-operation, tts-error>;\n\n    resource long-form-operation {\n        get-status: func() -> operation-status;\n        get-progress: func() -> f32;\n        cancel: func() -> result<_, tts-error>;\n        get-result: func() -> result<long-form-result, tts-error>;\n    }\n\n    enum operation-status {\n        pending,\n        processing,\n        completed,\n        failed,\n        cancelled,\n    }\n\n    record long-form-result {\n        output-location: string,\n        total-duration: f32,\n        chapter-durations: option<list<f32>>,\n        metadata: types.synthesis-metadata,\n    }\n}\n```",
              "url": "https://github.com/golemcloud/golem-ai/issues/23",
              "tech": [
                "go"
              ],
              "repo_name": "golem-ai",
              "repo_owner": "golemcloud",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "ZIO#517",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "ZIO",
              "id": "generated-ZIO",
              "name": "ZIO",
              "description": "",
              "members": [],
              "display_name": "ZIO",
              "created_at": "2026-01-23T05:51:28.439Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/ZIO?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "zio",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-23T05:51:28.439Z",
            "created_at": "2026-01-23T05:51:28.439Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-ZIO#517",
              "status": "open",
              "type": "issue",
              "number": 517,
              "title": "Add structural schemas",
              "source": {
                "data": {
                  "id": "source-ZIO#517",
                  "user": {
                    "login": "jdegoes",
                    "id": 156745,
                    "node_id": "MDQ6VXNlcjE1Njc0NQ==",
                    "avatar_url": "https://avatars.githubusercontent.com/u/156745?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/jdegoes",
                    "html_url": "https://github.com/jdegoes",
                    "followers_url": "https://api.github.com/users/jdegoes/followers",
                    "following_url": "https://api.github.com/users/jdegoes/following{/other_user}",
                    "gists_url": "https://api.github.com/users/jdegoes/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/jdegoes/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/jdegoes/subscriptions",
                    "organizations_url": "https://api.github.com/users/jdegoes/orgs",
                    "repos_url": "https://api.github.com/users/jdegoes/repos",
                    "events_url": "https://api.github.com/users/jdegoes/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/jdegoes/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Add structural schemas",
                  "body": "# Structural Type Schema Support\n\n## Overview\n\nExtend `Schema[A]` to support structural types, enabling schema derivation for types defined by their structure rather than their nominal identity. This allows for duck-typed schema validation and conversion between nominal and structural representations.\n\n## Core Concepts\n\n### Direct Structural Schema Derivation\n\nSchemas can be derived directly for structural types:\n\n```scala\n// Scala 3\ntype Person = { def name: String; def age: Int }\nval schema = Schema.derived[Person]\n\n// Scala 2\ntype Person = { def name: String; def age: Int }\nval schema = Schema.derived[Person]\n```\n\n**Note**: Both Scala 2 and Scala 3 use `def` for uniformity, even though Scala 3 supports `val` in structural types.\n\n**Implementation**: Schemas have bindings, which allow construction / deconstruction of values. Values for structural types are backed by:\n- **Scala 3**: `Selectable` \n- **Scala 2**: `Dynamic`\n\n### Nominal to Structural Conversion\n\nConvert nominal type schemas to their structural equivalents:\n\n```scala\ncase class Person(name: String, age: Int)\n\n// Get the structural schema corresponding to Person's shape\nval structuralSchema: Schema[{ def name: String; def age: Int }] = \n  Schema.derived[Person].structural\n```\n\n### Schema API Extension\n\n```scala\ncase class Schema[A](/* existing fields */) {\n  /**\n   * Convert this schema to a structural type schema.\n   * \n   * The structural type represents the \"shape\" of A without its nominal identity.\n   * This enables duck typing and structural validation.\n   * \n   * @param toStructural Macro-generated conversion to structural representation\n   * @return Schema for the structural type corresponding to A\n   */\n  def structural(implicit toStructural: ToStructural[A]): Schema[toStructural.StructuralType] = \n    toStructural.apply(this)\n}\n\n/**\n * Type class for converting nominal schemas to structural schemas.\n * Generated by macro for all supported types. Macro fails if a structural\n * type cannot be generated.\n *\n * NOTE: This approach has to be tested to yield inferrable types, and revised\n * if necessary. Inferrable types (from calling Schema#structural) are a must-have.\n */\ntrait ToStructural[A] {\n  type StructuralType\n  def apply(schema: Schema[A]): Schema[StructuralType]\n}\n\nobject ToStructural {\n  type Aux[A, S] = ToStructural[A] { type StructuralType = S }\n  \n  // Scala 3\n  transparent inline given [A]: ToStructural[A] = ${toStructuralMacro[A]}\n  \n  // Scala 2\n  implicit def materialize[A]: ToStructural[A] = macro toStructuralImpl[A]\n}\n```\n\n---\n\n## Examples\n\n### 1. Simple Product Types\n\n#### Case Class to Structural\n\n```scala\n// Both Scala 2 and Scala 3\ncase class Person(name: String, age: Int)\n\n// Original nominal schema\nval nominalSchema: Schema[Person] = Schema.derived[Person]\n\n// Convert to structural\nval structuralSchema: Schema[{ def name: String; def age: Int }] = \n  nominalSchema.structural\n\n// Direct structural derivation (equivalent)\nval directStructural: Schema[{ def name: String; def age: Int }] = \n  Schema.derived[{ def name: String; def age: Int }]\n```\n\n### 2. Nested Structures\n\n```scala\ncase class Address(street: String, city: String, zip: Int)\ncase class Person(name: String, age: Int, address: Address)\n\nval structuralSchema = Schema.derived[Person].structural\n// Type: Schema[{ \n//   def name: String\n//   def age: Int\n//   def address: { def street: String; def city: String; def zip: Int }\n// }]\n```\n\n### 3. Collections and Options\n\n```scala\ncase class Team(name: String, members: List[String], leader: Option[String])\n\nval structuralSchema = Schema.derived[Team].structural\n// Type: Schema[{\n//   def name: String\n//   def members: List[String]\n//   def leader: Option[String]\n// }]\n```\n\n### 4. Tuples to Structural\n\n```scala\n// Tuples can be converted to structural types\nval tupleSchema: Schema[(String, Int, Boolean)] = Schema.derived[(String, Int, Boolean)]\n\nval structuralSchema = tupleSchema.structural\n// Type: Schema[{ def _1: String; def _2: Int; def _3: Boolean }]\n```\n\n### 5. Sum Types (Sealed Traits) - Scala 3 Only\n\nSealed traits become union types of structural representations, with tag information stored at the type level:\n\n```scala\n// Scala 3 only\nsealed trait Result\ncase class Success(value: Int) extends Result\ncase class Failure(error: String) extends Result\n\nval structuralSchema = Schema.derived[Result].structural\n// Type: Schema[\n//   { type Tag = \"Success\"; def value: Int } | { type Tag = \"Failure\"; def error: String }\n// ]\n```\n\n**Note**: Sum type to structural conversion is **not supported in Scala 2** because it requires union types. Attempting to call `.structural` on a sealed trait schema in Scala 2 will result in a compile-time error.\n\n### 6. Enums (Scala 3 Only)\n\n```scala\nenum Status:\n  case Active, Inactive, Suspended\n\nval structuralSchema = Schema.derived[Status].structural\n// Type: Schema[{type Tag = \"Active\"} | {type Tag = \"Inactive\"} | {type Tag = \"Suspended\"}]\n```\n\n### 7. Opaque Types (Scala 3)\n\n```scala\nopaque type UserId = String\nobject UserId:\n  def apply(value: String): Either[String, UserId] = \n    if value.nonEmpty then Right(value) else Left(\"Empty user ID\")\n\ncase class User(id: UserId, name: String)\n\nval structuralSchema = Schema.derived[User].structural\n// Type: Schema[{ def id: String; def name: String }]\n// Opaque type is unwrapped to its underlying type\n```\n\n### 8. Bidirectional Conversion\n\nStructural schemas work seamlessly with `Into`/`As` (if this ticket is implemented **after** that ticket):\n\n```scala\ncase class Person(name: String, age: Int)\n\nval structuralSchema = Schema.derived[Person].structural\n\n// Create structural value (Scala 3)\nval structuralPerson = new Selectable {\n  def selectDynamic(field: String): Any = field match {\n    case \"name\" => \"Alice\"\n    case \"age\" => 30\n  }\n}\n\n// Convert structural to nominal using Into\nval person: Either[SchemaError, Person] = \n  Into[{ def name: String; def age: Int }, Person].into(structuralPerson)\n// => Right(Person(\"Alice\", 30))\n\n// Convert nominal to structural\nval backToStructural: Either[SchemaError, { def name: String; def age: Int }] = \n  Into[Person, { def name: String; def age: Int }].into(Person(\"Bob\", 25))\n```\n\n### 9. Empty and Single-Field Products\n\n```scala\n// Empty case class\ncase class Empty()\nval emptyStructural = Schema.derived[Empty].structural\n// Type: Schema[{}]\n\n// Single field\ncase class Id(value: String)\nval idStructural = Schema.derived[Id].structural\n// Type: Schema[{ def value: String }]\n```\n\n### 10. Large Products\n\n```scala\ncase class LargeRecord(\n  f1: String, f2: Int, f3: Boolean, f4: Double, f5: Long,\n  f6: String, f7: Int, f8: Boolean, f9: Double, f10: Long,\n  f11: String, f12: Int, f13: Boolean, f14: Double, f15: Long,\n  f16: String, f17: Int, f18: Boolean, f19: Double, f20: Long,\n  f21: String\n)\n\nval structuralSchema = Schema.derived[LargeRecord].structural\n// Type: Schema[{\n//   def f1: String; def f2: Int; def f3: Boolean; ...\n//   def f21: String\n// }]\n```\n\n---\n\n## Type Name Handling\n\n### Current Limitation\n\nSchemas currently use `TypeName[A]` to identify types. Structural types don't have meaningful nominal type names, which creates a mismatch.\n\n### Temporary Solution\n\nUntil `TypeName[A]` is replaced with `TypeId[A]` (see issue #471), structural schemas will use a normalized string representation of the structural type as a fake type name:\n\n```scala\ncase class Person(name: String, age: Int)\n\nval schema = Schema.derived[Person]\nschema.typeName // => TypeName for \"Person\"\n\nval structural = schema.structural\nstructural.typeName // => TypeName for \"{age:Int,name:String}\"\n// Normalized: fields sorted alphabetically, types fully qualified\n```\n\n### Normalization Rules\n\n1. **Field ordering**: Alphabetical by field name\n2. **Type qualification**: Use simple names for primitives and standard library types\n3. **Whitespace**: No whitespace in generated names\n4. **Collections**: Standard notation (e.g., `List[Int]`)\n5. **Options**: Explicit `Option[T]` notation\n6. **Nested structures**: Recursive application of rules\n7. **Deterministic**: Same structure always produces same normalized name\n\n### Examples\n\n```scala\n// Simple product\ncase class Point(x: Int, y: Int)\nSchema.derived[Point].structural.typeName \n// => \"{x:Int,y:Int}\"\n\n// Nested product\ncase class Address(street: String, zip: Int)\ncase class Person(name: String, address: Address)\nSchema.derived[Person].structural.typeName\n// => \"{address:{street:String,zip:Int},name:String}\"\n\n// With collections\ncase class Team(name: String, members: List[String])\nSchema.derived[Team].structural.typeName\n// => \"{members:List[String],name:String}\"\n\n// Union type (Scala 3)\nsealed trait Result\ncase class Success(value: Int) extends Result\ncase class Failure(error: String) extends Result\nSchema.derived[Result].structural.typeName\n// => \"{error:String}|{value:Int}\"\n```\n\n### Future: TypeId[A]\n\nThe upcoming `TypeId[A]` replacement will properly handle structural types by representing them by their structure rather than a string-based hack. See issue #471 for details.\n\n---\n\n## Limitations and Edge Cases\n\n### 1. Generic Types\n\n**Behavior depends on existing Schema derivation support for generic types.**\n\nIf `Schema.derived[Container[Int]]` already works, then structural conversion should work:\n\n```scala\ncase class Container[T](value: T)\n\n// If this works:\nval schema = Schema.derived[Container[Int]]\n\n// Then this should work:\nval structural = schema.structural\n// Type: Schema[{ def value: Int }]\n```\n\nIf generic type derivation is not currently supported, this ticket **does not require implementing it**. The macro should produce a clear compile-time error for unsupported generic types.\n\n### 2. Recursive Types\n\nRecursive types will **fail at compile-time** because Scala does not support infinite types:\n\n```scala\ncase class Tree(value: Int, children: List[Tree])\n\n// This will FAIL at compile-time:\nval structural = Schema.derived[Tree].structural\n// Compile error: Cannot generate infinite structural type\n\n// The structural type would need to be:\n// { def value: Int; def children: List[{ def value: Int; def children: List[...] }] }\n// which is infinite and unsupported\n```\n\nThe macro must detect recursive types and produce a helpful error message:\n\n```\nCompile error: Cannot generate structural type for recursive type Tree.\nStructural types cannot represent recursive structures.\n```\n\n### 3. Mutually Recursive Types\n\nSimilarly, mutually recursive types are unsupported:\n\n```scala\ncase class Node(id: Int, edges: List[Edge])\ncase class Edge(from: Int, to: Node)\n\n// This will FAIL at compile-time:\nval nodeStructural = Schema.derived[Node].structural\n// Compile error: Cannot generate structural type for mutually recursive types\n```\n\n### 4. Sum Types in Scala 2\n\nSealed traits and sum types **cannot be converted to structural types in Scala 2** because they require union types:\n\n```scala\n// Scala 2\nsealed trait Result\ncase class Success(value: Int) extends Result\ncase class Failure(error: String) extends Result\n\n// This will FAIL at compile-time in Scala 2:\nval structural = Schema.derived[Result].structural\n// Compile error: Cannot generate structural type for sum types in Scala 2.\n// Union types are required, which are only available in Scala 3.\n```\n\nThe macro must detect sum types in Scala 2 and produce a clear error.\n\n### 5. Case Objects\n\nCase objects become empty structural types:\n\n```scala\ncase object Singleton\n\nval structural = Schema.derived[Singleton.type].structural\n// Type: Schema[{}]\n```\n\nFor sum types with case objects (Scala 3):\n\n```scala\nsealed trait Status\ncase object Active extends Status\ncase object Inactive extends Status\n\nval structural = Schema.derived[Status].structural\n// Type: Schema[{} | {}]\n// Not particularly useful, but valid\n```\n\n### 6. Structural Types as Source\n\nDeriving schemas directly for structural types is supported:\n\n```scala\ntype PersonStructure = { def name: String; def age: Int }\n\nval schema = Schema.derived[PersonStructure]\n// Should work if structural type derivation is implemented\n```\n\nThe schema's bindings will use `Selectable` (Scala 3) or `Dynamic` (Scala 2) to construct and deconstruct values.\n\n---\n\n## Integration with Into/As\n\nStructural schemas compose naturally with `Into`/`As` conversions.\n\n### Nominal → Structural\n\n```scala\ncase class Person(name: String, age: Int)\n\n// Auto-derived conversion\nval nominalToStructural: Into[Person, { def name: String; def age: Int }] = \n  Into.derived\n\nval person = Person(\"Alice\", 30)\nval structural = nominalToStructural.into(person)\n// => Right(<Selectable/Dynamic instance>)\n```\n\n### Structural → Nominal\n\n```scala\ntype PersonStructure = { def name: String; def age: Int }\ncase class Person(name: String, age: Int)\n\n// Auto-derived conversion\nval structuralToNominal: Into[PersonStructure, Person] = \n  Into.derived\n\nval structural: PersonStructure = new Selectable {\n  def selectDynamic(field: String): Any = field match {\n    case \"name\" => \"Bob\"\n    case \"age\" => 25\n  }\n}\n\nval person = structuralToNominal.into(structural)\n// => Right(Person(\"Bob\", 25))\n```\n\n### Bidirectional (As)\n\n```scala\ncase class Person(name: String, age: Int)\n\n// Bidirectional conversion\nval personAs: As[Person, { def name: String; def age: Int }] = \n  As.derived\n\n// Nominal → Structural\nval structural = personAs.into(Person(\"Alice\", 30))\n\n// Structural → Nominal\nval nominal = structural.flatMap(personAs.from)\n// Round-trip successful\n```\n\n### Schema-Guided Conversion\n\n```scala\ncase class PersonV1(firstName: String, lastName: String, age: Int)\ncase class PersonV2(name: String, age: Int)\n\n// Use structural type as intermediary\ntype PersonStructure = { def name: String; def age: Int }\n\n// Step 1: Transform V1 to structural (custom logic)\nval v1ToStructural: Into[PersonV1, PersonStructure] = \n  new Into[PersonV1, PersonStructure] {\n    def into(v1: PersonV1): Either[SchemaError, PersonStructure] = {\n      Right(new Selectable {\n        def selectDynamic(field: String): Any = field match {\n          case \"name\" => s\"${v1.firstName} ${v1.lastName}\"\n          case \"age\" => v1.age\n        }\n      })\n    }\n  }\n\n// Step 2: Auto-convert structural to V2\nval structuralToV2: Into[PersonStructure, PersonV2] = Into.derived\n\n// Composed migration\ndef migrate(v1: PersonV1): Either[SchemaError, PersonV2] = {\n  v1ToStructural.into(v1).flatMap(structuralToV2.into)\n}\n```\n\n---\n\n## Testing Requirements\n\n### Test Matrix\n\n1. **Direct Structural Derivation**\n   - Simple products (case classes)\n   - Nested products\n   - Collections (List, Vector, Set, Map, Option, Either)\n   - Tuples (2-22 elements)\n   - Empty case classes\n   - Single-field case classes\n   - Large products (20+ fields)\n   - Case objects\n\n2. **Nominal to Structural Conversion**\n   - Case class → structural\n   - Tuple → structural\n   - Nested case classes → nested structural\n   - Case class with collections → structural with collections\n   - Empty case class → empty structural\n\n3. **Sum Types (Scala 3 Only)**\n   - Sealed trait → union type structural\n   - Sealed trait with case objects\n   - Enum → union type structural\n   - Nested sum types\n\n4. **Type Name Generation**\n   - Simple product normalized name\n   - Nested product normalized name\n   - Name determinism (same structure = same name)\n   - Alphabetical field ordering in names\n   - Union type names (Scala 3)\n\n5. **Selectable/Dynamic Implementation**\n   - Scala 3 Selectable field access\n   - Scala 2 Dynamic field access\n   - Field access correctness\n   - Missing field behavior\n   - Extra field behavior\n\n6. **Integration with Into/As**\n   - Nominal → Structural via Into\n   - Structural → Nominal via Into\n   - Round-trip via As\n   - Composed conversions with structural intermediary\n\n7. **Error Cases (Compile-Time)**\n   - Recursive types produce error\n   - Mutually recursive types produce error\n   - Sum types in Scala 2 produce error\n   - Unsupported types produce helpful errors\n\n8. **Generic Types** (if supported by existing Schema derivation)\n   - Fully applied generic → structural\n   - Generic with nested structural fields\n\n### Scala 2 vs Scala 3 Test Separation\n\n```\nsrc/test/scala/\n  structural/\n    common/\n      SimpleProductSpec.scala\n      NestedProductSpec.scala\n      CollectionsSpec.scala\n      TuplesSpec.scala\n      EmptyProductSpec.scala\n      SingleFieldSpec.scala\n      LargeProductSpec.scala\n      TypeNameNormalizationSpec.scala\n      IntoIntegrationSpec.scala\n      AsIntegrationSpec.scala\n      \n    scala3/\n      UnionTypesSpec.scala\n      SealedTraitToUnionSpec.scala\n      EnumToUnionSpec.scala\n      SelectableImplementationSpec.scala\n      \n    scala2/\n      DynamicImplementationSpec.scala\n      SumTypeErrorSpec.scala (verifies compile error)\n      \n    errors/\n      RecursiveTypeErrorSpec.scala\n      MutualRecursionErrorSpec.scala\n      UnsupportedTypeErrorSpec.scala\n```\n\n### Test Examples\n\n```scala\n// Test: Simple product to structural\ntest(\"case class converts to structural schema\") {\n  case class Person(name: String, age: Int)\n  \n  val structural = Schema.derived[Person].structural\n  \n  // Type check (this is a compile-time test)\n  val _: Schema[{ def name: String; def age: Int }] = structural\n  \n  assert(structural.typeName.toString.contains(\"name\"))\n  assert(structural.typeName.toString.contains(\"age\"))\n}\n\n// Test: Nested products\ntest(\"nested case classes convert to nested structural\") {\n  case class Address(street: String, zip: Int)\n  case class Person(name: String, address: Address)\n  \n  val structural = Schema.derived[Person].structural\n  \n  val _: Schema[{ \n    def name: String\n    def address: { def street: String; def zip: Int }\n  }] = structural\n}\n\n// Test: Tuple to structural\ntest(\"tuple converts to structural with _N fields\") {\n  val structural = Schema.derived[(String, Int, Boolean)].structural\n  \n  val _: Schema[{ def _1: String; def _2: Int; def _3: Boolean }] = structural\n}\n\n// Test: Union type (Scala 3 only)\ntest(\"sealed trait converts to union type structural\") {\n  sealed trait Result\n  case class Success(value: Int) extends Result\n  case class Failure(error: String) extends Result\n  \n  val structural = Schema.derived[Result].structural\n  \n  val _: Schema[{ def value: Int } | { def error: String }] = structural\n}\n\n// Test: Type name normalization\ntest(\"structural type names are normalized and deterministic\") {\n  case class Person(name: String, age: Int)\n  case class User(age: Int, name: String) // Different field order\n  \n  val personStructural = Schema.derived[Person].structural\n  val userStructural = Schema.derived[User].structural\n  \n  // Same structure, same normalized name\n  assert(personStructural.typeName == userStructural.typeName)\n  \n  // Alphabetical ordering\n  assert(personStructural.typeName.toString.contains(\"age\"))\n  assert(personStructural.typeName.toString.indexOf(\"age\") < \n         personStructural.typeName.toString.indexOf(\"name\"))\n}\n\n// Test: Integration with Into\ntest(\"structural to nominal conversion via Into\") {\n  case class Person(name: String, age: Int)\n  type PersonStructure = { def name: String; def age: Int }\n  \n  val structural: PersonStructure = new Selectable {\n    def selectDynamic(field: String): Any = field match {\n      case \"name\" => \"Alice\"\n      case \"age\" => 30\n    }\n  }\n  \n  val person = Into[PersonStructure, Person].into(structural)\n  assert(person == Right(Person(\"Alice\", 30)))\n}\n\n// Test: Round-trip via As\ntest(\"nominal to structural and back preserves data\") {\n  case class Person(name: String, age: Int)\n  type PersonStructure = { def name: String; def age: Int }\n  \n  val original = Person(\"Alice\", 30)\n  \n  val toStructural = As[Person, PersonStructure].into(original)\n  val backToNominal = toStructural.flatMap(As[Person, PersonStructure].from)\n  \n  assert(backToNominal == Right(original))\n}\n\n// Test: Recursive type compile error\ntest(\"recursive types produce compile error\") {\n  case class Tree(value: Int, children: List[Tree])\n  \n  assertDoesNotCompile(\"Schema.derived[Tree].structural\")\n}\n\n// Test: Sum type in Scala 2 compile error\ntest(\"sum types in Scala 2 produce compile error\") {\n  sealed trait Result\n  case class Success(value: Int) extends Result\n  \n  // Scala 2 only\n  assertDoesNotCompile(\"Schema.derived[Result].structural\")\n}\n```\n\n---\n\n## Implementation Notes\n\n### Macro Behavior\n\nThe macro must:\n\n1. **Detect product types** (case classes, tuples) and generate structural types with `def` members\n2. **Detect sum types** (sealed traits, enums) and:\n   - In Scala 3: Generate union types of structural representations\n   - In Scala 2: Fail with clear error message\n3. **Detect recursive types** and fail with clear error message\n4. **Normalize structural type representations** for type name generation\n5. **Generate `ToStructural` instance** with:\n   - `StructuralType` type member set to the generated structural type\n   - `apply` method that transforms the schema appropriately\n6. **Preserve field metadata** from original schema where applicable\n7. **Generate appropriate bindings** using `Selectable` (Scala 3) or `Dynamic` (Scala 2)\n\n### Schema Transformation\n\nWhen converting `Schema[A]` to `Schema[StructuralType]`:\n\n1. **Preserve field information**: Field names, types, optional/required status\n2. **Update type name**: Use normalized structural representation\n3. **Transform bindings**: Replace nominal constructors/deconstructors with structural equivalents\n4. **Preserve validation**: Maintain any validation logic that applies to field values\n5. **Handle nested schemas**: Recursively transform nested product types\n\n### Error Messages\n\nProvide clear compile-time errors:\n\n```scala\n// Recursive type\ncase class Tree(value: Int, children: List[Tree])\nSchema.derived[Tree].structural\n\n// Error:\n\"\"\"\nCannot generate structural type for recursive type Tree.\nStructural types cannot represent recursive structures.\nScala's type system does not support infinite types.\n\"\"\"\n\n// Sum type in Scala 2\nsealed trait Result\ncase class Success(value: Int) extends Result\nSchema.derived[Result].structural\n\n// Error (Scala 2 only):\n\"\"\"\nCannot generate structural type for sum type Result.\nStructural representation of sum types requires union types,\nwhich are only available in Scala 3.\nConsider upgrading to Scala 3 or using a different approach.\n\"\"\"\n```\n\n---\n\n## Deliverables\n\n1. ✅ `ToStructural[A]` trait and macro for Scala 2.13\n2. ✅ `ToStructural[A]` trait and macro for Scala 3.5\n3. ✅ `structural` method on `Schema[A]`\n4. ✅ Support for product types (case classes, tuples)\n5. ✅ Support for sum types (sealed traits, enums) in Scala 3 only\n6. ✅ Normalized type name generation\n7. ✅ `Selectable` bindings (Scala 3) and `Dynamic` bindings (Scala 2)\n8. ✅ Integration with `Into`/`As` for structural ↔ nominal conversions\n9. ✅ Comprehensive test suite (300+ test cases)\n10. ✅ Clear error messages for unsupported cases\n11. ✅ Documentation with examples",
                  "html_url": "https://github.com/zio/zio-blocks/issues/517"
                },
                "type": "github"
              },
              "hash": "zio/zio-blocks#517",
              "body": "# Structural Type Schema Support\n\n## Overview\n\nExtend `Schema[A]` to support structural types, enabling schema derivation for types defined by their structure rather than their nominal identity. This allows for duck-typed schema validation and conversion between nominal and structural representations.\n\n## Core Concepts\n\n### Direct Structural Schema Derivation\n\nSchemas can be derived directly for structural types:\n\n```scala\n// Scala 3\ntype Person = { def name: String; def age: Int }\nval schema = Schema.derived[Person]\n\n// Scala 2\ntype Person = { def name: String; def age: Int }\nval schema = Schema.derived[Person]\n```\n\n**Note**: Both Scala 2 and Scala 3 use `def` for uniformity, even though Scala 3 supports `val` in structural types.\n\n**Implementation**: Schemas have bindings, which allow construction / deconstruction of values. Values for structural types are backed by:\n- **Scala 3**: `Selectable` \n- **Scala 2**: `Dynamic`\n\n### Nominal to Structural Conversion\n\nConvert nominal type schemas to their structural equivalents:\n\n```scala\ncase class Person(name: String, age: Int)\n\n// Get the structural schema corresponding to Person's shape\nval structuralSchema: Schema[{ def name: String; def age: Int }] = \n  Schema.derived[Person].structural\n```\n\n### Schema API Extension\n\n```scala\ncase class Schema[A](/* existing fields */) {\n  /**\n   * Convert this schema to a structural type schema.\n   * \n   * The structural type represents the \"shape\" of A without its nominal identity.\n   * This enables duck typing and structural validation.\n   * \n   * @param toStructural Macro-generated conversion to structural representation\n   * @return Schema for the structural type corresponding to A\n   */\n  def structural(implicit toStructural: ToStructural[A]): Schema[toStructural.StructuralType] = \n    toStructural.apply(this)\n}\n\n/**\n * Type class for converting nominal schemas to structural schemas.\n * Generated by macro for all supported types. Macro fails if a structural\n * type cannot be generated.\n *\n * NOTE: This approach has to be tested to yield inferrable types, and revised\n * if necessary. Inferrable types (from calling Schema#structural) are a must-have.\n */\ntrait ToStructural[A] {\n  type StructuralType\n  def apply(schema: Schema[A]): Schema[StructuralType]\n}\n\nobject ToStructural {\n  type Aux[A, S] = ToStructural[A] { type StructuralType = S }\n  \n  // Scala 3\n  transparent inline given [A]: ToStructural[A] = ${toStructuralMacro[A]}\n  \n  // Scala 2\n  implicit def materialize[A]: ToStructural[A] = macro toStructuralImpl[A]\n}\n```\n\n---\n\n## Examples\n\n### 1. Simple Product Types\n\n#### Case Class to Structural\n\n```scala\n// Both Scala 2 and Scala 3\ncase class Person(name: String, age: Int)\n\n// Original nominal schema\nval nominalSchema: Schema[Person] = Schema.derived[Person]\n\n// Convert to structural\nval structuralSchema: Schema[{ def name: String; def age: Int }] = \n  nominalSchema.structural\n\n// Direct structural derivation (equivalent)\nval directStructural: Schema[{ def name: String; def age: Int }] = \n  Schema.derived[{ def name: String; def age: Int }]\n```\n\n### 2. Nested Structures\n\n```scala\ncase class Address(street: String, city: String, zip: Int)\ncase class Person(name: String, age: Int, address: Address)\n\nval structuralSchema = Schema.derived[Person].structural\n// Type: Schema[{ \n//   def name: String\n//   def age: Int\n//   def address: { def street: String; def city: String; def zip: Int }\n// }]\n```\n\n### 3. Collections and Options\n\n```scala\ncase class Team(name: String, members: List[String], leader: Option[String])\n\nval structuralSchema = Schema.derived[Team].structural\n// Type: Schema[{\n//   def name: String\n//   def members: List[String]\n//   def leader: Option[String]\n// }]\n```\n\n### 4. Tuples to Structural\n\n```scala\n// Tuples can be converted to structural types\nval tupleSchema: Schema[(String, Int, Boolean)] = Schema.derived[(String, Int, Boolean)]\n\nval structuralSchema = tupleSchema.structural\n// Type: Schema[{ def _1: String; def _2: Int; def _3: Boolean }]\n```\n\n### 5. Sum Types (Sealed Traits) - Scala 3 Only\n\nSealed traits become union types of structural representations, with tag information stored at the type level:\n\n```scala\n// Scala 3 only\nsealed trait Result\ncase class Success(value: Int) extends Result\ncase class Failure(error: String) extends Result\n\nval structuralSchema = Schema.derived[Result].structural\n// Type: Schema[\n//   { type Tag = \"Success\"; def value: Int } | { type Tag = \"Failure\"; def error: String }\n// ]\n```\n\n**Note**: Sum type to structural conversion is **not supported in Scala 2** because it requires union types. Attempting to call `.structural` on a sealed trait schema in Scala 2 will result in a compile-time error.\n\n### 6. Enums (Scala 3 Only)\n\n```scala\nenum Status:\n  case Active, Inactive, Suspended\n\nval structuralSchema = Schema.derived[Status].structural\n// Type: Schema[{type Tag = \"Active\"} | {type Tag = \"Inactive\"} | {type Tag = \"Suspended\"}]\n```\n\n### 7. Opaque Types (Scala 3)\n\n```scala\nopaque type UserId = String\nobject UserId:\n  def apply(value: String): Either[String, UserId] = \n    if value.nonEmpty then Right(value) else Left(\"Empty user ID\")\n\ncase class User(id: UserId, name: String)\n\nval structuralSchema = Schema.derived[User].structural\n// Type: Schema[{ def id: String; def name: String }]\n// Opaque type is unwrapped to its underlying type\n```\n\n### 8. Bidirectional Conversion\n\nStructural schemas work seamlessly with `Into`/`As` (if this ticket is implemented **after** that ticket):\n\n```scala\ncase class Person(name: String, age: Int)\n\nval structuralSchema = Schema.derived[Person].structural\n\n// Create structural value (Scala 3)\nval structuralPerson = new Selectable {\n  def selectDynamic(field: String): Any = field match {\n    case \"name\" => \"Alice\"\n    case \"age\" => 30\n  }\n}\n\n// Convert structural to nominal using Into\nval person: Either[SchemaError, Person] = \n  Into[{ def name: String; def age: Int }, Person].into(structuralPerson)\n// => Right(Person(\"Alice\", 30))\n\n// Convert nominal to structural\nval backToStructural: Either[SchemaError, { def name: String; def age: Int }] = \n  Into[Person, { def name: String; def age: Int }].into(Person(\"Bob\", 25))\n```\n\n### 9. Empty and Single-Field Products\n\n```scala\n// Empty case class\ncase class Empty()\nval emptyStructural = Schema.derived[Empty].structural\n// Type: Schema[{}]\n\n// Single field\ncase class Id(value: String)\nval idStructural = Schema.derived[Id].structural\n// Type: Schema[{ def value: String }]\n```\n\n### 10. Large Products\n\n```scala\ncase class LargeRecord(\n  f1: String, f2: Int, f3: Boolean, f4: Double, f5: Long,\n  f6: String, f7: Int, f8: Boolean, f9: Double, f10: Long,\n  f11: String, f12: Int, f13: Boolean, f14: Double, f15: Long,\n  f16: String, f17: Int, f18: Boolean, f19: Double, f20: Long,\n  f21: String\n)\n\nval structuralSchema = Schema.derived[LargeRecord].structural\n// Type: Schema[{\n//   def f1: String; def f2: Int; def f3: Boolean; ...\n//   def f21: String\n// }]\n```\n\n---\n\n## Type Name Handling\n\n### Current Limitation\n\nSchemas currently use `TypeName[A]` to identify types. Structural types don't have meaningful nominal type names, which creates a mismatch.\n\n### Temporary Solution\n\nUntil `TypeName[A]` is replaced with `TypeId[A]` (see issue #471), structural schemas will use a normalized string representation of the structural type as a fake type name:\n\n```scala\ncase class Person(name: String, age: Int)\n\nval schema = Schema.derived[Person]\nschema.typeName // => TypeName for \"Person\"\n\nval structural = schema.structural\nstructural.typeName // => TypeName for \"{age:Int,name:String}\"\n// Normalized: fields sorted alphabetically, types fully qualified\n```\n\n### Normalization Rules\n\n1. **Field ordering**: Alphabetical by field name\n2. **Type qualification**: Use simple names for primitives and standard library types\n3. **Whitespace**: No whitespace in generated names\n4. **Collections**: Standard notation (e.g., `List[Int]`)\n5. **Options**: Explicit `Option[T]` notation\n6. **Nested structures**: Recursive application of rules\n7. **Deterministic**: Same structure always produces same normalized name\n\n### Examples\n\n```scala\n// Simple product\ncase class Point(x: Int, y: Int)\nSchema.derived[Point].structural.typeName \n// => \"{x:Int,y:Int}\"\n\n// Nested product\ncase class Address(street: String, zip: Int)\ncase class Person(name: String, address: Address)\nSchema.derived[Person].structural.typeName\n// => \"{address:{street:String,zip:Int},name:String}\"\n\n// With collections\ncase class Team(name: String, members: List[String])\nSchema.derived[Team].structural.typeName\n// => \"{members:List[String],name:String}\"\n\n// Union type (Scala 3)\nsealed trait Result\ncase class Success(value: Int) extends Result\ncase class Failure(error: String) extends Result\nSchema.derived[Result].structural.typeName\n// => \"{error:String}|{value:Int}\"\n```\n\n### Future: TypeId[A]\n\nThe upcoming `TypeId[A]` replacement will properly handle structural types by representing them by their structure rather than a string-based hack. See issue #471 for details.\n\n---\n\n## Limitations and Edge Cases\n\n### 1. Generic Types\n\n**Behavior depends on existing Schema derivation support for generic types.**\n\nIf `Schema.derived[Container[Int]]` already works, then structural conversion should work:\n\n```scala\ncase class Container[T](value: T)\n\n// If this works:\nval schema = Schema.derived[Container[Int]]\n\n// Then this should work:\nval structural = schema.structural\n// Type: Schema[{ def value: Int }]\n```\n\nIf generic type derivation is not currently supported, this ticket **does not require implementing it**. The macro should produce a clear compile-time error for unsupported generic types.\n\n### 2. Recursive Types\n\nRecursive types will **fail at compile-time** because Scala does not support infinite types:\n\n```scala\ncase class Tree(value: Int, children: List[Tree])\n\n// This will FAIL at compile-time:\nval structural = Schema.derived[Tree].structural\n// Compile error: Cannot generate infinite structural type\n\n// The structural type would need to be:\n// { def value: Int; def children: List[{ def value: Int; def children: List[...] }] }\n// which is infinite and unsupported\n```\n\nThe macro must detect recursive types and produce a helpful error message:\n\n```\nCompile error: Cannot generate structural type for recursive type Tree.\nStructural types cannot represent recursive structures.\n```\n\n### 3. Mutually Recursive Types\n\nSimilarly, mutually recursive types are unsupported:\n\n```scala\ncase class Node(id: Int, edges: List[Edge])\ncase class Edge(from: Int, to: Node)\n\n// This will FAIL at compile-time:\nval nodeStructural = Schema.derived[Node].structural\n// Compile error: Cannot generate structural type for mutually recursive types\n```\n\n### 4. Sum Types in Scala 2\n\nSealed traits and sum types **cannot be converted to structural types in Scala 2** because they require union types:\n\n```scala\n// Scala 2\nsealed trait Result\ncase class Success(value: Int) extends Result\ncase class Failure(error: String) extends Result\n\n// This will FAIL at compile-time in Scala 2:\nval structural = Schema.derived[Result].structural\n// Compile error: Cannot generate structural type for sum types in Scala 2.\n// Union types are required, which are only available in Scala 3.\n```\n\nThe macro must detect sum types in Scala 2 and produce a clear error.\n\n### 5. Case Objects\n\nCase objects become empty structural types:\n\n```scala\ncase object Singleton\n\nval structural = Schema.derived[Singleton.type].structural\n// Type: Schema[{}]\n```\n\nFor sum types with case objects (Scala 3):\n\n```scala\nsealed trait Status\ncase object Active extends Status\ncase object Inactive extends Status\n\nval structural = Schema.derived[Status].structural\n// Type: Schema[{} | {}]\n// Not particularly useful, but valid\n```\n\n### 6. Structural Types as Source\n\nDeriving schemas directly for structural types is supported:\n\n```scala\ntype PersonStructure = { def name: String; def age: Int }\n\nval schema = Schema.derived[PersonStructure]\n// Should work if structural type derivation is implemented\n```\n\nThe schema's bindings will use `Selectable` (Scala 3) or `Dynamic` (Scala 2) to construct and deconstruct values.\n\n---\n\n## Integration with Into/As\n\nStructural schemas compose naturally with `Into`/`As` conversions.\n\n### Nominal → Structural\n\n```scala\ncase class Person(name: String, age: Int)\n\n// Auto-derived conversion\nval nominalToStructural: Into[Person, { def name: String; def age: Int }] = \n  Into.derived\n\nval person = Person(\"Alice\", 30)\nval structural = nominalToStructural.into(person)\n// => Right(<Selectable/Dynamic instance>)\n```\n\n### Structural → Nominal\n\n```scala\ntype PersonStructure = { def name: String; def age: Int }\ncase class Person(name: String, age: Int)\n\n// Auto-derived conversion\nval structuralToNominal: Into[PersonStructure, Person] = \n  Into.derived\n\nval structural: PersonStructure = new Selectable {\n  def selectDynamic(field: String): Any = field match {\n    case \"name\" => \"Bob\"\n    case \"age\" => 25\n  }\n}\n\nval person = structuralToNominal.into(structural)\n// => Right(Person(\"Bob\", 25))\n```\n\n### Bidirectional (As)\n\n```scala\ncase class Person(name: String, age: Int)\n\n// Bidirectional conversion\nval personAs: As[Person, { def name: String; def age: Int }] = \n  As.derived\n\n// Nominal → Structural\nval structural = personAs.into(Person(\"Alice\", 30))\n\n// Structural → Nominal\nval nominal = structural.flatMap(personAs.from)\n// Round-trip successful\n```\n\n### Schema-Guided Conversion\n\n```scala\ncase class PersonV1(firstName: String, lastName: String, age: Int)\ncase class PersonV2(name: String, age: Int)\n\n// Use structural type as intermediary\ntype PersonStructure = { def name: String; def age: Int }\n\n// Step 1: Transform V1 to structural (custom logic)\nval v1ToStructural: Into[PersonV1, PersonStructure] = \n  new Into[PersonV1, PersonStructure] {\n    def into(v1: PersonV1): Either[SchemaError, PersonStructure] = {\n      Right(new Selectable {\n        def selectDynamic(field: String): Any = field match {\n          case \"name\" => s\"${v1.firstName} ${v1.lastName}\"\n          case \"age\" => v1.age\n        }\n      })\n    }\n  }\n\n// Step 2: Auto-convert structural to V2\nval structuralToV2: Into[PersonStructure, PersonV2] = Into.derived\n\n// Composed migration\ndef migrate(v1: PersonV1): Either[SchemaError, PersonV2] = {\n  v1ToStructural.into(v1).flatMap(structuralToV2.into)\n}\n```\n\n---\n\n## Testing Requirements\n\n### Test Matrix\n\n1. **Direct Structural Derivation**\n   - Simple products (case classes)\n   - Nested products\n   - Collections (List, Vector, Set, Map, Option, Either)\n   - Tuples (2-22 elements)\n   - Empty case classes\n   - Single-field case classes\n   - Large products (20+ fields)\n   - Case objects\n\n2. **Nominal to Structural Conversion**\n   - Case class → structural\n   - Tuple → structural\n   - Nested case classes → nested structural\n   - Case class with collections → structural with collections\n   - Empty case class → empty structural\n\n3. **Sum Types (Scala 3 Only)**\n   - Sealed trait → union type structural\n   - Sealed trait with case objects\n   - Enum → union type structural\n   - Nested sum types\n\n4. **Type Name Generation**\n   - Simple product normalized name\n   - Nested product normalized name\n   - Name determinism (same structure = same name)\n   - Alphabetical field ordering in names\n   - Union type names (Scala 3)\n\n5. **Selectable/Dynamic Implementation**\n   - Scala 3 Selectable field access\n   - Scala 2 Dynamic field access\n   - Field access correctness\n   - Missing field behavior\n   - Extra field behavior\n\n6. **Integration with Into/As**\n   - Nominal → Structural via Into\n   - Structural → Nominal via Into\n   - Round-trip via As\n   - Composed conversions with structural intermediary\n\n7. **Error Cases (Compile-Time)**\n   - Recursive types produce error\n   - Mutually recursive types produce error\n   - Sum types in Scala 2 produce error\n   - Unsupported types produce helpful errors\n\n8. **Generic Types** (if supported by existing Schema derivation)\n   - Fully applied generic → structural\n   - Generic with nested structural fields\n\n### Scala 2 vs Scala 3 Test Separation\n\n```\nsrc/test/scala/\n  structural/\n    common/\n      SimpleProductSpec.scala\n      NestedProductSpec.scala\n      CollectionsSpec.scala\n      TuplesSpec.scala\n      EmptyProductSpec.scala\n      SingleFieldSpec.scala\n      LargeProductSpec.scala\n      TypeNameNormalizationSpec.scala\n      IntoIntegrationSpec.scala\n      AsIntegrationSpec.scala\n      \n    scala3/\n      UnionTypesSpec.scala\n      SealedTraitToUnionSpec.scala\n      EnumToUnionSpec.scala\n      SelectableImplementationSpec.scala\n      \n    scala2/\n      DynamicImplementationSpec.scala\n      SumTypeErrorSpec.scala (verifies compile error)\n      \n    errors/\n      RecursiveTypeErrorSpec.scala\n      MutualRecursionErrorSpec.scala\n      UnsupportedTypeErrorSpec.scala\n```\n\n### Test Examples\n\n```scala\n// Test: Simple product to structural\ntest(\"case class converts to structural schema\") {\n  case class Person(name: String, age: Int)\n  \n  val structural = Schema.derived[Person].structural\n  \n  // Type check (this is a compile-time test)\n  val _: Schema[{ def name: String; def age: Int }] = structural\n  \n  assert(structural.typeName.toString.contains(\"name\"))\n  assert(structural.typeName.toString.contains(\"age\"))\n}\n\n// Test: Nested products\ntest(\"nested case classes convert to nested structural\") {\n  case class Address(street: String, zip: Int)\n  case class Person(name: String, address: Address)\n  \n  val structural = Schema.derived[Person].structural\n  \n  val _: Schema[{ \n    def name: String\n    def address: { def street: String; def zip: Int }\n  }] = structural\n}\n\n// Test: Tuple to structural\ntest(\"tuple converts to structural with _N fields\") {\n  val structural = Schema.derived[(String, Int, Boolean)].structural\n  \n  val _: Schema[{ def _1: String; def _2: Int; def _3: Boolean }] = structural\n}\n\n// Test: Union type (Scala 3 only)\ntest(\"sealed trait converts to union type structural\") {\n  sealed trait Result\n  case class Success(value: Int) extends Result\n  case class Failure(error: String) extends Result\n  \n  val structural = Schema.derived[Result].structural\n  \n  val _: Schema[{ def value: Int } | { def error: String }] = structural\n}\n\n// Test: Type name normalization\ntest(\"structural type names are normalized and deterministic\") {\n  case class Person(name: String, age: Int)\n  case class User(age: Int, name: String) // Different field order\n  \n  val personStructural = Schema.derived[Person].structural\n  val userStructural = Schema.derived[User].structural\n  \n  // Same structure, same normalized name\n  assert(personStructural.typeName == userStructural.typeName)\n  \n  // Alphabetical ordering\n  assert(personStructural.typeName.toString.contains(\"age\"))\n  assert(personStructural.typeName.toString.indexOf(\"age\") < \n         personStructural.typeName.toString.indexOf(\"name\"))\n}\n\n// Test: Integration with Into\ntest(\"structural to nominal conversion via Into\") {\n  case class Person(name: String, age: Int)\n  type PersonStructure = { def name: String; def age: Int }\n  \n  val structural: PersonStructure = new Selectable {\n    def selectDynamic(field: String): Any = field match {\n      case \"name\" => \"Alice\"\n      case \"age\" => 30\n    }\n  }\n  \n  val person = Into[PersonStructure, Person].into(structural)\n  assert(person == Right(Person(\"Alice\", 30)))\n}\n\n// Test: Round-trip via As\ntest(\"nominal to structural and back preserves data\") {\n  case class Person(name: String, age: Int)\n  type PersonStructure = { def name: String; def age: Int }\n  \n  val original = Person(\"Alice\", 30)\n  \n  val toStructural = As[Person, PersonStructure].into(original)\n  val backToNominal = toStructural.flatMap(As[Person, PersonStructure].from)\n  \n  assert(backToNominal == Right(original))\n}\n\n// Test: Recursive type compile error\ntest(\"recursive types produce compile error\") {\n  case class Tree(value: Int, children: List[Tree])\n  \n  assertDoesNotCompile(\"Schema.derived[Tree].structural\")\n}\n\n// Test: Sum type in Scala 2 compile error\ntest(\"sum types in Scala 2 produce compile error\") {\n  sealed trait Result\n  case class Success(value: Int) extends Result\n  \n  // Scala 2 only\n  assertDoesNotCompile(\"Schema.derived[Result].structural\")\n}\n```\n\n---\n\n## Implementation Notes\n\n### Macro Behavior\n\nThe macro must:\n\n1. **Detect product types** (case classes, tuples) and generate structural types with `def` members\n2. **Detect sum types** (sealed traits, enums) and:\n   - In Scala 3: Generate union types of structural representations\n   - In Scala 2: Fail with clear error message\n3. **Detect recursive types** and fail with clear error message\n4. **Normalize structural type representations** for type name generation\n5. **Generate `ToStructural` instance** with:\n   - `StructuralType` type member set to the generated structural type\n   - `apply` method that transforms the schema appropriately\n6. **Preserve field metadata** from original schema where applicable\n7. **Generate appropriate bindings** using `Selectable` (Scala 3) or `Dynamic` (Scala 2)\n\n### Schema Transformation\n\nWhen converting `Schema[A]` to `Schema[StructuralType]`:\n\n1. **Preserve field information**: Field names, types, optional/required status\n2. **Update type name**: Use normalized structural representation\n3. **Transform bindings**: Replace nominal constructors/deconstructors with structural equivalents\n4. **Preserve validation**: Maintain any validation logic that applies to field values\n5. **Handle nested schemas**: Recursively transform nested product types\n\n### Error Messages\n\nProvide clear compile-time errors:\n\n```scala\n// Recursive type\ncase class Tree(value: Int, children: List[Tree])\nSchema.derived[Tree].structural\n\n// Error:\n\"\"\"\nCannot generate structural type for recursive type Tree.\nStructural types cannot represent recursive structures.\nScala's type system does not support infinite types.\n\"\"\"\n\n// Sum type in Scala 2\nsealed trait Result\ncase class Success(value: Int) extends Result\nSchema.derived[Result].structural\n\n// Error (Scala 2 only):\n\"\"\"\nCannot generate structural type for sum type Result.\nStructural representation of sum types requires union types,\nwhich are only available in Scala 3.\nConsider upgrading to Scala 3 or using a different approach.\n\"\"\"\n```\n\n---\n\n## Deliverables\n\n1. ✅ `ToStructural[A]` trait and macro for Scala 2.13\n2. ✅ `ToStructural[A]` trait and macro for Scala 3.5\n3. ✅ `structural` method on `Schema[A]`\n4. ✅ Support for product types (case classes, tuples)\n5. ✅ Support for sum types (sealed traits, enums) in Scala 3 only\n6. ✅ Normalized type name generation\n7. ✅ `Selectable` bindings (Scala 3) and `Dynamic` bindings (Scala 2)\n8. ✅ Integration with `Into`/`As` for structural ↔ nominal conversions\n9. ✅ Comprehensive test suite (300+ test cases)\n10. ✅ Clear error messages for unsupported cases\n11. ✅ Documentation with examples",
              "url": "https://github.com/zio/zio-blocks/issues/517",
              "tech": [],
              "repo_name": "zio-blocks",
              "repo_owner": "zio",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "ZIO#685",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "ZIO",
              "id": "generated-ZIO",
              "name": "ZIO",
              "description": "",
              "members": [],
              "display_name": "ZIO",
              "created_at": "2026-01-23T05:51:28.709Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/ZIO?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "zio",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-23T05:51:28.709Z",
            "created_at": "2026-01-23T05:51:28.709Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-ZIO#685",
              "status": "open",
              "type": "issue",
              "number": 685,
              "title": "Add JsonPatch - Depends on #679",
              "source": {
                "data": {
                  "id": "source-ZIO#685",
                  "user": {
                    "login": "jdegoes",
                    "id": 156745,
                    "node_id": "MDQ6VXNlcjE1Njc0NQ==",
                    "avatar_url": "https://avatars.githubusercontent.com/u/156745?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/jdegoes",
                    "html_url": "https://github.com/jdegoes",
                    "followers_url": "https://api.github.com/users/jdegoes/followers",
                    "following_url": "https://api.github.com/users/jdegoes/following{/other_user}",
                    "gists_url": "https://api.github.com/users/jdegoes/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/jdegoes/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/jdegoes/subscriptions",
                    "organizations_url": "https://api.github.com/users/jdegoes/orgs",
                    "repos_url": "https://api.github.com/users/jdegoes/repos",
                    "events_url": "https://api.github.com/users/jdegoes/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/jdegoes/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Add JsonPatch - Depends on #679",
                  "body": "<html><head></head><body><h1>Add <code>JsonPatch</code> type for diffing and patching JSON values</h1>\n<h2>Summary</h2>\n<p>Implement a <code>JsonPatch</code> type that enables computing diffs between JSON values and applying patches to transform one JSON value into another. This type should mirror the existing <code>DynamicPatch</code> implementation, adapted for JSON's simpler data model.</p>\n<h2>Motivation</h2>\n<p><code>DynamicValue</code> has a well-designed <code>DynamicPatch</code> system with:</p>\n<ul>\n<li>Monoid composition (<code>++</code> with <code>empty</code> identity)</li>\n<li>LCS-based sequence diffing</li>\n<li>Primitive delta operations (numeric deltas, string edits)</li>\n<li>Comprehensive algebraic laws verified by property tests</li>\n</ul>\n<p>The proposed <code>Json</code> type (see #TBD) needs equivalent patching capabilities. Rather than converting <code>Json ↔ DynamicValue</code> for every patch operation, a native <code>JsonPatch</code> provides:</p>\n<ul>\n<li>Type safety (no conversion errors for JSON-incompatible DynamicPatch operations)</li>\n<li>API consistency with the <code>Json</code> type</li>\n<li>Potential for JSON-specific optimizations</li>\n</ul>\n<h2>Design Sketch</h2>\n<p>A design sketch is available at <a href=\"https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/json/JsonPatch.scala\"><code>schema/shared/src/main/scala/zio/blocks/schema/json/JsonPatch.scala</code></a>. This sketch is <strong>a guide, not a specification</strong> — implementers should use judgment and deviate where appropriate.</p>\n<h3>Core Types</h3>\n<p>The design mirrors <code>DynamicPatch</code> with JSON-specific adaptations:</p>\n\nDynamicPatch | JsonPatch | Notes\n-- | -- | --\nDynamicPatch(Vector[DynamicPatchOp]) | JsonPatch(Vector[JsonPatchOp]) | Same structure\nOperation.Set | Op.Set | Same\nOperation.PrimitiveDelta | Op.PrimitiveDelta | Simplified for JSON types\nOperation.SequenceEdit | Op.ArrayEdit | Renamed\nOperation.MapEdit | Op.ObjectEdit | String keys only\nOperation.Patch | Op.Nested | Same\nSeqOp | ArrayOp | Same operations\nMapOp | ObjectOp | String keys only\nPrimitiveOp (14 variants) | PrimitiveOp (2 variants) | See below\n\n\n<h3>StringOp</h3>\n<p>Mirror <code>DynamicPatch.StringOp</code> exactly:</p>\n<ul>\n<li><code>Insert(index: Int, text: String)</code></li>\n<li><code>Delete(index: Int, length: Int)</code></li>\n<li><code>Append(text: String)</code></li>\n<li><code>Modify(index: Int, length: Int, text: String)</code></li>\n</ul>\n<h3>ArrayOp</h3>\n<p>Mirror <code>DynamicPatch.SeqOp</code>:</p>\n<ul>\n<li><code>Insert(index: Int, values: Vector[Json])</code></li>\n<li><code>Append(values: Vector[Json])</code></li>\n<li><code>Delete(index: Int, count: Int)</code></li>\n<li><code>Modify(index: Int, op: Op)</code></li>\n</ul>\n<h3>ObjectOp</h3>\n<p>Mirror <code>DynamicPatch.MapOp</code> with string keys:</p>\n<ul>\n<li><code>Add(key: String, value: Json)</code></li>\n<li><code>Remove(key: String)</code></li>\n<li><code>Modify(key: String, patch: JsonPatch)</code></li>\n</ul>\n<h2>Requirements</h2>\n<h3>Functional Requirements</h3>\n<ul>\n<li>[ ] <strong>F1</strong>: <code>JsonPatch.diff(source, target)</code> computes a patch transforming source to target</li>\n<li>[ ] <strong>F2</strong>: <code>patch.apply(json, mode)</code> applies a patch with configurable failure handling</li>\n<li>[ ] <strong>F3</strong>: <code>patch1 ++ patch2</code> composes patches (apply first, then second)</li>\n<li>[ ] <strong>F4</strong>: <code>JsonPatch.empty</code> is the identity element for composition</li>\n<li>[ ] <strong>F5</strong>: Support <code>JsonPatchMode.Strict</code>, <code>Lenient</code>, and <code>Clobber</code> modes</li>\n<li>[ ] <strong>F6</strong>: Bidirectional conversion: <code>toDynamicPatch</code> / <code>fromDynamicPatch</code></li>\n</ul>\n<h3>Algebraic Laws</h3>\n<p>All laws must be verified with property-based tests (see <code>PatchLawsSpec</code> for reference):</p>\n<ul>\n<li>[ ] <strong>L1</strong>: Left identity — <code>(empty ++ p)(j) == p(j)</code></li>\n<li>[ ] <strong>L2</strong>: Right identity — <code>(p ++ empty)(j) == p(j)</code></li>\n<li>[ ] <strong>L3</strong>: Associativity — <code>((p1 ++ p2) ++ p3)(j) == (p1 ++ (p2 ++ p3))(j)</code></li>\n<li>[ ] <strong>L4</strong>: Roundtrip — <code>diff(a, b)(a) == Right(b)</code></li>\n<li>[ ] <strong>L5</strong>: Identity diff — <code>diff(j, j).isEmpty</code></li>\n<li>[ ] <strong>L6</strong>: Diff composition — <code>(diff(a, b) ++ diff(b, c))(a) == Right(c)</code></li>\n<li>[ ] <strong>L7</strong>: Lenient subsumes Strict — if <code>p(j, Strict) == Right(r)</code> then <code>p(j, Lenient) == Right(r)</code></li>\n</ul>\n<h3>Testing Requirements</h3>\n<ul>\n<li>[ ] <strong>T1</strong>: Property-based tests for all algebraic laws (see <code>PatchLawsSpec</code>)</li>\n<li>[ ] <strong>T2</strong>: Test each operation type (<code>Set</code>, <code>PrimitiveDelta</code>, <code>ArrayEdit</code>, <code>ObjectEdit</code>, <code>Nested</code>)</li>\n<li>[ ] <strong>T3</strong>: Test each <code>ArrayOp</code> variant (<code>Insert</code>, <code>Append</code>, <code>Delete</code>, <code>Modify</code>)</li>\n<li>[ ] <strong>T4</strong>: Test each <code>ObjectOp</code> variant (<code>Add</code>, <code>Remove</code>, <code>Modify</code>)</li>\n<li>[ ] <strong>T5</strong>: Test each <code>StringOp</code> variant (<code>Insert</code>, <code>Delete</code>, <code>Append</code>, <code>Modify</code>)</li>\n<li>[ ] <strong>T6</strong>: Test <code>NumberDelta</code> with positive, negative, zero, and decimal deltas</li>\n<li>[ ] <strong>T7</strong>: Test all three <code>JsonPatchMode</code> behaviors</li>\n<li>[ ] <strong>T8</strong>: Test <code>toDynamicPatch</code> / <code>fromDynamicPatch</code> roundtrip</li>\n<li>[ ] <strong>T9</strong>: Test edge cases: empty arrays, empty objects, empty strings, nested structures</li>\n<li>[ ] <strong>T10</strong>: Test error cases: invalid paths, type mismatches, out-of-bounds indices</li>\n</ul>\n<h3>Documentation Requirements</h3>\n<ul>\n<li>[ ] <strong>D1</strong>: ScalaDoc for all public types and methods</li>\n<li>[ ] <strong>D2</strong>: Usage examples in ScalaDoc (see sketch for examples)</li>\n<li>[ ] <strong>D3</strong>: Document algebraic laws in type-level comments</li>\n<li>[ ] <strong>D4</strong>: Document relationship to <code>DynamicPatch</code></li>\n</ul>\n<h3>Implementation Notes</h3>\n<ol>\n<li>\n<p><strong>Follow <code>DynamicPatch</code> patterns</strong>: The implementation in <code>DynamicPatch.scala</code> is the reference. Study <code>Differ.scala</code> for diff algorithms (especially LCS for sequences and strings).</p>\n</li>\n<li>\n<p><strong>Reuse algorithms where possible</strong>: Consider whether <code>JsonPatch</code> can delegate to <code>DynamicPatch</code> internally, or share algorithm implementations.</p>\n</li>\n<li>\n<p><strong>Keep it minimal</strong>: Resist adding operations not present in <code>DynamicPatch</code>. The design is intentionally minimal and principled.</p>\n</li>\n<li>\n<p><strong>Performance considerations</strong>: The register-based design of ZIO Blocks prioritizes performance. Avoid unnecessary allocations in hot paths.</p>\n</li>\n</ol>\n<h2>Out of Scope</h2>\n<p>The following are explicitly <strong>not</strong> part of this issue:</p>\n<ul>\n<li>RFC 6902 JSON Patch serialization format (separate issue)</li>\n<li>Patch inversion / undo support (separate issue)</li>\n<li>Patch optimization / compaction (separate issue)</li>\n<li>Integration with <code>Json</code> type methods like <code>json.diff(other)</code> (depends on <code>Json</code> implementation)</li>\n</ul>\n<h2>Related</h2>\n<ul>\n<li><code>DynamicPatch</code> — <a href=\"https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/DynamicPatch.scala\"><code>schema/shared/src/main/scala/zio/blocks/schema/patch/DynamicPatch.scala</code></a></li>\n<li><code>Differ</code> — <a href=\"https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/Differ.scala\"><code>schema/shared/src/main/scala/zio/blocks/schema/patch/Differ.scala</code></a></li>\n<li><code>PatchLawsSpec</code> — <a href=\"https://claude.ai/chat/schema/shared/src/test/scala/zio/blocks/schema/patch/PatchLawsSpec.scala\"><code>schema/shared/src/test/scala/zio/blocks/schema/patch/PatchLawsSpec.scala</code></a></li>\n<li><code>PatchMode</code> — <a href=\"https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/PatchMode.scala\"><code>schema/shared/src/main/scala/zio/blocks/schema/patch/PatchMode.scala</code></a></li>\n</ul>\n<h2>Acceptance Criteria</h2>\n<ul>\n<li>[ ] All functional requirements (F1-F6) implemented</li>\n<li>[ ] All algebraic laws (L1-L7) pass property-based tests</li>\n<li>[ ] All testing requirements (T1-T10) have corresponding test cases</li>\n<li>[ ] All documentation requirements (D1-D4) complete</li>\n<li>[ ] Code reviewed and approved</li>\n<li>[ ] CI passing</li>\n</ul></body></html># Add `JsonPatch` type for diffing and patching JSON values\n\n## Summary\n\nImplement a `JsonPatch` type that enables computing diffs between JSON values and applying patches to transform one JSON value into another. This type should mirror the existing `DynamicPatch` implementation, adapted for JSON's simpler data model.\n\n## Motivation\n\n`DynamicValue` has a well-designed `DynamicPatch` system with:\n- Monoid composition (`++` with `empty` identity)\n- LCS-based sequence diffing\n- Primitive delta operations (numeric deltas, string edits)\n- Comprehensive algebraic laws verified by property tests\n\nThe proposed `Json` type (see #TBD) needs equivalent patching capabilities. Rather than converting `Json ↔ DynamicValue` for every patch operation, a native `JsonPatch` provides:\n- Type safety (no conversion errors for JSON-incompatible DynamicPatch operations)\n- API consistency with the `Json` type\n- Potential for JSON-specific optimizations\n\n## Design Sketch\n\nA design sketch is available at [`[schema/shared/src/main/scala/zio/blocks/schema/json/JsonPatch.scala](https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/json/JsonPatch.scala)`](./schema/shared/src/main/scala/zio/blocks/schema/json/JsonPatch.scala). This sketch is **a guide, not a specification** — implementers should use judgment and deviate where appropriate.\n\n### Core Types\n\nThe design mirrors `DynamicPatch` with JSON-specific adaptations:\n\n| DynamicPatch | JsonPatch | Notes |\n|--------------|-----------|-------|\n| `DynamicPatch(Vector[DynamicPatchOp])` | `JsonPatch(Vector[JsonPatchOp])` | Same structure |\n| `Operation.Set` | `Op.Set` | Same |\n| `Operation.PrimitiveDelta` | `Op.PrimitiveDelta` | Simplified for JSON types |\n| `Operation.SequenceEdit` | `Op.ArrayEdit` | Renamed |\n| `Operation.MapEdit` | `Op.ObjectEdit` | String keys only |\n| `Operation.Patch` | `Op.Nested` | Same |\n| `SeqOp` | `ArrayOp` | Same operations |\n| `MapOp` | `ObjectOp` | String keys only |\n| `PrimitiveOp` (14 variants) | `PrimitiveOp` (2 variants) | See below |\n\n### Primitive Operations\n\nJSON has a simpler type system than `DynamicValue`:\n\n| JSON Type | Delta Operation | Notes |\n|-----------|-----------------|-------|\n| Number | `NumberDelta(BigDecimal)` | Unifies all numeric deltas |\n| String | `StringEdit(Vector[StringOp])` | Same as `DynamicPatch` |\n| Boolean | Use `Op.Set` | No delta (same as `DynamicPatch`) |\n| Null | Use `Op.Set` | No delta |\n\n### StringOp\n\nMirror `DynamicPatch.StringOp` exactly:\n- `Insert(index: Int, text: String)`\n- `Delete(index: Int, length: Int)`\n- `Append(text: String)`\n- `Modify(index: Int, length: Int, text: String)`\n\n### ArrayOp\n\nMirror `DynamicPatch.SeqOp`:\n- `Insert(index: Int, values: Vector[Json])`\n- `Append(values: Vector[Json])`\n- `Delete(index: Int, count: Int)`\n- `Modify(index: Int, op: Op)`\n\n### ObjectOp\n\nMirror `DynamicPatch.MapOp` with string keys:\n- `Add(key: String, value: Json)`\n- `Remove(key: String)`\n- `Modify(key: String, patch: JsonPatch)`\n\n## Requirements\n\n### Functional Requirements\n\n- [ ] **F1**: `JsonPatch.diff(source, target)` computes a patch transforming source to target\n- [ ] **F2**: `patch.apply(json, mode)` applies a patch with configurable failure handling\n- [ ] **F3**: `patch1 ++ patch2` composes patches (apply first, then second)\n- [ ] **F4**: `JsonPatch.empty` is the identity element for composition\n- [ ] **F5**: Support `JsonPatchMode.Strict`, `Lenient`, and `Clobber` modes\n- [ ] **F6**: Bidirectional conversion: `toDynamicPatch` / `fromDynamicPatch`\n\n### Algebraic Laws\n\nAll laws must be verified with property-based tests (see `PatchLawsSpec` for reference):\n\n- [ ] **L1**: Left identity — `(empty ++ p)(j) == p(j)`\n- [ ] **L2**: Right identity — `(p ++ empty)(j) == p(j)`\n- [ ] **L3**: Associativity — `((p1 ++ p2) ++ p3)(j) == (p1 ++ (p2 ++ p3))(j)`\n- [ ] **L4**: Roundtrip — `diff(a, b)(a) == Right(b)`\n- [ ] **L5**: Identity diff — `diff(j, j).isEmpty`\n- [ ] **L6**: Diff composition — `(diff(a, b) ++ diff(b, c))(a) == Right(c)`\n- [ ] **L7**: Lenient subsumes Strict — if `p(j, Strict) == Right(r)` then `p(j, Lenient) == Right(r)`\n\n### Testing Requirements\n\n- [ ] **T1**: Property-based tests for all algebraic laws (see `PatchLawsSpec`)\n- [ ] **T2**: Test each operation type (`Set`, `PrimitiveDelta`, `ArrayEdit`, `ObjectEdit`, `Nested`)\n- [ ] **T3**: Test each `ArrayOp` variant (`Insert`, `Append`, `Delete`, `Modify`)\n- [ ] **T4**: Test each `ObjectOp` variant (`Add`, `Remove`, `Modify`)\n- [ ] **T5**: Test each `StringOp` variant (`Insert`, `Delete`, `Append`, `Modify`)\n- [ ] **T6**: Test `NumberDelta` with positive, negative, zero, and decimal deltas\n- [ ] **T7**: Test all three `JsonPatchMode` behaviors\n- [ ] **T8**: Test `toDynamicPatch` / `fromDynamicPatch` roundtrip\n- [ ] **T9**: Test edge cases: empty arrays, empty objects, empty strings, nested structures\n- [ ] **T10**: Test error cases: invalid paths, type mismatches, out-of-bounds indices\n\n### Documentation Requirements\n\n- [ ] **D1**: ScalaDoc for all public types and methods\n- [ ] **D2**: Usage examples in ScalaDoc (see sketch for examples)\n- [ ] **D3**: Document algebraic laws in type-level comments\n- [ ] **D4**: Document relationship to `DynamicPatch`\n\n## Related\n\n- `DynamicPatch` — [`[schema/shared/src/main/scala/zio/blocks/schema/patch/DynamicPatch.scala](https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/DynamicPatch.scala)`](./schema/shared/src/main/scala/zio/blocks/schema/patch/DynamicPatch.scala)\n- `Differ` — [`[schema/shared/src/main/scala/zio/blocks/schema/patch/Differ.scala](https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/Differ.scala)`](./schema/shared/src/main/scala/zio/blocks/schema/patch/Differ.scala)\n- `PatchLawsSpec` — [`[schema/shared/src/test/scala/zio/blocks/schema/patch/PatchLawsSpec.scala](https://claude.ai/chat/schema/shared/src/test/scala/zio/blocks/schema/patch/PatchLawsSpec.scala)`](./schema/shared/src/test/scala/zio/blocks/schema/patch/PatchLawsSpec.scala)\n- `PatchMode` — [`[schema/shared/src/main/scala/zio/blocks/schema/patch/PatchMode.scala](https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/PatchMode.scala)`](./schema/shared/src/main/scala/zio/blocks/schema/patch/PatchMode.scala)\n\n## Acceptance Criteria\n\n- [ ] All functional requirements (F1-F6) implemented\n- [ ] All algebraic laws (L1-L7) pass property-based tests\n- [ ] All testing requirements (T1-T10) have corresponding test cases\n- [ ] All documentation requirements (D1-D4) complete\n- [ ] Code reviewed and approved\n- [ ] CI passing\n\n# Sketch\n\n```scala\npackage zio.blocks.schema.json\n\nimport zio.blocks.schema.DynamicOptic\nimport zio.blocks.schema.patch.DynamicPatch\n\n// =============================================================================\n// JSON PATCH\n// =============================================================================\n\n/**\n * An untyped patch that operates on [[Json]] values.\n *\n * `JsonPatch` is the JSON-specific counterpart to [[DynamicPatch]]. It represents\n * a sequence of operations that transform one JSON value into another. Patches\n * are serializable and composable.\n *\n * ==Design==\n *\n * This type directly mirrors [[DynamicPatch]] but is specialized for JSON's\n * simpler data model:\n *  - JSON has 4 leaf types (String, Number, Boolean, Null) vs 30 PrimitiveValues\n *  - JSON objects have string keys only (no arbitrary-keyed maps)\n *  - JSON has no native Variant type\n *\n * ==Algebraic Laws==\n *\n * '''Monoid Laws''' (under `++` composition):\n * {{{\n * // 1. LEFT IDENTITY\n * ∀ p: JsonPatch, j: Json.\n *   (JsonPatch.empty ++ p)(j, mode) == p(j, mode)\n *\n * // 2. RIGHT IDENTITY\n * ∀ p: JsonPatch, j: Json.\n *   (p ++ JsonPatch.empty)(j, mode) == p(j, mode)\n *\n * // 3. ASSOCIATIVITY\n * ∀ p1, p2, p3: JsonPatch, j: Json.\n *   ((p1 ++ p2) ++ p3)(j, mode) == (p1 ++ (p2 ++ p3))(j, mode)\n * }}}\n *\n * '''Diff/Apply Laws''':\n * {{{\n * // 4. ROUNDTRIP\n * ∀ source, target: Json.\n *   JsonPatch.diff(source, target)(source, Strict) == Right(target)\n *\n * // 5. IDENTITY DIFF\n * ∀ j: Json.\n *   JsonPatch.diff(j, j).isEmpty == true\n *\n * // 6. DIFF COMPOSITION\n * ∀ a, b, c: Json.\n *   (JsonPatch.diff(a, b) ++ JsonPatch.diff(b, c))(a, Strict) == Right(c)\n * }}}\n *\n * '''PatchMode Laws''':\n * {{{\n * // 7. STRICT FAILS ON ERROR\n * // Strict mode fails on first precondition violation\n *\n * // 8. LENIENT SKIPS ERRORS\n * // Lenient mode skips failing operations, always returns Right\n *\n * // 9. LENIENT SUBSUMES STRICT\n * ∀ p: JsonPatch, j: Json.\n *   p(j, Strict) == Right(r) implies p(j, Lenient) == Right(r)\n *\n * // 10. CLOBBER FORCES SUCCESS\n * // Clobber mode creates missing paths, always returns Right\n * }}}\n *\n * @param ops The sequence of patch operations\n */\nfinal case class JsonPatch(ops: Vector[JsonPatch.JsonPatchOp]) {\n\n  /**\n   * Applies this patch to a JSON value.\n   *\n   * @param json The JSON value to patch\n   * @param mode The patch mode (default: Strict)\n   * @return Either an error or the patched value\n   */\n  def apply(json: Json, mode: JsonPatchMode = JsonPatchMode.Strict): Either[JsonError, Json]\n\n  /**\n   * Composes this patch with another. Applies this patch first, then `that`.\n   *\n   * This is the monoid `combine` operation.\n   */\n  def ++(that: JsonPatch): JsonPatch = JsonPatch(ops ++ that.ops)\n\n  /**\n   * Returns true if this patch contains no operations.\n   */\n  def isEmpty: Boolean = ops.isEmpty\n\n  /**\n   * Converts this JSON patch to a [[DynamicPatch]].\n   */\n  def toDynamicPatch: DynamicPatch\n}\n\nobject JsonPatch {\n\n  /**\n   * Empty patch — the identity element for `++` composition.\n   */\n  val empty: JsonPatch = JsonPatch(Vector.empty)\n\n  /**\n   * Creates a patch with a single operation at the root path.\n   */\n  def root(op: Op): JsonPatch =\n    JsonPatch(Vector(JsonPatchOp(DynamicOptic.root, op)))\n\n  /**\n   * Creates a patch with a single operation at the given path.\n   */\n  def apply(path: DynamicOptic, op: Op): JsonPatch =\n    JsonPatch(Vector(JsonPatchOp(path, op)))\n\n  /**\n   * Computes a patch that transforms `oldJson` into `newJson`.\n   *\n   * Law: `diff(old, new)(old, Strict) == Right(new)`\n   */\n  def diff(oldJson: Json, newJson: Json): JsonPatch\n\n  /**\n   * Creates a JSON patch from a [[DynamicPatch]].\n   *\n   * May fail if the DynamicPatch contains operations not representable in JSON\n   * (e.g., non-string map keys, temporal deltas, variant operations).\n   */\n  def fromDynamicPatch(patch: DynamicPatch): Either[JsonError, JsonPatch]\n\n  // ===========================================================================\n  // JsonPatchOp — a single operation at a path\n  // ===========================================================================\n\n  /**\n   * A single patch operation: a path and what to do there.\n   *\n   * Mirrors [[DynamicPatch.DynamicPatchOp]].\n   */\n  final case class JsonPatchOp(path: DynamicOptic, op: Op)\n\n  // ===========================================================================\n  // Op — the operation to perform at a path\n  // ===========================================================================\n\n  /**\n   * The operation to perform at a target location.\n   *\n   * Mirrors [[DynamicPatch.Operation]] but specialized for JSON.\n   */\n  sealed trait Op\n\n  object Op {\n\n    /**\n     * Set a value directly (replacement).\n     *\n     * Mirrors [[DynamicPatch.Operation.Set]].\n     */\n    final case class Set(value: Json) extends Op\n\n    /**\n     * Apply a primitive delta operation.\n     *\n     * Used for numeric deltas and string edits.\n     * Mirrors [[DynamicPatch.Operation.PrimitiveDelta]].\n     */\n    final case class PrimitiveDelta(op: PrimitiveOp) extends Op\n\n    /**\n     * Apply array edit operations.\n     *\n     * Used for inserting, appending, deleting, or modifying array elements.\n     * Mirrors [[DynamicPatch.Operation.SequenceEdit]].\n     */\n    final case class ArrayEdit(ops: Vector[ArrayOp]) extends Op\n\n    /**\n     * Apply object edit operations.\n     *\n     * Used for adding, removing, or modifying object fields.\n     * Mirrors [[DynamicPatch.Operation.MapEdit]] but with string keys.\n     */\n    final case class ObjectEdit(ops: Vector[ObjectOp]) extends Op\n\n    /**\n     * Apply a nested patch.\n     *\n     * Used to group operations sharing a common path prefix.\n     * Mirrors [[DynamicPatch.Operation.Patch]].\n     */\n    final case class Nested(patch: JsonPatch) extends Op\n  }\n\n  // ===========================================================================\n  // PrimitiveOp — delta operations for JSON primitives\n  // ===========================================================================\n\n  /**\n   * Delta operations for JSON primitive values.\n   *\n   * JSON has only one numeric type, so we use BigDecimal for deltas.\n   * Boolean has no delta (use Set to toggle).\n   * Null has no delta (use Set to change).\n   *\n   * Mirrors [[DynamicPatch.PrimitiveOp]] but simplified for JSON's type system.\n   */\n  sealed trait PrimitiveOp\n\n  object PrimitiveOp {\n\n    /**\n     * Add a delta to a JSON number.\n     *\n     * Applied by: `currentValue + delta`\n     *\n     * Mirrors the numeric delta operations in [[DynamicPatch.PrimitiveOp]]\n     * (IntDelta, LongDelta, DoubleDelta, etc.) unified into one type.\n     */\n    final case class NumberDelta(delta: BigDecimal) extends PrimitiveOp\n\n    /**\n     * Apply string edit operations.\n     *\n     * Mirrors [[DynamicPatch.PrimitiveOp.StringEdit]].\n     */\n    final case class StringEdit(ops: Vector[StringOp]) extends PrimitiveOp\n  }\n\n  // ===========================================================================\n  // StringOp — edit operations for strings\n  // ===========================================================================\n\n  /**\n   * Edit operations for JSON strings.\n   *\n   * Mirrors [[DynamicPatch.StringOp]] exactly.\n   */\n  sealed trait StringOp\n\n  object StringOp {\n\n    /**\n     * Insert text at the given index.\n     */\n    final case class Insert(index: Int, text: String) extends StringOp\n\n    /**\n     * Delete characters starting at the given index.\n     */\n    final case class Delete(index: Int, length: Int) extends StringOp\n\n    /**\n     * Append text to the end of the string.\n     */\n    final case class Append(text: String) extends StringOp\n\n    /**\n     * Replace characters starting at index with new text.\n     */\n    final case class Modify(index: Int, length: Int, text: String) extends StringOp\n  }\n\n  // ===========================================================================\n  // ArrayOp — edit operations for arrays\n  // ===========================================================================\n\n  /**\n   * Edit operations for JSON arrays.\n   *\n   * Mirrors [[DynamicPatch.SeqOp]] but with Json values.\n   */\n  sealed trait ArrayOp\n\n  object ArrayOp {\n\n    /**\n     * Insert values at the given index.\n     */\n    final case class Insert(index: Int, values: Vector[Json]) extends ArrayOp\n\n    /**\n     * Append values to the end of the array.\n     */\n    final case class Append(values: Vector[Json]) extends ArrayOp\n\n    /**\n     * Delete elements starting at the given index.\n     */\n    final case class Delete(index: Int, count: Int) extends ArrayOp\n\n    /**\n     * Modify the element at the given index with a nested operation.\n     */\n    final case class Modify(index: Int, op: Op) extends ArrayOp\n  }\n\n  // ===========================================================================\n  // ObjectOp — edit operations for objects\n  // ===========================================================================\n\n  /**\n   * Edit operations for JSON objects.\n   *\n   * Mirrors [[DynamicPatch.MapOp]] but with string keys (JSON constraint).\n   */\n  sealed trait ObjectOp\n\n  object ObjectOp {\n\n    /**\n     * Add a field to the object.\n     */\n    final case class Add(key: String, value: Json) extends ObjectOp\n\n    /**\n     * Remove a field from the object.\n     */\n    final case class Remove(key: String) extends ObjectOp\n\n    /**\n     * Modify a field's value with a nested patch.\n     */\n    final case class Modify(key: String, patch: JsonPatch) extends ObjectOp\n  }\n}\n\n// =============================================================================\n// PATCH MODE\n// =============================================================================\n\n/**\n * Controls how patch application handles failures.\n *\n * Mirrors [[zio.blocks.schema.patch.PatchMode]].\n */\nsealed trait JsonPatchMode\n\nobject JsonPatchMode {\n\n  /**\n   * Fail on precondition violations.\n   */\n  case object Strict extends JsonPatchMode\n\n  /**\n   * Skip operations that fail preconditions.\n   */\n  case object Lenient extends JsonPatchMode\n\n  /**\n   * Replace/overwrite on conflicts (create missing paths).\n   */\n  case object Clobber extends JsonPatchMode\n}\n\n// =============================================================================\n// USAGE EXAMPLES\n// =============================================================================\n\n/*\n * ==Example 1: Basic Patching==\n *\n * {{{\n * import zio.blocks.schema.json._\n *\n * val json = Json.Object(Vector(\n *   \"name\" -> Json.String(\"Alice\"),\n *   \"age\" -> Json.Number(\"30\")\n * ))\n *\n * // Replace name\n * val patch = JsonPatch.root(JsonPatch.Op.Set(Json.String(\"Bob\")))\n *   // Or at a specific path:\n *   // JsonPatch(DynamicOptic.root.field(\"name\"), JsonPatch.Op.Set(Json.String(\"Bob\")))\n *\n * val result = patch(json, JsonPatchMode.Strict)\n * }}}\n *\n * ==Example 2: Diff and Apply (Roundtrip Law)==\n *\n * {{{\n * val source = Json.Object(Vector(\"x\" -> Json.Number(\"1\")))\n * val target = Json.Object(Vector(\"x\" -> Json.Number(\"5\")))\n *\n * val patch = JsonPatch.diff(source, target)\n *\n * // Roundtrip law\n * assert(patch(source, JsonPatchMode.Strict) == Right(target))\n *\n * // Identity diff law\n * assert(JsonPatch.diff(source, source).isEmpty)\n * }}}\n *\n * ==Example 3: Monoid Laws==\n *\n * {{{\n * val p1 = JsonPatch.diff(a, b)\n * val p2 = JsonPatch.diff(b, c)\n * val p3 = JsonPatch.diff(c, d)\n *\n * // Left identity\n * assert((JsonPatch.empty ++ p1)(a, Strict) == p1(a, Strict))\n *\n * // Right identity\n * assert((p1 ++ JsonPatch.empty)(a, Strict) == p1(a, Strict))\n *\n * // Associativity\n * assert(((p1 ++ p2) ++ p3)(a, Strict) == (p1 ++ (p2 ++ p3))(a, Strict))\n * }}}\n *\n * ==Example 4: Numeric Delta==\n *\n * {{{\n * val json = Json.Number(\"10\")\n *\n * // Add 5 to the number (more efficient than Set for large structures)\n * val patch = JsonPatch.root(\n *   JsonPatch.Op.PrimitiveDelta(JsonPatch.PrimitiveOp.NumberDelta(BigDecimal(5)))\n * )\n *\n * assert(patch(json, Strict) == Right(Json.Number(\"15\")))\n * }}}\n *\n * ==Example 5: String Edit==\n *\n * {{{\n * val json = Json.String(\"hello world\")\n *\n * // Change \"hello\" to \"hi\" using LCS-based edits\n * val patch = JsonPatch.root(\n *   JsonPatch.Op.PrimitiveDelta(\n *     JsonPatch.PrimitiveOp.StringEdit(Vector(\n *       JsonPatch.StringOp.Delete(0, 5),\n *       JsonPatch.StringOp.Insert(0, \"hi\")\n *     ))\n *   )\n * )\n *\n * assert(patch(json, Strict) == Right(Json.String(\"hi world\")))\n * }}}\n *\n * ==Example 6: Array Edit==\n *\n * {{{\n * val json = Json.Array(Vector(Json.Number(\"1\"), Json.Number(\"2\"), Json.Number(\"3\")))\n *\n * // Delete element at index 1, append new element\n * val patch = JsonPatch.root(\n *   JsonPatch.Op.ArrayEdit(Vector(\n *     JsonPatch.ArrayOp.Delete(1, 1),\n *     JsonPatch.ArrayOp.Append(Vector(Json.Number(\"4\")))\n *   ))\n * )\n *\n * // Result: [1, 3, 4]\n * }}}\n *\n * ==Example 7: Object Edit==\n *\n * {{{\n * val json = Json.Object(Vector(\"a\" -> Json.Number(\"1\"), \"b\" -> Json.Number(\"2\")))\n *\n * // Remove field \"a\", add field \"c\"\n * val patch = JsonPatch.root(\n *   JsonPatch.Op.ObjectEdit(Vector(\n *     JsonPatch.ObjectOp.Remove(\"a\"),\n *     JsonPatch.ObjectOp.Add(\"c\", Json.Number(\"3\"))\n *   ))\n * )\n *\n * // Result: {\"b\": 2, \"c\": 3}\n * }}}\n *\n * ==Example 8: Nested Patch==\n *\n * {{{\n * val json = Json.Object(Vector(\n *   \"user\" -> Json.Object(Vector(\n *     \"name\" -> Json.String(\"Alice\"),\n *     \"age\" -> Json.Number(\"30\")\n *   ))\n * ))\n *\n * // Patch nested inside \"user\"\n * val innerPatch = JsonPatch(Vector(\n *   JsonPatch.JsonPatchOp(\n *     DynamicOptic.root.field(\"age\"),\n *     JsonPatch.Op.PrimitiveDelta(JsonPatch.PrimitiveOp.NumberDelta(BigDecimal(1)))\n *   )\n * ))\n *\n * val patch = JsonPatch(\n *   DynamicOptic.root.field(\"user\"),\n *   JsonPatch.Op.Nested(innerPatch)\n * )\n *\n * // Increments user.age by 1\n * }}}\n *\n * ==Example 9: Diff Composition Law==\n *\n * {{{\n * val a = Json.Number(\"1\")\n * val b = Json.Number(\"5\")\n * val c = Json.Number(\"10\")\n *\n * val p1 = JsonPatch.diff(a, b)  // delta +4\n * val p2 = JsonPatch.diff(b, c)  // delta +5\n *\n * // Composition law: applying composed patch equals applying sequentially\n * assert((p1 ++ p2)(a, Strict) == Right(c))\n * }}}\n *\n * ==Example 10: PatchMode Behavior==\n *\n * {{{\n * val json = Json.Object(Vector(\"a\" -> Json.Number(\"1\")))\n *\n * // Try to remove non-existent field\n * val patch = JsonPatch.root(\n *   JsonPatch.Op.ObjectEdit(Vector(JsonPatch.ObjectOp.Remove(\"nonexistent\")))\n * )\n *\n * // Strict: fails\n * assert(patch(json, JsonPatchMode.Strict).isLeft)\n *\n * // Lenient: skips, returns unchanged\n * assert(patch(json, JsonPatchMode.Lenient) == Right(json))\n *\n * // Clobber: skips (nothing to clobber), returns unchanged\n * assert(patch(json, JsonPatchMode.Clobber) == Right(json))\n * }}}\n */\n```",
                  "html_url": "https://github.com/zio/zio-blocks/issues/685"
                },
                "type": "github"
              },
              "hash": "zio/zio-blocks#685",
              "body": "<html><head></head><body><h1>Add <code>JsonPatch</code> type for diffing and patching JSON values</h1>\n<h2>Summary</h2>\n<p>Implement a <code>JsonPatch</code> type that enables computing diffs between JSON values and applying patches to transform one JSON value into another. This type should mirror the existing <code>DynamicPatch</code> implementation, adapted for JSON's simpler data model.</p>\n<h2>Motivation</h2>\n<p><code>DynamicValue</code> has a well-designed <code>DynamicPatch</code> system with:</p>\n<ul>\n<li>Monoid composition (<code>++</code> with <code>empty</code> identity)</li>\n<li>LCS-based sequence diffing</li>\n<li>Primitive delta operations (numeric deltas, string edits)</li>\n<li>Comprehensive algebraic laws verified by property tests</li>\n</ul>\n<p>The proposed <code>Json</code> type (see #TBD) needs equivalent patching capabilities. Rather than converting <code>Json ↔ DynamicValue</code> for every patch operation, a native <code>JsonPatch</code> provides:</p>\n<ul>\n<li>Type safety (no conversion errors for JSON-incompatible DynamicPatch operations)</li>\n<li>API consistency with the <code>Json</code> type</li>\n<li>Potential for JSON-specific optimizations</li>\n</ul>\n<h2>Design Sketch</h2>\n<p>A design sketch is available at <a href=\"https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/json/JsonPatch.scala\"><code>schema/shared/src/main/scala/zio/blocks/schema/json/JsonPatch.scala</code></a>. This sketch is <strong>a guide, not a specification</strong> — implementers should use judgment and deviate where appropriate.</p>\n<h3>Core Types</h3>\n<p>The design mirrors <code>DynamicPatch</code> with JSON-specific adaptations:</p>\n\nDynamicPatch | JsonPatch | Notes\n-- | -- | --\nDynamicPatch(Vector[DynamicPatchOp]) | JsonPatch(Vector[JsonPatchOp]) | Same structure\nOperation.Set | Op.Set | Same\nOperation.PrimitiveDelta | Op.PrimitiveDelta | Simplified for JSON types\nOperation.SequenceEdit | Op.ArrayEdit | Renamed\nOperation.MapEdit | Op.ObjectEdit | String keys only\nOperation.Patch | Op.Nested | Same\nSeqOp | ArrayOp | Same operations\nMapOp | ObjectOp | String keys only\nPrimitiveOp (14 variants) | PrimitiveOp (2 variants) | See below\n\n\n<h3>StringOp</h3>\n<p>Mirror <code>DynamicPatch.StringOp</code> exactly:</p>\n<ul>\n<li><code>Insert(index: Int, text: String)</code></li>\n<li><code>Delete(index: Int, length: Int)</code></li>\n<li><code>Append(text: String)</code></li>\n<li><code>Modify(index: Int, length: Int, text: String)</code></li>\n</ul>\n<h3>ArrayOp</h3>\n<p>Mirror <code>DynamicPatch.SeqOp</code>:</p>\n<ul>\n<li><code>Insert(index: Int, values: Vector[Json])</code></li>\n<li><code>Append(values: Vector[Json])</code></li>\n<li><code>Delete(index: Int, count: Int)</code></li>\n<li><code>Modify(index: Int, op: Op)</code></li>\n</ul>\n<h3>ObjectOp</h3>\n<p>Mirror <code>DynamicPatch.MapOp</code> with string keys:</p>\n<ul>\n<li><code>Add(key: String, value: Json)</code></li>\n<li><code>Remove(key: String)</code></li>\n<li><code>Modify(key: String, patch: JsonPatch)</code></li>\n</ul>\n<h2>Requirements</h2>\n<h3>Functional Requirements</h3>\n<ul>\n<li>[ ] <strong>F1</strong>: <code>JsonPatch.diff(source, target)</code> computes a patch transforming source to target</li>\n<li>[ ] <strong>F2</strong>: <code>patch.apply(json, mode)</code> applies a patch with configurable failure handling</li>\n<li>[ ] <strong>F3</strong>: <code>patch1 ++ patch2</code> composes patches (apply first, then second)</li>\n<li>[ ] <strong>F4</strong>: <code>JsonPatch.empty</code> is the identity element for composition</li>\n<li>[ ] <strong>F5</strong>: Support <code>JsonPatchMode.Strict</code>, <code>Lenient</code>, and <code>Clobber</code> modes</li>\n<li>[ ] <strong>F6</strong>: Bidirectional conversion: <code>toDynamicPatch</code> / <code>fromDynamicPatch</code></li>\n</ul>\n<h3>Algebraic Laws</h3>\n<p>All laws must be verified with property-based tests (see <code>PatchLawsSpec</code> for reference):</p>\n<ul>\n<li>[ ] <strong>L1</strong>: Left identity — <code>(empty ++ p)(j) == p(j)</code></li>\n<li>[ ] <strong>L2</strong>: Right identity — <code>(p ++ empty)(j) == p(j)</code></li>\n<li>[ ] <strong>L3</strong>: Associativity — <code>((p1 ++ p2) ++ p3)(j) == (p1 ++ (p2 ++ p3))(j)</code></li>\n<li>[ ] <strong>L4</strong>: Roundtrip — <code>diff(a, b)(a) == Right(b)</code></li>\n<li>[ ] <strong>L5</strong>: Identity diff — <code>diff(j, j).isEmpty</code></li>\n<li>[ ] <strong>L6</strong>: Diff composition — <code>(diff(a, b) ++ diff(b, c))(a) == Right(c)</code></li>\n<li>[ ] <strong>L7</strong>: Lenient subsumes Strict — if <code>p(j, Strict) == Right(r)</code> then <code>p(j, Lenient) == Right(r)</code></li>\n</ul>\n<h3>Testing Requirements</h3>\n<ul>\n<li>[ ] <strong>T1</strong>: Property-based tests for all algebraic laws (see <code>PatchLawsSpec</code>)</li>\n<li>[ ] <strong>T2</strong>: Test each operation type (<code>Set</code>, <code>PrimitiveDelta</code>, <code>ArrayEdit</code>, <code>ObjectEdit</code>, <code>Nested</code>)</li>\n<li>[ ] <strong>T3</strong>: Test each <code>ArrayOp</code> variant (<code>Insert</code>, <code>Append</code>, <code>Delete</code>, <code>Modify</code>)</li>\n<li>[ ] <strong>T4</strong>: Test each <code>ObjectOp</code> variant (<code>Add</code>, <code>Remove</code>, <code>Modify</code>)</li>\n<li>[ ] <strong>T5</strong>: Test each <code>StringOp</code> variant (<code>Insert</code>, <code>Delete</code>, <code>Append</code>, <code>Modify</code>)</li>\n<li>[ ] <strong>T6</strong>: Test <code>NumberDelta</code> with positive, negative, zero, and decimal deltas</li>\n<li>[ ] <strong>T7</strong>: Test all three <code>JsonPatchMode</code> behaviors</li>\n<li>[ ] <strong>T8</strong>: Test <code>toDynamicPatch</code> / <code>fromDynamicPatch</code> roundtrip</li>\n<li>[ ] <strong>T9</strong>: Test edge cases: empty arrays, empty objects, empty strings, nested structures</li>\n<li>[ ] <strong>T10</strong>: Test error cases: invalid paths, type mismatches, out-of-bounds indices</li>\n</ul>\n<h3>Documentation Requirements</h3>\n<ul>\n<li>[ ] <strong>D1</strong>: ScalaDoc for all public types and methods</li>\n<li>[ ] <strong>D2</strong>: Usage examples in ScalaDoc (see sketch for examples)</li>\n<li>[ ] <strong>D3</strong>: Document algebraic laws in type-level comments</li>\n<li>[ ] <strong>D4</strong>: Document relationship to <code>DynamicPatch</code></li>\n</ul>\n<h3>Implementation Notes</h3>\n<ol>\n<li>\n<p><strong>Follow <code>DynamicPatch</code> patterns</strong>: The implementation in <code>DynamicPatch.scala</code> is the reference. Study <code>Differ.scala</code> for diff algorithms (especially LCS for sequences and strings).</p>\n</li>\n<li>\n<p><strong>Reuse algorithms where possible</strong>: Consider whether <code>JsonPatch</code> can delegate to <code>DynamicPatch</code> internally, or share algorithm implementations.</p>\n</li>\n<li>\n<p><strong>Keep it minimal</strong>: Resist adding operations not present in <code>DynamicPatch</code>. The design is intentionally minimal and principled.</p>\n</li>\n<li>\n<p><strong>Performance considerations</strong>: The register-based design of ZIO Blocks prioritizes performance. Avoid unnecessary allocations in hot paths.</p>\n</li>\n</ol>\n<h2>Out of Scope</h2>\n<p>The following are explicitly <strong>not</strong> part of this issue:</p>\n<ul>\n<li>RFC 6902 JSON Patch serialization format (separate issue)</li>\n<li>Patch inversion / undo support (separate issue)</li>\n<li>Patch optimization / compaction (separate issue)</li>\n<li>Integration with <code>Json</code> type methods like <code>json.diff(other)</code> (depends on <code>Json</code> implementation)</li>\n</ul>\n<h2>Related</h2>\n<ul>\n<li><code>DynamicPatch</code> — <a href=\"https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/DynamicPatch.scala\"><code>schema/shared/src/main/scala/zio/blocks/schema/patch/DynamicPatch.scala</code></a></li>\n<li><code>Differ</code> — <a href=\"https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/Differ.scala\"><code>schema/shared/src/main/scala/zio/blocks/schema/patch/Differ.scala</code></a></li>\n<li><code>PatchLawsSpec</code> — <a href=\"https://claude.ai/chat/schema/shared/src/test/scala/zio/blocks/schema/patch/PatchLawsSpec.scala\"><code>schema/shared/src/test/scala/zio/blocks/schema/patch/PatchLawsSpec.scala</code></a></li>\n<li><code>PatchMode</code> — <a href=\"https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/PatchMode.scala\"><code>schema/shared/src/main/scala/zio/blocks/schema/patch/PatchMode.scala</code></a></li>\n</ul>\n<h2>Acceptance Criteria</h2>\n<ul>\n<li>[ ] All functional requirements (F1-F6) implemented</li>\n<li>[ ] All algebraic laws (L1-L7) pass property-based tests</li>\n<li>[ ] All testing requirements (T1-T10) have corresponding test cases</li>\n<li>[ ] All documentation requirements (D1-D4) complete</li>\n<li>[ ] Code reviewed and approved</li>\n<li>[ ] CI passing</li>\n</ul></body></html># Add `JsonPatch` type for diffing and patching JSON values\n\n## Summary\n\nImplement a `JsonPatch` type that enables computing diffs between JSON values and applying patches to transform one JSON value into another. This type should mirror the existing `DynamicPatch` implementation, adapted for JSON's simpler data model.\n\n## Motivation\n\n`DynamicValue` has a well-designed `DynamicPatch` system with:\n- Monoid composition (`++` with `empty` identity)\n- LCS-based sequence diffing\n- Primitive delta operations (numeric deltas, string edits)\n- Comprehensive algebraic laws verified by property tests\n\nThe proposed `Json` type (see #TBD) needs equivalent patching capabilities. Rather than converting `Json ↔ DynamicValue` for every patch operation, a native `JsonPatch` provides:\n- Type safety (no conversion errors for JSON-incompatible DynamicPatch operations)\n- API consistency with the `Json` type\n- Potential for JSON-specific optimizations\n\n## Design Sketch\n\nA design sketch is available at [`[schema/shared/src/main/scala/zio/blocks/schema/json/JsonPatch.scala](https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/json/JsonPatch.scala)`](./schema/shared/src/main/scala/zio/blocks/schema/json/JsonPatch.scala). This sketch is **a guide, not a specification** — implementers should use judgment and deviate where appropriate.\n\n### Core Types\n\nThe design mirrors `DynamicPatch` with JSON-specific adaptations:\n\n| DynamicPatch | JsonPatch | Notes |\n|--------------|-----------|-------|\n| `DynamicPatch(Vector[DynamicPatchOp])` | `JsonPatch(Vector[JsonPatchOp])` | Same structure |\n| `Operation.Set` | `Op.Set` | Same |\n| `Operation.PrimitiveDelta` | `Op.PrimitiveDelta` | Simplified for JSON types |\n| `Operation.SequenceEdit` | `Op.ArrayEdit` | Renamed |\n| `Operation.MapEdit` | `Op.ObjectEdit` | String keys only |\n| `Operation.Patch` | `Op.Nested` | Same |\n| `SeqOp` | `ArrayOp` | Same operations |\n| `MapOp` | `ObjectOp` | String keys only |\n| `PrimitiveOp` (14 variants) | `PrimitiveOp` (2 variants) | See below |\n\n### Primitive Operations\n\nJSON has a simpler type system than `DynamicValue`:\n\n| JSON Type | Delta Operation | Notes |\n|-----------|-----------------|-------|\n| Number | `NumberDelta(BigDecimal)` | Unifies all numeric deltas |\n| String | `StringEdit(Vector[StringOp])` | Same as `DynamicPatch` |\n| Boolean | Use `Op.Set` | No delta (same as `DynamicPatch`) |\n| Null | Use `Op.Set` | No delta |\n\n### StringOp\n\nMirror `DynamicPatch.StringOp` exactly:\n- `Insert(index: Int, text: String)`\n- `Delete(index: Int, length: Int)`\n- `Append(text: String)`\n- `Modify(index: Int, length: Int, text: String)`\n\n### ArrayOp\n\nMirror `DynamicPatch.SeqOp`:\n- `Insert(index: Int, values: Vector[Json])`\n- `Append(values: Vector[Json])`\n- `Delete(index: Int, count: Int)`\n- `Modify(index: Int, op: Op)`\n\n### ObjectOp\n\nMirror `DynamicPatch.MapOp` with string keys:\n- `Add(key: String, value: Json)`\n- `Remove(key: String)`\n- `Modify(key: String, patch: JsonPatch)`\n\n## Requirements\n\n### Functional Requirements\n\n- [ ] **F1**: `JsonPatch.diff(source, target)` computes a patch transforming source to target\n- [ ] **F2**: `patch.apply(json, mode)` applies a patch with configurable failure handling\n- [ ] **F3**: `patch1 ++ patch2` composes patches (apply first, then second)\n- [ ] **F4**: `JsonPatch.empty` is the identity element for composition\n- [ ] **F5**: Support `JsonPatchMode.Strict`, `Lenient`, and `Clobber` modes\n- [ ] **F6**: Bidirectional conversion: `toDynamicPatch` / `fromDynamicPatch`\n\n### Algebraic Laws\n\nAll laws must be verified with property-based tests (see `PatchLawsSpec` for reference):\n\n- [ ] **L1**: Left identity — `(empty ++ p)(j) == p(j)`\n- [ ] **L2**: Right identity — `(p ++ empty)(j) == p(j)`\n- [ ] **L3**: Associativity — `((p1 ++ p2) ++ p3)(j) == (p1 ++ (p2 ++ p3))(j)`\n- [ ] **L4**: Roundtrip — `diff(a, b)(a) == Right(b)`\n- [ ] **L5**: Identity diff — `diff(j, j).isEmpty`\n- [ ] **L6**: Diff composition — `(diff(a, b) ++ diff(b, c))(a) == Right(c)`\n- [ ] **L7**: Lenient subsumes Strict — if `p(j, Strict) == Right(r)` then `p(j, Lenient) == Right(r)`\n\n### Testing Requirements\n\n- [ ] **T1**: Property-based tests for all algebraic laws (see `PatchLawsSpec`)\n- [ ] **T2**: Test each operation type (`Set`, `PrimitiveDelta`, `ArrayEdit`, `ObjectEdit`, `Nested`)\n- [ ] **T3**: Test each `ArrayOp` variant (`Insert`, `Append`, `Delete`, `Modify`)\n- [ ] **T4**: Test each `ObjectOp` variant (`Add`, `Remove`, `Modify`)\n- [ ] **T5**: Test each `StringOp` variant (`Insert`, `Delete`, `Append`, `Modify`)\n- [ ] **T6**: Test `NumberDelta` with positive, negative, zero, and decimal deltas\n- [ ] **T7**: Test all three `JsonPatchMode` behaviors\n- [ ] **T8**: Test `toDynamicPatch` / `fromDynamicPatch` roundtrip\n- [ ] **T9**: Test edge cases: empty arrays, empty objects, empty strings, nested structures\n- [ ] **T10**: Test error cases: invalid paths, type mismatches, out-of-bounds indices\n\n### Documentation Requirements\n\n- [ ] **D1**: ScalaDoc for all public types and methods\n- [ ] **D2**: Usage examples in ScalaDoc (see sketch for examples)\n- [ ] **D3**: Document algebraic laws in type-level comments\n- [ ] **D4**: Document relationship to `DynamicPatch`\n\n## Related\n\n- `DynamicPatch` — [`[schema/shared/src/main/scala/zio/blocks/schema/patch/DynamicPatch.scala](https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/DynamicPatch.scala)`](./schema/shared/src/main/scala/zio/blocks/schema/patch/DynamicPatch.scala)\n- `Differ` — [`[schema/shared/src/main/scala/zio/blocks/schema/patch/Differ.scala](https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/Differ.scala)`](./schema/shared/src/main/scala/zio/blocks/schema/patch/Differ.scala)\n- `PatchLawsSpec` — [`[schema/shared/src/test/scala/zio/blocks/schema/patch/PatchLawsSpec.scala](https://claude.ai/chat/schema/shared/src/test/scala/zio/blocks/schema/patch/PatchLawsSpec.scala)`](./schema/shared/src/test/scala/zio/blocks/schema/patch/PatchLawsSpec.scala)\n- `PatchMode` — [`[schema/shared/src/main/scala/zio/blocks/schema/patch/PatchMode.scala](https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/PatchMode.scala)`](./schema/shared/src/main/scala/zio/blocks/schema/patch/PatchMode.scala)\n\n## Acceptance Criteria\n\n- [ ] All functional requirements (F1-F6) implemented\n- [ ] All algebraic laws (L1-L7) pass property-based tests\n- [ ] All testing requirements (T1-T10) have corresponding test cases\n- [ ] All documentation requirements (D1-D4) complete\n- [ ] Code reviewed and approved\n- [ ] CI passing\n\n# Sketch\n\n```scala\npackage zio.blocks.schema.json\n\nimport zio.blocks.schema.DynamicOptic\nimport zio.blocks.schema.patch.DynamicPatch\n\n// =============================================================================\n// JSON PATCH\n// =============================================================================\n\n/**\n * An untyped patch that operates on [[Json]] values.\n *\n * `JsonPatch` is the JSON-specific counterpart to [[DynamicPatch]]. It represents\n * a sequence of operations that transform one JSON value into another. Patches\n * are serializable and composable.\n *\n * ==Design==\n *\n * This type directly mirrors [[DynamicPatch]] but is specialized for JSON's\n * simpler data model:\n *  - JSON has 4 leaf types (String, Number, Boolean, Null) vs 30 PrimitiveValues\n *  - JSON objects have string keys only (no arbitrary-keyed maps)\n *  - JSON has no native Variant type\n *\n * ==Algebraic Laws==\n *\n * '''Monoid Laws''' (under `++` composition):\n * {{{\n * // 1. LEFT IDENTITY\n * ∀ p: JsonPatch, j: Json.\n *   (JsonPatch.empty ++ p)(j, mode) == p(j, mode)\n *\n * // 2. RIGHT IDENTITY\n * ∀ p: JsonPatch, j: Json.\n *   (p ++ JsonPatch.empty)(j, mode) == p(j, mode)\n *\n * // 3. ASSOCIATIVITY\n * ∀ p1, p2, p3: JsonPatch, j: Json.\n *   ((p1 ++ p2) ++ p3)(j, mode) == (p1 ++ (p2 ++ p3))(j, mode)\n * }}}\n *\n * '''Diff/Apply Laws''':\n * {{{\n * // 4. ROUNDTRIP\n * ∀ source, target: Json.\n *   JsonPatch.diff(source, target)(source, Strict) == Right(target)\n *\n * // 5. IDENTITY DIFF\n * ∀ j: Json.\n *   JsonPatch.diff(j, j).isEmpty == true\n *\n * // 6. DIFF COMPOSITION\n * ∀ a, b, c: Json.\n *   (JsonPatch.diff(a, b) ++ JsonPatch.diff(b, c))(a, Strict) == Right(c)\n * }}}\n *\n * '''PatchMode Laws''':\n * {{{\n * // 7. STRICT FAILS ON ERROR\n * // Strict mode fails on first precondition violation\n *\n * // 8. LENIENT SKIPS ERRORS\n * // Lenient mode skips failing operations, always returns Right\n *\n * // 9. LENIENT SUBSUMES STRICT\n * ∀ p: JsonPatch, j: Json.\n *   p(j, Strict) == Right(r) implies p(j, Lenient) == Right(r)\n *\n * // 10. CLOBBER FORCES SUCCESS\n * // Clobber mode creates missing paths, always returns Right\n * }}}\n *\n * @param ops The sequence of patch operations\n */\nfinal case class JsonPatch(ops: Vector[JsonPatch.JsonPatchOp]) {\n\n  /**\n   * Applies this patch to a JSON value.\n   *\n   * @param json The JSON value to patch\n   * @param mode The patch mode (default: Strict)\n   * @return Either an error or the patched value\n   */\n  def apply(json: Json, mode: JsonPatchMode = JsonPatchMode.Strict): Either[JsonError, Json]\n\n  /**\n   * Composes this patch with another. Applies this patch first, then `that`.\n   *\n   * This is the monoid `combine` operation.\n   */\n  def ++(that: JsonPatch): JsonPatch = JsonPatch(ops ++ that.ops)\n\n  /**\n   * Returns true if this patch contains no operations.\n   */\n  def isEmpty: Boolean = ops.isEmpty\n\n  /**\n   * Converts this JSON patch to a [[DynamicPatch]].\n   */\n  def toDynamicPatch: DynamicPatch\n}\n\nobject JsonPatch {\n\n  /**\n   * Empty patch — the identity element for `++` composition.\n   */\n  val empty: JsonPatch = JsonPatch(Vector.empty)\n\n  /**\n   * Creates a patch with a single operation at the root path.\n   */\n  def root(op: Op): JsonPatch =\n    JsonPatch(Vector(JsonPatchOp(DynamicOptic.root, op)))\n\n  /**\n   * Creates a patch with a single operation at the given path.\n   */\n  def apply(path: DynamicOptic, op: Op): JsonPatch =\n    JsonPatch(Vector(JsonPatchOp(path, op)))\n\n  /**\n   * Computes a patch that transforms `oldJson` into `newJson`.\n   *\n   * Law: `diff(old, new)(old, Strict) == Right(new)`\n   */\n  def diff(oldJson: Json, newJson: Json): JsonPatch\n\n  /**\n   * Creates a JSON patch from a [[DynamicPatch]].\n   *\n   * May fail if the DynamicPatch contains operations not representable in JSON\n   * (e.g., non-string map keys, temporal deltas, variant operations).\n   */\n  def fromDynamicPatch(patch: DynamicPatch): Either[JsonError, JsonPatch]\n\n  // ===========================================================================\n  // JsonPatchOp — a single operation at a path\n  // ===========================================================================\n\n  /**\n   * A single patch operation: a path and what to do there.\n   *\n   * Mirrors [[DynamicPatch.DynamicPatchOp]].\n   */\n  final case class JsonPatchOp(path: DynamicOptic, op: Op)\n\n  // ===========================================================================\n  // Op — the operation to perform at a path\n  // ===========================================================================\n\n  /**\n   * The operation to perform at a target location.\n   *\n   * Mirrors [[DynamicPatch.Operation]] but specialized for JSON.\n   */\n  sealed trait Op\n\n  object Op {\n\n    /**\n     * Set a value directly (replacement).\n     *\n     * Mirrors [[DynamicPatch.Operation.Set]].\n     */\n    final case class Set(value: Json) extends Op\n\n    /**\n     * Apply a primitive delta operation.\n     *\n     * Used for numeric deltas and string edits.\n     * Mirrors [[DynamicPatch.Operation.PrimitiveDelta]].\n     */\n    final case class PrimitiveDelta(op: PrimitiveOp) extends Op\n\n    /**\n     * Apply array edit operations.\n     *\n     * Used for inserting, appending, deleting, or modifying array elements.\n     * Mirrors [[DynamicPatch.Operation.SequenceEdit]].\n     */\n    final case class ArrayEdit(ops: Vector[ArrayOp]) extends Op\n\n    /**\n     * Apply object edit operations.\n     *\n     * Used for adding, removing, or modifying object fields.\n     * Mirrors [[DynamicPatch.Operation.MapEdit]] but with string keys.\n     */\n    final case class ObjectEdit(ops: Vector[ObjectOp]) extends Op\n\n    /**\n     * Apply a nested patch.\n     *\n     * Used to group operations sharing a common path prefix.\n     * Mirrors [[DynamicPatch.Operation.Patch]].\n     */\n    final case class Nested(patch: JsonPatch) extends Op\n  }\n\n  // ===========================================================================\n  // PrimitiveOp — delta operations for JSON primitives\n  // ===========================================================================\n\n  /**\n   * Delta operations for JSON primitive values.\n   *\n   * JSON has only one numeric type, so we use BigDecimal for deltas.\n   * Boolean has no delta (use Set to toggle).\n   * Null has no delta (use Set to change).\n   *\n   * Mirrors [[DynamicPatch.PrimitiveOp]] but simplified for JSON's type system.\n   */\n  sealed trait PrimitiveOp\n\n  object PrimitiveOp {\n\n    /**\n     * Add a delta to a JSON number.\n     *\n     * Applied by: `currentValue + delta`\n     *\n     * Mirrors the numeric delta operations in [[DynamicPatch.PrimitiveOp]]\n     * (IntDelta, LongDelta, DoubleDelta, etc.) unified into one type.\n     */\n    final case class NumberDelta(delta: BigDecimal) extends PrimitiveOp\n\n    /**\n     * Apply string edit operations.\n     *\n     * Mirrors [[DynamicPatch.PrimitiveOp.StringEdit]].\n     */\n    final case class StringEdit(ops: Vector[StringOp]) extends PrimitiveOp\n  }\n\n  // ===========================================================================\n  // StringOp — edit operations for strings\n  // ===========================================================================\n\n  /**\n   * Edit operations for JSON strings.\n   *\n   * Mirrors [[DynamicPatch.StringOp]] exactly.\n   */\n  sealed trait StringOp\n\n  object StringOp {\n\n    /**\n     * Insert text at the given index.\n     */\n    final case class Insert(index: Int, text: String) extends StringOp\n\n    /**\n     * Delete characters starting at the given index.\n     */\n    final case class Delete(index: Int, length: Int) extends StringOp\n\n    /**\n     * Append text to the end of the string.\n     */\n    final case class Append(text: String) extends StringOp\n\n    /**\n     * Replace characters starting at index with new text.\n     */\n    final case class Modify(index: Int, length: Int, text: String) extends StringOp\n  }\n\n  // ===========================================================================\n  // ArrayOp — edit operations for arrays\n  // ===========================================================================\n\n  /**\n   * Edit operations for JSON arrays.\n   *\n   * Mirrors [[DynamicPatch.SeqOp]] but with Json values.\n   */\n  sealed trait ArrayOp\n\n  object ArrayOp {\n\n    /**\n     * Insert values at the given index.\n     */\n    final case class Insert(index: Int, values: Vector[Json]) extends ArrayOp\n\n    /**\n     * Append values to the end of the array.\n     */\n    final case class Append(values: Vector[Json]) extends ArrayOp\n\n    /**\n     * Delete elements starting at the given index.\n     */\n    final case class Delete(index: Int, count: Int) extends ArrayOp\n\n    /**\n     * Modify the element at the given index with a nested operation.\n     */\n    final case class Modify(index: Int, op: Op) extends ArrayOp\n  }\n\n  // ===========================================================================\n  // ObjectOp — edit operations for objects\n  // ===========================================================================\n\n  /**\n   * Edit operations for JSON objects.\n   *\n   * Mirrors [[DynamicPatch.MapOp]] but with string keys (JSON constraint).\n   */\n  sealed trait ObjectOp\n\n  object ObjectOp {\n\n    /**\n     * Add a field to the object.\n     */\n    final case class Add(key: String, value: Json) extends ObjectOp\n\n    /**\n     * Remove a field from the object.\n     */\n    final case class Remove(key: String) extends ObjectOp\n\n    /**\n     * Modify a field's value with a nested patch.\n     */\n    final case class Modify(key: String, patch: JsonPatch) extends ObjectOp\n  }\n}\n\n// =============================================================================\n// PATCH MODE\n// =============================================================================\n\n/**\n * Controls how patch application handles failures.\n *\n * Mirrors [[zio.blocks.schema.patch.PatchMode]].\n */\nsealed trait JsonPatchMode\n\nobject JsonPatchMode {\n\n  /**\n   * Fail on precondition violations.\n   */\n  case object Strict extends JsonPatchMode\n\n  /**\n   * Skip operations that fail preconditions.\n   */\n  case object Lenient extends JsonPatchMode\n\n  /**\n   * Replace/overwrite on conflicts (create missing paths).\n   */\n  case object Clobber extends JsonPatchMode\n}\n\n// =============================================================================\n// USAGE EXAMPLES\n// =============================================================================\n\n/*\n * ==Example 1: Basic Patching==\n *\n * {{{\n * import zio.blocks.schema.json._\n *\n * val json = Json.Object(Vector(\n *   \"name\" -> Json.String(\"Alice\"),\n *   \"age\" -> Json.Number(\"30\")\n * ))\n *\n * // Replace name\n * val patch = JsonPatch.root(JsonPatch.Op.Set(Json.String(\"Bob\")))\n *   // Or at a specific path:\n *   // JsonPatch(DynamicOptic.root.field(\"name\"), JsonPatch.Op.Set(Json.String(\"Bob\")))\n *\n * val result = patch(json, JsonPatchMode.Strict)\n * }}}\n *\n * ==Example 2: Diff and Apply (Roundtrip Law)==\n *\n * {{{\n * val source = Json.Object(Vector(\"x\" -> Json.Number(\"1\")))\n * val target = Json.Object(Vector(\"x\" -> Json.Number(\"5\")))\n *\n * val patch = JsonPatch.diff(source, target)\n *\n * // Roundtrip law\n * assert(patch(source, JsonPatchMode.Strict) == Right(target))\n *\n * // Identity diff law\n * assert(JsonPatch.diff(source, source).isEmpty)\n * }}}\n *\n * ==Example 3: Monoid Laws==\n *\n * {{{\n * val p1 = JsonPatch.diff(a, b)\n * val p2 = JsonPatch.diff(b, c)\n * val p3 = JsonPatch.diff(c, d)\n *\n * // Left identity\n * assert((JsonPatch.empty ++ p1)(a, Strict) == p1(a, Strict))\n *\n * // Right identity\n * assert((p1 ++ JsonPatch.empty)(a, Strict) == p1(a, Strict))\n *\n * // Associativity\n * assert(((p1 ++ p2) ++ p3)(a, Strict) == (p1 ++ (p2 ++ p3))(a, Strict))\n * }}}\n *\n * ==Example 4: Numeric Delta==\n *\n * {{{\n * val json = Json.Number(\"10\")\n *\n * // Add 5 to the number (more efficient than Set for large structures)\n * val patch = JsonPatch.root(\n *   JsonPatch.Op.PrimitiveDelta(JsonPatch.PrimitiveOp.NumberDelta(BigDecimal(5)))\n * )\n *\n * assert(patch(json, Strict) == Right(Json.Number(\"15\")))\n * }}}\n *\n * ==Example 5: String Edit==\n *\n * {{{\n * val json = Json.String(\"hello world\")\n *\n * // Change \"hello\" to \"hi\" using LCS-based edits\n * val patch = JsonPatch.root(\n *   JsonPatch.Op.PrimitiveDelta(\n *     JsonPatch.PrimitiveOp.StringEdit(Vector(\n *       JsonPatch.StringOp.Delete(0, 5),\n *       JsonPatch.StringOp.Insert(0, \"hi\")\n *     ))\n *   )\n * )\n *\n * assert(patch(json, Strict) == Right(Json.String(\"hi world\")))\n * }}}\n *\n * ==Example 6: Array Edit==\n *\n * {{{\n * val json = Json.Array(Vector(Json.Number(\"1\"), Json.Number(\"2\"), Json.Number(\"3\")))\n *\n * // Delete element at index 1, append new element\n * val patch = JsonPatch.root(\n *   JsonPatch.Op.ArrayEdit(Vector(\n *     JsonPatch.ArrayOp.Delete(1, 1),\n *     JsonPatch.ArrayOp.Append(Vector(Json.Number(\"4\")))\n *   ))\n * )\n *\n * // Result: [1, 3, 4]\n * }}}\n *\n * ==Example 7: Object Edit==\n *\n * {{{\n * val json = Json.Object(Vector(\"a\" -> Json.Number(\"1\"), \"b\" -> Json.Number(\"2\")))\n *\n * // Remove field \"a\", add field \"c\"\n * val patch = JsonPatch.root(\n *   JsonPatch.Op.ObjectEdit(Vector(\n *     JsonPatch.ObjectOp.Remove(\"a\"),\n *     JsonPatch.ObjectOp.Add(\"c\", Json.Number(\"3\"))\n *   ))\n * )\n *\n * // Result: {\"b\": 2, \"c\": 3}\n * }}}\n *\n * ==Example 8: Nested Patch==\n *\n * {{{\n * val json = Json.Object(Vector(\n *   \"user\" -> Json.Object(Vector(\n *     \"name\" -> Json.String(\"Alice\"),\n *     \"age\" -> Json.Number(\"30\")\n *   ))\n * ))\n *\n * // Patch nested inside \"user\"\n * val innerPatch = JsonPatch(Vector(\n *   JsonPatch.JsonPatchOp(\n *     DynamicOptic.root.field(\"age\"),\n *     JsonPatch.Op.PrimitiveDelta(JsonPatch.PrimitiveOp.NumberDelta(BigDecimal(1)))\n *   )\n * ))\n *\n * val patch = JsonPatch(\n *   DynamicOptic.root.field(\"user\"),\n *   JsonPatch.Op.Nested(innerPatch)\n * )\n *\n * // Increments user.age by 1\n * }}}\n *\n * ==Example 9: Diff Composition Law==\n *\n * {{{\n * val a = Json.Number(\"1\")\n * val b = Json.Number(\"5\")\n * val c = Json.Number(\"10\")\n *\n * val p1 = JsonPatch.diff(a, b)  // delta +4\n * val p2 = JsonPatch.diff(b, c)  // delta +5\n *\n * // Composition law: applying composed patch equals applying sequentially\n * assert((p1 ++ p2)(a, Strict) == Right(c))\n * }}}\n *\n * ==Example 10: PatchMode Behavior==\n *\n * {{{\n * val json = Json.Object(Vector(\"a\" -> Json.Number(\"1\")))\n *\n * // Try to remove non-existent field\n * val patch = JsonPatch.root(\n *   JsonPatch.Op.ObjectEdit(Vector(JsonPatch.ObjectOp.Remove(\"nonexistent\")))\n * )\n *\n * // Strict: fails\n * assert(patch(json, JsonPatchMode.Strict).isLeft)\n *\n * // Lenient: skips, returns unchanged\n * assert(patch(json, JsonPatchMode.Lenient) == Right(json))\n *\n * // Clobber: skips (nothing to clobber), returns unchanged\n * assert(patch(json, JsonPatchMode.Clobber) == Right(json))\n * }}}\n */\n```",
              "url": "https://github.com/zio/zio-blocks/issues/685",
              "tech": [],
              "repo_name": "zio-blocks",
              "repo_owner": "zio",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "ZIO#683",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "ZIO",
              "id": "generated-ZIO",
              "name": "ZIO",
              "description": "",
              "members": [],
              "display_name": "ZIO",
              "created_at": "2026-01-23T05:51:29.049Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/ZIO?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "zio",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-23T05:51:29.049Z",
            "created_at": "2026-01-23T05:51:29.049Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-ZIO#683",
              "status": "open",
              "type": "issue",
              "number": 683,
              "title": "Port BSON Support to ZIO Schema 2",
              "source": {
                "data": {
                  "id": "source-ZIO#683",
                  "user": {
                    "login": "jdegoes",
                    "id": 156745,
                    "node_id": "MDQ6VXNlcjE1Njc0NQ==",
                    "avatar_url": "https://avatars.githubusercontent.com/u/156745?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/jdegoes",
                    "html_url": "https://github.com/jdegoes",
                    "followers_url": "https://api.github.com/users/jdegoes/followers",
                    "following_url": "https://api.github.com/users/jdegoes/following{/other_user}",
                    "gists_url": "https://api.github.com/users/jdegoes/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/jdegoes/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/jdegoes/subscriptions",
                    "organizations_url": "https://api.github.com/users/jdegoes/orgs",
                    "repos_url": "https://api.github.com/users/jdegoes/repos",
                    "events_url": "https://api.github.com/users/jdegoes/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/jdegoes/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Port BSON Support to ZIO Schema 2",
                  "body": "In a separate top-level project (schema-bson), port the [old ZIO Schema BSON support](https://github.com/zio/zio-schema/tree/main/zio-schema-bson/src) to ZIO Schema 2.\n\nMust have at least as many tests as the old version, with any known bugs in the implementation identified and fixed.",
                  "html_url": "https://github.com/zio/zio-blocks/issues/683"
                },
                "type": "github"
              },
              "hash": "zio/zio-blocks#683",
              "body": "In a separate top-level project (schema-bson), port the [old ZIO Schema BSON support](https://github.com/zio/zio-schema/tree/main/zio-schema-bson/src) to ZIO Schema 2.\n\nMust have at least as many tests as the old version, with any known bugs in the implementation identified and fixed.",
              "url": "https://github.com/zio/zio-blocks/issues/683",
              "tech": [],
              "repo_name": "zio-blocks",
              "repo_owner": "zio",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "ZIO#682",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "ZIO",
              "id": "generated-ZIO",
              "name": "ZIO",
              "description": "",
              "members": [],
              "display_name": "ZIO",
              "created_at": "2026-01-23T05:51:29.296Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/ZIO?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "zio",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-23T05:51:29.296Z",
            "created_at": "2026-01-23T05:51:29.296Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-ZIO#682",
              "status": "open",
              "type": "issue",
              "number": 682,
              "title": "Port Message Pack Support to ZIO Schema 2",
              "source": {
                "data": {
                  "id": "source-ZIO#682",
                  "user": {
                    "login": "jdegoes",
                    "id": 156745,
                    "node_id": "MDQ6VXNlcjE1Njc0NQ==",
                    "avatar_url": "https://avatars.githubusercontent.com/u/156745?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/jdegoes",
                    "html_url": "https://github.com/jdegoes",
                    "followers_url": "https://api.github.com/users/jdegoes/followers",
                    "following_url": "https://api.github.com/users/jdegoes/following{/other_user}",
                    "gists_url": "https://api.github.com/users/jdegoes/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/jdegoes/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/jdegoes/subscriptions",
                    "organizations_url": "https://api.github.com/users/jdegoes/orgs",
                    "repos_url": "https://api.github.com/users/jdegoes/repos",
                    "events_url": "https://api.github.com/users/jdegoes/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/jdegoes/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Port Message Pack Support to ZIO Schema 2",
                  "body": "In a separate top-level project (schema-messagepack), port the [old ZIO Schema Message Pack support](https://github.com/zio/zio-schema/tree/main/zio-schema-msg-pack/src) to ZIO Schema 2.\n\nMust have at least as many tests as the old version, with any known bugs in the implementation identified and fixed.",
                  "html_url": "https://github.com/zio/zio-blocks/issues/682"
                },
                "type": "github"
              },
              "hash": "zio/zio-blocks#682",
              "body": "In a separate top-level project (schema-messagepack), port the [old ZIO Schema Message Pack support](https://github.com/zio/zio-schema/tree/main/zio-schema-msg-pack/src) to ZIO Schema 2.\n\nMust have at least as many tests as the old version, with any known bugs in the implementation identified and fixed.",
              "url": "https://github.com/zio/zio-blocks/issues/682",
              "tech": [],
              "repo_name": "zio-blocks",
              "repo_owner": "zio",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "ZIO#681",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "ZIO",
              "id": "generated-ZIO",
              "name": "ZIO",
              "description": "",
              "members": [],
              "display_name": "ZIO",
              "created_at": "2026-01-23T05:51:29.420Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/ZIO?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "zio",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-23T05:51:29.420Z",
            "created_at": "2026-01-23T05:51:29.420Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-ZIO#681",
              "status": "open",
              "type": "issue",
              "number": 681,
              "title": "Port Thrift Support to ZIO Schema 2",
              "source": {
                "data": {
                  "id": "source-ZIO#681",
                  "user": {
                    "login": "jdegoes",
                    "id": 156745,
                    "node_id": "MDQ6VXNlcjE1Njc0NQ==",
                    "avatar_url": "https://avatars.githubusercontent.com/u/156745?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/jdegoes",
                    "html_url": "https://github.com/jdegoes",
                    "followers_url": "https://api.github.com/users/jdegoes/followers",
                    "following_url": "https://api.github.com/users/jdegoes/following{/other_user}",
                    "gists_url": "https://api.github.com/users/jdegoes/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/jdegoes/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/jdegoes/subscriptions",
                    "organizations_url": "https://api.github.com/users/jdegoes/orgs",
                    "repos_url": "https://api.github.com/users/jdegoes/repos",
                    "events_url": "https://api.github.com/users/jdegoes/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/jdegoes/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Port Thrift Support to ZIO Schema 2",
                  "body": "In a separate top-level project (schema-thrift), port the [old ZIO Schema Thrift support](https://github.com/zio/zio-schema/tree/main/zio-schema-thrift/src) to ZIO Schema 2.\n\nMust have at least as many tests as the old version, with any known bugs in the implementation identified and fixed.",
                  "html_url": "https://github.com/zio/zio-blocks/issues/681"
                },
                "type": "github"
              },
              "hash": "zio/zio-blocks#681",
              "body": "In a separate top-level project (schema-thrift), port the [old ZIO Schema Thrift support](https://github.com/zio/zio-schema/tree/main/zio-schema-thrift/src) to ZIO Schema 2.\n\nMust have at least as many tests as the old version, with any known bugs in the implementation identified and fixed.",
              "url": "https://github.com/zio/zio-blocks/issues/681",
              "tech": [],
              "repo_name": "zio-blocks",
              "repo_owner": "zio",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "ZIO#519",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "ZIO",
              "id": "generated-ZIO",
              "name": "ZIO",
              "description": "",
              "members": [],
              "display_name": "ZIO",
              "created_at": "2026-01-23T05:51:29.555Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/ZIO?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "zio",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-23T05:51:29.555Z",
            "created_at": "2026-01-23T05:51:29.555Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-ZIO#519",
              "status": "open",
              "type": "issue",
              "number": 519,
              "title": "Schema Migration System for ZIO Schema 2",
              "source": {
                "data": {
                  "id": "source-ZIO#519",
                  "user": {
                    "login": "jdegoes",
                    "id": 156745,
                    "node_id": "MDQ6VXNlcjE1Njc0NQ==",
                    "avatar_url": "https://avatars.githubusercontent.com/u/156745?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/jdegoes",
                    "html_url": "https://github.com/jdegoes",
                    "followers_url": "https://api.github.com/users/jdegoes/followers",
                    "following_url": "https://api.github.com/users/jdegoes/following{/other_user}",
                    "gists_url": "https://api.github.com/users/jdegoes/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/jdegoes/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/jdegoes/subscriptions",
                    "organizations_url": "https://api.github.com/users/jdegoes/orgs",
                    "repos_url": "https://api.github.com/users/jdegoes/repos",
                    "events_url": "https://api.github.com/users/jdegoes/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/jdegoes/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Schema Migration System for ZIO Schema 2",
                  "body": "## Overview\n\nImplement a **pure, algebraic migration system** for ZIO Schema 2 that represents **structural transformations between schema versions** as first-class, serializable data.\n\nA migration describes how to transform data from one schema version to another, enabling:\n\n* schema evolution\n* backward / forward compatibility\n* data versioning\n* offline migrations (JSON, SQL, data lakes, registries, etc.)\n\nThe system provides a **typed, macro-validated user API** (`Migration[A, B]`) built on a **pure, serializable core** (`DynamicMigration`) that operates on `DynamicValue`. \n\nThe ADT is fully introspectable and can be used to generate DDL, etc.\n\n## Motivation & Big Picture\n\n### Why structural types?\n\nWhen evolving schemas over time, **older versions of data types should not require runtime representations**.\n\nIn this design:\n\n* **Current versions** are represented by real case classes / enums\n* **Past versions** are represented using:\n\n  * **structural types** for records\n  * **abstract types + intersection types** for sum types\n\nThese types:\n\n* exist **only at compile time**\n* have **no runtime representation**\n* introduce **zero runtime overhead**\n* do **not require optics or instances to be kept around**\n\nThis allows you to describe arbitrarily old versions of data *without polluting your runtime or codebase*.\n\n#### Typical Workflow\n\nA typical workflow looks like:\n\n1. You have a current type:\n\n   ```scala\n   @schema\n   case class Person(name: String, age: Int)\n   ```\n\n2. You derive and copy its structural shape:\n\n   ```scala\n   type PersonV1 = { def name: String; def age: Int }\n   ```\n\n3. You evolve the real type:\n\n   ```scala\n   @schema\n   case class Person(fullName: String, age: Int, country: String)\n   ```\n\n4. You keep only:\n\n   * the **current** runtime type\n   * the **structural type** for the old version\n   * a **pure migration** between them\n\nNo old case classes. No old optics. No runtime baggage.\n\nNote there is no requirement that the \"current\" type actually be a real case class, enum, etc.--so you can work purely with structural types, allowing you to define migrations for data types that are never materialized as runtime structures.\n\n---\n\n### Why pure data migrations?\n\nMigrations are represented entirely as **pure data**:\n\n* no user functions\n* no closures\n* no reflection\n* no runtime code generation\n\nAs a result:\n\n* migrations can be **serialized**\n* stored in **registries**\n* applied **dynamically**\n* inspected and transformed\n* used to generate:\n\n  * upgraders\n  * downgraders\n  * SQL DDL / DML\n  * offline data transforms\n\nWhile code generation is **out of scope for this ticket**, this explains many design decisions (invertibility, path-based actions, no functions).\n\n---\n\n## Core Architecture\n\n### Type Hierarchy\n\n```scala\n// Typed migration (user-facing API)\ncase class Migration[A, B](\n  dynamicMigration: DynamicMigration,\n  sourceSchema: Schema[A], // These are structural schemas!!!\n  targetSchema: Schema[B] // These are structural schemas!!!\n) {\n  /** Apply migration to transform A to B */\n  def apply(value: A): Either[MigrationError, B]\n\n  /** Compose migrations sequentially */\n  def ++[C](that: Migration[B, C]): Migration[A, C]\n\n  /** Alias for ++ */\n  def andThen[C](that: Migration[B, C]): Migration[A, C] = this ++ that\n\n  /** Reverse migration (structural inverse; runtime is best-effort) */\n  def reverse: Migration[B, A]\n}\n```\n\n```scala\n// Untyped migration (pure data, fully serializable)\ncase class DynamicMigration(\n  actions: Vector[MigrationAction]\n) {\n  def apply(value: DynamicValue): Either[MigrationError, DynamicValue]\n  def ++(that: DynamicMigration): DynamicMigration\n  def reverse: DynamicMigration\n}\n```\n\n* `Migration[A, B]` is introspectable, but not pure data due to bindings inside schemas\n* `DynamicMigration` is **fully serializable**\n\n---\n\n## User-Facing API: Selector Expressions\n\n### Selectors, not optics\n\nThe user-facing API **does not expose optics**.\n\nInstead, all locations are specified using **selector expressions**:\n\n```scala\nS => A\n```\n\nExamples:\n\n```scala\n_.name\n_.address.street\n_.addresses.each.streetNumber\n_.country.when[UK]\n```\n\nTo see the syntax, one can look at the `optic` macro, which utilizes the same selector syntax for optic creation (e.g. `optic(_.address.street)`, etc.).\n\n### Macro extraction\n\nAll builder methods that accept selectors are **implemented via macros** (or via a macro-generated type class such as `ToDynamicOptic`).\n\nThe macro:\n\n1. Inspects the selector expression\n2. Validates it is a supported projection\n3. Converts it into a `DynamicOptic`\n4. Stores that optic in the migration action\n\nSupported projections include:\n\n* field access (`_.foo.bar`)\n* case selection (`_.country.when[UK]`)\n* collection traversal (`_.items.each`)\n* (future) key access, wrappers, etc.\n\n`DynamicOptic` is **never exposed publicly**.\n\n---\n\n## Migration Builder\n\nAll selector-accepting methods are implemented via macros. For simplicity, these are shown as functions (e.g. `A => Any`), but this is NOT the way to implement them. Either all these functions need to be macros, or a macro needs to be used to generate an implicit / given at each call site. Macros may do additional validation to constrain the validity of these different types of transformations.\n\n```scala\nclass MigrationBuilder[A, B](\n  sourceSchema: Schema[A],\n  targetSchema: Schema[B],\n  actions: Vector[MigrationAction]\n) {\n\n  // ----- Record operations -----\n\n  def addField(\n    target: B => Any,\n    default: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  def dropField(\n    source: A => Any,\n    defaultForReverse: SchemaExpr[B, ?] = SchemaExpr.DefaultValue\n  ): MigrationBuilder[A, B]\n\n  def renameField(\n    from: A => Any,\n    to: B => Any\n  ): MigrationBuilder[A, B]\n\n  def transformField(\n    from: A => Any,\n    to: B => Any,\n    transform: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  def mandateField(\n    source: A => Option[?],\n    target: B => Any,\n    default: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  def optionalizeField(\n    source: A => Any,\n    target: B => Option[?]\n  ): MigrationBuilder[A, B]\n\n  def changeFieldType(\n    source: A => Any,\n    target: B => Any,\n    converter: SchemaExpr[A, ?]  // primitive-to-primitive only\n  ): MigrationBuilder[A, B]\n\n  // ----- Enum operations (limited) -----\n\n  def renameCase[SumA, SumB](\n    from: String,\n    to: String\n  ): MigrationBuilder[A, B]\n\n  def transformCase[SumA, CaseA, SumB, CaseB](\n    caseMigration: MigrationBuilder[CaseA, CaseB] => MigrationBuilder[CaseA, CaseB]\n  ): MigrationBuilder[A, B]\n\n  // ----- Collections -----\n\n  def transformElements(\n    at: A => Vector[?],\n    transform: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  // ----- Maps -----\n\n  def transformKeys(\n    at: A => Map[?, ?],\n    transform: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  def transformValues(\n    at: A => Map[?, ?],\n    transform: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  /** Build migration with full macro validation */\n  def build: Migration[A, B]\n\n  /** Build migration without full validation */\n  def buildPartial: Migration[A, B]\n}\n```\n\n---\n\n## Migration Actions (Untyped Core)\n\nAll actions operate at a **path**, represented by `DynamicOptic`.\n\n```scala\nsealed trait MigrationAction {\n  def at: DynamicOptic\n  def reverse: MigrationAction\n}\n```\n\n### Record Actions\n\n```scala\ncase class AddField(\n  at: DynamicOptic,\n  default: SchemaExpr[?]\n) extends MigrationAction\n\ncase class DropField(\n  at: DynamicOptic,\n  defaultForReverse: SchemaExpr[?]\n) extends MigrationAction\n\ncase class Rename(\n  at: DynamicOptic,\n  to: String\n) extends MigrationAction\n\ncase class TransformValue(\n  at: DynamicOptic,\n  transform: SchemaExpr[?]\n) extends MigrationAction\n\ncase class Mandate(\n  at: DynamicOptic,\n  default: SchemaExpr[?]\n) extends MigrationAction\n\ncase class Optionalize(\n  at: DynamicOptic\n) extends MigrationAction\n\ncase class Join(\n  at: DynamicOptic,\n  sourcePaths: Vector[DynamicOptic],\n  combiner: SchemaExpr[?]\n) extends MigrationAction\n\ncase class Split(\n  at: DynamicOptic,\n  targetPaths: Vector[DynamicOptic],\n  splitter: SchemaExpr[?]\n) extends MigrationAction\n\ncase class ChangeType(\n  at: DynamicOptic,\n  converter: SchemaExpr[?]\n) extends MigrationAction\n```\n\n---\n\n### Enum Actions (Supported)\n\n```scala\ncase class RenameCase(\n  at: DynamicOptic,\n  from: String,\n  to: String\n) extends MigrationAction\n\ncase class TransformCase(\n  at: DynamicOptic,\n  actions: Vector[MigrationAction]\n) extends MigrationAction\n```\n\n> Enum case addition / removal is **out of scope** for this ticket\n> (requires composite value construction).\n\n---\n\n### Collection / Map Actions\n\n```scala\ncase class TransformElements(\n  at: DynamicOptic,\n  transform: SchemaExpr[?]\n) extends MigrationAction\n\ncase class TransformKeys(\n  at: DynamicOptic,\n  transform: SchemaExpr[?]\n) extends MigrationAction\n\ncase class TransformValues(\n  at: DynamicOptic,\n  transform: SchemaExpr[?]\n) extends MigrationAction\n```\n\n---\n\n## SchemaExpr Integration\n\n* Used for all value-level transformations\n* **Constraints for this ticket**:\n\n  * primitive → primitive only\n  * joins / splits must produce primitives\n  * no record / enum construction\n\n### `SchemaExpr.DefaultValue`\n\nA special expression that:\n\n1. uses the macro-captured field schema\n2. calls `schema.defaultValue`\n3. converts the value to `DynamicValue`\n4. is stored for reverse migrations\n\n---\n\n## Type Modeling\n\n### Records (Structural Types)\n\n```scala\ntype PersonV0 = { val firstName: String; val lastName: String }\ntype PersonV1 = { val fullName: String; val age: Int }\n\nimplicit val v0Schema: Schema[PersonV0] = Schema.structural[PersonV0]\nimplicit val v1Schema: Schema[PersonV1] = Schema.structural[PersonV1]\n```\n\n---\n\n### Enums (Union of Structural Types with Tags)\n\nEnums are encoded into structural types by using union types, together with singleton types (string literals, which represent the name of the case of the enum).\n\nIn structural types, the names of the type aliases shown below are not relevant, nor are they used.\n\n```scala\ntype OldCreditCard =\n  { type Tag = \"CreditCard\"; def number: String; def exp: String }\ntype OldWireTransfer =\n  { type Tag = \"WireTransfer\"; def account: String; def routing: String }\ntype OldPaymentMethod = OldCreditCard | OldWireTransfer\n```\n\nMacros extract:\n\n* refinement type → structure of the case\n* type `Tag` with singleton type → case tag\n\n---\n\n## Laws\n\n### Identity\n\n```scala\nMigration.identity[A].apply(a) == Right(a)\n```\n\n### Associativity\n\n```scala\n(m1 ++ m2) ++ m3 == m1 ++ (m2 ++ m3)\n```\n\n### Structural Reverse\n\n```scala\nm.reverse.reverse == m\n```\n\n### Best-Effort Semantic Inverse\n\n```scala\nm.apply(a) == Right(b) ⇒ m.reverse.apply(b) == Right(a)\n```\n\n(when sufficient information exists)\n\n---\n\n## Error Handling\n\n* All runtime errors return `MigrationError`\n* Errors must capture **path information** (`DynamicOptic`)\n* Enables diagnostics such as:\n\n> “Failed to apply TransformValue at `.addresses.each.streetNumber`”\n\n---\n\n## Example\n\n```scala\ntype PersonV0 = { val firstName: String; val lastName: String }\n\n@schema\ncase class Person(fullName: String, age: Int)\n\nval migration =\n  Migration.newBuilder[PersonV0, Person]\n    .addField(_.age, 0)\n    .build\n\nval old =\n  new { val firstName = \"John\"; val lastName = \"Doe\" }\n\nmigration(old)\n// Right(Person(\"John Doe\", 0))\n```\n\n---\n\n## Success Criteria\n\n* [ ] `DynamicMigration` fully serializable\n* [ ] `Migration[A, B]` wraps schemas and actions\n* [ ] All actions path-based via `DynamicOptic`\n* [ ] User API uses selector functions (`S => A`) for \"optics\" on old and new types\n* [ ] Macro validation in `.build` to confirm \"old\" has been migrated to \"new\"\n* [ ] `.buildPartial` supported\n* [ ] Structural reverse implemented\n* [ ] Identity & associativity laws hold\n* [ ] Enum rename / transform supported\n* [ ] Errors include path information\n* [ ] Comprehensive tests\n* [ ] Scala 2.13 and Scala 3.5+ supported\n",
                  "html_url": "https://github.com/zio/zio-blocks/issues/519"
                },
                "type": "github"
              },
              "hash": "zio/zio-blocks#519",
              "body": "## Overview\n\nImplement a **pure, algebraic migration system** for ZIO Schema 2 that represents **structural transformations between schema versions** as first-class, serializable data.\n\nA migration describes how to transform data from one schema version to another, enabling:\n\n* schema evolution\n* backward / forward compatibility\n* data versioning\n* offline migrations (JSON, SQL, data lakes, registries, etc.)\n\nThe system provides a **typed, macro-validated user API** (`Migration[A, B]`) built on a **pure, serializable core** (`DynamicMigration`) that operates on `DynamicValue`. \n\nThe ADT is fully introspectable and can be used to generate DDL, etc.\n\n## Motivation & Big Picture\n\n### Why structural types?\n\nWhen evolving schemas over time, **older versions of data types should not require runtime representations**.\n\nIn this design:\n\n* **Current versions** are represented by real case classes / enums\n* **Past versions** are represented using:\n\n  * **structural types** for records\n  * **abstract types + intersection types** for sum types\n\nThese types:\n\n* exist **only at compile time**\n* have **no runtime representation**\n* introduce **zero runtime overhead**\n* do **not require optics or instances to be kept around**\n\nThis allows you to describe arbitrarily old versions of data *without polluting your runtime or codebase*.\n\n#### Typical Workflow\n\nA typical workflow looks like:\n\n1. You have a current type:\n\n   ```scala\n   @schema\n   case class Person(name: String, age: Int)\n   ```\n\n2. You derive and copy its structural shape:\n\n   ```scala\n   type PersonV1 = { def name: String; def age: Int }\n   ```\n\n3. You evolve the real type:\n\n   ```scala\n   @schema\n   case class Person(fullName: String, age: Int, country: String)\n   ```\n\n4. You keep only:\n\n   * the **current** runtime type\n   * the **structural type** for the old version\n   * a **pure migration** between them\n\nNo old case classes. No old optics. No runtime baggage.\n\nNote there is no requirement that the \"current\" type actually be a real case class, enum, etc.--so you can work purely with structural types, allowing you to define migrations for data types that are never materialized as runtime structures.\n\n---\n\n### Why pure data migrations?\n\nMigrations are represented entirely as **pure data**:\n\n* no user functions\n* no closures\n* no reflection\n* no runtime code generation\n\nAs a result:\n\n* migrations can be **serialized**\n* stored in **registries**\n* applied **dynamically**\n* inspected and transformed\n* used to generate:\n\n  * upgraders\n  * downgraders\n  * SQL DDL / DML\n  * offline data transforms\n\nWhile code generation is **out of scope for this ticket**, this explains many design decisions (invertibility, path-based actions, no functions).\n\n---\n\n## Core Architecture\n\n### Type Hierarchy\n\n```scala\n// Typed migration (user-facing API)\ncase class Migration[A, B](\n  dynamicMigration: DynamicMigration,\n  sourceSchema: Schema[A], // These are structural schemas!!!\n  targetSchema: Schema[B] // These are structural schemas!!!\n) {\n  /** Apply migration to transform A to B */\n  def apply(value: A): Either[MigrationError, B]\n\n  /** Compose migrations sequentially */\n  def ++[C](that: Migration[B, C]): Migration[A, C]\n\n  /** Alias for ++ */\n  def andThen[C](that: Migration[B, C]): Migration[A, C] = this ++ that\n\n  /** Reverse migration (structural inverse; runtime is best-effort) */\n  def reverse: Migration[B, A]\n}\n```\n\n```scala\n// Untyped migration (pure data, fully serializable)\ncase class DynamicMigration(\n  actions: Vector[MigrationAction]\n) {\n  def apply(value: DynamicValue): Either[MigrationError, DynamicValue]\n  def ++(that: DynamicMigration): DynamicMigration\n  def reverse: DynamicMigration\n}\n```\n\n* `Migration[A, B]` is introspectable, but not pure data due to bindings inside schemas\n* `DynamicMigration` is **fully serializable**\n\n---\n\n## User-Facing API: Selector Expressions\n\n### Selectors, not optics\n\nThe user-facing API **does not expose optics**.\n\nInstead, all locations are specified using **selector expressions**:\n\n```scala\nS => A\n```\n\nExamples:\n\n```scala\n_.name\n_.address.street\n_.addresses.each.streetNumber\n_.country.when[UK]\n```\n\nTo see the syntax, one can look at the `optic` macro, which utilizes the same selector syntax for optic creation (e.g. `optic(_.address.street)`, etc.).\n\n### Macro extraction\n\nAll builder methods that accept selectors are **implemented via macros** (or via a macro-generated type class such as `ToDynamicOptic`).\n\nThe macro:\n\n1. Inspects the selector expression\n2. Validates it is a supported projection\n3. Converts it into a `DynamicOptic`\n4. Stores that optic in the migration action\n\nSupported projections include:\n\n* field access (`_.foo.bar`)\n* case selection (`_.country.when[UK]`)\n* collection traversal (`_.items.each`)\n* (future) key access, wrappers, etc.\n\n`DynamicOptic` is **never exposed publicly**.\n\n---\n\n## Migration Builder\n\nAll selector-accepting methods are implemented via macros. For simplicity, these are shown as functions (e.g. `A => Any`), but this is NOT the way to implement them. Either all these functions need to be macros, or a macro needs to be used to generate an implicit / given at each call site. Macros may do additional validation to constrain the validity of these different types of transformations.\n\n```scala\nclass MigrationBuilder[A, B](\n  sourceSchema: Schema[A],\n  targetSchema: Schema[B],\n  actions: Vector[MigrationAction]\n) {\n\n  // ----- Record operations -----\n\n  def addField(\n    target: B => Any,\n    default: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  def dropField(\n    source: A => Any,\n    defaultForReverse: SchemaExpr[B, ?] = SchemaExpr.DefaultValue\n  ): MigrationBuilder[A, B]\n\n  def renameField(\n    from: A => Any,\n    to: B => Any\n  ): MigrationBuilder[A, B]\n\n  def transformField(\n    from: A => Any,\n    to: B => Any,\n    transform: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  def mandateField(\n    source: A => Option[?],\n    target: B => Any,\n    default: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  def optionalizeField(\n    source: A => Any,\n    target: B => Option[?]\n  ): MigrationBuilder[A, B]\n\n  def changeFieldType(\n    source: A => Any,\n    target: B => Any,\n    converter: SchemaExpr[A, ?]  // primitive-to-primitive only\n  ): MigrationBuilder[A, B]\n\n  // ----- Enum operations (limited) -----\n\n  def renameCase[SumA, SumB](\n    from: String,\n    to: String\n  ): MigrationBuilder[A, B]\n\n  def transformCase[SumA, CaseA, SumB, CaseB](\n    caseMigration: MigrationBuilder[CaseA, CaseB] => MigrationBuilder[CaseA, CaseB]\n  ): MigrationBuilder[A, B]\n\n  // ----- Collections -----\n\n  def transformElements(\n    at: A => Vector[?],\n    transform: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  // ----- Maps -----\n\n  def transformKeys(\n    at: A => Map[?, ?],\n    transform: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  def transformValues(\n    at: A => Map[?, ?],\n    transform: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  /** Build migration with full macro validation */\n  def build: Migration[A, B]\n\n  /** Build migration without full validation */\n  def buildPartial: Migration[A, B]\n}\n```\n\n---\n\n## Migration Actions (Untyped Core)\n\nAll actions operate at a **path**, represented by `DynamicOptic`.\n\n```scala\nsealed trait MigrationAction {\n  def at: DynamicOptic\n  def reverse: MigrationAction\n}\n```\n\n### Record Actions\n\n```scala\ncase class AddField(\n  at: DynamicOptic,\n  default: SchemaExpr[?]\n) extends MigrationAction\n\ncase class DropField(\n  at: DynamicOptic,\n  defaultForReverse: SchemaExpr[?]\n) extends MigrationAction\n\ncase class Rename(\n  at: DynamicOptic,\n  to: String\n) extends MigrationAction\n\ncase class TransformValue(\n  at: DynamicOptic,\n  transform: SchemaExpr[?]\n) extends MigrationAction\n\ncase class Mandate(\n  at: DynamicOptic,\n  default: SchemaExpr[?]\n) extends MigrationAction\n\ncase class Optionalize(\n  at: DynamicOptic\n) extends MigrationAction\n\ncase class Join(\n  at: DynamicOptic,\n  sourcePaths: Vector[DynamicOptic],\n  combiner: SchemaExpr[?]\n) extends MigrationAction\n\ncase class Split(\n  at: DynamicOptic,\n  targetPaths: Vector[DynamicOptic],\n  splitter: SchemaExpr[?]\n) extends MigrationAction\n\ncase class ChangeType(\n  at: DynamicOptic,\n  converter: SchemaExpr[?]\n) extends MigrationAction\n```\n\n---\n\n### Enum Actions (Supported)\n\n```scala\ncase class RenameCase(\n  at: DynamicOptic,\n  from: String,\n  to: String\n) extends MigrationAction\n\ncase class TransformCase(\n  at: DynamicOptic,\n  actions: Vector[MigrationAction]\n) extends MigrationAction\n```\n\n> Enum case addition / removal is **out of scope** for this ticket\n> (requires composite value construction).\n\n---\n\n### Collection / Map Actions\n\n```scala\ncase class TransformElements(\n  at: DynamicOptic,\n  transform: SchemaExpr[?]\n) extends MigrationAction\n\ncase class TransformKeys(\n  at: DynamicOptic,\n  transform: SchemaExpr[?]\n) extends MigrationAction\n\ncase class TransformValues(\n  at: DynamicOptic,\n  transform: SchemaExpr[?]\n) extends MigrationAction\n```\n\n---\n\n## SchemaExpr Integration\n\n* Used for all value-level transformations\n* **Constraints for this ticket**:\n\n  * primitive → primitive only\n  * joins / splits must produce primitives\n  * no record / enum construction\n\n### `SchemaExpr.DefaultValue`\n\nA special expression that:\n\n1. uses the macro-captured field schema\n2. calls `schema.defaultValue`\n3. converts the value to `DynamicValue`\n4. is stored for reverse migrations\n\n---\n\n## Type Modeling\n\n### Records (Structural Types)\n\n```scala\ntype PersonV0 = { val firstName: String; val lastName: String }\ntype PersonV1 = { val fullName: String; val age: Int }\n\nimplicit val v0Schema: Schema[PersonV0] = Schema.structural[PersonV0]\nimplicit val v1Schema: Schema[PersonV1] = Schema.structural[PersonV1]\n```\n\n---\n\n### Enums (Union of Structural Types with Tags)\n\nEnums are encoded into structural types by using union types, together with singleton types (string literals, which represent the name of the case of the enum).\n\nIn structural types, the names of the type aliases shown below are not relevant, nor are they used.\n\n```scala\ntype OldCreditCard =\n  { type Tag = \"CreditCard\"; def number: String; def exp: String }\ntype OldWireTransfer =\n  { type Tag = \"WireTransfer\"; def account: String; def routing: String }\ntype OldPaymentMethod = OldCreditCard | OldWireTransfer\n```\n\nMacros extract:\n\n* refinement type → structure of the case\n* type `Tag` with singleton type → case tag\n\n---\n\n## Laws\n\n### Identity\n\n```scala\nMigration.identity[A].apply(a) == Right(a)\n```\n\n### Associativity\n\n```scala\n(m1 ++ m2) ++ m3 == m1 ++ (m2 ++ m3)\n```\n\n### Structural Reverse\n\n```scala\nm.reverse.reverse == m\n```\n\n### Best-Effort Semantic Inverse\n\n```scala\nm.apply(a) == Right(b) ⇒ m.reverse.apply(b) == Right(a)\n```\n\n(when sufficient information exists)\n\n---\n\n## Error Handling\n\n* All runtime errors return `MigrationError`\n* Errors must capture **path information** (`DynamicOptic`)\n* Enables diagnostics such as:\n\n> “Failed to apply TransformValue at `.addresses.each.streetNumber`”\n\n---\n\n## Example\n\n```scala\ntype PersonV0 = { val firstName: String; val lastName: String }\n\n@schema\ncase class Person(fullName: String, age: Int)\n\nval migration =\n  Migration.newBuilder[PersonV0, Person]\n    .addField(_.age, 0)\n    .build\n\nval old =\n  new { val firstName = \"John\"; val lastName = \"Doe\" }\n\nmigration(old)\n// Right(Person(\"John Doe\", 0))\n```\n\n---\n\n## Success Criteria\n\n* [ ] `DynamicMigration` fully serializable\n* [ ] `Migration[A, B]` wraps schemas and actions\n* [ ] All actions path-based via `DynamicOptic`\n* [ ] User API uses selector functions (`S => A`) for \"optics\" on old and new types\n* [ ] Macro validation in `.build` to confirm \"old\" has been migrated to \"new\"\n* [ ] `.buildPartial` supported\n* [ ] Structural reverse implemented\n* [ ] Identity & associativity laws hold\n* [ ] Enum rename / transform supported\n* [ ] Errors include path information\n* [ ] Comprehensive tests\n* [ ] Scala 2.13 and Scala 3.5+ supported\n",
              "url": "https://github.com/zio/zio-blocks/issues/519",
              "tech": [],
              "repo_name": "zio-blocks",
              "repo_owner": "zio",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "ZIO#517",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "ZIO",
              "id": "generated-ZIO",
              "name": "ZIO",
              "description": "",
              "members": [],
              "display_name": "ZIO",
              "created_at": "2026-01-23T05:51:29.624Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/ZIO?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "zio",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-23T05:51:29.624Z",
            "created_at": "2026-01-23T05:51:29.624Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-ZIO#517",
              "status": "open",
              "type": "issue",
              "number": 517,
              "title": "Add structural schemas",
              "source": {
                "data": {
                  "id": "source-ZIO#517",
                  "user": {
                    "login": "jdegoes",
                    "id": 156745,
                    "node_id": "MDQ6VXNlcjE1Njc0NQ==",
                    "avatar_url": "https://avatars.githubusercontent.com/u/156745?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/jdegoes",
                    "html_url": "https://github.com/jdegoes",
                    "followers_url": "https://api.github.com/users/jdegoes/followers",
                    "following_url": "https://api.github.com/users/jdegoes/following{/other_user}",
                    "gists_url": "https://api.github.com/users/jdegoes/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/jdegoes/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/jdegoes/subscriptions",
                    "organizations_url": "https://api.github.com/users/jdegoes/orgs",
                    "repos_url": "https://api.github.com/users/jdegoes/repos",
                    "events_url": "https://api.github.com/users/jdegoes/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/jdegoes/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Add structural schemas",
                  "body": "# Structural Type Schema Support\n\n## Overview\n\nExtend `Schema[A]` to support structural types, enabling schema derivation for types defined by their structure rather than their nominal identity. This allows for duck-typed schema validation and conversion between nominal and structural representations.\n\n## Core Concepts\n\n### Direct Structural Schema Derivation\n\nSchemas can be derived directly for structural types:\n\n```scala\n// Scala 3\ntype Person = { def name: String; def age: Int }\nval schema = Schema.derived[Person]\n\n// Scala 2\ntype Person = { def name: String; def age: Int }\nval schema = Schema.derived[Person]\n```\n\n**Note**: Both Scala 2 and Scala 3 use `def` for uniformity, even though Scala 3 supports `val` in structural types.\n\n**Implementation**: Schemas have bindings, which allow construction / deconstruction of values. Values for structural types are backed by:\n- **Scala 3**: `Selectable` \n- **Scala 2**: `Dynamic`\n\n### Nominal to Structural Conversion\n\nConvert nominal type schemas to their structural equivalents:\n\n```scala\ncase class Person(name: String, age: Int)\n\n// Get the structural schema corresponding to Person's shape\nval structuralSchema: Schema[{ def name: String; def age: Int }] = \n  Schema.derived[Person].structural\n```\n\n### Schema API Extension\n\n```scala\ncase class Schema[A](/* existing fields */) {\n  /**\n   * Convert this schema to a structural type schema.\n   * \n   * The structural type represents the \"shape\" of A without its nominal identity.\n   * This enables duck typing and structural validation.\n   * \n   * @param toStructural Macro-generated conversion to structural representation\n   * @return Schema for the structural type corresponding to A\n   */\n  def structural(implicit toStructural: ToStructural[A]): Schema[toStructural.StructuralType] = \n    toStructural.apply(this)\n}\n\n/**\n * Type class for converting nominal schemas to structural schemas.\n * Generated by macro for all supported types. Macro fails if a structural\n * type cannot be generated.\n *\n * NOTE: This approach has to be tested to yield inferrable types, and revised\n * if necessary. Inferrable types (from calling Schema#structural) are a must-have.\n */\ntrait ToStructural[A] {\n  type StructuralType\n  def apply(schema: Schema[A]): Schema[StructuralType]\n}\n\nobject ToStructural {\n  type Aux[A, S] = ToStructural[A] { type StructuralType = S }\n  \n  // Scala 3\n  transparent inline given [A]: ToStructural[A] = ${toStructuralMacro[A]}\n  \n  // Scala 2\n  implicit def materialize[A]: ToStructural[A] = macro toStructuralImpl[A]\n}\n```\n\n---\n\n## Examples\n\n### 1. Simple Product Types\n\n#### Case Class to Structural\n\n```scala\n// Both Scala 2 and Scala 3\ncase class Person(name: String, age: Int)\n\n// Original nominal schema\nval nominalSchema: Schema[Person] = Schema.derived[Person]\n\n// Convert to structural\nval structuralSchema: Schema[{ def name: String; def age: Int }] = \n  nominalSchema.structural\n\n// Direct structural derivation (equivalent)\nval directStructural: Schema[{ def name: String; def age: Int }] = \n  Schema.derived[{ def name: String; def age: Int }]\n```\n\n### 2. Nested Structures\n\n```scala\ncase class Address(street: String, city: String, zip: Int)\ncase class Person(name: String, age: Int, address: Address)\n\nval structuralSchema = Schema.derived[Person].structural\n// Type: Schema[{ \n//   def name: String\n//   def age: Int\n//   def address: { def street: String; def city: String; def zip: Int }\n// }]\n```\n\n### 3. Collections and Options\n\n```scala\ncase class Team(name: String, members: List[String], leader: Option[String])\n\nval structuralSchema = Schema.derived[Team].structural\n// Type: Schema[{\n//   def name: String\n//   def members: List[String]\n//   def leader: Option[String]\n// }]\n```\n\n### 4. Tuples to Structural\n\n```scala\n// Tuples can be converted to structural types\nval tupleSchema: Schema[(String, Int, Boolean)] = Schema.derived[(String, Int, Boolean)]\n\nval structuralSchema = tupleSchema.structural\n// Type: Schema[{ def _1: String; def _2: Int; def _3: Boolean }]\n```\n\n### 5. Sum Types (Sealed Traits) - Scala 3 Only\n\nSealed traits become union types of structural representations, with tag information stored at the type level:\n\n```scala\n// Scala 3 only\nsealed trait Result\ncase class Success(value: Int) extends Result\ncase class Failure(error: String) extends Result\n\nval structuralSchema = Schema.derived[Result].structural\n// Type: Schema[\n//   { type Tag = \"Success\"; def value: Int } | { type Tag = \"Failure\"; def error: String }\n// ]\n```\n\n**Note**: Sum type to structural conversion is **not supported in Scala 2** because it requires union types. Attempting to call `.structural` on a sealed trait schema in Scala 2 will result in a compile-time error.\n\n### 6. Enums (Scala 3 Only)\n\n```scala\nenum Status:\n  case Active, Inactive, Suspended\n\nval structuralSchema = Schema.derived[Status].structural\n// Type: Schema[{type Tag = \"Active\"} | {type Tag = \"Inactive\"} | {type Tag = \"Suspended\"}]\n```\n\n### 7. Opaque Types (Scala 3)\n\n```scala\nopaque type UserId = String\nobject UserId:\n  def apply(value: String): Either[String, UserId] = \n    if value.nonEmpty then Right(value) else Left(\"Empty user ID\")\n\ncase class User(id: UserId, name: String)\n\nval structuralSchema = Schema.derived[User].structural\n// Type: Schema[{ def id: String; def name: String }]\n// Opaque type is unwrapped to its underlying type\n```\n\n### 8. Bidirectional Conversion\n\nStructural schemas work seamlessly with `Into`/`As` (if this ticket is implemented **after** that ticket):\n\n```scala\ncase class Person(name: String, age: Int)\n\nval structuralSchema = Schema.derived[Person].structural\n\n// Create structural value (Scala 3)\nval structuralPerson = new Selectable {\n  def selectDynamic(field: String): Any = field match {\n    case \"name\" => \"Alice\"\n    case \"age\" => 30\n  }\n}\n\n// Convert structural to nominal using Into\nval person: Either[SchemaError, Person] = \n  Into[{ def name: String; def age: Int }, Person].into(structuralPerson)\n// => Right(Person(\"Alice\", 30))\n\n// Convert nominal to structural\nval backToStructural: Either[SchemaError, { def name: String; def age: Int }] = \n  Into[Person, { def name: String; def age: Int }].into(Person(\"Bob\", 25))\n```\n\n### 9. Empty and Single-Field Products\n\n```scala\n// Empty case class\ncase class Empty()\nval emptyStructural = Schema.derived[Empty].structural\n// Type: Schema[{}]\n\n// Single field\ncase class Id(value: String)\nval idStructural = Schema.derived[Id].structural\n// Type: Schema[{ def value: String }]\n```\n\n### 10. Large Products\n\n```scala\ncase class LargeRecord(\n  f1: String, f2: Int, f3: Boolean, f4: Double, f5: Long,\n  f6: String, f7: Int, f8: Boolean, f9: Double, f10: Long,\n  f11: String, f12: Int, f13: Boolean, f14: Double, f15: Long,\n  f16: String, f17: Int, f18: Boolean, f19: Double, f20: Long,\n  f21: String\n)\n\nval structuralSchema = Schema.derived[LargeRecord].structural\n// Type: Schema[{\n//   def f1: String; def f2: Int; def f3: Boolean; ...\n//   def f21: String\n// }]\n```\n\n---\n\n## Type Name Handling\n\n### Current Limitation\n\nSchemas currently use `TypeName[A]` to identify types. Structural types don't have meaningful nominal type names, which creates a mismatch.\n\n### Temporary Solution\n\nUntil `TypeName[A]` is replaced with `TypeId[A]` (see issue #471), structural schemas will use a normalized string representation of the structural type as a fake type name:\n\n```scala\ncase class Person(name: String, age: Int)\n\nval schema = Schema.derived[Person]\nschema.typeName // => TypeName for \"Person\"\n\nval structural = schema.structural\nstructural.typeName // => TypeName for \"{age:Int,name:String}\"\n// Normalized: fields sorted alphabetically, types fully qualified\n```\n\n### Normalization Rules\n\n1. **Field ordering**: Alphabetical by field name\n2. **Type qualification**: Use simple names for primitives and standard library types\n3. **Whitespace**: No whitespace in generated names\n4. **Collections**: Standard notation (e.g., `List[Int]`)\n5. **Options**: Explicit `Option[T]` notation\n6. **Nested structures**: Recursive application of rules\n7. **Deterministic**: Same structure always produces same normalized name\n\n### Examples\n\n```scala\n// Simple product\ncase class Point(x: Int, y: Int)\nSchema.derived[Point].structural.typeName \n// => \"{x:Int,y:Int}\"\n\n// Nested product\ncase class Address(street: String, zip: Int)\ncase class Person(name: String, address: Address)\nSchema.derived[Person].structural.typeName\n// => \"{address:{street:String,zip:Int},name:String}\"\n\n// With collections\ncase class Team(name: String, members: List[String])\nSchema.derived[Team].structural.typeName\n// => \"{members:List[String],name:String}\"\n\n// Union type (Scala 3)\nsealed trait Result\ncase class Success(value: Int) extends Result\ncase class Failure(error: String) extends Result\nSchema.derived[Result].structural.typeName\n// => \"{error:String}|{value:Int}\"\n```\n\n### Future: TypeId[A]\n\nThe upcoming `TypeId[A]` replacement will properly handle structural types by representing them by their structure rather than a string-based hack. See issue #471 for details.\n\n---\n\n## Limitations and Edge Cases\n\n### 1. Generic Types\n\n**Behavior depends on existing Schema derivation support for generic types.**\n\nIf `Schema.derived[Container[Int]]` already works, then structural conversion should work:\n\n```scala\ncase class Container[T](value: T)\n\n// If this works:\nval schema = Schema.derived[Container[Int]]\n\n// Then this should work:\nval structural = schema.structural\n// Type: Schema[{ def value: Int }]\n```\n\nIf generic type derivation is not currently supported, this ticket **does not require implementing it**. The macro should produce a clear compile-time error for unsupported generic types.\n\n### 2. Recursive Types\n\nRecursive types will **fail at compile-time** because Scala does not support infinite types:\n\n```scala\ncase class Tree(value: Int, children: List[Tree])\n\n// This will FAIL at compile-time:\nval structural = Schema.derived[Tree].structural\n// Compile error: Cannot generate infinite structural type\n\n// The structural type would need to be:\n// { def value: Int; def children: List[{ def value: Int; def children: List[...] }] }\n// which is infinite and unsupported\n```\n\nThe macro must detect recursive types and produce a helpful error message:\n\n```\nCompile error: Cannot generate structural type for recursive type Tree.\nStructural types cannot represent recursive structures.\n```\n\n### 3. Mutually Recursive Types\n\nSimilarly, mutually recursive types are unsupported:\n\n```scala\ncase class Node(id: Int, edges: List[Edge])\ncase class Edge(from: Int, to: Node)\n\n// This will FAIL at compile-time:\nval nodeStructural = Schema.derived[Node].structural\n// Compile error: Cannot generate structural type for mutually recursive types\n```\n\n### 4. Sum Types in Scala 2\n\nSealed traits and sum types **cannot be converted to structural types in Scala 2** because they require union types:\n\n```scala\n// Scala 2\nsealed trait Result\ncase class Success(value: Int) extends Result\ncase class Failure(error: String) extends Result\n\n// This will FAIL at compile-time in Scala 2:\nval structural = Schema.derived[Result].structural\n// Compile error: Cannot generate structural type for sum types in Scala 2.\n// Union types are required, which are only available in Scala 3.\n```\n\nThe macro must detect sum types in Scala 2 and produce a clear error.\n\n### 5. Case Objects\n\nCase objects become empty structural types:\n\n```scala\ncase object Singleton\n\nval structural = Schema.derived[Singleton.type].structural\n// Type: Schema[{}]\n```\n\nFor sum types with case objects (Scala 3):\n\n```scala\nsealed trait Status\ncase object Active extends Status\ncase object Inactive extends Status\n\nval structural = Schema.derived[Status].structural\n// Type: Schema[{} | {}]\n// Not particularly useful, but valid\n```\n\n### 6. Structural Types as Source\n\nDeriving schemas directly for structural types is supported:\n\n```scala\ntype PersonStructure = { def name: String; def age: Int }\n\nval schema = Schema.derived[PersonStructure]\n// Should work if structural type derivation is implemented\n```\n\nThe schema's bindings will use `Selectable` (Scala 3) or `Dynamic` (Scala 2) to construct and deconstruct values.\n\n---\n\n## Integration with Into/As\n\nStructural schemas compose naturally with `Into`/`As` conversions.\n\n### Nominal → Structural\n\n```scala\ncase class Person(name: String, age: Int)\n\n// Auto-derived conversion\nval nominalToStructural: Into[Person, { def name: String; def age: Int }] = \n  Into.derived\n\nval person = Person(\"Alice\", 30)\nval structural = nominalToStructural.into(person)\n// => Right(<Selectable/Dynamic instance>)\n```\n\n### Structural → Nominal\n\n```scala\ntype PersonStructure = { def name: String; def age: Int }\ncase class Person(name: String, age: Int)\n\n// Auto-derived conversion\nval structuralToNominal: Into[PersonStructure, Person] = \n  Into.derived\n\nval structural: PersonStructure = new Selectable {\n  def selectDynamic(field: String): Any = field match {\n    case \"name\" => \"Bob\"\n    case \"age\" => 25\n  }\n}\n\nval person = structuralToNominal.into(structural)\n// => Right(Person(\"Bob\", 25))\n```\n\n### Bidirectional (As)\n\n```scala\ncase class Person(name: String, age: Int)\n\n// Bidirectional conversion\nval personAs: As[Person, { def name: String; def age: Int }] = \n  As.derived\n\n// Nominal → Structural\nval structural = personAs.into(Person(\"Alice\", 30))\n\n// Structural → Nominal\nval nominal = structural.flatMap(personAs.from)\n// Round-trip successful\n```\n\n### Schema-Guided Conversion\n\n```scala\ncase class PersonV1(firstName: String, lastName: String, age: Int)\ncase class PersonV2(name: String, age: Int)\n\n// Use structural type as intermediary\ntype PersonStructure = { def name: String; def age: Int }\n\n// Step 1: Transform V1 to structural (custom logic)\nval v1ToStructural: Into[PersonV1, PersonStructure] = \n  new Into[PersonV1, PersonStructure] {\n    def into(v1: PersonV1): Either[SchemaError, PersonStructure] = {\n      Right(new Selectable {\n        def selectDynamic(field: String): Any = field match {\n          case \"name\" => s\"${v1.firstName} ${v1.lastName}\"\n          case \"age\" => v1.age\n        }\n      })\n    }\n  }\n\n// Step 2: Auto-convert structural to V2\nval structuralToV2: Into[PersonStructure, PersonV2] = Into.derived\n\n// Composed migration\ndef migrate(v1: PersonV1): Either[SchemaError, PersonV2] = {\n  v1ToStructural.into(v1).flatMap(structuralToV2.into)\n}\n```\n\n---\n\n## Testing Requirements\n\n### Test Matrix\n\n1. **Direct Structural Derivation**\n   - Simple products (case classes)\n   - Nested products\n   - Collections (List, Vector, Set, Map, Option, Either)\n   - Tuples (2-22 elements)\n   - Empty case classes\n   - Single-field case classes\n   - Large products (20+ fields)\n   - Case objects\n\n2. **Nominal to Structural Conversion**\n   - Case class → structural\n   - Tuple → structural\n   - Nested case classes → nested structural\n   - Case class with collections → structural with collections\n   - Empty case class → empty structural\n\n3. **Sum Types (Scala 3 Only)**\n   - Sealed trait → union type structural\n   - Sealed trait with case objects\n   - Enum → union type structural\n   - Nested sum types\n\n4. **Type Name Generation**\n   - Simple product normalized name\n   - Nested product normalized name\n   - Name determinism (same structure = same name)\n   - Alphabetical field ordering in names\n   - Union type names (Scala 3)\n\n5. **Selectable/Dynamic Implementation**\n   - Scala 3 Selectable field access\n   - Scala 2 Dynamic field access\n   - Field access correctness\n   - Missing field behavior\n   - Extra field behavior\n\n6. **Integration with Into/As**\n   - Nominal → Structural via Into\n   - Structural → Nominal via Into\n   - Round-trip via As\n   - Composed conversions with structural intermediary\n\n7. **Error Cases (Compile-Time)**\n   - Recursive types produce error\n   - Mutually recursive types produce error\n   - Sum types in Scala 2 produce error\n   - Unsupported types produce helpful errors\n\n8. **Generic Types** (if supported by existing Schema derivation)\n   - Fully applied generic → structural\n   - Generic with nested structural fields\n\n### Scala 2 vs Scala 3 Test Separation\n\n```\nsrc/test/scala/\n  structural/\n    common/\n      SimpleProductSpec.scala\n      NestedProductSpec.scala\n      CollectionsSpec.scala\n      TuplesSpec.scala\n      EmptyProductSpec.scala\n      SingleFieldSpec.scala\n      LargeProductSpec.scala\n      TypeNameNormalizationSpec.scala\n      IntoIntegrationSpec.scala\n      AsIntegrationSpec.scala\n      \n    scala3/\n      UnionTypesSpec.scala\n      SealedTraitToUnionSpec.scala\n      EnumToUnionSpec.scala\n      SelectableImplementationSpec.scala\n      \n    scala2/\n      DynamicImplementationSpec.scala\n      SumTypeErrorSpec.scala (verifies compile error)\n      \n    errors/\n      RecursiveTypeErrorSpec.scala\n      MutualRecursionErrorSpec.scala\n      UnsupportedTypeErrorSpec.scala\n```\n\n### Test Examples\n\n```scala\n// Test: Simple product to structural\ntest(\"case class converts to structural schema\") {\n  case class Person(name: String, age: Int)\n  \n  val structural = Schema.derived[Person].structural\n  \n  // Type check (this is a compile-time test)\n  val _: Schema[{ def name: String; def age: Int }] = structural\n  \n  assert(structural.typeName.toString.contains(\"name\"))\n  assert(structural.typeName.toString.contains(\"age\"))\n}\n\n// Test: Nested products\ntest(\"nested case classes convert to nested structural\") {\n  case class Address(street: String, zip: Int)\n  case class Person(name: String, address: Address)\n  \n  val structural = Schema.derived[Person].structural\n  \n  val _: Schema[{ \n    def name: String\n    def address: { def street: String; def zip: Int }\n  }] = structural\n}\n\n// Test: Tuple to structural\ntest(\"tuple converts to structural with _N fields\") {\n  val structural = Schema.derived[(String, Int, Boolean)].structural\n  \n  val _: Schema[{ def _1: String; def _2: Int; def _3: Boolean }] = structural\n}\n\n// Test: Union type (Scala 3 only)\ntest(\"sealed trait converts to union type structural\") {\n  sealed trait Result\n  case class Success(value: Int) extends Result\n  case class Failure(error: String) extends Result\n  \n  val structural = Schema.derived[Result].structural\n  \n  val _: Schema[{ def value: Int } | { def error: String }] = structural\n}\n\n// Test: Type name normalization\ntest(\"structural type names are normalized and deterministic\") {\n  case class Person(name: String, age: Int)\n  case class User(age: Int, name: String) // Different field order\n  \n  val personStructural = Schema.derived[Person].structural\n  val userStructural = Schema.derived[User].structural\n  \n  // Same structure, same normalized name\n  assert(personStructural.typeName == userStructural.typeName)\n  \n  // Alphabetical ordering\n  assert(personStructural.typeName.toString.contains(\"age\"))\n  assert(personStructural.typeName.toString.indexOf(\"age\") < \n         personStructural.typeName.toString.indexOf(\"name\"))\n}\n\n// Test: Integration with Into\ntest(\"structural to nominal conversion via Into\") {\n  case class Person(name: String, age: Int)\n  type PersonStructure = { def name: String; def age: Int }\n  \n  val structural: PersonStructure = new Selectable {\n    def selectDynamic(field: String): Any = field match {\n      case \"name\" => \"Alice\"\n      case \"age\" => 30\n    }\n  }\n  \n  val person = Into[PersonStructure, Person].into(structural)\n  assert(person == Right(Person(\"Alice\", 30)))\n}\n\n// Test: Round-trip via As\ntest(\"nominal to structural and back preserves data\") {\n  case class Person(name: String, age: Int)\n  type PersonStructure = { def name: String; def age: Int }\n  \n  val original = Person(\"Alice\", 30)\n  \n  val toStructural = As[Person, PersonStructure].into(original)\n  val backToNominal = toStructural.flatMap(As[Person, PersonStructure].from)\n  \n  assert(backToNominal == Right(original))\n}\n\n// Test: Recursive type compile error\ntest(\"recursive types produce compile error\") {\n  case class Tree(value: Int, children: List[Tree])\n  \n  assertDoesNotCompile(\"Schema.derived[Tree].structural\")\n}\n\n// Test: Sum type in Scala 2 compile error\ntest(\"sum types in Scala 2 produce compile error\") {\n  sealed trait Result\n  case class Success(value: Int) extends Result\n  \n  // Scala 2 only\n  assertDoesNotCompile(\"Schema.derived[Result].structural\")\n}\n```\n\n---\n\n## Implementation Notes\n\n### Macro Behavior\n\nThe macro must:\n\n1. **Detect product types** (case classes, tuples) and generate structural types with `def` members\n2. **Detect sum types** (sealed traits, enums) and:\n   - In Scala 3: Generate union types of structural representations\n   - In Scala 2: Fail with clear error message\n3. **Detect recursive types** and fail with clear error message\n4. **Normalize structural type representations** for type name generation\n5. **Generate `ToStructural` instance** with:\n   - `StructuralType` type member set to the generated structural type\n   - `apply` method that transforms the schema appropriately\n6. **Preserve field metadata** from original schema where applicable\n7. **Generate appropriate bindings** using `Selectable` (Scala 3) or `Dynamic` (Scala 2)\n\n### Schema Transformation\n\nWhen converting `Schema[A]` to `Schema[StructuralType]`:\n\n1. **Preserve field information**: Field names, types, optional/required status\n2. **Update type name**: Use normalized structural representation\n3. **Transform bindings**: Replace nominal constructors/deconstructors with structural equivalents\n4. **Preserve validation**: Maintain any validation logic that applies to field values\n5. **Handle nested schemas**: Recursively transform nested product types\n\n### Error Messages\n\nProvide clear compile-time errors:\n\n```scala\n// Recursive type\ncase class Tree(value: Int, children: List[Tree])\nSchema.derived[Tree].structural\n\n// Error:\n\"\"\"\nCannot generate structural type for recursive type Tree.\nStructural types cannot represent recursive structures.\nScala's type system does not support infinite types.\n\"\"\"\n\n// Sum type in Scala 2\nsealed trait Result\ncase class Success(value: Int) extends Result\nSchema.derived[Result].structural\n\n// Error (Scala 2 only):\n\"\"\"\nCannot generate structural type for sum type Result.\nStructural representation of sum types requires union types,\nwhich are only available in Scala 3.\nConsider upgrading to Scala 3 or using a different approach.\n\"\"\"\n```\n\n---\n\n## Deliverables\n\n1. ✅ `ToStructural[A]` trait and macro for Scala 2.13\n2. ✅ `ToStructural[A]` trait and macro for Scala 3.5\n3. ✅ `structural` method on `Schema[A]`\n4. ✅ Support for product types (case classes, tuples)\n5. ✅ Support for sum types (sealed traits, enums) in Scala 3 only\n6. ✅ Normalized type name generation\n7. ✅ `Selectable` bindings (Scala 3) and `Dynamic` bindings (Scala 2)\n8. ✅ Integration with `Into`/`As` for structural ↔ nominal conversions\n9. ✅ Comprehensive test suite (300+ test cases)\n10. ✅ Clear error messages for unsupported cases\n11. ✅ Documentation with examples",
                  "html_url": "https://github.com/zio/zio-blocks/issues/517"
                },
                "type": "github"
              },
              "hash": "zio/zio-blocks#517",
              "body": "# Structural Type Schema Support\n\n## Overview\n\nExtend `Schema[A]` to support structural types, enabling schema derivation for types defined by their structure rather than their nominal identity. This allows for duck-typed schema validation and conversion between nominal and structural representations.\n\n## Core Concepts\n\n### Direct Structural Schema Derivation\n\nSchemas can be derived directly for structural types:\n\n```scala\n// Scala 3\ntype Person = { def name: String; def age: Int }\nval schema = Schema.derived[Person]\n\n// Scala 2\ntype Person = { def name: String; def age: Int }\nval schema = Schema.derived[Person]\n```\n\n**Note**: Both Scala 2 and Scala 3 use `def` for uniformity, even though Scala 3 supports `val` in structural types.\n\n**Implementation**: Schemas have bindings, which allow construction / deconstruction of values. Values for structural types are backed by:\n- **Scala 3**: `Selectable` \n- **Scala 2**: `Dynamic`\n\n### Nominal to Structural Conversion\n\nConvert nominal type schemas to their structural equivalents:\n\n```scala\ncase class Person(name: String, age: Int)\n\n// Get the structural schema corresponding to Person's shape\nval structuralSchema: Schema[{ def name: String; def age: Int }] = \n  Schema.derived[Person].structural\n```\n\n### Schema API Extension\n\n```scala\ncase class Schema[A](/* existing fields */) {\n  /**\n   * Convert this schema to a structural type schema.\n   * \n   * The structural type represents the \"shape\" of A without its nominal identity.\n   * This enables duck typing and structural validation.\n   * \n   * @param toStructural Macro-generated conversion to structural representation\n   * @return Schema for the structural type corresponding to A\n   */\n  def structural(implicit toStructural: ToStructural[A]): Schema[toStructural.StructuralType] = \n    toStructural.apply(this)\n}\n\n/**\n * Type class for converting nominal schemas to structural schemas.\n * Generated by macro for all supported types. Macro fails if a structural\n * type cannot be generated.\n *\n * NOTE: This approach has to be tested to yield inferrable types, and revised\n * if necessary. Inferrable types (from calling Schema#structural) are a must-have.\n */\ntrait ToStructural[A] {\n  type StructuralType\n  def apply(schema: Schema[A]): Schema[StructuralType]\n}\n\nobject ToStructural {\n  type Aux[A, S] = ToStructural[A] { type StructuralType = S }\n  \n  // Scala 3\n  transparent inline given [A]: ToStructural[A] = ${toStructuralMacro[A]}\n  \n  // Scala 2\n  implicit def materialize[A]: ToStructural[A] = macro toStructuralImpl[A]\n}\n```\n\n---\n\n## Examples\n\n### 1. Simple Product Types\n\n#### Case Class to Structural\n\n```scala\n// Both Scala 2 and Scala 3\ncase class Person(name: String, age: Int)\n\n// Original nominal schema\nval nominalSchema: Schema[Person] = Schema.derived[Person]\n\n// Convert to structural\nval structuralSchema: Schema[{ def name: String; def age: Int }] = \n  nominalSchema.structural\n\n// Direct structural derivation (equivalent)\nval directStructural: Schema[{ def name: String; def age: Int }] = \n  Schema.derived[{ def name: String; def age: Int }]\n```\n\n### 2. Nested Structures\n\n```scala\ncase class Address(street: String, city: String, zip: Int)\ncase class Person(name: String, age: Int, address: Address)\n\nval structuralSchema = Schema.derived[Person].structural\n// Type: Schema[{ \n//   def name: String\n//   def age: Int\n//   def address: { def street: String; def city: String; def zip: Int }\n// }]\n```\n\n### 3. Collections and Options\n\n```scala\ncase class Team(name: String, members: List[String], leader: Option[String])\n\nval structuralSchema = Schema.derived[Team].structural\n// Type: Schema[{\n//   def name: String\n//   def members: List[String]\n//   def leader: Option[String]\n// }]\n```\n\n### 4. Tuples to Structural\n\n```scala\n// Tuples can be converted to structural types\nval tupleSchema: Schema[(String, Int, Boolean)] = Schema.derived[(String, Int, Boolean)]\n\nval structuralSchema = tupleSchema.structural\n// Type: Schema[{ def _1: String; def _2: Int; def _3: Boolean }]\n```\n\n### 5. Sum Types (Sealed Traits) - Scala 3 Only\n\nSealed traits become union types of structural representations, with tag information stored at the type level:\n\n```scala\n// Scala 3 only\nsealed trait Result\ncase class Success(value: Int) extends Result\ncase class Failure(error: String) extends Result\n\nval structuralSchema = Schema.derived[Result].structural\n// Type: Schema[\n//   { type Tag = \"Success\"; def value: Int } | { type Tag = \"Failure\"; def error: String }\n// ]\n```\n\n**Note**: Sum type to structural conversion is **not supported in Scala 2** because it requires union types. Attempting to call `.structural` on a sealed trait schema in Scala 2 will result in a compile-time error.\n\n### 6. Enums (Scala 3 Only)\n\n```scala\nenum Status:\n  case Active, Inactive, Suspended\n\nval structuralSchema = Schema.derived[Status].structural\n// Type: Schema[{type Tag = \"Active\"} | {type Tag = \"Inactive\"} | {type Tag = \"Suspended\"}]\n```\n\n### 7. Opaque Types (Scala 3)\n\n```scala\nopaque type UserId = String\nobject UserId:\n  def apply(value: String): Either[String, UserId] = \n    if value.nonEmpty then Right(value) else Left(\"Empty user ID\")\n\ncase class User(id: UserId, name: String)\n\nval structuralSchema = Schema.derived[User].structural\n// Type: Schema[{ def id: String; def name: String }]\n// Opaque type is unwrapped to its underlying type\n```\n\n### 8. Bidirectional Conversion\n\nStructural schemas work seamlessly with `Into`/`As` (if this ticket is implemented **after** that ticket):\n\n```scala\ncase class Person(name: String, age: Int)\n\nval structuralSchema = Schema.derived[Person].structural\n\n// Create structural value (Scala 3)\nval structuralPerson = new Selectable {\n  def selectDynamic(field: String): Any = field match {\n    case \"name\" => \"Alice\"\n    case \"age\" => 30\n  }\n}\n\n// Convert structural to nominal using Into\nval person: Either[SchemaError, Person] = \n  Into[{ def name: String; def age: Int }, Person].into(structuralPerson)\n// => Right(Person(\"Alice\", 30))\n\n// Convert nominal to structural\nval backToStructural: Either[SchemaError, { def name: String; def age: Int }] = \n  Into[Person, { def name: String; def age: Int }].into(Person(\"Bob\", 25))\n```\n\n### 9. Empty and Single-Field Products\n\n```scala\n// Empty case class\ncase class Empty()\nval emptyStructural = Schema.derived[Empty].structural\n// Type: Schema[{}]\n\n// Single field\ncase class Id(value: String)\nval idStructural = Schema.derived[Id].structural\n// Type: Schema[{ def value: String }]\n```\n\n### 10. Large Products\n\n```scala\ncase class LargeRecord(\n  f1: String, f2: Int, f3: Boolean, f4: Double, f5: Long,\n  f6: String, f7: Int, f8: Boolean, f9: Double, f10: Long,\n  f11: String, f12: Int, f13: Boolean, f14: Double, f15: Long,\n  f16: String, f17: Int, f18: Boolean, f19: Double, f20: Long,\n  f21: String\n)\n\nval structuralSchema = Schema.derived[LargeRecord].structural\n// Type: Schema[{\n//   def f1: String; def f2: Int; def f3: Boolean; ...\n//   def f21: String\n// }]\n```\n\n---\n\n## Type Name Handling\n\n### Current Limitation\n\nSchemas currently use `TypeName[A]` to identify types. Structural types don't have meaningful nominal type names, which creates a mismatch.\n\n### Temporary Solution\n\nUntil `TypeName[A]` is replaced with `TypeId[A]` (see issue #471), structural schemas will use a normalized string representation of the structural type as a fake type name:\n\n```scala\ncase class Person(name: String, age: Int)\n\nval schema = Schema.derived[Person]\nschema.typeName // => TypeName for \"Person\"\n\nval structural = schema.structural\nstructural.typeName // => TypeName for \"{age:Int,name:String}\"\n// Normalized: fields sorted alphabetically, types fully qualified\n```\n\n### Normalization Rules\n\n1. **Field ordering**: Alphabetical by field name\n2. **Type qualification**: Use simple names for primitives and standard library types\n3. **Whitespace**: No whitespace in generated names\n4. **Collections**: Standard notation (e.g., `List[Int]`)\n5. **Options**: Explicit `Option[T]` notation\n6. **Nested structures**: Recursive application of rules\n7. **Deterministic**: Same structure always produces same normalized name\n\n### Examples\n\n```scala\n// Simple product\ncase class Point(x: Int, y: Int)\nSchema.derived[Point].structural.typeName \n// => \"{x:Int,y:Int}\"\n\n// Nested product\ncase class Address(street: String, zip: Int)\ncase class Person(name: String, address: Address)\nSchema.derived[Person].structural.typeName\n// => \"{address:{street:String,zip:Int},name:String}\"\n\n// With collections\ncase class Team(name: String, members: List[String])\nSchema.derived[Team].structural.typeName\n// => \"{members:List[String],name:String}\"\n\n// Union type (Scala 3)\nsealed trait Result\ncase class Success(value: Int) extends Result\ncase class Failure(error: String) extends Result\nSchema.derived[Result].structural.typeName\n// => \"{error:String}|{value:Int}\"\n```\n\n### Future: TypeId[A]\n\nThe upcoming `TypeId[A]` replacement will properly handle structural types by representing them by their structure rather than a string-based hack. See issue #471 for details.\n\n---\n\n## Limitations and Edge Cases\n\n### 1. Generic Types\n\n**Behavior depends on existing Schema derivation support for generic types.**\n\nIf `Schema.derived[Container[Int]]` already works, then structural conversion should work:\n\n```scala\ncase class Container[T](value: T)\n\n// If this works:\nval schema = Schema.derived[Container[Int]]\n\n// Then this should work:\nval structural = schema.structural\n// Type: Schema[{ def value: Int }]\n```\n\nIf generic type derivation is not currently supported, this ticket **does not require implementing it**. The macro should produce a clear compile-time error for unsupported generic types.\n\n### 2. Recursive Types\n\nRecursive types will **fail at compile-time** because Scala does not support infinite types:\n\n```scala\ncase class Tree(value: Int, children: List[Tree])\n\n// This will FAIL at compile-time:\nval structural = Schema.derived[Tree].structural\n// Compile error: Cannot generate infinite structural type\n\n// The structural type would need to be:\n// { def value: Int; def children: List[{ def value: Int; def children: List[...] }] }\n// which is infinite and unsupported\n```\n\nThe macro must detect recursive types and produce a helpful error message:\n\n```\nCompile error: Cannot generate structural type for recursive type Tree.\nStructural types cannot represent recursive structures.\n```\n\n### 3. Mutually Recursive Types\n\nSimilarly, mutually recursive types are unsupported:\n\n```scala\ncase class Node(id: Int, edges: List[Edge])\ncase class Edge(from: Int, to: Node)\n\n// This will FAIL at compile-time:\nval nodeStructural = Schema.derived[Node].structural\n// Compile error: Cannot generate structural type for mutually recursive types\n```\n\n### 4. Sum Types in Scala 2\n\nSealed traits and sum types **cannot be converted to structural types in Scala 2** because they require union types:\n\n```scala\n// Scala 2\nsealed trait Result\ncase class Success(value: Int) extends Result\ncase class Failure(error: String) extends Result\n\n// This will FAIL at compile-time in Scala 2:\nval structural = Schema.derived[Result].structural\n// Compile error: Cannot generate structural type for sum types in Scala 2.\n// Union types are required, which are only available in Scala 3.\n```\n\nThe macro must detect sum types in Scala 2 and produce a clear error.\n\n### 5. Case Objects\n\nCase objects become empty structural types:\n\n```scala\ncase object Singleton\n\nval structural = Schema.derived[Singleton.type].structural\n// Type: Schema[{}]\n```\n\nFor sum types with case objects (Scala 3):\n\n```scala\nsealed trait Status\ncase object Active extends Status\ncase object Inactive extends Status\n\nval structural = Schema.derived[Status].structural\n// Type: Schema[{} | {}]\n// Not particularly useful, but valid\n```\n\n### 6. Structural Types as Source\n\nDeriving schemas directly for structural types is supported:\n\n```scala\ntype PersonStructure = { def name: String; def age: Int }\n\nval schema = Schema.derived[PersonStructure]\n// Should work if structural type derivation is implemented\n```\n\nThe schema's bindings will use `Selectable` (Scala 3) or `Dynamic` (Scala 2) to construct and deconstruct values.\n\n---\n\n## Integration with Into/As\n\nStructural schemas compose naturally with `Into`/`As` conversions.\n\n### Nominal → Structural\n\n```scala\ncase class Person(name: String, age: Int)\n\n// Auto-derived conversion\nval nominalToStructural: Into[Person, { def name: String; def age: Int }] = \n  Into.derived\n\nval person = Person(\"Alice\", 30)\nval structural = nominalToStructural.into(person)\n// => Right(<Selectable/Dynamic instance>)\n```\n\n### Structural → Nominal\n\n```scala\ntype PersonStructure = { def name: String; def age: Int }\ncase class Person(name: String, age: Int)\n\n// Auto-derived conversion\nval structuralToNominal: Into[PersonStructure, Person] = \n  Into.derived\n\nval structural: PersonStructure = new Selectable {\n  def selectDynamic(field: String): Any = field match {\n    case \"name\" => \"Bob\"\n    case \"age\" => 25\n  }\n}\n\nval person = structuralToNominal.into(structural)\n// => Right(Person(\"Bob\", 25))\n```\n\n### Bidirectional (As)\n\n```scala\ncase class Person(name: String, age: Int)\n\n// Bidirectional conversion\nval personAs: As[Person, { def name: String; def age: Int }] = \n  As.derived\n\n// Nominal → Structural\nval structural = personAs.into(Person(\"Alice\", 30))\n\n// Structural → Nominal\nval nominal = structural.flatMap(personAs.from)\n// Round-trip successful\n```\n\n### Schema-Guided Conversion\n\n```scala\ncase class PersonV1(firstName: String, lastName: String, age: Int)\ncase class PersonV2(name: String, age: Int)\n\n// Use structural type as intermediary\ntype PersonStructure = { def name: String; def age: Int }\n\n// Step 1: Transform V1 to structural (custom logic)\nval v1ToStructural: Into[PersonV1, PersonStructure] = \n  new Into[PersonV1, PersonStructure] {\n    def into(v1: PersonV1): Either[SchemaError, PersonStructure] = {\n      Right(new Selectable {\n        def selectDynamic(field: String): Any = field match {\n          case \"name\" => s\"${v1.firstName} ${v1.lastName}\"\n          case \"age\" => v1.age\n        }\n      })\n    }\n  }\n\n// Step 2: Auto-convert structural to V2\nval structuralToV2: Into[PersonStructure, PersonV2] = Into.derived\n\n// Composed migration\ndef migrate(v1: PersonV1): Either[SchemaError, PersonV2] = {\n  v1ToStructural.into(v1).flatMap(structuralToV2.into)\n}\n```\n\n---\n\n## Testing Requirements\n\n### Test Matrix\n\n1. **Direct Structural Derivation**\n   - Simple products (case classes)\n   - Nested products\n   - Collections (List, Vector, Set, Map, Option, Either)\n   - Tuples (2-22 elements)\n   - Empty case classes\n   - Single-field case classes\n   - Large products (20+ fields)\n   - Case objects\n\n2. **Nominal to Structural Conversion**\n   - Case class → structural\n   - Tuple → structural\n   - Nested case classes → nested structural\n   - Case class with collections → structural with collections\n   - Empty case class → empty structural\n\n3. **Sum Types (Scala 3 Only)**\n   - Sealed trait → union type structural\n   - Sealed trait with case objects\n   - Enum → union type structural\n   - Nested sum types\n\n4. **Type Name Generation**\n   - Simple product normalized name\n   - Nested product normalized name\n   - Name determinism (same structure = same name)\n   - Alphabetical field ordering in names\n   - Union type names (Scala 3)\n\n5. **Selectable/Dynamic Implementation**\n   - Scala 3 Selectable field access\n   - Scala 2 Dynamic field access\n   - Field access correctness\n   - Missing field behavior\n   - Extra field behavior\n\n6. **Integration with Into/As**\n   - Nominal → Structural via Into\n   - Structural → Nominal via Into\n   - Round-trip via As\n   - Composed conversions with structural intermediary\n\n7. **Error Cases (Compile-Time)**\n   - Recursive types produce error\n   - Mutually recursive types produce error\n   - Sum types in Scala 2 produce error\n   - Unsupported types produce helpful errors\n\n8. **Generic Types** (if supported by existing Schema derivation)\n   - Fully applied generic → structural\n   - Generic with nested structural fields\n\n### Scala 2 vs Scala 3 Test Separation\n\n```\nsrc/test/scala/\n  structural/\n    common/\n      SimpleProductSpec.scala\n      NestedProductSpec.scala\n      CollectionsSpec.scala\n      TuplesSpec.scala\n      EmptyProductSpec.scala\n      SingleFieldSpec.scala\n      LargeProductSpec.scala\n      TypeNameNormalizationSpec.scala\n      IntoIntegrationSpec.scala\n      AsIntegrationSpec.scala\n      \n    scala3/\n      UnionTypesSpec.scala\n      SealedTraitToUnionSpec.scala\n      EnumToUnionSpec.scala\n      SelectableImplementationSpec.scala\n      \n    scala2/\n      DynamicImplementationSpec.scala\n      SumTypeErrorSpec.scala (verifies compile error)\n      \n    errors/\n      RecursiveTypeErrorSpec.scala\n      MutualRecursionErrorSpec.scala\n      UnsupportedTypeErrorSpec.scala\n```\n\n### Test Examples\n\n```scala\n// Test: Simple product to structural\ntest(\"case class converts to structural schema\") {\n  case class Person(name: String, age: Int)\n  \n  val structural = Schema.derived[Person].structural\n  \n  // Type check (this is a compile-time test)\n  val _: Schema[{ def name: String; def age: Int }] = structural\n  \n  assert(structural.typeName.toString.contains(\"name\"))\n  assert(structural.typeName.toString.contains(\"age\"))\n}\n\n// Test: Nested products\ntest(\"nested case classes convert to nested structural\") {\n  case class Address(street: String, zip: Int)\n  case class Person(name: String, address: Address)\n  \n  val structural = Schema.derived[Person].structural\n  \n  val _: Schema[{ \n    def name: String\n    def address: { def street: String; def zip: Int }\n  }] = structural\n}\n\n// Test: Tuple to structural\ntest(\"tuple converts to structural with _N fields\") {\n  val structural = Schema.derived[(String, Int, Boolean)].structural\n  \n  val _: Schema[{ def _1: String; def _2: Int; def _3: Boolean }] = structural\n}\n\n// Test: Union type (Scala 3 only)\ntest(\"sealed trait converts to union type structural\") {\n  sealed trait Result\n  case class Success(value: Int) extends Result\n  case class Failure(error: String) extends Result\n  \n  val structural = Schema.derived[Result].structural\n  \n  val _: Schema[{ def value: Int } | { def error: String }] = structural\n}\n\n// Test: Type name normalization\ntest(\"structural type names are normalized and deterministic\") {\n  case class Person(name: String, age: Int)\n  case class User(age: Int, name: String) // Different field order\n  \n  val personStructural = Schema.derived[Person].structural\n  val userStructural = Schema.derived[User].structural\n  \n  // Same structure, same normalized name\n  assert(personStructural.typeName == userStructural.typeName)\n  \n  // Alphabetical ordering\n  assert(personStructural.typeName.toString.contains(\"age\"))\n  assert(personStructural.typeName.toString.indexOf(\"age\") < \n         personStructural.typeName.toString.indexOf(\"name\"))\n}\n\n// Test: Integration with Into\ntest(\"structural to nominal conversion via Into\") {\n  case class Person(name: String, age: Int)\n  type PersonStructure = { def name: String; def age: Int }\n  \n  val structural: PersonStructure = new Selectable {\n    def selectDynamic(field: String): Any = field match {\n      case \"name\" => \"Alice\"\n      case \"age\" => 30\n    }\n  }\n  \n  val person = Into[PersonStructure, Person].into(structural)\n  assert(person == Right(Person(\"Alice\", 30)))\n}\n\n// Test: Round-trip via As\ntest(\"nominal to structural and back preserves data\") {\n  case class Person(name: String, age: Int)\n  type PersonStructure = { def name: String; def age: Int }\n  \n  val original = Person(\"Alice\", 30)\n  \n  val toStructural = As[Person, PersonStructure].into(original)\n  val backToNominal = toStructural.flatMap(As[Person, PersonStructure].from)\n  \n  assert(backToNominal == Right(original))\n}\n\n// Test: Recursive type compile error\ntest(\"recursive types produce compile error\") {\n  case class Tree(value: Int, children: List[Tree])\n  \n  assertDoesNotCompile(\"Schema.derived[Tree].structural\")\n}\n\n// Test: Sum type in Scala 2 compile error\ntest(\"sum types in Scala 2 produce compile error\") {\n  sealed trait Result\n  case class Success(value: Int) extends Result\n  \n  // Scala 2 only\n  assertDoesNotCompile(\"Schema.derived[Result].structural\")\n}\n```\n\n---\n\n## Implementation Notes\n\n### Macro Behavior\n\nThe macro must:\n\n1. **Detect product types** (case classes, tuples) and generate structural types with `def` members\n2. **Detect sum types** (sealed traits, enums) and:\n   - In Scala 3: Generate union types of structural representations\n   - In Scala 2: Fail with clear error message\n3. **Detect recursive types** and fail with clear error message\n4. **Normalize structural type representations** for type name generation\n5. **Generate `ToStructural` instance** with:\n   - `StructuralType` type member set to the generated structural type\n   - `apply` method that transforms the schema appropriately\n6. **Preserve field metadata** from original schema where applicable\n7. **Generate appropriate bindings** using `Selectable` (Scala 3) or `Dynamic` (Scala 2)\n\n### Schema Transformation\n\nWhen converting `Schema[A]` to `Schema[StructuralType]`:\n\n1. **Preserve field information**: Field names, types, optional/required status\n2. **Update type name**: Use normalized structural representation\n3. **Transform bindings**: Replace nominal constructors/deconstructors with structural equivalents\n4. **Preserve validation**: Maintain any validation logic that applies to field values\n5. **Handle nested schemas**: Recursively transform nested product types\n\n### Error Messages\n\nProvide clear compile-time errors:\n\n```scala\n// Recursive type\ncase class Tree(value: Int, children: List[Tree])\nSchema.derived[Tree].structural\n\n// Error:\n\"\"\"\nCannot generate structural type for recursive type Tree.\nStructural types cannot represent recursive structures.\nScala's type system does not support infinite types.\n\"\"\"\n\n// Sum type in Scala 2\nsealed trait Result\ncase class Success(value: Int) extends Result\nSchema.derived[Result].structural\n\n// Error (Scala 2 only):\n\"\"\"\nCannot generate structural type for sum type Result.\nStructural representation of sum types requires union types,\nwhich are only available in Scala 3.\nConsider upgrading to Scala 3 or using a different approach.\n\"\"\"\n```\n\n---\n\n## Deliverables\n\n1. ✅ `ToStructural[A]` trait and macro for Scala 2.13\n2. ✅ `ToStructural[A]` trait and macro for Scala 3.5\n3. ✅ `structural` method on `Schema[A]`\n4. ✅ Support for product types (case classes, tuples)\n5. ✅ Support for sum types (sealed traits, enums) in Scala 3 only\n6. ✅ Normalized type name generation\n7. ✅ `Selectable` bindings (Scala 3) and `Dynamic` bindings (Scala 2)\n8. ✅ Integration with `Into`/`As` for structural ↔ nominal conversions\n9. ✅ Comprehensive test suite (300+ test cases)\n10. ✅ Clear error messages for unsupported cases\n11. ✅ Documentation with examples",
              "url": "https://github.com/zio/zio-blocks/issues/517",
              "tech": [],
              "repo_name": "zio-blocks",
              "repo_owner": "zio",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "ZIO#471",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "ZIO",
              "id": "generated-ZIO",
              "name": "ZIO",
              "description": "",
              "members": [],
              "display_name": "ZIO",
              "created_at": "2026-01-23T05:51:29.851Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/ZIO?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "zio",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-23T05:51:29.851Z",
            "created_at": "2026-01-23T05:51:29.851Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-ZIO#471",
              "status": "open",
              "type": "issue",
              "number": 471,
              "title": "Replace TypeName by TypeId & Macro Derivation",
              "source": {
                "data": {
                  "id": "source-ZIO#471",
                  "user": {
                    "login": "jdegoes",
                    "id": 156745,
                    "node_id": "MDQ6VXNlcjE1Njc0NQ==",
                    "avatar_url": "https://avatars.githubusercontent.com/u/156745?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/jdegoes",
                    "html_url": "https://github.com/jdegoes",
                    "followers_url": "https://api.github.com/users/jdegoes/followers",
                    "following_url": "https://api.github.com/users/jdegoes/following{/other_user}",
                    "gists_url": "https://api.github.com/users/jdegoes/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/jdegoes/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/jdegoes/subscriptions",
                    "organizations_url": "https://api.github.com/users/jdegoes/orgs",
                    "repos_url": "https://api.github.com/users/jdegoes/repos",
                    "events_url": "https://api.github.com/users/jdegoes/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/jdegoes/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Replace TypeName by TypeId & Macro Derivation",
                  "body": "# Design and Implement `TypeId` for Type Registry\n\n## Goal\n\nDesign and implement a `TypeId[A]` data structure that can faithfully represent any Scala type or type constructor, capturing sufficient metadata to support:\n\n- **Type identity**: Uniquely identifying types across serialization boundaries\n- **Subtype checking**: Implementing `isSubtypeOf` directly on `TypeId` without runtime reflection\n- **Type equality**: Determining structural and nominal type equivalence\n- **Map/Set keys**: Using `TypeId` as keys in type registries (requires correct `equals`/`hashCode`)\n- **Macro derivation**: Derivation of `TypeId` for any type or type constructor, source-compatible across Scala 2/3\n\nThe data type must be used to wholly replace `TypeName` in the source code of ZIO Blocks.\n\n## Requirements\n\n### API Surface\n```scala\n// Explicit derivation\nval stringId: TypeId[String] = TypeId.of[String]\nval listId: TypeId[List] = TypeId.of[List]  // Type constructors supported\n\n// Implicit derivation for generic code\ndef process[A](value: A)(implicit typeId: TypeId[A]): Unit = ???\n\n// Or using Scala 3 context bounds\ndef process[A: TypeId](value: A): Unit = ???\n\n// Use as map keys in type registries\nval registry: Map[TypeId[_], Binding[_]] = Map(\n  TypeId.of[String] -> stringBinding,\n  TypeId.of[List[Int]] -> listIntBinding\n)\n```\n\n### Cross-Version Support\n\n- **Scala 2.13**: Use `scala.reflect.macros` for compile-time derivation\n- **Scala 3.x (3.0–3.7+)**: Use `scala.quoted` macros\n\nThe runtime data model (`TypeId`, `TypeRepr`, etc.) should be shared across versions. Only the macro implementations differ.\n\n### Equals and HashCode Contract\n\n`TypeId` instances will be used as keys in `Map` and `Set` collections within type registries. The `equals` and `hashCode` implementations must satisfy the following requirements:\n\n#### Equality Semantics\n\n1. **Nominal identity for non-aliases**: Two `TypeId` instances referring to the same nominal type (same `fullName`) are equal, regardless of when/where the macro derived them.\n\n2. **Type alias transparency**: Type aliases should be equal to their underlying types after normalization.\n```scala\n   type Age = Int\n   TypeId.of[Age] == TypeId.of[Int]  // true (after normalization)\n```\n\n3. **Opaque type nominality**: Opaque types are *not* equal to their representation or to other opaque types.\n```scala\n   opaque type Email = String\n   opaque type UserId = String\n   TypeId.of[Email] == TypeId.of[String]  // false\n   TypeId.of[Email] == TypeId.of[UserId]  // false\n```\n\n4. **Applied types**: Two applied types are equal iff their type constructors are equal and all type arguments are equal.\n```scala\n   TypeId.of[List[Int]] == TypeId.of[List[Int]]      // true\n   TypeId.of[List[Int]] == TypeId.of[List[String]]  // false\n```\n\n5. **Structural types**: Two structural types are equal iff they have the same members (by name and type).\n\n6. **Compound types**: Order matters for intersections and unions (or they must be normalized to a canonical order).\n```scala\n   // Option A: Order-sensitive\n   TypeId.of[A & B] != TypeId.of[B & A]\n   \n   // Option B: Canonicalized (preferred)\n   TypeId.of[A & B] == TypeId.of[B & A]  // after sorting components\n```\n\n#### HashCode Requirements\n\n1. **Consistency**: `hashCode` must be consistent with `equals`—equal objects must have equal hash codes.\n\n2. **Stability**: The same `TypeId` derived in different compilation units or at different times must produce the same `hashCode`.\n\n3. **Distribution**: Hash codes should be well-distributed to avoid collisions in hash maps.\n\n4. **Determinism**: `hashCode` must not depend on object identity, memory addresses, or other non-deterministic factors.\n\n#### Implementation Approach\n```scala\nsealed trait TypeId[A <: AnyKind] {\n  // ... other members ...\n\n  /** \n   * Equality based on normalized type structure.\n   * Type aliases are expanded before comparison.\n   */\n  override def equals(other: Any): Boolean = other match {\n    case that: TypeId[_] => TypeId.structurallyEqual(this, that)\n    case _ => false\n  }\n\n  /**\n   * Hash code based on normalized type structure.\n   * Must be consistent with equals.\n   */\n  override def hashCode(): Int = TypeId.structuralHash(this)\n}\n\nobject TypeId {\n  /**\n   * Compare two TypeIds for structural equality after normalization.\n   */\n  def structurallyEqual(a: TypeId[_], b: TypeId[_]): Boolean = {\n    // 1. Normalize both (expand aliases)\n    // 2. Compare structure recursively\n    // 3. For opaque types, compare by fullName only (nominal)\n    ???\n  }\n\n  /**\n   * Compute a stable hash code for a TypeId.\n   */\n  def structuralHash(id: TypeId[_]): Int = {\n    // 1. Normalize (expand aliases)\n    // 2. Compute hash from structural components\n    // 3. Must use stable values (fullName, not object identity)\n    ???\n  }\n}\n```\n\n#### Edge Cases\n\n- **Recursive types**: Must handle cycles without infinite loops in both `equals` and `hashCode`.\n- **Type parameters**: `TypeId.of[List]` (unapplied) must have different hash than `TypeId.of[List[Int]]` (applied).\n- **Path-dependent types**: `a.T` and `b.T` are equal only if `a` and `b` are the same stable path.\n- **Local types**: Types defined in local scopes need unique identification (e.g., include source location or synthetic index).\n\n### Key Operations\n```scala\ntrait TypeId[A <: AnyKind] {\n  def name: String\n  def fullName: String\n  def owner: Owner\n  def typeParams: List[TypeParam]\n  def parents: List[TypeRepr]\n  \n  // Core operations\n  def isSubtypeOf(other: TypeId[_]): Boolean\n  def isSupertypeOf(other: TypeId[_]): Boolean\n  def isEquivalentTo(other: TypeId[_]): Boolean\n  \n  // Equality (for use as map keys)\n  override def equals(other: Any): Boolean\n  override def hashCode(): Int\n}\n```\n\n## Attached Design Document\n\nSee the attached `TypeId-DataModel.md` for a comprehensive sketch of:\n\n- Core data structures (`TypeId`, `TypeRepr`, `TypeParam`, `Owner`, etc.)\n- Type expression representation (applied types, intersections, unions, match types, etc.)\n- Variance and bounds modeling\n- Substitution and normalization algorithms\n- Standard library type definitions\n\n> [!WARNING]\n> **The attached document is a design sketch, not production code.** Some details may be incorrect, incomplete, or require adjustment during implementation. It should be treated as a starting point for discussion and iteration, not a specification to implement verbatim.\n\n## Test Strategy\n\nComprehensive testing should validate four layers: **macro derivation correctness**, **data model completeness**, **type operation correctness**, and **equals/hashCode correctness**.\n\n### 1. Equals and HashCode Tests\n\nThese tests are critical since `TypeId` will be used as map keys.\n\n#### Basic Contract Tests\n```scala\ntest(\"equals is reflexive\") {\n  val id = TypeId.of[String]\n  assertTrue(id == id)\n  assertTrue(id.equals(id))\n}\n\ntest(\"equals is symmetric\") {\n  val id1 = TypeId.of[String]\n  val id2 = TypeId.of[String]\n  assertTrue(id1 == id2)\n  assertTrue(id2 == id1)\n}\n\ntest(\"equals is transitive\") {\n  val id1 = TypeId.of[String]\n  val id2 = TypeId.of[String]\n  val id3 = TypeId.of[String]\n  assertTrue(id1 == id2)\n  assertTrue(id2 == id3)\n  assertTrue(id1 == id3)\n}\n\ntest(\"hashCode is consistent with equals\") {\n  val id1 = TypeId.of[String]\n  val id2 = TypeId.of[String]\n  assertTrue(id1 == id2)\n  assertTrue(id1.hashCode == id2.hashCode)\n}\n\ntest(\"hashCode is stable across invocations\") {\n  val id = TypeId.of[List[Int]]\n  val hash1 = id.hashCode\n  val hash2 = id.hashCode\n  assertTrue(hash1 == hash2)\n}\n```\n\n#### Nominal Type Equality\n```scala\ntest(\"same nominal types are equal\") {\n  assertTrue(TypeId.of[String] == TypeId.of[String])\n  assertTrue(TypeId.of[Int] == TypeId.of[Int])\n  assertTrue(TypeId.of[List[Int]] == TypeId.of[List[Int]])\n}\n\ntest(\"different nominal types are not equal\") {\n  assertTrue(TypeId.of[String] != TypeId.of[Int])\n  assertTrue(TypeId.of[List[Int]] != TypeId.of[List[String]])\n  assertTrue(TypeId.of[List[Int]] != TypeId.of[Vector[Int]])\n}\n```\n\n#### Type Alias Equality\n```scala\ntest(\"type aliases equal their underlying types\") {\n  type Age = Int\n  type Name = String\n  \n  assertTrue(TypeId.of[Age] == TypeId.of[Int])\n  assertTrue(TypeId.of[Name] == TypeId.of[String])\n  assertTrue(TypeId.of[Age].hashCode == TypeId.of[Int].hashCode)\n}\n\ntest(\"chained type aliases resolve correctly\") {\n  type A = Int\n  type B = A\n  type C = B\n  \n  assertTrue(TypeId.of[C] == TypeId.of[Int])\n  assertTrue(TypeId.of[C] == TypeId.of[A])\n  assertTrue(TypeId.of[C] == TypeId.of[B])\n}\n\ntest(\"generic type aliases equal their expansion\") {\n  type MyList[A] = List[A]\n  \n  assertTrue(TypeId.of[MyList[Int]] == TypeId.of[List[Int]])\n  assertTrue(TypeId.of[MyList[String]] == TypeId.of[List[String]])\n}\n```\n\n#### Opaque Type Equality\n```scala\ntest(\"opaque types are not equal to their representation\") {\n  opaque type Email = String\n  \n  assertTrue(TypeId.of[Email] != TypeId.of[String])\n  assertTrue(TypeId.of[Email].hashCode != TypeId.of[String].hashCode) // likely but not guaranteed\n}\n\ntest(\"different opaque types are not equal even with same representation\") {\n  opaque type Email = String\n  opaque type UserId = String\n  \n  assertTrue(TypeId.of[Email] != TypeId.of[UserId])\n}\n\ntest(\"same opaque type is equal to itself\") {\n  opaque type Email = String\n  \n  assertTrue(TypeId.of[Email] == TypeId.of[Email])\n}\n```\n\n#### Applied Type Equality\n```scala\ntest(\"applied types with same constructor and args are equal\") {\n  assertTrue(TypeId.of[List[Int]] == TypeId.of[List[Int]])\n  assertTrue(TypeId.of[Map[String, Int]] == TypeId.of[Map[String, Int]])\n  assertTrue(TypeId.of[Either[String, Int]] == TypeId.of[Either[String, Int]])\n}\n\ntest(\"applied types with different args are not equal\") {\n  assertTrue(TypeId.of[List[Int]] != TypeId.of[List[String]])\n  assertTrue(TypeId.of[Map[String, Int]] != TypeId.of[Map[Int, String]])\n}\n\ntest(\"unapplied type constructor not equal to applied type\") {\n  assertTrue(TypeId.of[List] != TypeId.of[List[Int]])\n  assertTrue(TypeId.of[Map] != TypeId.of[Map[String, Int]])\n}\n```\n\n#### Compound Type Equality\n```scala\ntest(\"intersection types equality\") {\n  // Assuming canonicalized ordering\n  assertTrue(TypeId.of[Serializable & Comparable[String]] == TypeId.of[Serializable & Comparable[String]])\n}\n\ntest(\"union types equality\") {\n  assertTrue(TypeId.of[Int | String] == TypeId.of[Int | String])\n}\n```\n\n#### Map/Set Usage Tests\n```scala\ntest(\"TypeId works as Map key\") {\n  val map = Map[TypeId[_], String](\n    TypeId.of[String] -> \"string\",\n    TypeId.of[Int] -> \"int\",\n    TypeId.of[List[Int]] -> \"list-int\"\n  )\n  \n  assertTrue(map(TypeId.of[String]) == \"string\")\n  assertTrue(map(TypeId.of[Int]) == \"int\")\n  assertTrue(map(TypeId.of[List[Int]]) == \"list-int\")\n  assertTrue(map.get(TypeId.of[Double]).isEmpty)\n}\n\ntest(\"TypeId works as Map key with type aliases\") {\n  type Age = Int\n  \n  val map = Map[TypeId[_], String](\n    TypeId.of[Int] -> \"int\"\n  )\n  \n  // Should find the entry via alias\n  assertTrue(map(TypeId.of[Age]) == \"int\")\n}\n\ntest(\"TypeId works in Set\") {\n  val set = Set(\n    TypeId.of[String],\n    TypeId.of[Int],\n    TypeId.of[List[Int]]\n  )\n  \n  assertTrue(set.contains(TypeId.of[String]))\n  assertTrue(set.contains(TypeId.of[Int]))\n  assertTrue(!set.contains(TypeId.of[Double]))\n}\n\ntest(\"TypeId deduplication in Set\") {\n  type Age = Int\n  \n  val set = Set(\n    TypeId.of[Int],\n    TypeId.of[Age]  // Should deduplicate\n  )\n  \n  assertTrue(set.size == 1)\n}\n\ntest(\"mutable HashMap works with TypeId\") {\n  val map = scala.collection.mutable.HashMap[TypeId[_], String]()\n  \n  map(TypeId.of[String]) = \"string\"\n  map(TypeId.of[Int]) = \"int\"\n  \n  assertTrue(map(TypeId.of[String]) == \"string\")\n  \n  // Update via equal key\n  type Name = String\n  map(TypeId.of[Name]) = \"updated\"\n  assertTrue(map(TypeId.of[String]) == \"updated\")\n}\n```\n\n#### Cross-Compilation Equality\n```scala\ntest(\"TypeId equality is stable across compilation units\") {\n  // id1 derived in CompilationUnitA\n  val id1 = CompilationUnitA.stringTypeId\n  // id2 derived in CompilationUnitB  \n  val id2 = CompilationUnitB.stringTypeId\n  \n  assertTrue(id1 == id2)\n  assertTrue(id1.hashCode == id2.hashCode)\n}\n```\n\n### 2. Macro Derivation Tests\n\nVerify that the macro correctly captures type information for all supported type forms.\n\n#### Primitive and Basic Types\n```scala\ntest(\"derives primitives correctly\") {\n  assertTrue(TypeId.of[Int].name == \"Int\")\n  assertTrue(TypeId.of[String].fullName == \"java.lang.String\")\n  assertTrue(TypeId.of[Unit].isValueClass)\n}\n```\n\n#### Generic Types and Type Constructors\n```scala\ntest(\"derives type constructors\") {\n  val listId = TypeId.of[List]\n  assertTrue(listId.arity == 1)\n  assertTrue(listId.typeParams.head.variance == Variance.Covariant)\n}\n\ntest(\"derives applied types\") {\n  val listIntId = TypeId.of[List[Int]]\n  // Should capture that this is List applied to Int\n}\n\ntest(\"derives higher-kinded types\") {\n  val functorId = TypeId.of[Functor]  // Functor[F[_]]\n  assertTrue(functorId.typeParams.head.kind == Kind.`* -> *`)\n}\n```\n\n#### Type Aliases and Opaque Types\n```scala\ntype Age = Int\nopaque type Email = String\n\ntest(\"derives type aliases\") {\n  val ageId = TypeId.of[Age]\n  assertTrue(ageId.isAlias)\n  assertTrue(ageId.aliasedTo == Some(TypeRepr.Ref(TypeId.of[Int])))\n}\n\ntest(\"derives opaque types\") {\n  val emailId = TypeId.of[Email]\n  assertTrue(emailId.isOpaque)\n  // Representation should be captured\n}\n```\n\n#### Classes, Traits, Objects, Enums\n```scala\nsealed trait Animal\ncase class Dog(name: String) extends Animal\ncase object Cat extends Animal\n\nenum Color { case Red, Green, Blue, RGB(r: Int, g: Int, b: Int) }\n\ntest(\"derives sealed hierarchy\") {\n  val animalId = TypeId.of[Animal]\n  assertTrue(animalId.isSealed)\n  assertTrue(animalId.defKind match {\n    case TypeDefKind.Trait(true, subtypes) => subtypes.nonEmpty\n    case _ => false\n  })\n}\n\ntest(\"derives enums with cases\") {\n  val colorId = TypeId.of[Color]\n  assertTrue(colorId.enumCases.map(_.name) == List(\"Red\", \"Green\", \"Blue\", \"RGB\"))\n  assertTrue(colorId.enumCases.find(_.name == \"RGB\").exists(_.params.nonEmpty))\n}\n```\n\n#### Structural and Refinement Types\n```scala\ntest(\"derives structural types\") {\n  type Sized = { def size: Int }\n  val sizedId = TypeId.of[Sized]\n  // Should capture the structural member\n}\n```\n\n#### Compound Types\n```scala\ntest(\"derives intersection types\") {\n  val id = TypeId.of[String & Serializable]\n  // Should capture both components\n}\n\ntest(\"derives union types\") {\n  val id = TypeId.of[String | Int]\n  // Should capture both components\n}\n```\n\n#### Tuple Types (Including Named Tuples for Scala 3.5+)\n```scala\ntest(\"derives positional tuples\") {\n  val id = TypeId.of[(Int, String, Boolean)]\n  // Should capture element types\n}\n\ntest(\"derives named tuples\") {  // Scala 3.5+\n  val id = TypeId.of[(name: String, age: Int)]\n  // Should capture labels and types\n}\n```\n\n#### Function Types\n```scala\ntest(\"derives function types\") {\n  val id = TypeId.of[(Int, String) => Boolean]\n  // Should capture param types and result type\n}\n\ntest(\"derives context function types\") {  // Scala 3\n  val id = TypeId.of[(Int, String) ?=> Boolean]\n}\n\ntest(\"derives polymorphic function types\") {  // Scala 3\n  val id = TypeId.of[[A] => A => A]\n}\n```\n\n#### Path-Dependent and Singleton Types\n```scala\nobject Outer {\n  object Inner {\n    type T = Int\n  }\n  val inner: Inner.type = Inner\n}\n\ntest(\"derives path-dependent types\") {\n  val id = TypeId.of[Outer.Inner.T]\n  // Should capture the path\n}\n\ntest(\"derives singleton types\") {\n  val id = TypeId.of[Outer.Inner.type]\n}\n```\n\n#### Match Types (Scala 3)\n```scala\ntype Elem[X] = X match {\n  case String => Char\n  case Array[t] => t\n}\n\ntest(\"derives match types\") {\n  val id = TypeId.of[Elem]\n  // Should capture scrutinee, cases, and binders\n}\n```\n\n### 3. Data Model Completeness Tests\n\nVerify that round-tripping through the model preserves type information.\n```scala\ntest(\"TypeRepr substitution is correct\") {\n  val A = TypeParam(\"A\", 0)\n  val listOfA = TypeRepr.Applied(TypeRepr.Ref(listId), List(TypeRepr.ParamRef(A)))\n  val substituted = listOfA.substitute(Map(A -> TypeRepr.Ref(intId)))\n  assertTrue(substituted == TypeRepr.Applied(TypeRepr.Ref(listId), List(TypeRepr.Ref(intId))))\n}\n\ntest(\"normalization expands aliases\") {\n  type MyInt = Int\n  val myIntRepr = TypeRepr.Ref(TypeId.of[MyInt])\n  val normalized = TypeNormalization.normalize(myIntRepr)\n  assertTrue(normalized == TypeRepr.Ref(TypeId.of[Int]))\n}\n```\n\n### 4. Subtyping Tests\n\nVerify that `isSubtypeOf` correctly implements Scala's subtyping rules.\n\n#### Basic Subtyping\n```scala\ntest(\"Nothing is subtype of everything\") {\n  assertTrue(TypeId.of[Nothing].isSubtypeOf(TypeId.of[Int]))\n  assertTrue(TypeId.of[Nothing].isSubtypeOf(TypeId.of[String]))\n  assertTrue(TypeId.of[Nothing].isSubtypeOf(TypeId.of[Any]))\n}\n\ntest(\"everything is subtype of Any\") {\n  assertTrue(TypeId.of[Int].isSubtypeOf(TypeId.of[Any]))\n  assertTrue(TypeId.of[String].isSubtypeOf(TypeId.of[Any]))\n  assertTrue(TypeId.of[List[Int]].isSubtypeOf(TypeId.of[Any]))\n}\n\ntest(\"reflexivity\") {\n  assertTrue(TypeId.of[String].isSubtypeOf(TypeId.of[String]))\n  assertTrue(TypeId.of[List[Int]].isSubtypeOf(TypeId.of[List[Int]]))\n}\n```\n\n#### Variance-Aware Subtyping\n```scala\ntest(\"covariant type parameter subtyping\") {\n  // List is covariant: List[Dog] <: List[Animal]\n  assertTrue(TypeId.of[List[Dog]].isSubtypeOf(TypeId.of[List[Animal]]))\n  assertTrue(!TypeId.of[List[Animal]].isSubtypeOf(TypeId.of[List[Dog]]))\n}\n\ntest(\"contravariant type parameter subtyping\") {\n  // Function1 is contravariant in input: (Animal => Int) <: (Dog => Int)\n  assertTrue(TypeId.of[Animal => Int].isSubtypeOf(TypeId.of[Dog => Int]))\n  assertTrue(!TypeId.of[Dog => Int].isSubtypeOf(TypeId.of[Animal => Int]))\n}\n\ntest(\"invariant type parameter subtyping\") {\n  // Array is invariant\n  assertTrue(!TypeId.of[Array[Dog]].isSubtypeOf(TypeId.of[Array[Animal]]))\n  assertTrue(!TypeId.of[Array[Animal]].isSubtypeOf(TypeId.of[Array[Dog]]))\n}\n```\n\n#### Union and Intersection Types\n```scala\ntest(\"union type subtyping\") {\n  // A <: A | B and B <: A | B\n  assertTrue(TypeId.of[Int].isSubtypeOf(TypeId.of[Int | String]))\n  assertTrue(TypeId.of[String].isSubtypeOf(TypeId.of[Int | String]))\n  \n  // A | B <: C requires both A <: C and B <: C\n  assertTrue(!TypeId.of[Int | String].isSubtypeOf(TypeId.of[Int]))\n}\n\ntest(\"intersection type subtyping\") {\n  // A & B <: A and A & B <: B\n  assertTrue(TypeId.of[Serializable & Comparable[String]].isSubtypeOf(TypeId.of[Serializable]))\n  \n  // A <: B & C requires A <: B and A <: C\n}\n```\n\n#### Nominal Hierarchy Subtyping\n```scala\ntest(\"class hierarchy subtyping\") {\n  assertTrue(TypeId.of[Dog].isSubtypeOf(TypeId.of[Animal]))\n  assertTrue(TypeId.of[String].isSubtypeOf(TypeId.of[CharSequence]))\n}\n```\n\n#### Type Alias Transparency\n```scala\ntest(\"type aliases are transparent for subtyping\") {\n  type Age = Int\n  assertTrue(TypeId.of[Age].isSubtypeOf(TypeId.of[Int]))\n  assertTrue(TypeId.of[Int].isSubtypeOf(TypeId.of[Age]))\n  assertTrue(TypeId.of[Age].isEquivalentTo(TypeId.of[Int]))\n}\n```\n\n#### Opaque Type Nominality\n```scala\ntest(\"opaque types are nominally distinct\") {\n  opaque type Email = String\n  opaque type UserId = String\n  \n  assertTrue(!TypeId.of[Email].isSubtypeOf(TypeId.of[String]))  // Outside defining scope\n  assertTrue(!TypeId.of[Email].isSubtypeOf(TypeId.of[UserId]))\n}\n```\n\n### 5. Edge Cases and Regression Tests\n```scala\ntest(\"handles recursive types\") {\n  enum Tree[+A] {\n    case Leaf(value: A)\n    case Branch(left: Tree[A], right: Tree[A])\n  }\n  val treeId = TypeId.of[Tree]\n  // Should not stack overflow on equals/hashCode\n  val hash = treeId.hashCode  // Must terminate\n  assertTrue(treeId == treeId)    // Must terminate\n}\n\ntest(\"handles deeply nested generics\") {\n  val id = TypeId.of[List[Map[String, Option[Either[Int, List[String]]]]]]\n  // Should capture full structure\n  val hash = id.hashCode\n  assertTrue(id == TypeId.of[List[Map[String, Option[Either[Int, List[String]]]]]])\n}\n\ntest(\"handles local and anonymous types\") {\n  def foo() = {\n    class Local\n    TypeId.of[Local]\n  }\n  // Should handle gracefully\n}\n\ntest(\"handles Java types\") {\n  val id = TypeId.of[java.util.ArrayList[String]]\n  // Should interop correctly\n}\n```\n\n### 6. Cross-Compilation Tests\n\nRun the same test suite on both Scala 2.13 and Scala 3.x to ensure consistent behavior:\n```scala\n// In shared test sources\nclass TypeIdSpec extends AnyFunSuite {\n  // All tests above should pass on both Scala versions\n}\n```\n\nSpecific attention should be paid to:\n- Features that exist only in Scala 3 (union/intersection types, enums, match types, named tuples)\n- Features with different representations (Scala 2 existentials vs Scala 3 wildcards)\n- Macro API differences (should be invisible to users but implementation must handle both)\n- **Equality of TypeIds derived in Scala 2 vs Scala 3 for the same type** (if cross-published)\n\n## Acceptance Criteria\n\n- [ ] `TypeId.of[A]` works for all documented type forms on Scala 2.13\n- [ ] `TypeId.of[A]` works for all documented type forms on Scala 3.0–3.7\n- [ ] `implicit TypeId[A]` derivation works in generic contexts\n- [ ] `isSubtypeOf` correctly handles variance, unions, intersections, and nominal hierarchies\n- [ ] Type aliases are normalized correctly\n- [ ] Opaque types maintain nominal distinction\n- [ ] **`equals` and `hashCode` satisfy the Java contract**\n- [ ] **`TypeId` works correctly as `Map` and `Set` keys**\n- [ ] **Type aliases resolve to equal `TypeId` as their underlying types**\n- [ ] **Opaque types have distinct `TypeId` from their representation**\n- [ ] **`hashCode` is stable and deterministic across compilations**\n- [ ] All tests pass on both Scala versions\n- [ ] No runtime reflection is required (all information captured at compile time)\n\n# Sketch of TypeId\n\n# TypeId Data Model for Scala 3.x Type Registry\n\nA comprehensive data model for representing Scala 3 types and type constructors, designed to support:\n- Lossless type representation for serialization/deserialization frameworks\n- Subtype checking (`isSubtypeOf`)\n- Type equality checking\n- Type normalization (alias expansion)\n\n## Design Principles\n\n1. **Polykinded phantom types**: `TypeId[A <: AnyKind]` preserves Scala type information at compile time\n2. **Separation of identity and representation**: `TypeId` identifies types; `TypeRepr` represents type expressions\n3. **Complete metadata**: Capture everything a macro can know at compile time\n4. **Stability tracking**: Path-dependent types require knowing path stability\n\n---\n\n## Core Data Model\n\n### Variance\n```scala\nenum Variance {\n  case Invariant\n  case Covariant\n  case Contravariant\n\n  def symbol: String = this match {\n    case Invariant     => \"\"\n    case Covariant     => \"+\"\n    case Contravariant => \"-\"\n  }\n\n  /** Flip variance for contravariant positions */\n  def flip: Variance = this match {\n    case Invariant     => Invariant\n    case Covariant     => Contravariant\n    case Contravariant => Covariant\n  }\n}\n```\n\n### TypeBounds\n```scala\nfinal case class TypeBounds(\n  lower: Option[TypeRepr],  // >: bound\n  upper: Option[TypeRepr]   // <: bound\n) {\n  def isUnbounded: Boolean = lower.isEmpty && upper.isEmpty\n  \n  def hasLower: Boolean = lower.isDefined\n  def hasUpper: Boolean = upper.isDefined\n  \n  /** Combine bounds (intersection of constraints) */\n  def &(other: TypeBounds): TypeBounds = TypeBounds(\n    lower = (lower, other.lower) match {\n      case (Some(l1), Some(l2)) => Some(TypeRepr.Union(l1, l2))\n      case (Some(l), None) => Some(l)\n      case (None, Some(l)) => Some(l)\n      case (None, None) => None\n    },\n    upper = (upper, other.upper) match {\n      case (Some(u1), Some(u2)) => Some(TypeRepr.Intersection(u1, u2))\n      case (Some(u), None) => Some(u)\n      case (None, Some(u)) => Some(u)\n      case (None, None) => None\n    }\n  )\n}\n\nobject TypeBounds {\n  val empty: TypeBounds = TypeBounds(None, None)\n  \n  def upper(tpe: TypeRepr): TypeBounds = TypeBounds(None, Some(tpe))\n  def lower(tpe: TypeRepr): TypeBounds = TypeBounds(Some(tpe), None)\n  def exact(tpe: TypeRepr): TypeBounds = TypeBounds(Some(tpe), Some(tpe))\n}\n```\n\n### Kind\n\nRepresents the \"type of a type\" - distinguishing proper types from type constructors.\n```scala\nsealed trait Kind {\n  def arity: Int\n  def isProperType: Boolean = this == Kind.Type\n  def isHigherKinded: Boolean = !isProperType\n}\n\nobject Kind {\n  /** Proper type: Int, String, List[Int] */\n  case object Type extends Kind { \n    def arity: Int = 0 \n  }\n\n  /** Type constructor: List, Option, Map */\n  final case class Arrow(params: List[Kind], result: Kind) extends Kind {\n    def arity: Int = params.size\n  }\n\n  // Convenience constructors\n  val `* -> *`: Kind = Arrow(List(Type), Type)\n  val `* -> * -> *`: Kind = Arrow(List(Type, Type), Type)\n  val `(* -> *) -> *`: Kind = Arrow(List(`* -> *`), Type)\n  \n  def arity(n: Int): Kind = \n    if (n == 0) Type \n    else Arrow(List.fill(n)(Type), Type)\n}\n```\n\n### TypeParam\n\nComplete type parameter specification with all information needed for subtyping.\n```scala\nfinal case class TypeParam(\n  name: String,\n  index: Int,\n  variance: Variance = Variance.Invariant,\n  bounds: TypeBounds = TypeBounds.empty,\n  kind: Kind = Kind.Type\n) {\n  def isHigherKinded: Boolean = kind.isHigherKinded\n  def isCovariant: Boolean = variance == Variance.Covariant\n  def isContravariant: Boolean = variance == Variance.Contravariant\n  def isInvariant: Boolean = variance == Variance.Invariant\n}\n\nobject TypeParam {\n  def invariant(name: String, index: Int): TypeParam = \n    TypeParam(name, index, Variance.Invariant)\n    \n  def covariant(name: String, index: Int): TypeParam = \n    TypeParam(name, index, Variance.Covariant)\n    \n  def contravariant(name: String, index: Int): TypeParam = \n    TypeParam(name, index, Variance.Contravariant)\n}\n```\n\n---\n\n## Type Definition Classification\n\n### TypeDefKind\n\nClassifies what kind of type definition a `TypeId` represents.\n```scala\nsealed trait TypeDefKind\n\nobject TypeDefKind {\n  final case class Class(\n    isFinal: Boolean = false,\n    isAbstract: Boolean = false,\n    isCase: Boolean = false,\n    isValue: Boolean = false  // extends AnyVal\n  ) extends TypeDefKind\n\n  final case class Trait(\n    isSealed: Boolean = false,\n    knownSubtypes: List[TypeRepr] = Nil\n  ) extends TypeDefKind\n\n  /** Singleton object */\n  case object Object extends TypeDefKind\n\n  /** Scala 3 enum */\n  final case class Enum(\n    cases: List[EnumCaseInfo]\n  ) extends TypeDefKind\n\n  /** Individual enum case (when represented as its own type) */\n  final case class EnumCase(\n    parentEnum: TypeRepr,\n    ordinal: Int,\n    isObjectCase: Boolean  // case Red vs case RGB(...)\n  ) extends TypeDefKind\n\n  /** Type alias: type Foo = Bar */\n  case object TypeAlias extends TypeDefKind\n\n  /** Opaque type: opaque type Foo = Bar */\n  final case class OpaqueType(\n    publicBounds: TypeBounds  // Bounds visible outside defining scope\n  ) extends TypeDefKind\n\n  /** Abstract type member */\n  case object AbstractType extends TypeDefKind\n}\n\n/** Information about an enum case for serialization */\nfinal case class EnumCaseInfo(\n  name: String,\n  ordinal: Int,\n  params: List[EnumCaseParam],  // Empty for object cases\n  isObjectCase: Boolean\n) {\n  def arity: Int = params.size\n}\n\nfinal case class EnumCaseParam(\n  name: String,\n  tpe: TypeRepr\n)\n```\n\n---\n\n## Parameters and Clauses\n\n### ParamClause\n```scala\nsealed trait ParamClause {\n  def params: List[Param]\n  def isEmpty: Boolean = params.isEmpty\n  def size: Int = params.size\n}\n\nobject ParamClause {\n  final case class Regular(params: List[Param]) extends ParamClause\n  final case class Using(params: List[Param]) extends ParamClause\n  final case class Implicit(params: List[Param]) extends ParamClause\n  \n  val empty: ParamClause = Regular(Nil)\n}\n```\n\n### Param\n```scala\nfinal case class Param(\n  name: String,\n  tpe: TypeRepr,\n  hasDefault: Boolean = false,\n  isRepeated: Boolean = false  // varargs: A*\n)\n```\n\n---\n\n## Ownership and Paths\n\n### Owner\n\nRepresents the lexical owner of a type definition.\n```scala\nfinal case class Owner(segments: List[Owner.Segment]) {\n  def /(segment: Owner.Segment): Owner = Owner(segments :+ segment)\n  \n  def parent: Option[Owner] = \n    if (segments.isEmpty) None \n    else Some(Owner(segments.init))\n  \n  def isRoot: Boolean = segments.isEmpty\n  \n  def asString: String = segments.map(_.show).mkString(\".\")\n  \n  /** Check if this owner is a prefix of another */\n  def isPrefixOf(other: Owner): Boolean =\n    other.segments.startsWith(segments)\n}\n\nobject Owner {\n  sealed trait Segment {\n    def name: String\n    def show: String = name\n  }\n\n  final case class Package(name: String) extends Segment\n  final case class Term(name: String) extends Segment\n  final case class Type(name: String) extends Segment\n  final case class Local(index: Int) extends Segment {\n    def name: String = s\"<local$index>\"\n  }\n\n  val Root: Owner = Owner(Nil)\n  \n  def pkg(name: String): Owner = Owner(List(Package(name)))\n  def pkgs(names: String*): Owner = Owner(names.map(Package(_)).toList)\n}\n```\n\n### TermPath\n\nRepresents paths to terms, used for singleton and path-dependent types.\n```scala\nfinal case class TermPath(segments: List[TermPath.Segment]) {\n  def /(segment: TermPath.Segment): TermPath = \n    TermPath(segments :+ segment)\n  \n  def isStable: Boolean = segments.forall(_.isStable)\n  \n  def asString: String = segments.map(_.name).mkString(\".\")\n}\n\nobject TermPath {\n  sealed trait Segment {\n    def name: String\n    def isStable: Boolean\n  }\n\n  /** Package reference - always stable */\n  final case class Package(name: String) extends Segment {\n    def isStable: Boolean = true\n  }\n\n  /** Object/module reference - always stable */\n  final case class Module(name: String) extends Segment {\n    def isStable: Boolean = true\n  }\n\n  /** Val reference - stable */\n  final case class Val(name: String) extends Segment {\n    def isStable: Boolean = true\n  }\n\n  /** Lazy val reference - stable */\n  final case class LazyVal(name: String) extends Segment {\n    def isStable: Boolean = true\n  }\n\n  /** Var reference - NOT stable */\n  final case class Var(name: String) extends Segment {\n    def isStable: Boolean = false\n  }\n\n  /** Def/method reference - NOT stable */\n  final case class Def(name: String) extends Segment {\n    def isStable: Boolean = false\n  }\n\n  /** This reference */\n  final case class This(ownerName: String) extends Segment {\n    def name: String = s\"$ownerName.this\"\n    def isStable: Boolean = true\n  }\n\n  /** Super reference */\n  final case class Super(ownerName: String, mixinName: Option[String]) extends Segment {\n    def name: String = mixinName.fold(s\"$ownerName.super\")(m => s\"$ownerName.super[$m]\")\n    def isStable: Boolean = true\n  }\n\n  val empty: TermPath = TermPath(Nil)\n}\n```\n\n---\n\n## TypeId: Type Identity\n\nThe primary type for identifying types and type constructors.\n```scala\nsealed trait TypeId[A <: AnyKind] {\n  def name: String\n  def owner: Owner\n  def typeParams: List[TypeParam]\n  def defKind: TypeDefKind\n  def parents: List[TypeRepr]\n  def selfType: Option[TypeRepr]\n  def aliasedTo: Option[TypeRepr]      // For type aliases\n  def representation: Option[TypeRepr] // For opaque types\n  def annotations: List[Annotation]\n\n  // Derived properties\n  final def arity: Int = typeParams.size\n  \n  final def fullName: String =\n    if (owner.isRoot) name\n    else s\"${owner.asString}.$name\"\n\n  final def isProperType: Boolean = arity == 0\n  final def isTypeConstructor: Boolean = arity > 0\n\n  final def isClass: Boolean = defKind.isInstanceOf[TypeDefKind.Class]\n  final def isTrait: Boolean = defKind.isInstanceOf[TypeDefKind.Trait]\n  final def isObject: Boolean = defKind == TypeDefKind.Object\n  final def isEnum: Boolean = defKind.isInstanceOf[TypeDefKind.Enum]\n  final def isAlias: Boolean = defKind == TypeDefKind.TypeAlias\n  final def isOpaque: Boolean = defKind.isInstanceOf[TypeDefKind.OpaqueType]\n  final def isAbstract: Boolean = defKind == TypeDefKind.AbstractType\n\n  final def isSealed: Boolean = defKind match {\n    case TypeDefKind.Trait(isSealed, _) => isSealed\n    case _ => false\n  }\n\n  final def isCaseClass: Boolean = defKind match {\n    case TypeDefKind.Class(_, _, isCase, _) => isCase\n    case _ => false\n  }\n\n  final def isValueClass: Boolean = defKind match {\n    case TypeDefKind.Class(_, _, _, isValue) => isValue\n    case _ => false\n  }\n  \n  /** Get enum cases if this is an enum */\n  final def enumCases: List[EnumCaseInfo] = defKind match {\n    case TypeDefKind.Enum(cases) => cases\n    case _ => Nil\n  }\n}\n\nobject TypeId {\n  private final case class Impl[A <: AnyKind](\n    name: String,\n    owner: Owner,\n    typeParams: List[TypeParam],\n    defKind: TypeDefKind,\n    parents: List[TypeRepr],\n    selfType: Option[TypeRepr],\n    aliasedTo: Option[TypeRepr],\n    representation: Option[TypeRepr],\n    annotations: List[Annotation]\n  ) extends TypeId[A]\n\n  // ========== Smart Constructors ==========\n\n  def nominal[A <: AnyKind](\n    name: String,\n    owner: Owner,\n    typeParams: List[TypeParam] = Nil,\n    defKind: TypeDefKind,\n    parents: List[TypeRepr] = Nil,\n    selfType: Option[TypeRepr] = None,\n    annotations: List[Annotation] = Nil\n  ): TypeId[A] = Impl[A](\n    name, owner, typeParams, defKind,\n    parents, selfType, None, None, annotations\n  )\n\n  def alias[A <: AnyKind](\n    name: String,\n    owner: Owner,\n    typeParams: List[TypeParam] = Nil,\n    aliased: TypeRepr,\n    annotations: List[Annotation] = Nil\n  ): TypeId[A] = Impl[A](\n    name, owner, typeParams, TypeDefKind.TypeAlias,\n    Nil, None, Some(aliased), None, annotations\n  )\n\n  def opaque[A <: AnyKind](\n    name: String,\n    owner: Owner,\n    typeParams: List[TypeParam] = Nil,\n    representation: TypeRepr,\n    publicBounds: TypeBounds = TypeBounds.empty,\n    annotations: List[Annotation] = Nil\n  ): TypeId[A] = Impl[A](\n    name, owner, typeParams, TypeDefKind.OpaqueType(publicBounds),\n    Nil, None, None, Some(representation), annotations\n  )\n\n  // ========== Extractors ==========\n\n  object Nominal {\n    def unapply(id: TypeId[?]): Option[(String, Owner, List[TypeParam], TypeDefKind, List[TypeRepr])] =\n      if (id.aliasedTo.isEmpty && id.representation.isEmpty)\n        Some((id.name, id.owner, id.typeParams, id.defKind, id.parents))\n      else None\n  }\n\n  object Alias {\n    def unapply(id: TypeId[?]): Option[(String, Owner, List[TypeParam], TypeRepr)] =\n      id.aliasedTo.map(a => (id.name, id.owner, id.typeParams, a))\n  }\n\n  object Opaque {\n    def unapply(id: TypeId[?]): Option[(String, Owner, List[TypeParam], TypeRepr, TypeBounds)] =\n      (id.defKind, id.representation) match {\n        case (TypeDefKind.OpaqueType(bounds), Some(repr)) =>\n          Some((id.name, id.owner, id.typeParams, repr, bounds))\n        case _ => None\n      }\n  }\n\n  object Sealed {\n    def unapply(id: TypeId[?]): Option[(String, List[TypeRepr])] =\n      id.defKind match {\n        case TypeDefKind.Trait(true, subtypes) => Some((id.name, subtypes))\n        case _ => None\n      }\n  }\n  \n  object Enum {\n    def unapply(id: TypeId[?]): Option[(String, Owner, List[EnumCaseInfo])] =\n      id.defKind match {\n        case TypeDefKind.Enum(cases) => Some((id.name, id.owner, cases))\n        case _ => None\n      }\n  }\n}\n```\n\n---\n\n## TypeRepr: Type Expressions\n\nThe expression language for representing type structures.\n```scala\nsealed trait TypeRepr {\n  /** Substitute type parameters with concrete types */\n  def substitute(substitutions: Map[TypeParam, TypeRepr]): TypeRepr =\n    TypeRepr.substitute(this, substitutions)\n}\n\nobject TypeRepr {\n\n  // ==================== Type References ====================\n\n  /** Reference to a type by its TypeId */\n  final case class Ref(id: TypeId[? <: AnyKind]) extends TypeRepr\n\n  /** Reference to a type parameter */\n  final case class ParamRef(\n    param: TypeParam,\n    binderDepth: Int = 0  // De Bruijn index: 0 = innermost binder\n  ) extends TypeRepr\n\n  /** Path-dependent type: qualifier.Member */\n  final case class TypeSelect(\n    qualifier: TermPath,\n    memberName: String\n  ) extends TypeRepr {\n    def isStable: Boolean = qualifier.isStable\n  }\n\n  /** Type projection (deprecated but exists): Outer#Inner */\n  final case class TypeProjection(\n    prefix: TypeRepr,\n    memberName: String\n  ) extends TypeRepr\n\n  // ==================== Type Application ====================\n\n  /** Type constructor application: F[A, B] */\n  final case class Applied(\n    tycon: TypeRepr,\n    args: List[TypeRepr]\n  ) extends TypeRepr {\n    def arity: Int = args.size\n  }\n\n  // ==================== Type Constructors ====================\n\n  /** Type lambda: [X, Y] =>> F[X, Y] */\n  final case class TypeLambda(\n    params: List[TypeParam],\n    body: TypeRepr\n  ) extends TypeRepr {\n    def arity: Int = params.size\n  }\n\n  // ==================== Compound Types ====================\n\n  /** Intersection: A & B & C */\n  final case class Intersection(components: List[TypeRepr]) extends TypeRepr {\n    require(components.sizeIs >= 2, \"Intersection requires at least 2 types\")\n  }\n  \n  object Intersection {\n    def apply(left: TypeRepr, right: TypeRepr): Intersection =\n      (left, right) match {\n        case (Intersection(l), Intersection(r)) => Intersection(l ++ r)\n        case (Intersection(l), r) => Intersection(l :+ r)\n        case (l, Intersection(r)) => Intersection(l :: r)\n        case (l, r) => Intersection(List(l, r))\n      }\n  }\n\n  /** Union: A | B | C */\n  final case class Union(components: List[TypeRepr]) extends TypeRepr {\n    require(components.sizeIs >= 2, \"Union requires at least 2 types\")\n  }\n  \n  object Union {\n    def apply(left: TypeRepr, right: TypeRepr): Union =\n      (left, right) match {\n        case (Union(l), Union(r)) => Union(l ++ r)\n        case (Union(l), r) => Union(l :+ r)\n        case (l, Union(r)) => Union(l :: r)\n        case (l, r) => Union(List(l, r))\n      }\n  }\n\n  /** Structural/refinement type: { def foo: Int; type T } */\n  final case class Structural(\n    parents: List[TypeRepr],\n    members: List[Member]\n  ) extends TypeRepr\n\n  // ==================== Function Types ====================\n\n  /** Regular function: (A, B) => C */\n  final case class Function(\n    params: List[TypeRepr],\n    result: TypeRepr\n  ) extends TypeRepr {\n    def arity: Int = params.size\n  }\n\n  /** Context function: (A, B) ?=> C */\n  final case class ContextFunction(\n    params: List[TypeRepr],\n    result: TypeRepr\n  ) extends TypeRepr\n\n  /** Polymorphic function: [A] => A => A */\n  final case class PolyFunction(\n    typeParams: List[TypeParam],\n    result: TypeRepr\n  ) extends TypeRepr\n\n  /** Dependent function: (x: A) => x.T */\n  final case class DependentFunction(\n    params: List[Param],\n    result: TypeRepr  // May contain references to param names\n  ) extends TypeRepr\n\n  // ==================== Special Parameter Types ====================\n\n  /** By-name type: => A */\n  final case class ByName(underlying: TypeRepr) extends TypeRepr\n\n  /** Repeated/vararg type: A* */\n  final case class Repeated(underlying: TypeRepr) extends TypeRepr\n\n  // ==================== Tuple Types ====================\n\n  /** Tuple type with optional labels: (A, B) or (name: String, age: Int) */\n  final case class Tuple(elements: List[TupleElement]) extends TypeRepr {\n    def arity: Int = elements.size\n    def isNamed: Boolean = elements.exists(_.label.isDefined)\n    def isPositional: Boolean = elements.forall(_.label.isEmpty)\n    \n    def labels: List[Option[String]] = elements.map(_.label)\n    def types: List[TypeRepr] = elements.map(_.tpe)\n  }\n\n  final case class TupleElement(\n    label: Option[String],\n    tpe: TypeRepr\n  )\n  \n  object Tuple {\n    def positional(types: TypeRepr*): Tuple = \n      Tuple(types.map(t => TupleElement(None, t)).toList)\n      \n    def named(fields: (String, TypeRepr)*): Tuple =\n      Tuple(fields.map { case (n, t) => TupleElement(Some(n), t) }.toList)\n  }\n\n  // ==================== Singleton & Literal Types ====================\n\n  /** Singleton type: x.type */\n  final case class Singleton(path: TermPath) extends TypeRepr {\n    def isStable: Boolean = path.isStable\n  }\n\n  /** This type: this.type within a class */\n  final case class ThisType(owner: TypeId[? <: AnyKind]) extends TypeRepr\n\n  /** Super type reference */\n  final case class SuperType(\n    thisType: TypeRepr,\n    mixinTrait: Option[TypeRepr]\n  ) extends TypeRepr\n\n  /** Literal/constant type: 42, \"foo\", true */\n  final case class ConstantType(value: Constant) extends TypeRepr\n\n  // ==================== Match Types ====================\n\n  /** Match type: T match { case P => R; ... } */\n  final case class MatchType(\n    bound: TypeRepr,\n    scrutinee: TypeRepr,\n    cases: List[MatchTypeCase]\n  ) extends TypeRepr\n\n  final case class MatchTypeCase(\n    bindings: List[TypeParam],  // Captured type vars, e.g., `t` in `case Array[t] => t`\n    pattern: TypeRepr,\n    result: TypeRepr            // Can reference bindings via ParamRef\n  )\n\n  // ==================== Bounded/Wildcard Types ====================\n\n  /** Wildcard with bounds: ? <: Upper, ? >: Lower */\n  final case class Wildcard(bounds: TypeBounds) extends TypeRepr\n  \n  object Wildcard {\n    val unbounded: Wildcard = Wildcard(TypeBounds.empty)\n    def <:(upper: TypeRepr): Wildcard = Wildcard(TypeBounds.upper(upper))\n    def >:(lower: TypeRepr): Wildcard = Wildcard(TypeBounds.lower(lower))\n  }\n\n  // ==================== Recursive Types ====================\n\n  /** Recursive type: used for recursive type aliases */\n  final case class RecType(body: TypeRepr) extends TypeRepr\n\n  /** Reference to enclosing RecType */\n  case object RecThis extends TypeRepr\n\n  // ==================== Annotated Types ====================\n\n  /** Type with annotations: A @ann */\n  final case class Annotated(\n    underlying: TypeRepr,\n    annotations: List[Annotation]\n  ) extends TypeRepr\n\n  // ==================== Top, Bottom, and Special Types ====================\n\n  case object AnyType extends TypeRepr\n  case object AnyKindType extends TypeRepr\n  case object NothingType extends TypeRepr\n  case object NullType extends TypeRepr\n  case object UnitType extends TypeRepr\n\n  // ==================== Substitution ====================\n\n  def substitute(repr: TypeRepr, subs: Map[TypeParam, TypeRepr]): TypeRepr = {\n    def go(r: TypeRepr): TypeRepr = r match {\n      case ParamRef(param, 0) => subs.getOrElse(param, r)\n      case ParamRef(_, _) => r  // Different binder depth\n      case Ref(_) => r\n      case Applied(tycon, args) => Applied(go(tycon), args.map(go))\n      case TypeLambda(params, body) =>\n        // Shift substitutions to account for new binders\n        val shifted = subs.map { case (p, t) => p -> shiftBinderDepth(t, 1) }\n        TypeLambda(params, substitute(body, shifted))\n      case Intersection(comps) => Intersection(comps.map(go))\n      case Union(comps) => Union(comps.map(go))\n      case Structural(parents, members) =>\n        Structural(parents.map(go), members.map(substituteMember(_, subs)))\n      case Function(params, result) => Function(params.map(go), go(result))\n      case ContextFunction(params, result) => ContextFunction(params.map(go), go(result))\n      case PolyFunction(tps, result) => PolyFunction(tps, go(result))\n      case DependentFunction(params, result) =>\n        DependentFunction(params.map(p => p.copy(tpe = go(p.tpe))), go(result))\n      case ByName(u) => ByName(go(u))\n      case Repeated(u) => Repeated(go(u))\n      case Tuple(elems) => Tuple(elems.map(e => e.copy(tpe = go(e.tpe))))\n      case MatchType(bound, scrutinee, cases) =>\n        MatchType(go(bound), go(scrutinee), cases.map(substituteMatchCase(_, subs)))\n      case Wildcard(bounds) => Wildcard(substituteBounds(bounds, subs))\n      case RecType(body) => RecType(go(body))\n      case Annotated(underlying, anns) => Annotated(go(underlying), anns)\n      case TypeSelect(_, _) | TypeProjection(_, _) | Singleton(_) |\n           ThisType(_) | SuperType(_, _) | ConstantType(_) | RecThis |\n           AnyType | AnyKindType | NothingType | NullType | UnitType => r\n    }\n    go(repr)\n  }\n\n  private def shiftBinderDepth(repr: TypeRepr, delta: Int): TypeRepr = repr match {\n    case ParamRef(param, depth) => ParamRef(param, depth + delta)\n    case Applied(tycon, args) => Applied(shiftBinderDepth(tycon, delta), args.map(shiftBinderDepth(_, delta)))\n    // ... other cases follow same pattern\n    case other => other  // Simplified; full impl would recurse\n  }\n\n  private def substituteBounds(bounds: TypeBounds, subs: Map[TypeParam, TypeRepr]): TypeBounds =\n    TypeBounds(bounds.lower.map(substitute(_, subs)), bounds.upper.map(substitute(_, subs)))\n\n  private def substituteMatchCase(c: MatchTypeCase, subs: Map[TypeParam, TypeRepr]): MatchTypeCase = {\n    // Remove bindings from substitution map (they shadow outer params)\n    val shadowedSubs = subs -- c.bindings\n    MatchTypeCase(c.bindings, substitute(c.pattern, shadowedSubs), substitute(c.result, shadowedSubs))\n  }\n\n  private def substituteMember(m: Member, subs: Map[TypeParam, TypeRepr]): Member = m match {\n    case Member.Val(name, tpe, isMutable, targetName, annotations) =>\n      Member.Val(name, substitute(tpe, subs), isMutable, targetName, annotations)\n    case Member.Def(name, typeParams, paramClauses, result, targetName, annotations) =>\n      Member.Def(\n        name, typeParams,\n        paramClauses.map(substituteParamClause(_, subs)),\n        substitute(result, subs),\n        targetName, annotations\n      )\n    case Member.TypeMember(name, typeParams, bounds, alias, annotations) =>\n      Member.TypeMember(\n        name, typeParams,\n        substituteBounds(bounds, subs),\n        alias.map(substitute(_, subs)),\n        annotations\n      )\n  }\n\n  private def substituteParamClause(clause: ParamClause, subs: Map[TypeParam, TypeRepr]): ParamClause = {\n    def subParam(p: Param): Param = p.copy(tpe = substitute(p.tpe, subs))\n    clause match {\n      case ParamClause.Regular(params) => ParamClause.Regular(params.map(subParam))\n      case ParamClause.Using(params) => ParamClause.Using(params.map(subParam))\n      case ParamClause.Implicit(params) => ParamClause.Implicit(params.map(subParam))\n    }\n  }\n}\n```\n\n---\n\n## Members: For Structural Types\n```scala\nsealed trait Member\n\nobject Member {\n  final case class Val(\n    name: String,\n    tpe: TypeRepr,\n    isMutable: Boolean = false,\n    targetName: Option[String] = None,  // @targetName annotation\n    annotations: List[Annotation] = Nil\n  ) extends Member\n\n  final case class Def(\n    name: String,\n    typeParams: List[TypeParam] = Nil,\n    paramClauses: List[ParamClause] = Nil,\n    result: TypeRepr,\n    targetName: Option[String] = None,\n    annotations: List[Annotation] = Nil\n  ) extends Member {\n    def arity: Int = paramClauses.map(_.size).sum\n  }\n\n  final case class TypeMember(\n    name: String,\n    typeParams: List[TypeParam] = Nil,\n    bounds: TypeBounds = TypeBounds.empty,\n    alias: Option[TypeRepr] = None,  // Some = type alias, None = abstract\n    annotations: List[Annotation] = Nil\n  ) extends Member {\n    def isAbstract: Boolean = alias.isEmpty && bounds != TypeBounds.empty\n    def isAlias: Boolean = alias.isDefined\n  }\n}\n```\n\n---\n\n## Constants and Annotations\n\n### Constant\n```scala\nsealed trait Constant {\n  type Value\n  def value: Value\n}\n\nobject Constant {\n  final case class IntConst(value: Int) extends Constant { type Value = Int }\n  final case class LongConst(value: Long) extends Constant { type Value = Long }\n  final case class FloatConst(value: Float) extends Constant { type Value = Float }\n  final case class DoubleConst(value: Double) extends Constant { type Value = Double }\n  final case class BooleanConst(value: Boolean) extends Constant { type Value = Boolean }\n  final case class CharConst(value: Char) extends Constant { type Value = Char }\n  final case class StringConst(value: String) extends Constant { type Value = String }\n  final case class NullConst() extends Constant { type Value = Null; def value: Null = null }\n  final case class UnitConst() extends Constant { type Value = Unit; def value: Unit = () }\n  final case class ClassOfConst(tpe: TypeRepr) extends Constant { type Value = TypeRepr; def value: TypeRepr = tpe }\n}\n```\n\n### Annotation\n```scala\nfinal case class Annotation(\n  tpe: TypeRepr,\n  args: List[AnnotationArg]\n)\n\nsealed trait AnnotationArg\n\nobject AnnotationArg {\n  final case class ConstArg(value: Constant) extends AnnotationArg\n  final case class ArrayArg(elements: List[AnnotationArg]) extends AnnotationArg\n  final case class NestedArg(annotation: Annotation) extends AnnotationArg\n  final case class TypeArg(tpe: TypeRepr) extends AnnotationArg\n  final case class NamedArg(name: String, value: AnnotationArg) extends AnnotationArg\n}\n```\n\n---\n\n## Type Operations\n\n### Normalization\n\nExpands type aliases to their underlying types.\n```scala\nobject TypeNormalization {\n  \n  /**\n   * Normalize a type by expanding type aliases.\n   * Does NOT expand opaque types (they are nominally distinct).\n   */\n  def normalize(tpe: TypeRepr): TypeRepr = tpe match {\n    // Direct alias reference with no args\n    case TypeRepr.Ref(TypeId.Alias(_, _, Nil, aliased)) =>\n      normalize(aliased)\n    \n    // Applied alias: expand and substitute\n    case TypeRepr.Applied(TypeRepr.Ref(TypeId.Alias(_, _, params, aliased)), args) \n        if params.size == args.size =>\n      val subs = params.zip(args.map(normalize)).toMap\n      normalize(TypeRepr.substitute(aliased, subs))\n    \n    // Recurse into compound types\n    case TypeRepr.Applied(tycon, args) =>\n      TypeRepr.Applied(normalize(tycon), args.map(normalize))\n    \n    case TypeRepr.Intersection(comps) =>\n      TypeRepr.Intersection(comps.map(normalize))\n    \n    case TypeRepr.Union(comps) =>\n      TypeRepr.Union(comps.map(normalize))\n    \n    case TypeRepr.Function(params, result) =>\n      TypeRepr.Function(params.map(normalize), normalize(result))\n    \n    case TypeRepr.ContextFunction(params, result) =>\n      TypeRepr.ContextFunction(params.map(normalize), normalize(result))\n    \n    case TypeRepr.Tuple(elems) =>\n      TypeRepr.Tuple(elems.map(e => e.copy(tpe = normalize(e.tpe))))\n    \n    case TypeRepr.ByName(u) => TypeRepr.ByName(normalize(u))\n    case TypeRepr.Repeated(u) => TypeRepr.Repeated(normalize(u))\n    case TypeRepr.Annotated(u, anns) => TypeRepr.Annotated(normalize(u), anns)\n    case TypeRepr.Wildcard(bounds) => \n      TypeRepr.Wildcard(TypeBounds(bounds.lower.map(normalize), bounds.upper.map(normalize)))\n    \n    // Atoms don't change\n    case _ => tpe\n  }\n  \n  /**\n   * Get the underlying representation of an opaque type.\n   * Only valid within the opaque type's defining scope.\n   */\n  def unwrapOpaque(tpe: TypeRepr): Option[TypeRepr] = tpe match {\n    case TypeRepr.Ref(TypeId.Opaque(_, _, Nil, repr, _)) =>\n      Some(repr)\n    case TypeRepr.Applied(TypeRepr.Ref(TypeId.Opaque(_, _, params, repr, _)), args)\n        if params.size == args.size =>\n      val subs = params.zip(args).toMap\n      Some(TypeRepr.substitute(repr, subs))\n    case _ => None\n  }\n}\n```\n\n### Type Equality\n```scala\nobject TypeEquality {\n  \n  /**\n   * Check if two types are equal (after normalization).\n   * This is structural equality, not reference equality.\n   */\n  def areEqual(a: TypeRepr, b: TypeRepr): Boolean = {\n    val aNorm = TypeNormalization.normalize(a)\n    val bNorm = TypeNormalization.normalize(b)\n    structurallyEqual(aNorm, bNorm)\n  }\n  \n  private def structurallyEqual(a: TypeRepr, b: TypeRepr): Boolean = (a, b) match {\n    case (TypeRepr.Ref(idA), TypeRepr.Ref(idB)) =>\n      idA.fullName == idB.fullName\n    \n    case (TypeRepr.ParamRef(pA, dA), TypeRepr.ParamRef(pB, dB)) =>\n      pA.index == pB.index && dA == dB\n    \n    case (TypeRepr.Applied(tcA, argsA), TypeRepr.Applied(tcB, argsB)) =>\n      structurallyEqual(tcA, tcB) && \n        argsA.size == argsB.size &&\n        argsA.zip(argsB).forall { case (x, y) => structurallyEqual(x, y) }\n    \n    case (TypeRepr.Intersection(cA), TypeRepr.Intersection(cB)) =>\n      cA.size == cB.size && cA.zip(cB).forall { case (x, y) => structurallyEqual(x, y) }\n    \n    case (TypeRepr.Union(cA), TypeRepr.Union(cB)) =>\n      cA.size == cB.size && cA.zip(cB).forall { case (x, y) => structurallyEqual(x, y) }\n    \n    case (TypeRepr.Function(pA, rA), TypeRepr.Function(pB, rB)) =>\n      pA.size == pB.size &&\n        pA.zip(pB).forall { case (x, y) => structurallyEqual(x, y) } &&\n        structurallyEqual(rA, rB)\n    \n    case (TypeRepr.Tuple(eA), TypeRepr.Tuple(eB)) =>\n      eA.size == eB.size && eA.zip(eB).forall { case (x, y) => \n        x.label == y.label && structurallyEqual(x.tpe, y.tpe)\n      }\n    \n    case (TypeRepr.ConstantType(cA), TypeRepr.ConstantType(cB)) =>\n      cA == cB\n    \n    case (TypeRepr.AnyType, TypeRepr.AnyType) => true\n    case (TypeRepr.NothingType, TypeRepr.NothingType) => true\n    case (TypeRepr.NullType, TypeRepr.NullType) => true\n    case (TypeRepr.UnitType, TypeRepr.UnitType) => true\n    \n    // More cases for full coverage...\n    case _ => false\n  }\n}\n```\n\n### Subtyping\n```scala\nobject Subtyping {\n  \n  /**\n   * Context for subtyping calculations.\n   * Tracks assumptions to handle recursive types and avoid infinite loops.\n   */\n  final case class Context(\n    assumptions: Set[(TypeRepr, TypeRepr)] = Set.empty,\n    depth: Int = 0,\n    maxDepth: Int = 100\n  ) {\n    def assume(sub: TypeRepr, sup: TypeRepr): Context =\n      copy(assumptions = assumptions + ((sub, sup)))\n    \n    def isAssumed(sub: TypeRepr, sup: TypeRepr): Boolean =\n      assumptions.contains((sub, sup))\n    \n    def deeper: Context = copy(depth = depth + 1)\n    def tooDeep: Boolean = depth >= maxDepth\n  }\n  \n  /**\n   * Check if `sub` is a subtype of `sup`.\n   * \n   * Implements the Scala 3 subtyping rules including:\n   * - Reflexivity: A <: A\n   * - Top: A <: Any for all A\n   * - Bottom: Nothing <: A for all A  \n   * - Variance-aware generic subtyping\n   * - Union/intersection type rules\n   * - Structural subtyping\n   */\n  def isSubtype(sub: TypeRepr, sup: TypeRepr)(using ctx: Context = Context()): Boolean = ???\n  \n  /**\n   * Check if two types are equivalent (mutual subtypes).\n   */\n  def isEquivalent(a: TypeRepr, b: TypeRepr)(using ctx: Context = Context()): Boolean =\n    isSubtype(a, b) && isSubtype(b, a)\n  \n  /**\n   * Find the least upper bound (LUB) of two types.\n   * Returns the most specific type that is a supertype of both.\n   */\n  def lub(a: TypeRepr, b: TypeRepr): TypeRepr = ???\n  \n  /**\n   * Find the greatest lower bound (GLB) of two types.\n   * Returns the most general type that is a subtype of both.\n   */\n  def glb(a: TypeRepr, b: TypeRepr): TypeRepr = ???\n  \n  /**\n   * Check if a type conforms to given bounds.\n   */\n  def conformsToBounds(tpe: TypeRepr, bounds: TypeBounds)(using ctx: Context = Context()): Boolean = {\n    val lowerOk = bounds.lower.forall(lo => isSubtype(lo, tpe))\n    val upperOk = bounds.upper.forall(hi => isSubtype(tpe, hi))\n    lowerOk && upperOk\n  }\n  \n  /**\n   * Reduce a match type to its result, if possible.\n   * Returns None if the match type cannot be reduced (e.g., abstract scrutinee).\n   */\n  def reduceMatchType(mt: TypeRepr.MatchType)(using ctx: Context = Context()): Option[TypeRepr] = ???\n}\n```\n\n---\n\n## Standard Library Type Definitions\n\nPredefined `TypeId` instances for common types.\n```scala\nobject StandardTypes {\n  import TypeDefKind.*\n  \n  private val scalaOwner = Owner.pkg(\"scala\")\n  private val scalaCollectionImmutable = Owner.pkgs(\"scala\", \"collection\", \"immutable\")\n  private val javaLang = Owner.pkgs(\"java\", \"lang\")\n  \n  // ========== Primitives ==========\n  \n  val IntId: TypeId[Int] = TypeId.nominal[Int](\n    \"Int\", scalaOwner, Nil, Class(isFinal = true, isValue = true)\n  )\n  \n  val LongId: TypeId[Long] = TypeId.nominal[Long](\n    \"Long\", scalaOwner, Nil, Class(isFinal = true, isValue = true)\n  )\n  \n  val DoubleId: TypeId[Double] = TypeId.nominal[Double](\n    \"Double\", scalaOwner, Nil, Class(isFinal = true, isValue = true)\n  )\n  \n  val FloatId: TypeId[Float] = TypeId.nominal[Float](\n    \"Float\", scalaOwner, Nil, Class(isFinal = true, isValue = true)\n  )\n  \n  val BooleanId: TypeId[Boolean] = TypeId.nominal[Boolean](\n    \"Boolean\", scalaOwner, Nil, Class(isFinal = true, isValue = true)\n  )\n  \n  val CharId: TypeId[Char] = TypeId.nominal[Char](\n    \"Char\", scalaOwner, Nil, Class(isFinal = true, isValue = true)\n  )\n  \n  val ByteId: TypeId[Byte] = TypeId.nominal[Byte](\n    \"Byte\", scalaOwner, Nil, Class(isFinal = true, isValue = true)\n  )\n  \n  val ShortId: TypeId[Short] = TypeId.nominal[Short](\n    \"Short\", scalaOwner, Nil, Class(isFinal = true, isValue = true)\n  )\n  \n  val UnitId: TypeId[Unit] = TypeId.nominal[Unit](\n    \"Unit\", scalaOwner, Nil, Class(isFinal = true, isValue = true)\n  )\n  \n  // ========== Reference Types ==========\n  \n  val StringId: TypeId[String] = TypeId.nominal[String](\n    \"String\", javaLang, Nil, Class(isFinal = true)\n  )\n  \n  val AnyId: TypeId[Any] = TypeId.nominal[Any](\n    \"Any\", scalaOwner, Nil, Class(isAbstract = true)\n  )\n  \n  val AnyRefId: TypeId[AnyRef] = TypeId.nominal[AnyRef](\n    \"AnyRef\", scalaOwner, Nil, Class(isAbstract = true),\n    parents = List(TypeRepr.Ref(AnyId))\n  )\n  \n  val AnyValId: TypeId[AnyVal] = TypeId.nominal[AnyVal](\n    \"AnyVal\", scalaOwner, Nil, Class(isAbstract = true),\n    parents = List(TypeRepr.Ref(AnyId))\n  )\n  \n  val NothingId: TypeId[Nothing] = TypeId.nominal[Nothing](\n    \"Nothing\", scalaOwner, Nil, Class(isFinal = true, isAbstract = true)\n  )\n  \n  val NullId: TypeId[Null] = TypeId.nominal[Null](\n    \"Null\", scalaOwner, Nil, Class(isFinal = true)\n  )\n  \n  // ========== Collection Type Constructors ==========\n  \n  private val A = TypeParam.covariant(\"A\", 0)\n  private val K = TypeParam.invariant(\"K\", 0)\n  private val V = TypeParam.covariant(\"V\", 1)\n  \n  val ListId: TypeId[List] = TypeId.nominal[List](\n    \"List\", scalaCollectionImmutable, List(A), Trait(isSealed = true)\n  )\n  \n  val VectorId: TypeId[Vector] = TypeId.nominal[Vector](\n    \"Vector\", scalaCollectionImmutable, List(A), Class(isFinal = true)\n  )\n  \n  val SetId: TypeId[Set] = TypeId.nominal[Set](\n    \"Set\", scalaCollectionImmutable, List(A), Trait()\n  )\n  \n  val MapId: TypeId[Map] = TypeId.nominal[Map](\n    \"Map\", scalaCollectionImmutable, List(K, V), Trait()\n  )\n  \n  val OptionId: TypeId[Option] = TypeId.nominal[Option](\n    \"Option\", scalaOwner, List(A), Trait(isSealed = true)\n  )\n  \n  val EitherA = TypeParam.covariant(\"A\", 0)\n  val EitherB = TypeParam.covariant(\"B\", 1)\n  val EitherId: TypeId[Either] = TypeId.nominal[Either](\n    \"Either\", scalaOwner, List(EitherA, EitherB), Trait(isSealed = true)\n  )\n  \n  // ========== Tuple Type Constructors ==========\n  \n  val EmptyTupleId: TypeId[EmptyTuple] = TypeId.nominal[EmptyTuple](\n    \"EmptyTuple\", scalaOwner, Nil, Object\n  )\n  \n  val TupleConsH = TypeParam.covariant(\"H\", 0)\n  val TupleConsT = TypeParam.covariant(\"T\", 1, bounds = TypeBounds.upper(TypeRepr.Ref(???))) // <: Tuple\n  val TupleConsId: TypeId[*:] = TypeId.nominal[*:](\n    \"*:\", scalaOwner, List(TupleConsH, TupleConsT), Class(isFinal = true, isCase = true)\n  )\n  \n  // ========== Convenience TypeRepr Builders ==========\n  \n  def int: TypeRepr = TypeRepr.Ref(IntId)\n  def long: TypeRepr = TypeRepr.Ref(LongId)\n  def double: TypeRepr = TypeRepr.Ref(DoubleId)\n  def float: TypeRepr = TypeRepr.Ref(FloatId)\n  def boolean: TypeRepr = TypeRepr.Ref(BooleanId)\n  def string: TypeRepr = TypeRepr.Ref(StringId)\n  def unit: TypeRepr = TypeRepr.UnitType\n  def any: TypeRepr = TypeRepr.AnyType\n  def nothing: TypeRepr = TypeRepr.NothingType\n  \n  def list(elem: TypeRepr): TypeRepr = TypeRepr.Applied(TypeRepr.Ref(ListId), List(elem))\n  def option(elem: TypeRepr): TypeRepr = TypeRepr.Applied(TypeRepr.Ref(OptionId), List(elem))\n  def map(key: TypeRepr, value: TypeRepr): TypeRepr = TypeRepr.Applied(TypeRepr.Ref(MapId), List(key, value))\n  def either(left: TypeRepr, right: TypeRepr): TypeRepr = TypeRepr.Applied(TypeRepr.Ref(EitherId), List(left, right))\n}\n```\n\n---\n\n## Example Usage\n```scala\nobject Examples {\n  import TypeRepr.*\n  import StandardTypes.*\n  \n  // ========== Simple Types ==========\n  \n  val intType: TypeRepr = int\n  val stringType: TypeRepr = string\n  val listOfInt: TypeRepr = list(int)\n  val mapStringToInt: TypeRepr = map(string, int)\n  \n  // ========== Named Tuple ==========\n  \n  // (name: String, age: Int)\n  val personTuple: TypeRepr = Tuple.named(\n    \"name\" -> string,\n    \"age\" -> int\n  )\n  \n  // ========== Type Alias ==========\n  \n  // type Age = Int\n  val AgeId: TypeId[Int] = TypeId.alias[Int](\n    \"Age\",\n    Owner.pkg(\"myapp\"),\n    Nil,\n    int\n  )\n  \n  // type StringMap[V] = Map[String, V]\n  val V = TypeParam.covariant(\"V\", 0)\n  val StringMapId: TypeId[Map[String, *]] = TypeId.alias[Map[String, *]](\n    \"StringMap\",\n    Owner.pkg(\"myapp\"),\n    List(V),\n    Applied(Ref(MapId), List(string, ParamRef(V)))\n  )\n  \n  // ========== Opaque Type ==========\n  \n  // opaque type Email = String\n  val EmailId: TypeId[String] = TypeId.opaque[String](\n    \"Email\",\n    Owner.pkg(\"myapp\"),\n    Nil,\n    string\n  )\n  \n  // ========== Enum ==========\n  \n  val ColorId: TypeId[?] = TypeId.nominal(\n    \"Color\",\n    Owner.pkg(\"myapp\"),\n    Nil,\n    TypeDefKind.Enum(List(\n      EnumCaseInfo(\"Red\", 0, Nil, isObjectCase = true),\n      EnumCaseInfo(\"Green\", 1, Nil, isObjectCase = true),\n      EnumCaseInfo(\"Blue\", 2, Nil, isObjectCase = true),\n      EnumCaseInfo(\"RGB\", 3, List(\n        EnumCaseParam(\"r\", int),\n        EnumCaseParam(\"g\", int),\n        EnumCaseParam(\"b\", int)\n      ), isObjectCase = false)\n    ))\n  )\n  \n  // ========== Match Type ==========\n  \n  // type Elem[X] = X match { case String => Char; case Array[t] => t }\n  val X = TypeParam.invariant(\"X\", 0)\n  val t = TypeParam.invariant(\"t\", 0)\n  \n  val ElemId: TypeId[?] = TypeId.alias(\n    \"Elem\",\n    Owner.pkg(\"myapp\"),\n    List(X),\n    MatchType(\n      bound = any,\n      scrutinee = ParamRef(X),\n      cases = List(\n        MatchTypeCase(Nil, string, Ref(CharId)),\n        MatchTypeCase(\n          List(t),\n          Applied(Ref(???), List(ParamRef(t))), // Array[t]\n          ParamRef(t)\n        )\n      )\n    )\n  )\n  \n  // ========== Structural Type ==========\n  \n  // { def size: Int; val name: String }\n  val sizedNamed: TypeRepr = Structural(\n    parents = Nil,\n    members = List(\n      Member.Def(\"size\", Nil, Nil, int),\n      Member.Val(\"name\", string)\n    )\n  )\n  \n  // ========== Path-Dependent Type ==========\n  \n  // myModule.Inner.T\n  val pathDependent: TypeRepr = TypeSelect(\n    TermPath(List(\n      TermPath.Package(\"myapp\"),\n      TermPath.Module(\"myModule\"),\n      TermPath.Module(\"Inner\")\n    )),\n    \"T\"\n  )\n  \n  // ========== Intersection & Union ==========\n  \n  // String & { def foo: Int }\n  val stringWithFoo: TypeRepr = Intersection(\n    string,\n    Structural(Nil, List(Member.Def(\"foo\", Nil, Nil, int)))\n  )\n  \n  // String | Int\n  val stringOrInt: TypeRepr = Union(string, int)\n  \n  // ========== Function Types ==========\n  \n  // (Int, String) => Boolean\n  val func: TypeRepr = Function(List(int, string), boolean)\n  \n  // (Int, String) ?=> Boolean (context function)\n  val ctxFunc: TypeRepr = ContextFunction(List(int, string), boolean)\n  \n  // [A] => A => A (polymorphic function)\n  val polyFunc: TypeRepr = PolyFunction(\n    List(TypeParam.invariant(\"A\", 0)),\n    Function(List(ParamRef(TypeParam.invariant(\"A\", 0))), ParamRef(TypeParam.invariant(\"A\", 0)))\n  )\n}\n```\n\n---\n\n## Macro Derivation (Sketch)\n```scala\nimport scala.quoted.*\n\nobject TypeIdMacros {\n  \n  /**\n   * Derive a TypeId for any type or type constructor at compile time.\n   * Captures all type information available to the compiler.\n   */\n  inline def derive[A <: AnyKind]: TypeId[A] = ${ deriveMacro[A] }\n  \n  def deriveMacro[A <: AnyKind: Type](using Quotes): Expr[TypeId[A]] = {\n    import quotes.reflect.*\n    \n    val tpe = TypeRepr.of[A]\n    \n    // Extract type information from compiler\n    // ... implementation details ...\n    \n    ???\n  }\n  \n  /**\n   * Derive a TypeRepr for a concrete type at compile time.\n   */\n  inline def typeRepr[A]: TypeRepr = ${ typeReprMacro[A] }\n  \n  def typeReprMacro[A: Type](using Quotes): Expr[TypeRepr] = ???\n}\n```\n\n---\n\n## Open Questions / Future Work\n\n1. **Recursive type handling**: The `RecType`/`RecThis` encoding may need refinement for complex recursive types.\n\n2. **Match type reduction**: Full implementation requires tracking what patterns are \"provably disjoint.\"\n\n3. **Structural subtyping**: Member-by-member comparison with proper handling of overloaded methods.\n\n4. **Scala 2 compatibility**: Some constructs (existentials, compound types) may need additional representation.\n\n5. **Serialization format**: The data model is designed for runtime use; a compact serialization format (e.g., protobuf schema) would be a natural next step.",
                  "html_url": "https://github.com/zio/zio-blocks/issues/471"
                },
                "type": "github"
              },
              "hash": "zio/zio-blocks#471",
              "body": "# Design and Implement `TypeId` for Type Registry\n\n## Goal\n\nDesign and implement a `TypeId[A]` data structure that can faithfully represent any Scala type or type constructor, capturing sufficient metadata to support:\n\n- **Type identity**: Uniquely identifying types across serialization boundaries\n- **Subtype checking**: Implementing `isSubtypeOf` directly on `TypeId` without runtime reflection\n- **Type equality**: Determining structural and nominal type equivalence\n- **Map/Set keys**: Using `TypeId` as keys in type registries (requires correct `equals`/`hashCode`)\n- **Macro derivation**: Derivation of `TypeId` for any type or type constructor, source-compatible across Scala 2/3\n\nThe data type must be used to wholly replace `TypeName` in the source code of ZIO Blocks.\n\n## Requirements\n\n### API Surface\n```scala\n// Explicit derivation\nval stringId: TypeId[String] = TypeId.of[String]\nval listId: TypeId[List] = TypeId.of[List]  // Type constructors supported\n\n// Implicit derivation for generic code\ndef process[A](value: A)(implicit typeId: TypeId[A]): Unit = ???\n\n// Or using Scala 3 context bounds\ndef process[A: TypeId](value: A): Unit = ???\n\n// Use as map keys in type registries\nval registry: Map[TypeId[_], Binding[_]] = Map(\n  TypeId.of[String] -> stringBinding,\n  TypeId.of[List[Int]] -> listIntBinding\n)\n```\n\n### Cross-Version Support\n\n- **Scala 2.13**: Use `scala.reflect.macros` for compile-time derivation\n- **Scala 3.x (3.0–3.7+)**: Use `scala.quoted` macros\n\nThe runtime data model (`TypeId`, `TypeRepr`, etc.) should be shared across versions. Only the macro implementations differ.\n\n### Equals and HashCode Contract\n\n`TypeId` instances will be used as keys in `Map` and `Set` collections within type registries. The `equals` and `hashCode` implementations must satisfy the following requirements:\n\n#### Equality Semantics\n\n1. **Nominal identity for non-aliases**: Two `TypeId` instances referring to the same nominal type (same `fullName`) are equal, regardless of when/where the macro derived them.\n\n2. **Type alias transparency**: Type aliases should be equal to their underlying types after normalization.\n```scala\n   type Age = Int\n   TypeId.of[Age] == TypeId.of[Int]  // true (after normalization)\n```\n\n3. **Opaque type nominality**: Opaque types are *not* equal to their representation or to other opaque types.\n```scala\n   opaque type Email = String\n   opaque type UserId = String\n   TypeId.of[Email] == TypeId.of[String]  // false\n   TypeId.of[Email] == TypeId.of[UserId]  // false\n```\n\n4. **Applied types**: Two applied types are equal iff their type constructors are equal and all type arguments are equal.\n```scala\n   TypeId.of[List[Int]] == TypeId.of[List[Int]]      // true\n   TypeId.of[List[Int]] == TypeId.of[List[String]]  // false\n```\n\n5. **Structural types**: Two structural types are equal iff they have the same members (by name and type).\n\n6. **Compound types**: Order matters for intersections and unions (or they must be normalized to a canonical order).\n```scala\n   // Option A: Order-sensitive\n   TypeId.of[A & B] != TypeId.of[B & A]\n   \n   // Option B: Canonicalized (preferred)\n   TypeId.of[A & B] == TypeId.of[B & A]  // after sorting components\n```\n\n#### HashCode Requirements\n\n1. **Consistency**: `hashCode` must be consistent with `equals`—equal objects must have equal hash codes.\n\n2. **Stability**: The same `TypeId` derived in different compilation units or at different times must produce the same `hashCode`.\n\n3. **Distribution**: Hash codes should be well-distributed to avoid collisions in hash maps.\n\n4. **Determinism**: `hashCode` must not depend on object identity, memory addresses, or other non-deterministic factors.\n\n#### Implementation Approach\n```scala\nsealed trait TypeId[A <: AnyKind] {\n  // ... other members ...\n\n  /** \n   * Equality based on normalized type structure.\n   * Type aliases are expanded before comparison.\n   */\n  override def equals(other: Any): Boolean = other match {\n    case that: TypeId[_] => TypeId.structurallyEqual(this, that)\n    case _ => false\n  }\n\n  /**\n   * Hash code based on normalized type structure.\n   * Must be consistent with equals.\n   */\n  override def hashCode(): Int = TypeId.structuralHash(this)\n}\n\nobject TypeId {\n  /**\n   * Compare two TypeIds for structural equality after normalization.\n   */\n  def structurallyEqual(a: TypeId[_], b: TypeId[_]): Boolean = {\n    // 1. Normalize both (expand aliases)\n    // 2. Compare structure recursively\n    // 3. For opaque types, compare by fullName only (nominal)\n    ???\n  }\n\n  /**\n   * Compute a stable hash code for a TypeId.\n   */\n  def structuralHash(id: TypeId[_]): Int = {\n    // 1. Normalize (expand aliases)\n    // 2. Compute hash from structural components\n    // 3. Must use stable values (fullName, not object identity)\n    ???\n  }\n}\n```\n\n#### Edge Cases\n\n- **Recursive types**: Must handle cycles without infinite loops in both `equals` and `hashCode`.\n- **Type parameters**: `TypeId.of[List]` (unapplied) must have different hash than `TypeId.of[List[Int]]` (applied).\n- **Path-dependent types**: `a.T` and `b.T` are equal only if `a` and `b` are the same stable path.\n- **Local types**: Types defined in local scopes need unique identification (e.g., include source location or synthetic index).\n\n### Key Operations\n```scala\ntrait TypeId[A <: AnyKind] {\n  def name: String\n  def fullName: String\n  def owner: Owner\n  def typeParams: List[TypeParam]\n  def parents: List[TypeRepr]\n  \n  // Core operations\n  def isSubtypeOf(other: TypeId[_]): Boolean\n  def isSupertypeOf(other: TypeId[_]): Boolean\n  def isEquivalentTo(other: TypeId[_]): Boolean\n  \n  // Equality (for use as map keys)\n  override def equals(other: Any): Boolean\n  override def hashCode(): Int\n}\n```\n\n## Attached Design Document\n\nSee the attached `TypeId-DataModel.md` for a comprehensive sketch of:\n\n- Core data structures (`TypeId`, `TypeRepr`, `TypeParam`, `Owner`, etc.)\n- Type expression representation (applied types, intersections, unions, match types, etc.)\n- Variance and bounds modeling\n- Substitution and normalization algorithms\n- Standard library type definitions\n\n> [!WARNING]\n> **The attached document is a design sketch, not production code.** Some details may be incorrect, incomplete, or require adjustment during implementation. It should be treated as a starting point for discussion and iteration, not a specification to implement verbatim.\n\n## Test Strategy\n\nComprehensive testing should validate four layers: **macro derivation correctness**, **data model completeness**, **type operation correctness**, and **equals/hashCode correctness**.\n\n### 1. Equals and HashCode Tests\n\nThese tests are critical since `TypeId` will be used as map keys.\n\n#### Basic Contract Tests\n```scala\ntest(\"equals is reflexive\") {\n  val id = TypeId.of[String]\n  assertTrue(id == id)\n  assertTrue(id.equals(id))\n}\n\ntest(\"equals is symmetric\") {\n  val id1 = TypeId.of[String]\n  val id2 = TypeId.of[String]\n  assertTrue(id1 == id2)\n  assertTrue(id2 == id1)\n}\n\ntest(\"equals is transitive\") {\n  val id1 = TypeId.of[String]\n  val id2 = TypeId.of[String]\n  val id3 = TypeId.of[String]\n  assertTrue(id1 == id2)\n  assertTrue(id2 == id3)\n  assertTrue(id1 == id3)\n}\n\ntest(\"hashCode is consistent with equals\") {\n  val id1 = TypeId.of[String]\n  val id2 = TypeId.of[String]\n  assertTrue(id1 == id2)\n  assertTrue(id1.hashCode == id2.hashCode)\n}\n\ntest(\"hashCode is stable across invocations\") {\n  val id = TypeId.of[List[Int]]\n  val hash1 = id.hashCode\n  val hash2 = id.hashCode\n  assertTrue(hash1 == hash2)\n}\n```\n\n#### Nominal Type Equality\n```scala\ntest(\"same nominal types are equal\") {\n  assertTrue(TypeId.of[String] == TypeId.of[String])\n  assertTrue(TypeId.of[Int] == TypeId.of[Int])\n  assertTrue(TypeId.of[List[Int]] == TypeId.of[List[Int]])\n}\n\ntest(\"different nominal types are not equal\") {\n  assertTrue(TypeId.of[String] != TypeId.of[Int])\n  assertTrue(TypeId.of[List[Int]] != TypeId.of[List[String]])\n  assertTrue(TypeId.of[List[Int]] != TypeId.of[Vector[Int]])\n}\n```\n\n#### Type Alias Equality\n```scala\ntest(\"type aliases equal their underlying types\") {\n  type Age = Int\n  type Name = String\n  \n  assertTrue(TypeId.of[Age] == TypeId.of[Int])\n  assertTrue(TypeId.of[Name] == TypeId.of[String])\n  assertTrue(TypeId.of[Age].hashCode == TypeId.of[Int].hashCode)\n}\n\ntest(\"chained type aliases resolve correctly\") {\n  type A = Int\n  type B = A\n  type C = B\n  \n  assertTrue(TypeId.of[C] == TypeId.of[Int])\n  assertTrue(TypeId.of[C] == TypeId.of[A])\n  assertTrue(TypeId.of[C] == TypeId.of[B])\n}\n\ntest(\"generic type aliases equal their expansion\") {\n  type MyList[A] = List[A]\n  \n  assertTrue(TypeId.of[MyList[Int]] == TypeId.of[List[Int]])\n  assertTrue(TypeId.of[MyList[String]] == TypeId.of[List[String]])\n}\n```\n\n#### Opaque Type Equality\n```scala\ntest(\"opaque types are not equal to their representation\") {\n  opaque type Email = String\n  \n  assertTrue(TypeId.of[Email] != TypeId.of[String])\n  assertTrue(TypeId.of[Email].hashCode != TypeId.of[String].hashCode) // likely but not guaranteed\n}\n\ntest(\"different opaque types are not equal even with same representation\") {\n  opaque type Email = String\n  opaque type UserId = String\n  \n  assertTrue(TypeId.of[Email] != TypeId.of[UserId])\n}\n\ntest(\"same opaque type is equal to itself\") {\n  opaque type Email = String\n  \n  assertTrue(TypeId.of[Email] == TypeId.of[Email])\n}\n```\n\n#### Applied Type Equality\n```scala\ntest(\"applied types with same constructor and args are equal\") {\n  assertTrue(TypeId.of[List[Int]] == TypeId.of[List[Int]])\n  assertTrue(TypeId.of[Map[String, Int]] == TypeId.of[Map[String, Int]])\n  assertTrue(TypeId.of[Either[String, Int]] == TypeId.of[Either[String, Int]])\n}\n\ntest(\"applied types with different args are not equal\") {\n  assertTrue(TypeId.of[List[Int]] != TypeId.of[List[String]])\n  assertTrue(TypeId.of[Map[String, Int]] != TypeId.of[Map[Int, String]])\n}\n\ntest(\"unapplied type constructor not equal to applied type\") {\n  assertTrue(TypeId.of[List] != TypeId.of[List[Int]])\n  assertTrue(TypeId.of[Map] != TypeId.of[Map[String, Int]])\n}\n```\n\n#### Compound Type Equality\n```scala\ntest(\"intersection types equality\") {\n  // Assuming canonicalized ordering\n  assertTrue(TypeId.of[Serializable & Comparable[String]] == TypeId.of[Serializable & Comparable[String]])\n}\n\ntest(\"union types equality\") {\n  assertTrue(TypeId.of[Int | String] == TypeId.of[Int | String])\n}\n```\n\n#### Map/Set Usage Tests\n```scala\ntest(\"TypeId works as Map key\") {\n  val map = Map[TypeId[_], String](\n    TypeId.of[String] -> \"string\",\n    TypeId.of[Int] -> \"int\",\n    TypeId.of[List[Int]] -> \"list-int\"\n  )\n  \n  assertTrue(map(TypeId.of[String]) == \"string\")\n  assertTrue(map(TypeId.of[Int]) == \"int\")\n  assertTrue(map(TypeId.of[List[Int]]) == \"list-int\")\n  assertTrue(map.get(TypeId.of[Double]).isEmpty)\n}\n\ntest(\"TypeId works as Map key with type aliases\") {\n  type Age = Int\n  \n  val map = Map[TypeId[_], String](\n    TypeId.of[Int] -> \"int\"\n  )\n  \n  // Should find the entry via alias\n  assertTrue(map(TypeId.of[Age]) == \"int\")\n}\n\ntest(\"TypeId works in Set\") {\n  val set = Set(\n    TypeId.of[String],\n    TypeId.of[Int],\n    TypeId.of[List[Int]]\n  )\n  \n  assertTrue(set.contains(TypeId.of[String]))\n  assertTrue(set.contains(TypeId.of[Int]))\n  assertTrue(!set.contains(TypeId.of[Double]))\n}\n\ntest(\"TypeId deduplication in Set\") {\n  type Age = Int\n  \n  val set = Set(\n    TypeId.of[Int],\n    TypeId.of[Age]  // Should deduplicate\n  )\n  \n  assertTrue(set.size == 1)\n}\n\ntest(\"mutable HashMap works with TypeId\") {\n  val map = scala.collection.mutable.HashMap[TypeId[_], String]()\n  \n  map(TypeId.of[String]) = \"string\"\n  map(TypeId.of[Int]) = \"int\"\n  \n  assertTrue(map(TypeId.of[String]) == \"string\")\n  \n  // Update via equal key\n  type Name = String\n  map(TypeId.of[Name]) = \"updated\"\n  assertTrue(map(TypeId.of[String]) == \"updated\")\n}\n```\n\n#### Cross-Compilation Equality\n```scala\ntest(\"TypeId equality is stable across compilation units\") {\n  // id1 derived in CompilationUnitA\n  val id1 = CompilationUnitA.stringTypeId\n  // id2 derived in CompilationUnitB  \n  val id2 = CompilationUnitB.stringTypeId\n  \n  assertTrue(id1 == id2)\n  assertTrue(id1.hashCode == id2.hashCode)\n}\n```\n\n### 2. Macro Derivation Tests\n\nVerify that the macro correctly captures type information for all supported type forms.\n\n#### Primitive and Basic Types\n```scala\ntest(\"derives primitives correctly\") {\n  assertTrue(TypeId.of[Int].name == \"Int\")\n  assertTrue(TypeId.of[String].fullName == \"java.lang.String\")\n  assertTrue(TypeId.of[Unit].isValueClass)\n}\n```\n\n#### Generic Types and Type Constructors\n```scala\ntest(\"derives type constructors\") {\n  val listId = TypeId.of[List]\n  assertTrue(listId.arity == 1)\n  assertTrue(listId.typeParams.head.variance == Variance.Covariant)\n}\n\ntest(\"derives applied types\") {\n  val listIntId = TypeId.of[List[Int]]\n  // Should capture that this is List applied to Int\n}\n\ntest(\"derives higher-kinded types\") {\n  val functorId = TypeId.of[Functor]  // Functor[F[_]]\n  assertTrue(functorId.typeParams.head.kind == Kind.`* -> *`)\n}\n```\n\n#### Type Aliases and Opaque Types\n```scala\ntype Age = Int\nopaque type Email = String\n\ntest(\"derives type aliases\") {\n  val ageId = TypeId.of[Age]\n  assertTrue(ageId.isAlias)\n  assertTrue(ageId.aliasedTo == Some(TypeRepr.Ref(TypeId.of[Int])))\n}\n\ntest(\"derives opaque types\") {\n  val emailId = TypeId.of[Email]\n  assertTrue(emailId.isOpaque)\n  // Representation should be captured\n}\n```\n\n#### Classes, Traits, Objects, Enums\n```scala\nsealed trait Animal\ncase class Dog(name: String) extends Animal\ncase object Cat extends Animal\n\nenum Color { case Red, Green, Blue, RGB(r: Int, g: Int, b: Int) }\n\ntest(\"derives sealed hierarchy\") {\n  val animalId = TypeId.of[Animal]\n  assertTrue(animalId.isSealed)\n  assertTrue(animalId.defKind match {\n    case TypeDefKind.Trait(true, subtypes) => subtypes.nonEmpty\n    case _ => false\n  })\n}\n\ntest(\"derives enums with cases\") {\n  val colorId = TypeId.of[Color]\n  assertTrue(colorId.enumCases.map(_.name) == List(\"Red\", \"Green\", \"Blue\", \"RGB\"))\n  assertTrue(colorId.enumCases.find(_.name == \"RGB\").exists(_.params.nonEmpty))\n}\n```\n\n#### Structural and Refinement Types\n```scala\ntest(\"derives structural types\") {\n  type Sized = { def size: Int }\n  val sizedId = TypeId.of[Sized]\n  // Should capture the structural member\n}\n```\n\n#### Compound Types\n```scala\ntest(\"derives intersection types\") {\n  val id = TypeId.of[String & Serializable]\n  // Should capture both components\n}\n\ntest(\"derives union types\") {\n  val id = TypeId.of[String | Int]\n  // Should capture both components\n}\n```\n\n#### Tuple Types (Including Named Tuples for Scala 3.5+)\n```scala\ntest(\"derives positional tuples\") {\n  val id = TypeId.of[(Int, String, Boolean)]\n  // Should capture element types\n}\n\ntest(\"derives named tuples\") {  // Scala 3.5+\n  val id = TypeId.of[(name: String, age: Int)]\n  // Should capture labels and types\n}\n```\n\n#### Function Types\n```scala\ntest(\"derives function types\") {\n  val id = TypeId.of[(Int, String) => Boolean]\n  // Should capture param types and result type\n}\n\ntest(\"derives context function types\") {  // Scala 3\n  val id = TypeId.of[(Int, String) ?=> Boolean]\n}\n\ntest(\"derives polymorphic function types\") {  // Scala 3\n  val id = TypeId.of[[A] => A => A]\n}\n```\n\n#### Path-Dependent and Singleton Types\n```scala\nobject Outer {\n  object Inner {\n    type T = Int\n  }\n  val inner: Inner.type = Inner\n}\n\ntest(\"derives path-dependent types\") {\n  val id = TypeId.of[Outer.Inner.T]\n  // Should capture the path\n}\n\ntest(\"derives singleton types\") {\n  val id = TypeId.of[Outer.Inner.type]\n}\n```\n\n#### Match Types (Scala 3)\n```scala\ntype Elem[X] = X match {\n  case String => Char\n  case Array[t] => t\n}\n\ntest(\"derives match types\") {\n  val id = TypeId.of[Elem]\n  // Should capture scrutinee, cases, and binders\n}\n```\n\n### 3. Data Model Completeness Tests\n\nVerify that round-tripping through the model preserves type information.\n```scala\ntest(\"TypeRepr substitution is correct\") {\n  val A = TypeParam(\"A\", 0)\n  val listOfA = TypeRepr.Applied(TypeRepr.Ref(listId), List(TypeRepr.ParamRef(A)))\n  val substituted = listOfA.substitute(Map(A -> TypeRepr.Ref(intId)))\n  assertTrue(substituted == TypeRepr.Applied(TypeRepr.Ref(listId), List(TypeRepr.Ref(intId))))\n}\n\ntest(\"normalization expands aliases\") {\n  type MyInt = Int\n  val myIntRepr = TypeRepr.Ref(TypeId.of[MyInt])\n  val normalized = TypeNormalization.normalize(myIntRepr)\n  assertTrue(normalized == TypeRepr.Ref(TypeId.of[Int]))\n}\n```\n\n### 4. Subtyping Tests\n\nVerify that `isSubtypeOf` correctly implements Scala's subtyping rules.\n\n#### Basic Subtyping\n```scala\ntest(\"Nothing is subtype of everything\") {\n  assertTrue(TypeId.of[Nothing].isSubtypeOf(TypeId.of[Int]))\n  assertTrue(TypeId.of[Nothing].isSubtypeOf(TypeId.of[String]))\n  assertTrue(TypeId.of[Nothing].isSubtypeOf(TypeId.of[Any]))\n}\n\ntest(\"everything is subtype of Any\") {\n  assertTrue(TypeId.of[Int].isSubtypeOf(TypeId.of[Any]))\n  assertTrue(TypeId.of[String].isSubtypeOf(TypeId.of[Any]))\n  assertTrue(TypeId.of[List[Int]].isSubtypeOf(TypeId.of[Any]))\n}\n\ntest(\"reflexivity\") {\n  assertTrue(TypeId.of[String].isSubtypeOf(TypeId.of[String]))\n  assertTrue(TypeId.of[List[Int]].isSubtypeOf(TypeId.of[List[Int]]))\n}\n```\n\n#### Variance-Aware Subtyping\n```scala\ntest(\"covariant type parameter subtyping\") {\n  // List is covariant: List[Dog] <: List[Animal]\n  assertTrue(TypeId.of[List[Dog]].isSubtypeOf(TypeId.of[List[Animal]]))\n  assertTrue(!TypeId.of[List[Animal]].isSubtypeOf(TypeId.of[List[Dog]]))\n}\n\ntest(\"contravariant type parameter subtyping\") {\n  // Function1 is contravariant in input: (Animal => Int) <: (Dog => Int)\n  assertTrue(TypeId.of[Animal => Int].isSubtypeOf(TypeId.of[Dog => Int]))\n  assertTrue(!TypeId.of[Dog => Int].isSubtypeOf(TypeId.of[Animal => Int]))\n}\n\ntest(\"invariant type parameter subtyping\") {\n  // Array is invariant\n  assertTrue(!TypeId.of[Array[Dog]].isSubtypeOf(TypeId.of[Array[Animal]]))\n  assertTrue(!TypeId.of[Array[Animal]].isSubtypeOf(TypeId.of[Array[Dog]]))\n}\n```\n\n#### Union and Intersection Types\n```scala\ntest(\"union type subtyping\") {\n  // A <: A | B and B <: A | B\n  assertTrue(TypeId.of[Int].isSubtypeOf(TypeId.of[Int | String]))\n  assertTrue(TypeId.of[String].isSubtypeOf(TypeId.of[Int | String]))\n  \n  // A | B <: C requires both A <: C and B <: C\n  assertTrue(!TypeId.of[Int | String].isSubtypeOf(TypeId.of[Int]))\n}\n\ntest(\"intersection type subtyping\") {\n  // A & B <: A and A & B <: B\n  assertTrue(TypeId.of[Serializable & Comparable[String]].isSubtypeOf(TypeId.of[Serializable]))\n  \n  // A <: B & C requires A <: B and A <: C\n}\n```\n\n#### Nominal Hierarchy Subtyping\n```scala\ntest(\"class hierarchy subtyping\") {\n  assertTrue(TypeId.of[Dog].isSubtypeOf(TypeId.of[Animal]))\n  assertTrue(TypeId.of[String].isSubtypeOf(TypeId.of[CharSequence]))\n}\n```\n\n#### Type Alias Transparency\n```scala\ntest(\"type aliases are transparent for subtyping\") {\n  type Age = Int\n  assertTrue(TypeId.of[Age].isSubtypeOf(TypeId.of[Int]))\n  assertTrue(TypeId.of[Int].isSubtypeOf(TypeId.of[Age]))\n  assertTrue(TypeId.of[Age].isEquivalentTo(TypeId.of[Int]))\n}\n```\n\n#### Opaque Type Nominality\n```scala\ntest(\"opaque types are nominally distinct\") {\n  opaque type Email = String\n  opaque type UserId = String\n  \n  assertTrue(!TypeId.of[Email].isSubtypeOf(TypeId.of[String]))  // Outside defining scope\n  assertTrue(!TypeId.of[Email].isSubtypeOf(TypeId.of[UserId]))\n}\n```\n\n### 5. Edge Cases and Regression Tests\n```scala\ntest(\"handles recursive types\") {\n  enum Tree[+A] {\n    case Leaf(value: A)\n    case Branch(left: Tree[A], right: Tree[A])\n  }\n  val treeId = TypeId.of[Tree]\n  // Should not stack overflow on equals/hashCode\n  val hash = treeId.hashCode  // Must terminate\n  assertTrue(treeId == treeId)    // Must terminate\n}\n\ntest(\"handles deeply nested generics\") {\n  val id = TypeId.of[List[Map[String, Option[Either[Int, List[String]]]]]]\n  // Should capture full structure\n  val hash = id.hashCode\n  assertTrue(id == TypeId.of[List[Map[String, Option[Either[Int, List[String]]]]]])\n}\n\ntest(\"handles local and anonymous types\") {\n  def foo() = {\n    class Local\n    TypeId.of[Local]\n  }\n  // Should handle gracefully\n}\n\ntest(\"handles Java types\") {\n  val id = TypeId.of[java.util.ArrayList[String]]\n  // Should interop correctly\n}\n```\n\n### 6. Cross-Compilation Tests\n\nRun the same test suite on both Scala 2.13 and Scala 3.x to ensure consistent behavior:\n```scala\n// In shared test sources\nclass TypeIdSpec extends AnyFunSuite {\n  // All tests above should pass on both Scala versions\n}\n```\n\nSpecific attention should be paid to:\n- Features that exist only in Scala 3 (union/intersection types, enums, match types, named tuples)\n- Features with different representations (Scala 2 existentials vs Scala 3 wildcards)\n- Macro API differences (should be invisible to users but implementation must handle both)\n- **Equality of TypeIds derived in Scala 2 vs Scala 3 for the same type** (if cross-published)\n\n## Acceptance Criteria\n\n- [ ] `TypeId.of[A]` works for all documented type forms on Scala 2.13\n- [ ] `TypeId.of[A]` works for all documented type forms on Scala 3.0–3.7\n- [ ] `implicit TypeId[A]` derivation works in generic contexts\n- [ ] `isSubtypeOf` correctly handles variance, unions, intersections, and nominal hierarchies\n- [ ] Type aliases are normalized correctly\n- [ ] Opaque types maintain nominal distinction\n- [ ] **`equals` and `hashCode` satisfy the Java contract**\n- [ ] **`TypeId` works correctly as `Map` and `Set` keys**\n- [ ] **Type aliases resolve to equal `TypeId` as their underlying types**\n- [ ] **Opaque types have distinct `TypeId` from their representation**\n- [ ] **`hashCode` is stable and deterministic across compilations**\n- [ ] All tests pass on both Scala versions\n- [ ] No runtime reflection is required (all information captured at compile time)\n\n# Sketch of TypeId\n\n# TypeId Data Model for Scala 3.x Type Registry\n\nA comprehensive data model for representing Scala 3 types and type constructors, designed to support:\n- Lossless type representation for serialization/deserialization frameworks\n- Subtype checking (`isSubtypeOf`)\n- Type equality checking\n- Type normalization (alias expansion)\n\n## Design Principles\n\n1. **Polykinded phantom types**: `TypeId[A <: AnyKind]` preserves Scala type information at compile time\n2. **Separation of identity and representation**: `TypeId` identifies types; `TypeRepr` represents type expressions\n3. **Complete metadata**: Capture everything a macro can know at compile time\n4. **Stability tracking**: Path-dependent types require knowing path stability\n\n---\n\n## Core Data Model\n\n### Variance\n```scala\nenum Variance {\n  case Invariant\n  case Covariant\n  case Contravariant\n\n  def symbol: String = this match {\n    case Invariant     => \"\"\n    case Covariant     => \"+\"\n    case Contravariant => \"-\"\n  }\n\n  /** Flip variance for contravariant positions */\n  def flip: Variance = this match {\n    case Invariant     => Invariant\n    case Covariant     => Contravariant\n    case Contravariant => Covariant\n  }\n}\n```\n\n### TypeBounds\n```scala\nfinal case class TypeBounds(\n  lower: Option[TypeRepr],  // >: bound\n  upper: Option[TypeRepr]   // <: bound\n) {\n  def isUnbounded: Boolean = lower.isEmpty && upper.isEmpty\n  \n  def hasLower: Boolean = lower.isDefined\n  def hasUpper: Boolean = upper.isDefined\n  \n  /** Combine bounds (intersection of constraints) */\n  def &(other: TypeBounds): TypeBounds = TypeBounds(\n    lower = (lower, other.lower) match {\n      case (Some(l1), Some(l2)) => Some(TypeRepr.Union(l1, l2))\n      case (Some(l), None) => Some(l)\n      case (None, Some(l)) => Some(l)\n      case (None, None) => None\n    },\n    upper = (upper, other.upper) match {\n      case (Some(u1), Some(u2)) => Some(TypeRepr.Intersection(u1, u2))\n      case (Some(u), None) => Some(u)\n      case (None, Some(u)) => Some(u)\n      case (None, None) => None\n    }\n  )\n}\n\nobject TypeBounds {\n  val empty: TypeBounds = TypeBounds(None, None)\n  \n  def upper(tpe: TypeRepr): TypeBounds = TypeBounds(None, Some(tpe))\n  def lower(tpe: TypeRepr): TypeBounds = TypeBounds(Some(tpe), None)\n  def exact(tpe: TypeRepr): TypeBounds = TypeBounds(Some(tpe), Some(tpe))\n}\n```\n\n### Kind\n\nRepresents the \"type of a type\" - distinguishing proper types from type constructors.\n```scala\nsealed trait Kind {\n  def arity: Int\n  def isProperType: Boolean = this == Kind.Type\n  def isHigherKinded: Boolean = !isProperType\n}\n\nobject Kind {\n  /** Proper type: Int, String, List[Int] */\n  case object Type extends Kind { \n    def arity: Int = 0 \n  }\n\n  /** Type constructor: List, Option, Map */\n  final case class Arrow(params: List[Kind], result: Kind) extends Kind {\n    def arity: Int = params.size\n  }\n\n  // Convenience constructors\n  val `* -> *`: Kind = Arrow(List(Type), Type)\n  val `* -> * -> *`: Kind = Arrow(List(Type, Type), Type)\n  val `(* -> *) -> *`: Kind = Arrow(List(`* -> *`), Type)\n  \n  def arity(n: Int): Kind = \n    if (n == 0) Type \n    else Arrow(List.fill(n)(Type), Type)\n}\n```\n\n### TypeParam\n\nComplete type parameter specification with all information needed for subtyping.\n```scala\nfinal case class TypeParam(\n  name: String,\n  index: Int,\n  variance: Variance = Variance.Invariant,\n  bounds: TypeBounds = TypeBounds.empty,\n  kind: Kind = Kind.Type\n) {\n  def isHigherKinded: Boolean = kind.isHigherKinded\n  def isCovariant: Boolean = variance == Variance.Covariant\n  def isContravariant: Boolean = variance == Variance.Contravariant\n  def isInvariant: Boolean = variance == Variance.Invariant\n}\n\nobject TypeParam {\n  def invariant(name: String, index: Int): TypeParam = \n    TypeParam(name, index, Variance.Invariant)\n    \n  def covariant(name: String, index: Int): TypeParam = \n    TypeParam(name, index, Variance.Covariant)\n    \n  def contravariant(name: String, index: Int): TypeParam = \n    TypeParam(name, index, Variance.Contravariant)\n}\n```\n\n---\n\n## Type Definition Classification\n\n### TypeDefKind\n\nClassifies what kind of type definition a `TypeId` represents.\n```scala\nsealed trait TypeDefKind\n\nobject TypeDefKind {\n  final case class Class(\n    isFinal: Boolean = false,\n    isAbstract: Boolean = false,\n    isCase: Boolean = false,\n    isValue: Boolean = false  // extends AnyVal\n  ) extends TypeDefKind\n\n  final case class Trait(\n    isSealed: Boolean = false,\n    knownSubtypes: List[TypeRepr] = Nil\n  ) extends TypeDefKind\n\n  /** Singleton object */\n  case object Object extends TypeDefKind\n\n  /** Scala 3 enum */\n  final case class Enum(\n    cases: List[EnumCaseInfo]\n  ) extends TypeDefKind\n\n  /** Individual enum case (when represented as its own type) */\n  final case class EnumCase(\n    parentEnum: TypeRepr,\n    ordinal: Int,\n    isObjectCase: Boolean  // case Red vs case RGB(...)\n  ) extends TypeDefKind\n\n  /** Type alias: type Foo = Bar */\n  case object TypeAlias extends TypeDefKind\n\n  /** Opaque type: opaque type Foo = Bar */\n  final case class OpaqueType(\n    publicBounds: TypeBounds  // Bounds visible outside defining scope\n  ) extends TypeDefKind\n\n  /** Abstract type member */\n  case object AbstractType extends TypeDefKind\n}\n\n/** Information about an enum case for serialization */\nfinal case class EnumCaseInfo(\n  name: String,\n  ordinal: Int,\n  params: List[EnumCaseParam],  // Empty for object cases\n  isObjectCase: Boolean\n) {\n  def arity: Int = params.size\n}\n\nfinal case class EnumCaseParam(\n  name: String,\n  tpe: TypeRepr\n)\n```\n\n---\n\n## Parameters and Clauses\n\n### ParamClause\n```scala\nsealed trait ParamClause {\n  def params: List[Param]\n  def isEmpty: Boolean = params.isEmpty\n  def size: Int = params.size\n}\n\nobject ParamClause {\n  final case class Regular(params: List[Param]) extends ParamClause\n  final case class Using(params: List[Param]) extends ParamClause\n  final case class Implicit(params: List[Param]) extends ParamClause\n  \n  val empty: ParamClause = Regular(Nil)\n}\n```\n\n### Param\n```scala\nfinal case class Param(\n  name: String,\n  tpe: TypeRepr,\n  hasDefault: Boolean = false,\n  isRepeated: Boolean = false  // varargs: A*\n)\n```\n\n---\n\n## Ownership and Paths\n\n### Owner\n\nRepresents the lexical owner of a type definition.\n```scala\nfinal case class Owner(segments: List[Owner.Segment]) {\n  def /(segment: Owner.Segment): Owner = Owner(segments :+ segment)\n  \n  def parent: Option[Owner] = \n    if (segments.isEmpty) None \n    else Some(Owner(segments.init))\n  \n  def isRoot: Boolean = segments.isEmpty\n  \n  def asString: String = segments.map(_.show).mkString(\".\")\n  \n  /** Check if this owner is a prefix of another */\n  def isPrefixOf(other: Owner): Boolean =\n    other.segments.startsWith(segments)\n}\n\nobject Owner {\n  sealed trait Segment {\n    def name: String\n    def show: String = name\n  }\n\n  final case class Package(name: String) extends Segment\n  final case class Term(name: String) extends Segment\n  final case class Type(name: String) extends Segment\n  final case class Local(index: Int) extends Segment {\n    def name: String = s\"<local$index>\"\n  }\n\n  val Root: Owner = Owner(Nil)\n  \n  def pkg(name: String): Owner = Owner(List(Package(name)))\n  def pkgs(names: String*): Owner = Owner(names.map(Package(_)).toList)\n}\n```\n\n### TermPath\n\nRepresents paths to terms, used for singleton and path-dependent types.\n```scala\nfinal case class TermPath(segments: List[TermPath.Segment]) {\n  def /(segment: TermPath.Segment): TermPath = \n    TermPath(segments :+ segment)\n  \n  def isStable: Boolean = segments.forall(_.isStable)\n  \n  def asString: String = segments.map(_.name).mkString(\".\")\n}\n\nobject TermPath {\n  sealed trait Segment {\n    def name: String\n    def isStable: Boolean\n  }\n\n  /** Package reference - always stable */\n  final case class Package(name: String) extends Segment {\n    def isStable: Boolean = true\n  }\n\n  /** Object/module reference - always stable */\n  final case class Module(name: String) extends Segment {\n    def isStable: Boolean = true\n  }\n\n  /** Val reference - stable */\n  final case class Val(name: String) extends Segment {\n    def isStable: Boolean = true\n  }\n\n  /** Lazy val reference - stable */\n  final case class LazyVal(name: String) extends Segment {\n    def isStable: Boolean = true\n  }\n\n  /** Var reference - NOT stable */\n  final case class Var(name: String) extends Segment {\n    def isStable: Boolean = false\n  }\n\n  /** Def/method reference - NOT stable */\n  final case class Def(name: String) extends Segment {\n    def isStable: Boolean = false\n  }\n\n  /** This reference */\n  final case class This(ownerName: String) extends Segment {\n    def name: String = s\"$ownerName.this\"\n    def isStable: Boolean = true\n  }\n\n  /** Super reference */\n  final case class Super(ownerName: String, mixinName: Option[String]) extends Segment {\n    def name: String = mixinName.fold(s\"$ownerName.super\")(m => s\"$ownerName.super[$m]\")\n    def isStable: Boolean = true\n  }\n\n  val empty: TermPath = TermPath(Nil)\n}\n```\n\n---\n\n## TypeId: Type Identity\n\nThe primary type for identifying types and type constructors.\n```scala\nsealed trait TypeId[A <: AnyKind] {\n  def name: String\n  def owner: Owner\n  def typeParams: List[TypeParam]\n  def defKind: TypeDefKind\n  def parents: List[TypeRepr]\n  def selfType: Option[TypeRepr]\n  def aliasedTo: Option[TypeRepr]      // For type aliases\n  def representation: Option[TypeRepr] // For opaque types\n  def annotations: List[Annotation]\n\n  // Derived properties\n  final def arity: Int = typeParams.size\n  \n  final def fullName: String =\n    if (owner.isRoot) name\n    else s\"${owner.asString}.$name\"\n\n  final def isProperType: Boolean = arity == 0\n  final def isTypeConstructor: Boolean = arity > 0\n\n  final def isClass: Boolean = defKind.isInstanceOf[TypeDefKind.Class]\n  final def isTrait: Boolean = defKind.isInstanceOf[TypeDefKind.Trait]\n  final def isObject: Boolean = defKind == TypeDefKind.Object\n  final def isEnum: Boolean = defKind.isInstanceOf[TypeDefKind.Enum]\n  final def isAlias: Boolean = defKind == TypeDefKind.TypeAlias\n  final def isOpaque: Boolean = defKind.isInstanceOf[TypeDefKind.OpaqueType]\n  final def isAbstract: Boolean = defKind == TypeDefKind.AbstractType\n\n  final def isSealed: Boolean = defKind match {\n    case TypeDefKind.Trait(isSealed, _) => isSealed\n    case _ => false\n  }\n\n  final def isCaseClass: Boolean = defKind match {\n    case TypeDefKind.Class(_, _, isCase, _) => isCase\n    case _ => false\n  }\n\n  final def isValueClass: Boolean = defKind match {\n    case TypeDefKind.Class(_, _, _, isValue) => isValue\n    case _ => false\n  }\n  \n  /** Get enum cases if this is an enum */\n  final def enumCases: List[EnumCaseInfo] = defKind match {\n    case TypeDefKind.Enum(cases) => cases\n    case _ => Nil\n  }\n}\n\nobject TypeId {\n  private final case class Impl[A <: AnyKind](\n    name: String,\n    owner: Owner,\n    typeParams: List[TypeParam],\n    defKind: TypeDefKind,\n    parents: List[TypeRepr],\n    selfType: Option[TypeRepr],\n    aliasedTo: Option[TypeRepr],\n    representation: Option[TypeRepr],\n    annotations: List[Annotation]\n  ) extends TypeId[A]\n\n  // ========== Smart Constructors ==========\n\n  def nominal[A <: AnyKind](\n    name: String,\n    owner: Owner,\n    typeParams: List[TypeParam] = Nil,\n    defKind: TypeDefKind,\n    parents: List[TypeRepr] = Nil,\n    selfType: Option[TypeRepr] = None,\n    annotations: List[Annotation] = Nil\n  ): TypeId[A] = Impl[A](\n    name, owner, typeParams, defKind,\n    parents, selfType, None, None, annotations\n  )\n\n  def alias[A <: AnyKind](\n    name: String,\n    owner: Owner,\n    typeParams: List[TypeParam] = Nil,\n    aliased: TypeRepr,\n    annotations: List[Annotation] = Nil\n  ): TypeId[A] = Impl[A](\n    name, owner, typeParams, TypeDefKind.TypeAlias,\n    Nil, None, Some(aliased), None, annotations\n  )\n\n  def opaque[A <: AnyKind](\n    name: String,\n    owner: Owner,\n    typeParams: List[TypeParam] = Nil,\n    representation: TypeRepr,\n    publicBounds: TypeBounds = TypeBounds.empty,\n    annotations: List[Annotation] = Nil\n  ): TypeId[A] = Impl[A](\n    name, owner, typeParams, TypeDefKind.OpaqueType(publicBounds),\n    Nil, None, None, Some(representation), annotations\n  )\n\n  // ========== Extractors ==========\n\n  object Nominal {\n    def unapply(id: TypeId[?]): Option[(String, Owner, List[TypeParam], TypeDefKind, List[TypeRepr])] =\n      if (id.aliasedTo.isEmpty && id.representation.isEmpty)\n        Some((id.name, id.owner, id.typeParams, id.defKind, id.parents))\n      else None\n  }\n\n  object Alias {\n    def unapply(id: TypeId[?]): Option[(String, Owner, List[TypeParam], TypeRepr)] =\n      id.aliasedTo.map(a => (id.name, id.owner, id.typeParams, a))\n  }\n\n  object Opaque {\n    def unapply(id: TypeId[?]): Option[(String, Owner, List[TypeParam], TypeRepr, TypeBounds)] =\n      (id.defKind, id.representation) match {\n        case (TypeDefKind.OpaqueType(bounds), Some(repr)) =>\n          Some((id.name, id.owner, id.typeParams, repr, bounds))\n        case _ => None\n      }\n  }\n\n  object Sealed {\n    def unapply(id: TypeId[?]): Option[(String, List[TypeRepr])] =\n      id.defKind match {\n        case TypeDefKind.Trait(true, subtypes) => Some((id.name, subtypes))\n        case _ => None\n      }\n  }\n  \n  object Enum {\n    def unapply(id: TypeId[?]): Option[(String, Owner, List[EnumCaseInfo])] =\n      id.defKind match {\n        case TypeDefKind.Enum(cases) => Some((id.name, id.owner, cases))\n        case _ => None\n      }\n  }\n}\n```\n\n---\n\n## TypeRepr: Type Expressions\n\nThe expression language for representing type structures.\n```scala\nsealed trait TypeRepr {\n  /** Substitute type parameters with concrete types */\n  def substitute(substitutions: Map[TypeParam, TypeRepr]): TypeRepr =\n    TypeRepr.substitute(this, substitutions)\n}\n\nobject TypeRepr {\n\n  // ==================== Type References ====================\n\n  /** Reference to a type by its TypeId */\n  final case class Ref(id: TypeId[? <: AnyKind]) extends TypeRepr\n\n  /** Reference to a type parameter */\n  final case class ParamRef(\n    param: TypeParam,\n    binderDepth: Int = 0  // De Bruijn index: 0 = innermost binder\n  ) extends TypeRepr\n\n  /** Path-dependent type: qualifier.Member */\n  final case class TypeSelect(\n    qualifier: TermPath,\n    memberName: String\n  ) extends TypeRepr {\n    def isStable: Boolean = qualifier.isStable\n  }\n\n  /** Type projection (deprecated but exists): Outer#Inner */\n  final case class TypeProjection(\n    prefix: TypeRepr,\n    memberName: String\n  ) extends TypeRepr\n\n  // ==================== Type Application ====================\n\n  /** Type constructor application: F[A, B] */\n  final case class Applied(\n    tycon: TypeRepr,\n    args: List[TypeRepr]\n  ) extends TypeRepr {\n    def arity: Int = args.size\n  }\n\n  // ==================== Type Constructors ====================\n\n  /** Type lambda: [X, Y] =>> F[X, Y] */\n  final case class TypeLambda(\n    params: List[TypeParam],\n    body: TypeRepr\n  ) extends TypeRepr {\n    def arity: Int = params.size\n  }\n\n  // ==================== Compound Types ====================\n\n  /** Intersection: A & B & C */\n  final case class Intersection(components: List[TypeRepr]) extends TypeRepr {\n    require(components.sizeIs >= 2, \"Intersection requires at least 2 types\")\n  }\n  \n  object Intersection {\n    def apply(left: TypeRepr, right: TypeRepr): Intersection =\n      (left, right) match {\n        case (Intersection(l), Intersection(r)) => Intersection(l ++ r)\n        case (Intersection(l), r) => Intersection(l :+ r)\n        case (l, Intersection(r)) => Intersection(l :: r)\n        case (l, r) => Intersection(List(l, r))\n      }\n  }\n\n  /** Union: A | B | C */\n  final case class Union(components: List[TypeRepr]) extends TypeRepr {\n    require(components.sizeIs >= 2, \"Union requires at least 2 types\")\n  }\n  \n  object Union {\n    def apply(left: TypeRepr, right: TypeRepr): Union =\n      (left, right) match {\n        case (Union(l), Union(r)) => Union(l ++ r)\n        case (Union(l), r) => Union(l :+ r)\n        case (l, Union(r)) => Union(l :: r)\n        case (l, r) => Union(List(l, r))\n      }\n  }\n\n  /** Structural/refinement type: { def foo: Int; type T } */\n  final case class Structural(\n    parents: List[TypeRepr],\n    members: List[Member]\n  ) extends TypeRepr\n\n  // ==================== Function Types ====================\n\n  /** Regular function: (A, B) => C */\n  final case class Function(\n    params: List[TypeRepr],\n    result: TypeRepr\n  ) extends TypeRepr {\n    def arity: Int = params.size\n  }\n\n  /** Context function: (A, B) ?=> C */\n  final case class ContextFunction(\n    params: List[TypeRepr],\n    result: TypeRepr\n  ) extends TypeRepr\n\n  /** Polymorphic function: [A] => A => A */\n  final case class PolyFunction(\n    typeParams: List[TypeParam],\n    result: TypeRepr\n  ) extends TypeRepr\n\n  /** Dependent function: (x: A) => x.T */\n  final case class DependentFunction(\n    params: List[Param],\n    result: TypeRepr  // May contain references to param names\n  ) extends TypeRepr\n\n  // ==================== Special Parameter Types ====================\n\n  /** By-name type: => A */\n  final case class ByName(underlying: TypeRepr) extends TypeRepr\n\n  /** Repeated/vararg type: A* */\n  final case class Repeated(underlying: TypeRepr) extends TypeRepr\n\n  // ==================== Tuple Types ====================\n\n  /** Tuple type with optional labels: (A, B) or (name: String, age: Int) */\n  final case class Tuple(elements: List[TupleElement]) extends TypeRepr {\n    def arity: Int = elements.size\n    def isNamed: Boolean = elements.exists(_.label.isDefined)\n    def isPositional: Boolean = elements.forall(_.label.isEmpty)\n    \n    def labels: List[Option[String]] = elements.map(_.label)\n    def types: List[TypeRepr] = elements.map(_.tpe)\n  }\n\n  final case class TupleElement(\n    label: Option[String],\n    tpe: TypeRepr\n  )\n  \n  object Tuple {\n    def positional(types: TypeRepr*): Tuple = \n      Tuple(types.map(t => TupleElement(None, t)).toList)\n      \n    def named(fields: (String, TypeRepr)*): Tuple =\n      Tuple(fields.map { case (n, t) => TupleElement(Some(n), t) }.toList)\n  }\n\n  // ==================== Singleton & Literal Types ====================\n\n  /** Singleton type: x.type */\n  final case class Singleton(path: TermPath) extends TypeRepr {\n    def isStable: Boolean = path.isStable\n  }\n\n  /** This type: this.type within a class */\n  final case class ThisType(owner: TypeId[? <: AnyKind]) extends TypeRepr\n\n  /** Super type reference */\n  final case class SuperType(\n    thisType: TypeRepr,\n    mixinTrait: Option[TypeRepr]\n  ) extends TypeRepr\n\n  /** Literal/constant type: 42, \"foo\", true */\n  final case class ConstantType(value: Constant) extends TypeRepr\n\n  // ==================== Match Types ====================\n\n  /** Match type: T match { case P => R; ... } */\n  final case class MatchType(\n    bound: TypeRepr,\n    scrutinee: TypeRepr,\n    cases: List[MatchTypeCase]\n  ) extends TypeRepr\n\n  final case class MatchTypeCase(\n    bindings: List[TypeParam],  // Captured type vars, e.g., `t` in `case Array[t] => t`\n    pattern: TypeRepr,\n    result: TypeRepr            // Can reference bindings via ParamRef\n  )\n\n  // ==================== Bounded/Wildcard Types ====================\n\n  /** Wildcard with bounds: ? <: Upper, ? >: Lower */\n  final case class Wildcard(bounds: TypeBounds) extends TypeRepr\n  \n  object Wildcard {\n    val unbounded: Wildcard = Wildcard(TypeBounds.empty)\n    def <:(upper: TypeRepr): Wildcard = Wildcard(TypeBounds.upper(upper))\n    def >:(lower: TypeRepr): Wildcard = Wildcard(TypeBounds.lower(lower))\n  }\n\n  // ==================== Recursive Types ====================\n\n  /** Recursive type: used for recursive type aliases */\n  final case class RecType(body: TypeRepr) extends TypeRepr\n\n  /** Reference to enclosing RecType */\n  case object RecThis extends TypeRepr\n\n  // ==================== Annotated Types ====================\n\n  /** Type with annotations: A @ann */\n  final case class Annotated(\n    underlying: TypeRepr,\n    annotations: List[Annotation]\n  ) extends TypeRepr\n\n  // ==================== Top, Bottom, and Special Types ====================\n\n  case object AnyType extends TypeRepr\n  case object AnyKindType extends TypeRepr\n  case object NothingType extends TypeRepr\n  case object NullType extends TypeRepr\n  case object UnitType extends TypeRepr\n\n  // ==================== Substitution ====================\n\n  def substitute(repr: TypeRepr, subs: Map[TypeParam, TypeRepr]): TypeRepr = {\n    def go(r: TypeRepr): TypeRepr = r match {\n      case ParamRef(param, 0) => subs.getOrElse(param, r)\n      case ParamRef(_, _) => r  // Different binder depth\n      case Ref(_) => r\n      case Applied(tycon, args) => Applied(go(tycon), args.map(go))\n      case TypeLambda(params, body) =>\n        // Shift substitutions to account for new binders\n        val shifted = subs.map { case (p, t) => p -> shiftBinderDepth(t, 1) }\n        TypeLambda(params, substitute(body, shifted))\n      case Intersection(comps) => Intersection(comps.map(go))\n      case Union(comps) => Union(comps.map(go))\n      case Structural(parents, members) =>\n        Structural(parents.map(go), members.map(substituteMember(_, subs)))\n      case Function(params, result) => Function(params.map(go), go(result))\n      case ContextFunction(params, result) => ContextFunction(params.map(go), go(result))\n      case PolyFunction(tps, result) => PolyFunction(tps, go(result))\n      case DependentFunction(params, result) =>\n        DependentFunction(params.map(p => p.copy(tpe = go(p.tpe))), go(result))\n      case ByName(u) => ByName(go(u))\n      case Repeated(u) => Repeated(go(u))\n      case Tuple(elems) => Tuple(elems.map(e => e.copy(tpe = go(e.tpe))))\n      case MatchType(bound, scrutinee, cases) =>\n        MatchType(go(bound), go(scrutinee), cases.map(substituteMatchCase(_, subs)))\n      case Wildcard(bounds) => Wildcard(substituteBounds(bounds, subs))\n      case RecType(body) => RecType(go(body))\n      case Annotated(underlying, anns) => Annotated(go(underlying), anns)\n      case TypeSelect(_, _) | TypeProjection(_, _) | Singleton(_) |\n           ThisType(_) | SuperType(_, _) | ConstantType(_) | RecThis |\n           AnyType | AnyKindType | NothingType | NullType | UnitType => r\n    }\n    go(repr)\n  }\n\n  private def shiftBinderDepth(repr: TypeRepr, delta: Int): TypeRepr = repr match {\n    case ParamRef(param, depth) => ParamRef(param, depth + delta)\n    case Applied(tycon, args) => Applied(shiftBinderDepth(tycon, delta), args.map(shiftBinderDepth(_, delta)))\n    // ... other cases follow same pattern\n    case other => other  // Simplified; full impl would recurse\n  }\n\n  private def substituteBounds(bounds: TypeBounds, subs: Map[TypeParam, TypeRepr]): TypeBounds =\n    TypeBounds(bounds.lower.map(substitute(_, subs)), bounds.upper.map(substitute(_, subs)))\n\n  private def substituteMatchCase(c: MatchTypeCase, subs: Map[TypeParam, TypeRepr]): MatchTypeCase = {\n    // Remove bindings from substitution map (they shadow outer params)\n    val shadowedSubs = subs -- c.bindings\n    MatchTypeCase(c.bindings, substitute(c.pattern, shadowedSubs), substitute(c.result, shadowedSubs))\n  }\n\n  private def substituteMember(m: Member, subs: Map[TypeParam, TypeRepr]): Member = m match {\n    case Member.Val(name, tpe, isMutable, targetName, annotations) =>\n      Member.Val(name, substitute(tpe, subs), isMutable, targetName, annotations)\n    case Member.Def(name, typeParams, paramClauses, result, targetName, annotations) =>\n      Member.Def(\n        name, typeParams,\n        paramClauses.map(substituteParamClause(_, subs)),\n        substitute(result, subs),\n        targetName, annotations\n      )\n    case Member.TypeMember(name, typeParams, bounds, alias, annotations) =>\n      Member.TypeMember(\n        name, typeParams,\n        substituteBounds(bounds, subs),\n        alias.map(substitute(_, subs)),\n        annotations\n      )\n  }\n\n  private def substituteParamClause(clause: ParamClause, subs: Map[TypeParam, TypeRepr]): ParamClause = {\n    def subParam(p: Param): Param = p.copy(tpe = substitute(p.tpe, subs))\n    clause match {\n      case ParamClause.Regular(params) => ParamClause.Regular(params.map(subParam))\n      case ParamClause.Using(params) => ParamClause.Using(params.map(subParam))\n      case ParamClause.Implicit(params) => ParamClause.Implicit(params.map(subParam))\n    }\n  }\n}\n```\n\n---\n\n## Members: For Structural Types\n```scala\nsealed trait Member\n\nobject Member {\n  final case class Val(\n    name: String,\n    tpe: TypeRepr,\n    isMutable: Boolean = false,\n    targetName: Option[String] = None,  // @targetName annotation\n    annotations: List[Annotation] = Nil\n  ) extends Member\n\n  final case class Def(\n    name: String,\n    typeParams: List[TypeParam] = Nil,\n    paramClauses: List[ParamClause] = Nil,\n    result: TypeRepr,\n    targetName: Option[String] = None,\n    annotations: List[Annotation] = Nil\n  ) extends Member {\n    def arity: Int = paramClauses.map(_.size).sum\n  }\n\n  final case class TypeMember(\n    name: String,\n    typeParams: List[TypeParam] = Nil,\n    bounds: TypeBounds = TypeBounds.empty,\n    alias: Option[TypeRepr] = None,  // Some = type alias, None = abstract\n    annotations: List[Annotation] = Nil\n  ) extends Member {\n    def isAbstract: Boolean = alias.isEmpty && bounds != TypeBounds.empty\n    def isAlias: Boolean = alias.isDefined\n  }\n}\n```\n\n---\n\n## Constants and Annotations\n\n### Constant\n```scala\nsealed trait Constant {\n  type Value\n  def value: Value\n}\n\nobject Constant {\n  final case class IntConst(value: Int) extends Constant { type Value = Int }\n  final case class LongConst(value: Long) extends Constant { type Value = Long }\n  final case class FloatConst(value: Float) extends Constant { type Value = Float }\n  final case class DoubleConst(value: Double) extends Constant { type Value = Double }\n  final case class BooleanConst(value: Boolean) extends Constant { type Value = Boolean }\n  final case class CharConst(value: Char) extends Constant { type Value = Char }\n  final case class StringConst(value: String) extends Constant { type Value = String }\n  final case class NullConst() extends Constant { type Value = Null; def value: Null = null }\n  final case class UnitConst() extends Constant { type Value = Unit; def value: Unit = () }\n  final case class ClassOfConst(tpe: TypeRepr) extends Constant { type Value = TypeRepr; def value: TypeRepr = tpe }\n}\n```\n\n### Annotation\n```scala\nfinal case class Annotation(\n  tpe: TypeRepr,\n  args: List[AnnotationArg]\n)\n\nsealed trait AnnotationArg\n\nobject AnnotationArg {\n  final case class ConstArg(value: Constant) extends AnnotationArg\n  final case class ArrayArg(elements: List[AnnotationArg]) extends AnnotationArg\n  final case class NestedArg(annotation: Annotation) extends AnnotationArg\n  final case class TypeArg(tpe: TypeRepr) extends AnnotationArg\n  final case class NamedArg(name: String, value: AnnotationArg) extends AnnotationArg\n}\n```\n\n---\n\n## Type Operations\n\n### Normalization\n\nExpands type aliases to their underlying types.\n```scala\nobject TypeNormalization {\n  \n  /**\n   * Normalize a type by expanding type aliases.\n   * Does NOT expand opaque types (they are nominally distinct).\n   */\n  def normalize(tpe: TypeRepr): TypeRepr = tpe match {\n    // Direct alias reference with no args\n    case TypeRepr.Ref(TypeId.Alias(_, _, Nil, aliased)) =>\n      normalize(aliased)\n    \n    // Applied alias: expand and substitute\n    case TypeRepr.Applied(TypeRepr.Ref(TypeId.Alias(_, _, params, aliased)), args) \n        if params.size == args.size =>\n      val subs = params.zip(args.map(normalize)).toMap\n      normalize(TypeRepr.substitute(aliased, subs))\n    \n    // Recurse into compound types\n    case TypeRepr.Applied(tycon, args) =>\n      TypeRepr.Applied(normalize(tycon), args.map(normalize))\n    \n    case TypeRepr.Intersection(comps) =>\n      TypeRepr.Intersection(comps.map(normalize))\n    \n    case TypeRepr.Union(comps) =>\n      TypeRepr.Union(comps.map(normalize))\n    \n    case TypeRepr.Function(params, result) =>\n      TypeRepr.Function(params.map(normalize), normalize(result))\n    \n    case TypeRepr.ContextFunction(params, result) =>\n      TypeRepr.ContextFunction(params.map(normalize), normalize(result))\n    \n    case TypeRepr.Tuple(elems) =>\n      TypeRepr.Tuple(elems.map(e => e.copy(tpe = normalize(e.tpe))))\n    \n    case TypeRepr.ByName(u) => TypeRepr.ByName(normalize(u))\n    case TypeRepr.Repeated(u) => TypeRepr.Repeated(normalize(u))\n    case TypeRepr.Annotated(u, anns) => TypeRepr.Annotated(normalize(u), anns)\n    case TypeRepr.Wildcard(bounds) => \n      TypeRepr.Wildcard(TypeBounds(bounds.lower.map(normalize), bounds.upper.map(normalize)))\n    \n    // Atoms don't change\n    case _ => tpe\n  }\n  \n  /**\n   * Get the underlying representation of an opaque type.\n   * Only valid within the opaque type's defining scope.\n   */\n  def unwrapOpaque(tpe: TypeRepr): Option[TypeRepr] = tpe match {\n    case TypeRepr.Ref(TypeId.Opaque(_, _, Nil, repr, _)) =>\n      Some(repr)\n    case TypeRepr.Applied(TypeRepr.Ref(TypeId.Opaque(_, _, params, repr, _)), args)\n        if params.size == args.size =>\n      val subs = params.zip(args).toMap\n      Some(TypeRepr.substitute(repr, subs))\n    case _ => None\n  }\n}\n```\n\n### Type Equality\n```scala\nobject TypeEquality {\n  \n  /**\n   * Check if two types are equal (after normalization).\n   * This is structural equality, not reference equality.\n   */\n  def areEqual(a: TypeRepr, b: TypeRepr): Boolean = {\n    val aNorm = TypeNormalization.normalize(a)\n    val bNorm = TypeNormalization.normalize(b)\n    structurallyEqual(aNorm, bNorm)\n  }\n  \n  private def structurallyEqual(a: TypeRepr, b: TypeRepr): Boolean = (a, b) match {\n    case (TypeRepr.Ref(idA), TypeRepr.Ref(idB)) =>\n      idA.fullName == idB.fullName\n    \n    case (TypeRepr.ParamRef(pA, dA), TypeRepr.ParamRef(pB, dB)) =>\n      pA.index == pB.index && dA == dB\n    \n    case (TypeRepr.Applied(tcA, argsA), TypeRepr.Applied(tcB, argsB)) =>\n      structurallyEqual(tcA, tcB) && \n        argsA.size == argsB.size &&\n        argsA.zip(argsB).forall { case (x, y) => structurallyEqual(x, y) }\n    \n    case (TypeRepr.Intersection(cA), TypeRepr.Intersection(cB)) =>\n      cA.size == cB.size && cA.zip(cB).forall { case (x, y) => structurallyEqual(x, y) }\n    \n    case (TypeRepr.Union(cA), TypeRepr.Union(cB)) =>\n      cA.size == cB.size && cA.zip(cB).forall { case (x, y) => structurallyEqual(x, y) }\n    \n    case (TypeRepr.Function(pA, rA), TypeRepr.Function(pB, rB)) =>\n      pA.size == pB.size &&\n        pA.zip(pB).forall { case (x, y) => structurallyEqual(x, y) } &&\n        structurallyEqual(rA, rB)\n    \n    case (TypeRepr.Tuple(eA), TypeRepr.Tuple(eB)) =>\n      eA.size == eB.size && eA.zip(eB).forall { case (x, y) => \n        x.label == y.label && structurallyEqual(x.tpe, y.tpe)\n      }\n    \n    case (TypeRepr.ConstantType(cA), TypeRepr.ConstantType(cB)) =>\n      cA == cB\n    \n    case (TypeRepr.AnyType, TypeRepr.AnyType) => true\n    case (TypeRepr.NothingType, TypeRepr.NothingType) => true\n    case (TypeRepr.NullType, TypeRepr.NullType) => true\n    case (TypeRepr.UnitType, TypeRepr.UnitType) => true\n    \n    // More cases for full coverage...\n    case _ => false\n  }\n}\n```\n\n### Subtyping\n```scala\nobject Subtyping {\n  \n  /**\n   * Context for subtyping calculations.\n   * Tracks assumptions to handle recursive types and avoid infinite loops.\n   */\n  final case class Context(\n    assumptions: Set[(TypeRepr, TypeRepr)] = Set.empty,\n    depth: Int = 0,\n    maxDepth: Int = 100\n  ) {\n    def assume(sub: TypeRepr, sup: TypeRepr): Context =\n      copy(assumptions = assumptions + ((sub, sup)))\n    \n    def isAssumed(sub: TypeRepr, sup: TypeRepr): Boolean =\n      assumptions.contains((sub, sup))\n    \n    def deeper: Context = copy(depth = depth + 1)\n    def tooDeep: Boolean = depth >= maxDepth\n  }\n  \n  /**\n   * Check if `sub` is a subtype of `sup`.\n   * \n   * Implements the Scala 3 subtyping rules including:\n   * - Reflexivity: A <: A\n   * - Top: A <: Any for all A\n   * - Bottom: Nothing <: A for all A  \n   * - Variance-aware generic subtyping\n   * - Union/intersection type rules\n   * - Structural subtyping\n   */\n  def isSubtype(sub: TypeRepr, sup: TypeRepr)(using ctx: Context = Context()): Boolean = ???\n  \n  /**\n   * Check if two types are equivalent (mutual subtypes).\n   */\n  def isEquivalent(a: TypeRepr, b: TypeRepr)(using ctx: Context = Context()): Boolean =\n    isSubtype(a, b) && isSubtype(b, a)\n  \n  /**\n   * Find the least upper bound (LUB) of two types.\n   * Returns the most specific type that is a supertype of both.\n   */\n  def lub(a: TypeRepr, b: TypeRepr): TypeRepr = ???\n  \n  /**\n   * Find the greatest lower bound (GLB) of two types.\n   * Returns the most general type that is a subtype of both.\n   */\n  def glb(a: TypeRepr, b: TypeRepr): TypeRepr = ???\n  \n  /**\n   * Check if a type conforms to given bounds.\n   */\n  def conformsToBounds(tpe: TypeRepr, bounds: TypeBounds)(using ctx: Context = Context()): Boolean = {\n    val lowerOk = bounds.lower.forall(lo => isSubtype(lo, tpe))\n    val upperOk = bounds.upper.forall(hi => isSubtype(tpe, hi))\n    lowerOk && upperOk\n  }\n  \n  /**\n   * Reduce a match type to its result, if possible.\n   * Returns None if the match type cannot be reduced (e.g., abstract scrutinee).\n   */\n  def reduceMatchType(mt: TypeRepr.MatchType)(using ctx: Context = Context()): Option[TypeRepr] = ???\n}\n```\n\n---\n\n## Standard Library Type Definitions\n\nPredefined `TypeId` instances for common types.\n```scala\nobject StandardTypes {\n  import TypeDefKind.*\n  \n  private val scalaOwner = Owner.pkg(\"scala\")\n  private val scalaCollectionImmutable = Owner.pkgs(\"scala\", \"collection\", \"immutable\")\n  private val javaLang = Owner.pkgs(\"java\", \"lang\")\n  \n  // ========== Primitives ==========\n  \n  val IntId: TypeId[Int] = TypeId.nominal[Int](\n    \"Int\", scalaOwner, Nil, Class(isFinal = true, isValue = true)\n  )\n  \n  val LongId: TypeId[Long] = TypeId.nominal[Long](\n    \"Long\", scalaOwner, Nil, Class(isFinal = true, isValue = true)\n  )\n  \n  val DoubleId: TypeId[Double] = TypeId.nominal[Double](\n    \"Double\", scalaOwner, Nil, Class(isFinal = true, isValue = true)\n  )\n  \n  val FloatId: TypeId[Float] = TypeId.nominal[Float](\n    \"Float\", scalaOwner, Nil, Class(isFinal = true, isValue = true)\n  )\n  \n  val BooleanId: TypeId[Boolean] = TypeId.nominal[Boolean](\n    \"Boolean\", scalaOwner, Nil, Class(isFinal = true, isValue = true)\n  )\n  \n  val CharId: TypeId[Char] = TypeId.nominal[Char](\n    \"Char\", scalaOwner, Nil, Class(isFinal = true, isValue = true)\n  )\n  \n  val ByteId: TypeId[Byte] = TypeId.nominal[Byte](\n    \"Byte\", scalaOwner, Nil, Class(isFinal = true, isValue = true)\n  )\n  \n  val ShortId: TypeId[Short] = TypeId.nominal[Short](\n    \"Short\", scalaOwner, Nil, Class(isFinal = true, isValue = true)\n  )\n  \n  val UnitId: TypeId[Unit] = TypeId.nominal[Unit](\n    \"Unit\", scalaOwner, Nil, Class(isFinal = true, isValue = true)\n  )\n  \n  // ========== Reference Types ==========\n  \n  val StringId: TypeId[String] = TypeId.nominal[String](\n    \"String\", javaLang, Nil, Class(isFinal = true)\n  )\n  \n  val AnyId: TypeId[Any] = TypeId.nominal[Any](\n    \"Any\", scalaOwner, Nil, Class(isAbstract = true)\n  )\n  \n  val AnyRefId: TypeId[AnyRef] = TypeId.nominal[AnyRef](\n    \"AnyRef\", scalaOwner, Nil, Class(isAbstract = true),\n    parents = List(TypeRepr.Ref(AnyId))\n  )\n  \n  val AnyValId: TypeId[AnyVal] = TypeId.nominal[AnyVal](\n    \"AnyVal\", scalaOwner, Nil, Class(isAbstract = true),\n    parents = List(TypeRepr.Ref(AnyId))\n  )\n  \n  val NothingId: TypeId[Nothing] = TypeId.nominal[Nothing](\n    \"Nothing\", scalaOwner, Nil, Class(isFinal = true, isAbstract = true)\n  )\n  \n  val NullId: TypeId[Null] = TypeId.nominal[Null](\n    \"Null\", scalaOwner, Nil, Class(isFinal = true)\n  )\n  \n  // ========== Collection Type Constructors ==========\n  \n  private val A = TypeParam.covariant(\"A\", 0)\n  private val K = TypeParam.invariant(\"K\", 0)\n  private val V = TypeParam.covariant(\"V\", 1)\n  \n  val ListId: TypeId[List] = TypeId.nominal[List](\n    \"List\", scalaCollectionImmutable, List(A), Trait(isSealed = true)\n  )\n  \n  val VectorId: TypeId[Vector] = TypeId.nominal[Vector](\n    \"Vector\", scalaCollectionImmutable, List(A), Class(isFinal = true)\n  )\n  \n  val SetId: TypeId[Set] = TypeId.nominal[Set](\n    \"Set\", scalaCollectionImmutable, List(A), Trait()\n  )\n  \n  val MapId: TypeId[Map] = TypeId.nominal[Map](\n    \"Map\", scalaCollectionImmutable, List(K, V), Trait()\n  )\n  \n  val OptionId: TypeId[Option] = TypeId.nominal[Option](\n    \"Option\", scalaOwner, List(A), Trait(isSealed = true)\n  )\n  \n  val EitherA = TypeParam.covariant(\"A\", 0)\n  val EitherB = TypeParam.covariant(\"B\", 1)\n  val EitherId: TypeId[Either] = TypeId.nominal[Either](\n    \"Either\", scalaOwner, List(EitherA, EitherB), Trait(isSealed = true)\n  )\n  \n  // ========== Tuple Type Constructors ==========\n  \n  val EmptyTupleId: TypeId[EmptyTuple] = TypeId.nominal[EmptyTuple](\n    \"EmptyTuple\", scalaOwner, Nil, Object\n  )\n  \n  val TupleConsH = TypeParam.covariant(\"H\", 0)\n  val TupleConsT = TypeParam.covariant(\"T\", 1, bounds = TypeBounds.upper(TypeRepr.Ref(???))) // <: Tuple\n  val TupleConsId: TypeId[*:] = TypeId.nominal[*:](\n    \"*:\", scalaOwner, List(TupleConsH, TupleConsT), Class(isFinal = true, isCase = true)\n  )\n  \n  // ========== Convenience TypeRepr Builders ==========\n  \n  def int: TypeRepr = TypeRepr.Ref(IntId)\n  def long: TypeRepr = TypeRepr.Ref(LongId)\n  def double: TypeRepr = TypeRepr.Ref(DoubleId)\n  def float: TypeRepr = TypeRepr.Ref(FloatId)\n  def boolean: TypeRepr = TypeRepr.Ref(BooleanId)\n  def string: TypeRepr = TypeRepr.Ref(StringId)\n  def unit: TypeRepr = TypeRepr.UnitType\n  def any: TypeRepr = TypeRepr.AnyType\n  def nothing: TypeRepr = TypeRepr.NothingType\n  \n  def list(elem: TypeRepr): TypeRepr = TypeRepr.Applied(TypeRepr.Ref(ListId), List(elem))\n  def option(elem: TypeRepr): TypeRepr = TypeRepr.Applied(TypeRepr.Ref(OptionId), List(elem))\n  def map(key: TypeRepr, value: TypeRepr): TypeRepr = TypeRepr.Applied(TypeRepr.Ref(MapId), List(key, value))\n  def either(left: TypeRepr, right: TypeRepr): TypeRepr = TypeRepr.Applied(TypeRepr.Ref(EitherId), List(left, right))\n}\n```\n\n---\n\n## Example Usage\n```scala\nobject Examples {\n  import TypeRepr.*\n  import StandardTypes.*\n  \n  // ========== Simple Types ==========\n  \n  val intType: TypeRepr = int\n  val stringType: TypeRepr = string\n  val listOfInt: TypeRepr = list(int)\n  val mapStringToInt: TypeRepr = map(string, int)\n  \n  // ========== Named Tuple ==========\n  \n  // (name: String, age: Int)\n  val personTuple: TypeRepr = Tuple.named(\n    \"name\" -> string,\n    \"age\" -> int\n  )\n  \n  // ========== Type Alias ==========\n  \n  // type Age = Int\n  val AgeId: TypeId[Int] = TypeId.alias[Int](\n    \"Age\",\n    Owner.pkg(\"myapp\"),\n    Nil,\n    int\n  )\n  \n  // type StringMap[V] = Map[String, V]\n  val V = TypeParam.covariant(\"V\", 0)\n  val StringMapId: TypeId[Map[String, *]] = TypeId.alias[Map[String, *]](\n    \"StringMap\",\n    Owner.pkg(\"myapp\"),\n    List(V),\n    Applied(Ref(MapId), List(string, ParamRef(V)))\n  )\n  \n  // ========== Opaque Type ==========\n  \n  // opaque type Email = String\n  val EmailId: TypeId[String] = TypeId.opaque[String](\n    \"Email\",\n    Owner.pkg(\"myapp\"),\n    Nil,\n    string\n  )\n  \n  // ========== Enum ==========\n  \n  val ColorId: TypeId[?] = TypeId.nominal(\n    \"Color\",\n    Owner.pkg(\"myapp\"),\n    Nil,\n    TypeDefKind.Enum(List(\n      EnumCaseInfo(\"Red\", 0, Nil, isObjectCase = true),\n      EnumCaseInfo(\"Green\", 1, Nil, isObjectCase = true),\n      EnumCaseInfo(\"Blue\", 2, Nil, isObjectCase = true),\n      EnumCaseInfo(\"RGB\", 3, List(\n        EnumCaseParam(\"r\", int),\n        EnumCaseParam(\"g\", int),\n        EnumCaseParam(\"b\", int)\n      ), isObjectCase = false)\n    ))\n  )\n  \n  // ========== Match Type ==========\n  \n  // type Elem[X] = X match { case String => Char; case Array[t] => t }\n  val X = TypeParam.invariant(\"X\", 0)\n  val t = TypeParam.invariant(\"t\", 0)\n  \n  val ElemId: TypeId[?] = TypeId.alias(\n    \"Elem\",\n    Owner.pkg(\"myapp\"),\n    List(X),\n    MatchType(\n      bound = any,\n      scrutinee = ParamRef(X),\n      cases = List(\n        MatchTypeCase(Nil, string, Ref(CharId)),\n        MatchTypeCase(\n          List(t),\n          Applied(Ref(???), List(ParamRef(t))), // Array[t]\n          ParamRef(t)\n        )\n      )\n    )\n  )\n  \n  // ========== Structural Type ==========\n  \n  // { def size: Int; val name: String }\n  val sizedNamed: TypeRepr = Structural(\n    parents = Nil,\n    members = List(\n      Member.Def(\"size\", Nil, Nil, int),\n      Member.Val(\"name\", string)\n    )\n  )\n  \n  // ========== Path-Dependent Type ==========\n  \n  // myModule.Inner.T\n  val pathDependent: TypeRepr = TypeSelect(\n    TermPath(List(\n      TermPath.Package(\"myapp\"),\n      TermPath.Module(\"myModule\"),\n      TermPath.Module(\"Inner\")\n    )),\n    \"T\"\n  )\n  \n  // ========== Intersection & Union ==========\n  \n  // String & { def foo: Int }\n  val stringWithFoo: TypeRepr = Intersection(\n    string,\n    Structural(Nil, List(Member.Def(\"foo\", Nil, Nil, int)))\n  )\n  \n  // String | Int\n  val stringOrInt: TypeRepr = Union(string, int)\n  \n  // ========== Function Types ==========\n  \n  // (Int, String) => Boolean\n  val func: TypeRepr = Function(List(int, string), boolean)\n  \n  // (Int, String) ?=> Boolean (context function)\n  val ctxFunc: TypeRepr = ContextFunction(List(int, string), boolean)\n  \n  // [A] => A => A (polymorphic function)\n  val polyFunc: TypeRepr = PolyFunction(\n    List(TypeParam.invariant(\"A\", 0)),\n    Function(List(ParamRef(TypeParam.invariant(\"A\", 0))), ParamRef(TypeParam.invariant(\"A\", 0)))\n  )\n}\n```\n\n---\n\n## Macro Derivation (Sketch)\n```scala\nimport scala.quoted.*\n\nobject TypeIdMacros {\n  \n  /**\n   * Derive a TypeId for any type or type constructor at compile time.\n   * Captures all type information available to the compiler.\n   */\n  inline def derive[A <: AnyKind]: TypeId[A] = ${ deriveMacro[A] }\n  \n  def deriveMacro[A <: AnyKind: Type](using Quotes): Expr[TypeId[A]] = {\n    import quotes.reflect.*\n    \n    val tpe = TypeRepr.of[A]\n    \n    // Extract type information from compiler\n    // ... implementation details ...\n    \n    ???\n  }\n  \n  /**\n   * Derive a TypeRepr for a concrete type at compile time.\n   */\n  inline def typeRepr[A]: TypeRepr = ${ typeReprMacro[A] }\n  \n  def typeReprMacro[A: Type](using Quotes): Expr[TypeRepr] = ???\n}\n```\n\n---\n\n## Open Questions / Future Work\n\n1. **Recursive type handling**: The `RecType`/`RecThis` encoding may need refinement for complex recursive types.\n\n2. **Match type reduction**: Full implementation requires tracking what patterns are \"provably disjoint.\"\n\n3. **Structural subtyping**: Member-by-member comparison with proper handling of overloaded methods.\n\n4. **Scala 2 compatibility**: Some constructs (existentials, compound types) may need additional representation.\n\n5. **Serialization format**: The data model is designed for runtime use; a compact serialization format (e.g., protobuf schema) would be a natural next step.",
              "url": "https://github.com/zio/zio-blocks/issues/471",
              "tech": [],
              "repo_name": "zio-blocks",
              "repo_owner": "zio",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "ZIO#3697",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "ZIO",
              "id": "generated-ZIO",
              "name": "ZIO",
              "description": "",
              "members": [],
              "display_name": "ZIO",
              "created_at": "2026-01-23T05:51:30.201Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/ZIO?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "zio",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-23T05:51:30.201Z",
            "created_at": "2026-01-23T05:51:30.201Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-ZIO#3697",
              "status": "open",
              "type": "issue",
              "number": 3697,
              "title": "Datastar requests from Endpoint",
              "source": {
                "data": {
                  "id": "source-ZIO#3697",
                  "user": {
                    "login": "987Nabil",
                    "id": 7283535,
                    "node_id": "MDQ6VXNlcjcyODM1MzU=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/7283535?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/987Nabil",
                    "html_url": "https://github.com/987Nabil",
                    "followers_url": "https://api.github.com/users/987Nabil/followers",
                    "following_url": "https://api.github.com/users/987Nabil/following{/other_user}",
                    "gists_url": "https://api.github.com/users/987Nabil/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/987Nabil/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/987Nabil/subscriptions",
                    "organizations_url": "https://api.github.com/users/987Nabil/orgs",
                    "repos_url": "https://api.github.com/users/987Nabil/repos",
                    "events_url": "https://api.github.com/users/987Nabil/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/987Nabil/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Datastar requests from Endpoint",
                  "body": "Build Datastar expressions for request against an Endpoint from its definition\n",
                  "html_url": "https://github.com/zio/zio-http/issues/3697"
                },
                "type": "github"
              },
              "hash": "zio/zio-http#3697",
              "body": "Build Datastar expressions for request against an Endpoint from its definition\n",
              "url": "https://github.com/zio/zio-http/issues/3697",
              "tech": [],
              "repo_name": "zio-http",
              "repo_owner": "zio",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "ZIO#3472",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "ZIO",
              "id": "generated-ZIO",
              "name": "ZIO",
              "description": "",
              "members": [],
              "display_name": "ZIO",
              "created_at": "2026-01-23T05:51:30.319Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/ZIO?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "zio",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-23T05:51:30.319Z",
            "created_at": "2026-01-23T05:51:30.319Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-ZIO#3472",
              "status": "open",
              "type": "issue",
              "number": 3472,
              "title": "Split into multiple modules",
              "source": {
                "data": {
                  "id": "source-ZIO#3472",
                  "user": {
                    "login": "987Nabil",
                    "id": 7283535,
                    "node_id": "MDQ6VXNlcjcyODM1MzU=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/7283535?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/987Nabil",
                    "html_url": "https://github.com/987Nabil",
                    "followers_url": "https://api.github.com/users/987Nabil/followers",
                    "following_url": "https://api.github.com/users/987Nabil/following{/other_user}",
                    "gists_url": "https://api.github.com/users/987Nabil/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/987Nabil/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/987Nabil/subscriptions",
                    "organizations_url": "https://api.github.com/users/987Nabil/orgs",
                    "repos_url": "https://api.github.com/users/987Nabil/repos",
                    "events_url": "https://api.github.com/users/987Nabil/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/987Nabil/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Split into multiple modules",
                  "body": "Currently, the zio-http artifact contains a lot of different parts of zio-http exclusively. They are not separate maven artifacts.\n\nWe want to change this, to support future changes/features.\n\nThere should be at least these modules that are published into maven. \n\n1. core\n2. endpoint\n3. netty\n\nShould we have client and server in different modules?",
                  "html_url": "https://github.com/zio/zio-http/issues/3472"
                },
                "type": "github"
              },
              "hash": "zio/zio-http#3472",
              "body": "Currently, the zio-http artifact contains a lot of different parts of zio-http exclusively. They are not separate maven artifacts.\n\nWe want to change this, to support future changes/features.\n\nThere should be at least these modules that are published into maven. \n\n1. core\n2. endpoint\n3. netty\n\nShould we have client and server in different modules?",
              "url": "https://github.com/zio/zio-http/issues/3472",
              "tech": [],
              "repo_name": "zio-http",
              "repo_owner": "zio",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "GolemCloud#275",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "GolemCloud",
              "id": "generated-GolemCloud",
              "name": "GolemCloud",
              "description": "",
              "members": [],
              "display_name": "GolemCloud",
              "created_at": "2026-01-23T05:51:32.638Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/GolemCloud?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "golemcloud",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-23T05:51:32.638Z",
            "created_at": "2026-01-23T05:51:32.638Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [
              "go"
            ],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-GolemCloud#275",
              "status": "open",
              "type": "issue",
              "number": 275,
              "title": "Incorporate MCP Server into Golem CLI",
              "source": {
                "data": {
                  "id": "source-GolemCloud#275",
                  "user": {
                    "login": "jdegoes",
                    "id": 156745,
                    "node_id": "MDQ6VXNlcjE1Njc0NQ==",
                    "avatar_url": "https://avatars.githubusercontent.com/u/156745?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/jdegoes",
                    "html_url": "https://github.com/jdegoes",
                    "followers_url": "https://api.github.com/users/jdegoes/followers",
                    "following_url": "https://api.github.com/users/jdegoes/following{/other_user}",
                    "gists_url": "https://api.github.com/users/jdegoes/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/jdegoes/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/jdegoes/subscriptions",
                    "organizations_url": "https://api.github.com/users/jdegoes/orgs",
                    "repos_url": "https://api.github.com/users/jdegoes/repos",
                    "events_url": "https://api.github.com/users/jdegoes/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/jdegoes/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Incorporate MCP Server into Golem CLI",
                  "body": "With a new command, Golem CLI enters serve mode:\n\n```bash\n%> golem-cli --serve --serve-port 1232\n%> golem-cli running MCP Server at port 1232\n```\n\nIn this mode, Golem CLI creates an MCP Server that exposes different commands as different tools, and exposes relevant resources (the manifest file in the current, ancestor, and children directories) as resources.\n\nWhen this ticket is completed, it should be possible to use an agent such as Claude Code to perform anything that Golem CLI can do. Moreover, all individual tools and resources must be end-to-end tested with an MCP Client that interacts with the MCP Server.\n\n[This library](https://github.com/rust-mcp-stack/rust-mcp-sdk) looks like the one to use for Rust, but perhaps there are better options available.",
                  "html_url": "https://github.com/golemcloud/golem/issues/1926"
                },
                "type": "github"
              },
              "hash": "golemcloud/golem-cli#275",
              "body": "With a new command, Golem CLI enters serve mode:\n\n```bash\n%> golem-cli --serve --serve-port 1232\n%> golem-cli running MCP Server at port 1232\n```\n\nIn this mode, Golem CLI creates an MCP Server that exposes different commands as different tools, and exposes relevant resources (the manifest file in the current, ancestor, and children directories) as resources.\n\nWhen this ticket is completed, it should be possible to use an agent such as Claude Code to perform anything that Golem CLI can do. Moreover, all individual tools and resources must be end-to-end tested with an MCP Client that interacts with the MCP Server.\n\n[This library](https://github.com/rust-mcp-stack/rust-mcp-sdk) looks like the one to use for Rust, but perhaps there are better options available.",
              "url": "https://github.com/golemcloud/golem/issues/1926",
              "tech": [
                "go"
              ],
              "repo_name": "golem-cli",
              "repo_owner": "golemcloud",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "GolemCloud#23",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "GolemCloud",
              "id": "generated-GolemCloud",
              "name": "GolemCloud",
              "description": "",
              "members": [],
              "display_name": "GolemCloud",
              "created_at": "2026-01-23T05:51:32.848Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/GolemCloud?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "golemcloud",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-23T05:51:32.848Z",
            "created_at": "2026-01-23T05:51:32.848Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [
              "go"
            ],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-GolemCloud#23",
              "status": "open",
              "type": "issue",
              "number": 23,
              "title": "Implement Durable Text-to-Speech Provider Components for golem:tts WIT Interface",
              "source": {
                "data": {
                  "id": "source-GolemCloud#23",
                  "user": {
                    "login": "jdegoes",
                    "id": 156745,
                    "node_id": "MDQ6VXNlcjE1Njc0NQ==",
                    "avatar_url": "https://avatars.githubusercontent.com/u/156745?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/jdegoes",
                    "html_url": "https://github.com/jdegoes",
                    "followers_url": "https://api.github.com/users/jdegoes/followers",
                    "following_url": "https://api.github.com/users/jdegoes/following{/other_user}",
                    "gists_url": "https://api.github.com/users/jdegoes/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/jdegoes/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/jdegoes/subscriptions",
                    "organizations_url": "https://api.github.com/users/jdegoes/orgs",
                    "repos_url": "https://api.github.com/users/jdegoes/repos",
                    "events_url": "https://api.github.com/users/jdegoes/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/jdegoes/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Implement Durable Text-to-Speech Provider Components for golem:tts WIT Interface",
                  "body": "I have attached to this ticket a WIT file that describes a generic interface for text-to-speech operations. This interface can be implemented by various providers, either by emulating features not present in a given provider, utilizing the provider's native support for a feature, or indicating an error if a particular combination is not natively supported by a provider.\n\nThe intent of this WIT specification is to allow developers of WASM components (on wasmCloud, Spin, or Golem) to leverage text-to-speech capabilities to build voice-powered applications, accessibility services, and audio content generation systems in a portable and provider-agnostic fashion.\n\nThis ticket involves constructing implementations of this WIT interface for the following providers:\n\n- **ElevenLabs**: The leading AI voice synthesis platform with comprehensive voice cloning, real-time streaming, voice conversion, and sound effects generation capabilities.\n- **AWS Polly**: Amazon's enterprise text-to-speech service with extensive language support, custom lexicons, speech marks, and asynchronous synthesis for long-form content.\n- **Google Cloud Text-to-Speech**: Google's neural voice synthesis service with WaveNet and Neural2 voices, device optimization profiles, and streaming synthesis capabilities.\n- **Deepgram Aura**: High-performance real-time TTS with session-based streaming, low-latency neural voices, and conversational AI optimization.\n\nThese implementations must be written in Rust and compilable to WASM Components (WASI 0.23 only, since Golem does not yet support WASI 0.3). The standard Rust toolchain for WASM component development can be employed (see cargo component and the Rust examples of components in this and other Golem repositories).\n\nAdditionally, these implementations should incorporate custom durability semantics using the Golem durability API and the Golem host API. This approach ensures that durability is managed at the level of individual TTS operations (voice synthesis, streaming session creation, voice cloning, batch processing), providing a higher-level and clearer operation log, which aids in debugging and monitoring. See golem:llm and golem:embed for more details and durable implementations in this same repository.\n\nThe final deliverables associated with this ticket are:\n\n- **ElevenLabs implementation**: A WASM Component (WASI 0.23), named `tts-elevenlabs.wasm`, with a full test suite and custom durability implementation at the level of TTS operations.\n- **AWS Polly implementation**: A WASM Component (WASI 0.23), named `tts-polly.wasm`, with a full test suite and custom durability implementation at the level of TTS operations.\n- **Google Cloud TTS implementation**: A WASM Component (WASI 0.23), named `tts-google.wasm`, with a full test suite and custom durability implementation at the level of TTS operations.\n- **Deepgram Aura implementation**: A WASM Component (WASI 0.23), named `tts-deepgram.wasm`, with a full test suite and custom durability implementation at the level of TTS operations.\n\n**Note**: If you have a strong recommendation to swap out one or two of these with other popular / common TTS providers (such as Azure Cognitive Services Speech, IBM Watson Text to Speech, or OpenAI TTS), then as long as you get permission beforehand, that's okay with me. However, we definitely need ElevenLabs and AWS Polly.\n\nThese components will require runtime configuration, notably API keys, endpoint URLs, authentication credentials, and provider-specific settings. For configuring this information, the components can use environment variables for now (in the future, they will use wasi-runtime-config, but Golem does not support this yet, whereas Golem has good support for environment variables).\n\nMoreover, the Rust components need to be tested within Golem to ensure compatibility with Golem 1.2.x.\n\nThis WIT has been designed by examining and comparing the APIs of ElevenLabs, AWS Polly, Google Cloud TTS, Azure Speech Services, OpenAI TTS, and Deepgram Aura. However, given there are no implementations, it is possible the provided WIT is not the optimal abstraction across all these providers. Therefore, deviations from the proposed design can be made. However, to be accepted, any deviation must be fully justified and deemed by Golem core contributors to be an improvement from the original specification.\n\n## Implementation Guidelines\n\nEach provider implementation should handle the following key mapping considerations:\n\n- **Voice Management**: Map the unified voice resource to provider-specific voice identifiers, handle voice discovery and metadata appropriately for each provider's voice catalog structure\n- **Audio Format Conversion**: Implement native audio format support where available, or provide format conversion for unsupported output formats using audio processing libraries\n- **Streaming Implementation**: Utilize native streaming APIs where supported (ElevenLabs, Deepgram), or implement chunk-based synthesis for providers without native streaming support\n- **Authentication Handling**: Implement appropriate authentication mechanisms (API keys, OAuth, service accounts) per provider requirements\n- **Feature Availability**: Route advanced features (voice cloning, sound effects, speech marks) through provider-native APIs where supported, or return `unsupported-operation` errors for unavailable features\n- **Error Mapping**: Map provider-specific HTTP errors and API responses to the unified `tts-error` enumeration with appropriate context preservation\n- **Rate Limiting**: Handle provider-specific rate limits and quota management, implementing appropriate retry logic and error reporting\n- **Long-form Content**: Implement efficient handling of long-form synthesis using provider-native async operations (AWS Polly) or intelligent chunking strategies\n\n## Testing Requirements\n\nEach implementation must include comprehensive test suites covering:\n- Basic synthesis operations (text-to-speech with various voices and configurations)\n- Voice discovery and metadata retrieval\n- Streaming synthesis lifecycle (session creation, chunk processing, cleanup)\n- Advanced feature testing (voice cloning, sound effects, custom pronunciations where supported)\n- Audio format validation and quality verification\n- Authentication and authorization scenarios\n- Error handling for unsupported operations and malformed inputs\n- Rate limiting and quota management behavior\n- Connection management and retry logic\n- Long-form content synthesis (>5000 characters)\n- Durability semantics verification across operation boundaries\n- Provider-specific feature utilization (lexicons for Polly, voice settings for ElevenLabs, etc.)\n\n## Configuration Requirements\n\nEach implementation should support the following environment variables:\n\n### Common Configuration\n- `TTS_PROVIDER_ENDPOINT`: Custom endpoint URL (for enterprise/regional deployments)\n- `TTS_PROVIDER_TIMEOUT`: Request timeout in seconds (default: 30)\n- `TTS_PROVIDER_MAX_RETRIES`: Maximum retry attempts (default: 3)\n- `TTS_PROVIDER_LOG_LEVEL`: Logging verbosity (debug, info, warn, error)\n\n### Provider-Specific Configuration\n- **ElevenLabs**: `ELEVENLABS_API_KEY`, `ELEVENLABS_MODEL_VERSION`\n- **AWS Polly**: `AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`, `AWS_REGION`, `AWS_SESSION_TOKEN`\n- **Google Cloud**: `GOOGLE_APPLICATION_CREDENTIALS`, `GOOGLE_CLOUD_PROJECT`\n- **Deepgram**: `DEEPGRAM_API_KEY`, `DEEPGRAM_API_VERSION`\n\n```wit\npackage golem:tts@1.0.0;\n\n/// Core types and error handling for universal text-to-speech\ninterface types {\n    /// Comprehensive error types covering all TTS operations\n    variant tts-error {\n        /// Input validation errors\n        invalid-text(string),\n        text-too-long(u32),\n        invalid-ssml(string),\n        unsupported-language(string),\n        \n        /// Voice and model errors\n        voice-not-found(string),\n        model-not-found(string),\n        voice-unavailable(string),\n        \n        /// Authentication and authorization\n        unauthorized(string),\n        access-denied(string),\n        \n        /// Resource and quota limits\n        quota-exceeded(quota-info),\n        rate-limited(u32),\n        insufficient-credits,\n        \n        /// Operation errors\n        synthesis-failed(string),\n        unsupported-operation(string),\n        invalid-configuration(string),\n        \n        /// Service errors\n        service-unavailable(string),\n        network-error(string),\n        internal-error(string),\n        \n        /// Storage errors (for async operations)\n        invalid-storage-location(string),\n        storage-access-denied(string),\n    }\n\n    record quota-info {\n        used: u32,\n        limit: u32,\n        reset-time: u64,\n        unit: quota-unit,\n    }\n\n    enum quota-unit {\n        characters,\n        requests,\n        seconds,\n        credits,\n    }\n\n    /// Language identification using BCP 47 codes\n    type language-code = string;\n\n    /// Voice gender classification\n    enum voice-gender {\n        male,\n        female,\n        neutral,\n    }\n\n    /// Voice quality tiers\n    enum voice-quality {\n        standard,\n        premium,\n        neural,\n        studio,\n    }\n\n    /// Text input types\n    enum text-type {\n        plain,\n        ssml,\n    }\n\n    /// Audio output formats\n    enum audio-format {\n        mp3,\n        wav,\n        pcm,\n        ogg-opus,\n        aac,\n        flac,\n        mulaw,\n        alaw,\n    }\n\n    /// Audio quality settings\n    record audio-config {\n        format: audio-format,\n        sample-rate: option<u32>,\n        bit-rate: option<u32>,\n        channels: option<u8>,\n    }\n\n    /// Voice synthesis parameters\n    record voice-settings {\n        /// Speaking rate (0.25 to 4.0, default 1.0)\n        speed: option<f32>,\n        /// Pitch adjustment in semitones (-20.0 to 20.0, default 0.0)\n        pitch: option<f32>,\n        /// Volume gain in dB (-96.0 to 16.0, default 0.0)\n        volume: option<f32>,\n        /// Voice stability (0.0 to 1.0, provider-specific)\n        stability: option<f32>,\n        /// Similarity to original (0.0 to 1.0, provider-specific)\n        similarity: option<f32>,\n        /// Style exaggeration (0.0 to 1.0, provider-specific)\n        style: option<f32>,\n    }\n\n    /// Audio effects and device optimization\n    flags audio-effects {\n        telephone-quality,\n        headphone-optimized,\n        speaker-optimized,\n        car-audio-optimized,\n        noise-reduction,\n        bass-boost,\n        treble-boost,\n    }\n\n    /// Input text with metadata\n    record text-input {\n        content: string,\n        text-type: text-type,\n        language: option<language-code>,\n    }\n\n    /// Complete synthesis result\n    record synthesis-result {\n        audio-data: list<u8>,\n        metadata: synthesis-metadata,\n    }\n\n    /// Metadata about synthesized audio\n    record synthesis-metadata {\n        duration-seconds: f32,\n        character-count: u32,\n        word-count: u32,\n        audio-size-bytes: u32,\n        request-id: string,\n        provider-info: option<string>,\n    }\n\n    /// Streaming audio chunk\n    record audio-chunk {\n        data: list<u8>,\n        sequence-number: u32,\n        is-final: bool,\n        timing-info: option<timing-info>,\n    }\n\n    /// Timing and synchronization information\n    record timing-info {\n        start-time-seconds: f32,\n        end-time-seconds: option<f32>,\n        text-offset: option<u32>,\n        mark-type: option<timing-mark-type>,\n    }\n\n    enum timing-mark-type {\n        word,\n        sentence,\n        paragraph,\n        ssml-mark,\n        viseme,\n    }\n\n\n}\n\n/// Voice discovery and management\ninterface voices {\n    use types.{tts-error, language-code, voice-gender, voice-quality};\n\n    /// Represents a voice that can be used for speech synthesis\n    resource voice {\n        /// Get voice identification\n        get-id: func() -> string;\n        get-name: func() -> string;\n        get-provider-id: func() -> option<string>;\n        \n        /// Get voice characteristics\n        get-language: func() -> language-code;\n        get-additional-languages: func() -> list<language-code>;\n        get-gender: func() -> voice-gender;\n        get-quality: func() -> voice-quality;\n        get-description: func() -> option<string>;\n        \n        /// Voice capabilities\n        supports-ssml: func() -> bool;\n        get-sample-rates: func() -> list<u32>;\n        get-supported-formats: func() -> list<types.audio-format>;\n        \n        /// Voice management (may return unsupported-operation)\n        update-settings: func(settings: types.voice-settings) -> result<_, tts-error>;\n        delete: func() -> result<_, tts-error>;\n        clone: func() -> result<voice, tts-error>;\n        \n        /// Preview voice with sample text\n        preview: func(text: string) -> result<list<u8>, tts-error>;\n    }\n\n    /// Voice search and filtering\n    record voice-filter {\n        language: option<language-code>,\n        gender: option<voice-gender>,\n        quality: option<voice-quality>,\n        supports-ssml: option<bool>,\n        provider: option<string>,\n        search-query: option<string>,\n    }\n\n    /// Detailed voice information\n    record voice-info {\n        id: string,\n        name: string,\n        language: language-code,\n        additional-languages: list<language-code>,\n        gender: voice-gender,\n        quality: voice-quality,\n        description: option<string>,\n        provider: string,\n        sample-rate: u32,\n        is-custom: bool,\n        is-cloned: bool,\n        preview-url: option<string>,\n        use-cases: list<string>,\n    }\n\n    /// Resource-based iterator for voice results\n    resource voice-results {\n        /// Check if more voices are available\n        has-more: func() -> bool;\n        \n        /// Get next batch of voices\n        get-next: func() -> result<list<voice-info>, tts-error>;\n        \n        /// Get total count if available\n        get-total-count: func() -> option<u32>;\n    }\n\n    /// List available voices with filtering and pagination\n    list-voices: func(\n        filter: option<voice-filter>\n    ) -> result<voice-results, tts-error>;\n\n    /// Get specific voice by ID\n    get-voice: func(voice-id: string) -> result<voice, tts-error>;\n\n    /// Search voices by characteristics\n    search-voices: func(\n        query: string,\n        filter: option<voice-filter>\n    ) -> result<list<voice-info>, tts-error>;\n\n    /// Get supported languages\n    list-languages: func() -> result<list<language-info>, tts-error>;\n\n    record language-info {\n        code: language-code,\n        name: string,\n        native-name: string,\n        voice-count: u32,\n    }\n}\n\n/// Core text-to-speech synthesis operations\ninterface synthesis {\n    use types.{\n        text-input, audio-config, voice-settings, audio-effects,\n        synthesis-result, tts-error, timing-info\n    };\n    use voices.{voice};\n\n    /// Synthesis configuration options\n    record synthesis-options {\n        audio-config: option<audio-config>,\n        voice-settings: option<voice-settings>,\n        audio-effects: option<audio-effects>,\n        enable-timing: option<bool>,\n        enable-word-timing: option<bool>,\n        seed: option<u32>,\n        model-version: option<string>,\n        context: option<synthesis-context>,\n    }\n\n    /// Context for better synthesis quality\n    record synthesis-context {\n        previous-text: option<string>,\n        next-text: option<string>,\n        topic: option<string>,\n        emotion: option<string>,\n        speaking-style: option<string>,\n    }\n\n    /// Convert text to speech (removed async)\n    synthesize: func(\n        input: text-input,\n        voice: borrow<voice>,\n        options: option<synthesis-options>\n    ) -> result<synthesis-result, tts-error>;\n\n    /// Batch synthesis for multiple inputs (removed async)\n    synthesize-batch: func(\n        inputs: list<text-input>,\n        voice: borrow<voice>,\n        options: option<synthesis-options>\n    ) -> result<list<synthesis-result>, tts-error>;\n\n    /// Get timing information without audio synthesis\n    get-timing-marks: func(\n        input: text-input,\n        voice: borrow<voice>\n    ) -> result<list<timing-info>, tts-error>;\n\n    /// Validate text before synthesis\n    validate-input: func(\n        input: text-input,\n        voice: borrow<voice>\n    ) -> result<validation-result, tts-error>;\n\n    record validation-result {\n        is-valid: bool,\n        character-count: u32,\n        estimated-duration: option<f32>,\n        warnings: list<string>,\n        errors: list<string>,\n    }\n}\n\n/// Real-time streaming synthesis\ninterface streaming {\n    use types.{\n        text-input, audio-config, voice-settings, audio-chunk,\n        tts-error, timing-info\n    };\n    use voices.{voice};\n    use synthesis.{synthesis-options};\n\n    /// Streaming synthesis session\n    resource synthesis-stream {\n        /// Send text for synthesis (can be called multiple times)\n        send-text: func(input: text-input) -> result<_, tts-error>;\n        \n        /// Signal end of input and flush remaining audio\n        finish: func() -> result<_, tts-error>;\n        \n        /// Receive next audio chunk (non-blocking)\n        receive-chunk: func() -> result<option<audio-chunk>, tts-error>;\n        \n        /// Check if more chunks are available\n        has-pending-audio: func() -> bool;\n        \n        /// Get current stream status\n        get-status: func() -> stream-status;\n        \n        /// Close stream and clean up resources\n        close: func();\n    }\n\n    enum stream-status {\n        ready,\n        processing,\n        finished,\n        error,\n        closed,\n    }\n\n    /// Create streaming synthesis session\n    create-stream: func(\n        voice: borrow<voice>,\n        options: option<synthesis-options>\n    ) -> result<synthesis-stream, tts-error>;\n\n    /// Real-time voice conversion streaming\n    create-voice-conversion-stream: func(\n        target-voice: borrow<voice>,\n        options: option<synthesis-options>\n    ) -> result<voice-conversion-stream, tts-error>;\n\n    resource voice-conversion-stream {\n        /// Send input audio chunks\n        send-audio: func(audio-data: list<u8>) -> result<_, tts-error>;\n        \n        /// Receive converted audio chunks\n        receive-converted: func() -> result<option<audio-chunk>, tts-error>;\n        \n        finish: func() -> result<_, tts-error>;\n        close: func();\n    }\n}\n\n/// Advanced TTS features and voice manipulation\ninterface advanced {\n    use types.{tts-error, audio-config, language-code};\n    use voices.{voice};\n\n    /// Voice cloning and creation (removed async)\n    create-voice-clone: func(\n        name: string,\n        audio-samples: list<audio-sample>,\n        description: option<string>\n    ) -> result<voice, tts-error>;\n\n    record audio-sample {\n        data: list<u8>,\n        transcript: option<string>,\n        quality-rating: option<u8>,\n    }\n\n    /// Design synthetic voice (removed async)\n    design-voice: func(\n        name: string,\n        characteristics: voice-design-params\n    ) -> result<voice, tts-error>;\n\n    record voice-design-params {\n        gender: types.voice-gender,\n        age-category: age-category,\n        accent: string,\n        personality-traits: list<string>,\n        reference-voice: option<string>,\n    }\n\n    enum age-category {\n        child,\n        young-adult,\n        middle-aged,\n        elderly,\n    }\n\n    /// Voice-to-voice conversion (removed async)\n    convert-voice: func(\n        input-audio: list<u8>,\n        target-voice: borrow<voice>,\n        preserve-timing: option<bool>\n    ) -> result<list<u8>, tts-error>;\n\n    /// Generate sound effects from text description (removed async)\n    generate-sound-effect: func(\n        description: string,\n        duration-seconds: option<f32>,\n        style-influence: option<f32>\n    ) -> result<list<u8>, tts-error>;\n\n    /// Custom pronunciation management\n    resource pronunciation-lexicon {\n        get-name: func() -> string;\n        get-language: func() -> language-code;\n        get-entry-count: func() -> u32;\n        \n        /// Add pronunciation rule\n        add-entry: func(word: string, pronunciation: string) -> result<_, tts-error>;\n        \n        /// Remove pronunciation rule\n        remove-entry: func(word: string) -> result<_, tts-error>;\n        \n        /// Export lexicon content\n        export-content: func() -> result<string, tts-error>;\n    }\n\n    /// Create custom pronunciation lexicon\n    create-lexicon: func(\n        name: string,\n        language: language-code,\n        entries: option<list<pronunciation-entry>>\n    ) -> result<pronunciation-lexicon, tts-error>;\n\n    record pronunciation-entry {\n        word: string,\n        pronunciation: string,\n        part-of-speech: option<string>,\n    }\n\n    /// Long-form content synthesis with optimization (removed async)\n    synthesize-long-form: func(\n        content: string,\n        voice: borrow<voice>,\n        output-location: string,\n        chapter-breaks: option<list<u32>>\n    ) -> result<long-form-operation, tts-error>;\n\n    resource long-form-operation {\n        get-status: func() -> operation-status;\n        get-progress: func() -> f32;\n        cancel: func() -> result<_, tts-error>;\n        get-result: func() -> result<long-form-result, tts-error>;\n    }\n\n    enum operation-status {\n        pending,\n        processing,\n        completed,\n        failed,\n        cancelled,\n    }\n\n    record long-form-result {\n        output-location: string,\n        total-duration: f32,\n        chapter-durations: option<list<f32>>,\n        metadata: types.synthesis-metadata,\n    }\n}\n```",
                  "html_url": "https://github.com/golemcloud/golem-ai/issues/23"
                },
                "type": "github"
              },
              "hash": "golemcloud/golem-ai#23",
              "body": "I have attached to this ticket a WIT file that describes a generic interface for text-to-speech operations. This interface can be implemented by various providers, either by emulating features not present in a given provider, utilizing the provider's native support for a feature, or indicating an error if a particular combination is not natively supported by a provider.\n\nThe intent of this WIT specification is to allow developers of WASM components (on wasmCloud, Spin, or Golem) to leverage text-to-speech capabilities to build voice-powered applications, accessibility services, and audio content generation systems in a portable and provider-agnostic fashion.\n\nThis ticket involves constructing implementations of this WIT interface for the following providers:\n\n- **ElevenLabs**: The leading AI voice synthesis platform with comprehensive voice cloning, real-time streaming, voice conversion, and sound effects generation capabilities.\n- **AWS Polly**: Amazon's enterprise text-to-speech service with extensive language support, custom lexicons, speech marks, and asynchronous synthesis for long-form content.\n- **Google Cloud Text-to-Speech**: Google's neural voice synthesis service with WaveNet and Neural2 voices, device optimization profiles, and streaming synthesis capabilities.\n- **Deepgram Aura**: High-performance real-time TTS with session-based streaming, low-latency neural voices, and conversational AI optimization.\n\nThese implementations must be written in Rust and compilable to WASM Components (WASI 0.23 only, since Golem does not yet support WASI 0.3). The standard Rust toolchain for WASM component development can be employed (see cargo component and the Rust examples of components in this and other Golem repositories).\n\nAdditionally, these implementations should incorporate custom durability semantics using the Golem durability API and the Golem host API. This approach ensures that durability is managed at the level of individual TTS operations (voice synthesis, streaming session creation, voice cloning, batch processing), providing a higher-level and clearer operation log, which aids in debugging and monitoring. See golem:llm and golem:embed for more details and durable implementations in this same repository.\n\nThe final deliverables associated with this ticket are:\n\n- **ElevenLabs implementation**: A WASM Component (WASI 0.23), named `tts-elevenlabs.wasm`, with a full test suite and custom durability implementation at the level of TTS operations.\n- **AWS Polly implementation**: A WASM Component (WASI 0.23), named `tts-polly.wasm`, with a full test suite and custom durability implementation at the level of TTS operations.\n- **Google Cloud TTS implementation**: A WASM Component (WASI 0.23), named `tts-google.wasm`, with a full test suite and custom durability implementation at the level of TTS operations.\n- **Deepgram Aura implementation**: A WASM Component (WASI 0.23), named `tts-deepgram.wasm`, with a full test suite and custom durability implementation at the level of TTS operations.\n\n**Note**: If you have a strong recommendation to swap out one or two of these with other popular / common TTS providers (such as Azure Cognitive Services Speech, IBM Watson Text to Speech, or OpenAI TTS), then as long as you get permission beforehand, that's okay with me. However, we definitely need ElevenLabs and AWS Polly.\n\nThese components will require runtime configuration, notably API keys, endpoint URLs, authentication credentials, and provider-specific settings. For configuring this information, the components can use environment variables for now (in the future, they will use wasi-runtime-config, but Golem does not support this yet, whereas Golem has good support for environment variables).\n\nMoreover, the Rust components need to be tested within Golem to ensure compatibility with Golem 1.2.x.\n\nThis WIT has been designed by examining and comparing the APIs of ElevenLabs, AWS Polly, Google Cloud TTS, Azure Speech Services, OpenAI TTS, and Deepgram Aura. However, given there are no implementations, it is possible the provided WIT is not the optimal abstraction across all these providers. Therefore, deviations from the proposed design can be made. However, to be accepted, any deviation must be fully justified and deemed by Golem core contributors to be an improvement from the original specification.\n\n## Implementation Guidelines\n\nEach provider implementation should handle the following key mapping considerations:\n\n- **Voice Management**: Map the unified voice resource to provider-specific voice identifiers, handle voice discovery and metadata appropriately for each provider's voice catalog structure\n- **Audio Format Conversion**: Implement native audio format support where available, or provide format conversion for unsupported output formats using audio processing libraries\n- **Streaming Implementation**: Utilize native streaming APIs where supported (ElevenLabs, Deepgram), or implement chunk-based synthesis for providers without native streaming support\n- **Authentication Handling**: Implement appropriate authentication mechanisms (API keys, OAuth, service accounts) per provider requirements\n- **Feature Availability**: Route advanced features (voice cloning, sound effects, speech marks) through provider-native APIs where supported, or return `unsupported-operation` errors for unavailable features\n- **Error Mapping**: Map provider-specific HTTP errors and API responses to the unified `tts-error` enumeration with appropriate context preservation\n- **Rate Limiting**: Handle provider-specific rate limits and quota management, implementing appropriate retry logic and error reporting\n- **Long-form Content**: Implement efficient handling of long-form synthesis using provider-native async operations (AWS Polly) or intelligent chunking strategies\n\n## Testing Requirements\n\nEach implementation must include comprehensive test suites covering:\n- Basic synthesis operations (text-to-speech with various voices and configurations)\n- Voice discovery and metadata retrieval\n- Streaming synthesis lifecycle (session creation, chunk processing, cleanup)\n- Advanced feature testing (voice cloning, sound effects, custom pronunciations where supported)\n- Audio format validation and quality verification\n- Authentication and authorization scenarios\n- Error handling for unsupported operations and malformed inputs\n- Rate limiting and quota management behavior\n- Connection management and retry logic\n- Long-form content synthesis (>5000 characters)\n- Durability semantics verification across operation boundaries\n- Provider-specific feature utilization (lexicons for Polly, voice settings for ElevenLabs, etc.)\n\n## Configuration Requirements\n\nEach implementation should support the following environment variables:\n\n### Common Configuration\n- `TTS_PROVIDER_ENDPOINT`: Custom endpoint URL (for enterprise/regional deployments)\n- `TTS_PROVIDER_TIMEOUT`: Request timeout in seconds (default: 30)\n- `TTS_PROVIDER_MAX_RETRIES`: Maximum retry attempts (default: 3)\n- `TTS_PROVIDER_LOG_LEVEL`: Logging verbosity (debug, info, warn, error)\n\n### Provider-Specific Configuration\n- **ElevenLabs**: `ELEVENLABS_API_KEY`, `ELEVENLABS_MODEL_VERSION`\n- **AWS Polly**: `AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`, `AWS_REGION`, `AWS_SESSION_TOKEN`\n- **Google Cloud**: `GOOGLE_APPLICATION_CREDENTIALS`, `GOOGLE_CLOUD_PROJECT`\n- **Deepgram**: `DEEPGRAM_API_KEY`, `DEEPGRAM_API_VERSION`\n\n```wit\npackage golem:tts@1.0.0;\n\n/// Core types and error handling for universal text-to-speech\ninterface types {\n    /// Comprehensive error types covering all TTS operations\n    variant tts-error {\n        /// Input validation errors\n        invalid-text(string),\n        text-too-long(u32),\n        invalid-ssml(string),\n        unsupported-language(string),\n        \n        /// Voice and model errors\n        voice-not-found(string),\n        model-not-found(string),\n        voice-unavailable(string),\n        \n        /// Authentication and authorization\n        unauthorized(string),\n        access-denied(string),\n        \n        /// Resource and quota limits\n        quota-exceeded(quota-info),\n        rate-limited(u32),\n        insufficient-credits,\n        \n        /// Operation errors\n        synthesis-failed(string),\n        unsupported-operation(string),\n        invalid-configuration(string),\n        \n        /// Service errors\n        service-unavailable(string),\n        network-error(string),\n        internal-error(string),\n        \n        /// Storage errors (for async operations)\n        invalid-storage-location(string),\n        storage-access-denied(string),\n    }\n\n    record quota-info {\n        used: u32,\n        limit: u32,\n        reset-time: u64,\n        unit: quota-unit,\n    }\n\n    enum quota-unit {\n        characters,\n        requests,\n        seconds,\n        credits,\n    }\n\n    /// Language identification using BCP 47 codes\n    type language-code = string;\n\n    /// Voice gender classification\n    enum voice-gender {\n        male,\n        female,\n        neutral,\n    }\n\n    /// Voice quality tiers\n    enum voice-quality {\n        standard,\n        premium,\n        neural,\n        studio,\n    }\n\n    /// Text input types\n    enum text-type {\n        plain,\n        ssml,\n    }\n\n    /// Audio output formats\n    enum audio-format {\n        mp3,\n        wav,\n        pcm,\n        ogg-opus,\n        aac,\n        flac,\n        mulaw,\n        alaw,\n    }\n\n    /// Audio quality settings\n    record audio-config {\n        format: audio-format,\n        sample-rate: option<u32>,\n        bit-rate: option<u32>,\n        channels: option<u8>,\n    }\n\n    /// Voice synthesis parameters\n    record voice-settings {\n        /// Speaking rate (0.25 to 4.0, default 1.0)\n        speed: option<f32>,\n        /// Pitch adjustment in semitones (-20.0 to 20.0, default 0.0)\n        pitch: option<f32>,\n        /// Volume gain in dB (-96.0 to 16.0, default 0.0)\n        volume: option<f32>,\n        /// Voice stability (0.0 to 1.0, provider-specific)\n        stability: option<f32>,\n        /// Similarity to original (0.0 to 1.0, provider-specific)\n        similarity: option<f32>,\n        /// Style exaggeration (0.0 to 1.0, provider-specific)\n        style: option<f32>,\n    }\n\n    /// Audio effects and device optimization\n    flags audio-effects {\n        telephone-quality,\n        headphone-optimized,\n        speaker-optimized,\n        car-audio-optimized,\n        noise-reduction,\n        bass-boost,\n        treble-boost,\n    }\n\n    /// Input text with metadata\n    record text-input {\n        content: string,\n        text-type: text-type,\n        language: option<language-code>,\n    }\n\n    /// Complete synthesis result\n    record synthesis-result {\n        audio-data: list<u8>,\n        metadata: synthesis-metadata,\n    }\n\n    /// Metadata about synthesized audio\n    record synthesis-metadata {\n        duration-seconds: f32,\n        character-count: u32,\n        word-count: u32,\n        audio-size-bytes: u32,\n        request-id: string,\n        provider-info: option<string>,\n    }\n\n    /// Streaming audio chunk\n    record audio-chunk {\n        data: list<u8>,\n        sequence-number: u32,\n        is-final: bool,\n        timing-info: option<timing-info>,\n    }\n\n    /// Timing and synchronization information\n    record timing-info {\n        start-time-seconds: f32,\n        end-time-seconds: option<f32>,\n        text-offset: option<u32>,\n        mark-type: option<timing-mark-type>,\n    }\n\n    enum timing-mark-type {\n        word,\n        sentence,\n        paragraph,\n        ssml-mark,\n        viseme,\n    }\n\n\n}\n\n/// Voice discovery and management\ninterface voices {\n    use types.{tts-error, language-code, voice-gender, voice-quality};\n\n    /// Represents a voice that can be used for speech synthesis\n    resource voice {\n        /// Get voice identification\n        get-id: func() -> string;\n        get-name: func() -> string;\n        get-provider-id: func() -> option<string>;\n        \n        /// Get voice characteristics\n        get-language: func() -> language-code;\n        get-additional-languages: func() -> list<language-code>;\n        get-gender: func() -> voice-gender;\n        get-quality: func() -> voice-quality;\n        get-description: func() -> option<string>;\n        \n        /// Voice capabilities\n        supports-ssml: func() -> bool;\n        get-sample-rates: func() -> list<u32>;\n        get-supported-formats: func() -> list<types.audio-format>;\n        \n        /// Voice management (may return unsupported-operation)\n        update-settings: func(settings: types.voice-settings) -> result<_, tts-error>;\n        delete: func() -> result<_, tts-error>;\n        clone: func() -> result<voice, tts-error>;\n        \n        /// Preview voice with sample text\n        preview: func(text: string) -> result<list<u8>, tts-error>;\n    }\n\n    /// Voice search and filtering\n    record voice-filter {\n        language: option<language-code>,\n        gender: option<voice-gender>,\n        quality: option<voice-quality>,\n        supports-ssml: option<bool>,\n        provider: option<string>,\n        search-query: option<string>,\n    }\n\n    /// Detailed voice information\n    record voice-info {\n        id: string,\n        name: string,\n        language: language-code,\n        additional-languages: list<language-code>,\n        gender: voice-gender,\n        quality: voice-quality,\n        description: option<string>,\n        provider: string,\n        sample-rate: u32,\n        is-custom: bool,\n        is-cloned: bool,\n        preview-url: option<string>,\n        use-cases: list<string>,\n    }\n\n    /// Resource-based iterator for voice results\n    resource voice-results {\n        /// Check if more voices are available\n        has-more: func() -> bool;\n        \n        /// Get next batch of voices\n        get-next: func() -> result<list<voice-info>, tts-error>;\n        \n        /// Get total count if available\n        get-total-count: func() -> option<u32>;\n    }\n\n    /// List available voices with filtering and pagination\n    list-voices: func(\n        filter: option<voice-filter>\n    ) -> result<voice-results, tts-error>;\n\n    /// Get specific voice by ID\n    get-voice: func(voice-id: string) -> result<voice, tts-error>;\n\n    /// Search voices by characteristics\n    search-voices: func(\n        query: string,\n        filter: option<voice-filter>\n    ) -> result<list<voice-info>, tts-error>;\n\n    /// Get supported languages\n    list-languages: func() -> result<list<language-info>, tts-error>;\n\n    record language-info {\n        code: language-code,\n        name: string,\n        native-name: string,\n        voice-count: u32,\n    }\n}\n\n/// Core text-to-speech synthesis operations\ninterface synthesis {\n    use types.{\n        text-input, audio-config, voice-settings, audio-effects,\n        synthesis-result, tts-error, timing-info\n    };\n    use voices.{voice};\n\n    /// Synthesis configuration options\n    record synthesis-options {\n        audio-config: option<audio-config>,\n        voice-settings: option<voice-settings>,\n        audio-effects: option<audio-effects>,\n        enable-timing: option<bool>,\n        enable-word-timing: option<bool>,\n        seed: option<u32>,\n        model-version: option<string>,\n        context: option<synthesis-context>,\n    }\n\n    /// Context for better synthesis quality\n    record synthesis-context {\n        previous-text: option<string>,\n        next-text: option<string>,\n        topic: option<string>,\n        emotion: option<string>,\n        speaking-style: option<string>,\n    }\n\n    /// Convert text to speech (removed async)\n    synthesize: func(\n        input: text-input,\n        voice: borrow<voice>,\n        options: option<synthesis-options>\n    ) -> result<synthesis-result, tts-error>;\n\n    /// Batch synthesis for multiple inputs (removed async)\n    synthesize-batch: func(\n        inputs: list<text-input>,\n        voice: borrow<voice>,\n        options: option<synthesis-options>\n    ) -> result<list<synthesis-result>, tts-error>;\n\n    /// Get timing information without audio synthesis\n    get-timing-marks: func(\n        input: text-input,\n        voice: borrow<voice>\n    ) -> result<list<timing-info>, tts-error>;\n\n    /// Validate text before synthesis\n    validate-input: func(\n        input: text-input,\n        voice: borrow<voice>\n    ) -> result<validation-result, tts-error>;\n\n    record validation-result {\n        is-valid: bool,\n        character-count: u32,\n        estimated-duration: option<f32>,\n        warnings: list<string>,\n        errors: list<string>,\n    }\n}\n\n/// Real-time streaming synthesis\ninterface streaming {\n    use types.{\n        text-input, audio-config, voice-settings, audio-chunk,\n        tts-error, timing-info\n    };\n    use voices.{voice};\n    use synthesis.{synthesis-options};\n\n    /// Streaming synthesis session\n    resource synthesis-stream {\n        /// Send text for synthesis (can be called multiple times)\n        send-text: func(input: text-input) -> result<_, tts-error>;\n        \n        /// Signal end of input and flush remaining audio\n        finish: func() -> result<_, tts-error>;\n        \n        /// Receive next audio chunk (non-blocking)\n        receive-chunk: func() -> result<option<audio-chunk>, tts-error>;\n        \n        /// Check if more chunks are available\n        has-pending-audio: func() -> bool;\n        \n        /// Get current stream status\n        get-status: func() -> stream-status;\n        \n        /// Close stream and clean up resources\n        close: func();\n    }\n\n    enum stream-status {\n        ready,\n        processing,\n        finished,\n        error,\n        closed,\n    }\n\n    /// Create streaming synthesis session\n    create-stream: func(\n        voice: borrow<voice>,\n        options: option<synthesis-options>\n    ) -> result<synthesis-stream, tts-error>;\n\n    /// Real-time voice conversion streaming\n    create-voice-conversion-stream: func(\n        target-voice: borrow<voice>,\n        options: option<synthesis-options>\n    ) -> result<voice-conversion-stream, tts-error>;\n\n    resource voice-conversion-stream {\n        /// Send input audio chunks\n        send-audio: func(audio-data: list<u8>) -> result<_, tts-error>;\n        \n        /// Receive converted audio chunks\n        receive-converted: func() -> result<option<audio-chunk>, tts-error>;\n        \n        finish: func() -> result<_, tts-error>;\n        close: func();\n    }\n}\n\n/// Advanced TTS features and voice manipulation\ninterface advanced {\n    use types.{tts-error, audio-config, language-code};\n    use voices.{voice};\n\n    /// Voice cloning and creation (removed async)\n    create-voice-clone: func(\n        name: string,\n        audio-samples: list<audio-sample>,\n        description: option<string>\n    ) -> result<voice, tts-error>;\n\n    record audio-sample {\n        data: list<u8>,\n        transcript: option<string>,\n        quality-rating: option<u8>,\n    }\n\n    /// Design synthetic voice (removed async)\n    design-voice: func(\n        name: string,\n        characteristics: voice-design-params\n    ) -> result<voice, tts-error>;\n\n    record voice-design-params {\n        gender: types.voice-gender,\n        age-category: age-category,\n        accent: string,\n        personality-traits: list<string>,\n        reference-voice: option<string>,\n    }\n\n    enum age-category {\n        child,\n        young-adult,\n        middle-aged,\n        elderly,\n    }\n\n    /// Voice-to-voice conversion (removed async)\n    convert-voice: func(\n        input-audio: list<u8>,\n        target-voice: borrow<voice>,\n        preserve-timing: option<bool>\n    ) -> result<list<u8>, tts-error>;\n\n    /// Generate sound effects from text description (removed async)\n    generate-sound-effect: func(\n        description: string,\n        duration-seconds: option<f32>,\n        style-influence: option<f32>\n    ) -> result<list<u8>, tts-error>;\n\n    /// Custom pronunciation management\n    resource pronunciation-lexicon {\n        get-name: func() -> string;\n        get-language: func() -> language-code;\n        get-entry-count: func() -> u32;\n        \n        /// Add pronunciation rule\n        add-entry: func(word: string, pronunciation: string) -> result<_, tts-error>;\n        \n        /// Remove pronunciation rule\n        remove-entry: func(word: string) -> result<_, tts-error>;\n        \n        /// Export lexicon content\n        export-content: func() -> result<string, tts-error>;\n    }\n\n    /// Create custom pronunciation lexicon\n    create-lexicon: func(\n        name: string,\n        language: language-code,\n        entries: option<list<pronunciation-entry>>\n    ) -> result<pronunciation-lexicon, tts-error>;\n\n    record pronunciation-entry {\n        word: string,\n        pronunciation: string,\n        part-of-speech: option<string>,\n    }\n\n    /// Long-form content synthesis with optimization (removed async)\n    synthesize-long-form: func(\n        content: string,\n        voice: borrow<voice>,\n        output-location: string,\n        chapter-breaks: option<list<u32>>\n    ) -> result<long-form-operation, tts-error>;\n\n    resource long-form-operation {\n        get-status: func() -> operation-status;\n        get-progress: func() -> f32;\n        cancel: func() -> result<_, tts-error>;\n        get-result: func() -> result<long-form-result, tts-error>;\n    }\n\n    enum operation-status {\n        pending,\n        processing,\n        completed,\n        failed,\n        cancelled,\n    }\n\n    record long-form-result {\n        output-location: string,\n        total-duration: f32,\n        chapter-durations: option<list<f32>>,\n        metadata: types.synthesis-metadata,\n    }\n}\n```",
              "url": "https://github.com/golemcloud/golem-ai/issues/23",
              "tech": [
                "go"
              ],
              "repo_name": "golem-ai",
              "repo_owner": "golemcloud",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "activepieces#9703",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "activepieces",
              "id": "generated-activepieces",
              "name": "Activepieces",
              "description": "",
              "members": [],
              "display_name": "Activepieces",
              "created_at": "2026-01-23T05:52:18.984Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/activepieces?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "activepieces",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-23T05:52:18.984Z",
            "created_at": "2026-01-23T05:52:18.984Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-activepieces#9703",
              "status": "open",
              "type": "issue",
              "number": 9703,
              "title": "[MCP] Oracle Fusion Cloud ERP",
              "source": {
                "data": {
                  "id": "source-activepieces#9703",
                  "user": {
                    "login": "kishanprmr",
                    "id": 135701940,
                    "node_id": "U_kgDOCBaltA",
                    "avatar_url": "https://avatars.githubusercontent.com/u/135701940?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/kishanprmr",
                    "html_url": "https://github.com/kishanprmr",
                    "followers_url": "https://api.github.com/users/kishanprmr/followers",
                    "following_url": "https://api.github.com/users/kishanprmr/following{/other_user}",
                    "gists_url": "https://api.github.com/users/kishanprmr/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/kishanprmr/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/kishanprmr/subscriptions",
                    "organizations_url": "https://api.github.com/users/kishanprmr/orgs",
                    "repos_url": "https://api.github.com/users/kishanprmr/repos",
                    "events_url": "https://api.github.com/users/kishanprmr/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/kishanprmr/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "[MCP] Oracle Fusion Cloud ERP",
                  "body": "## ​ 🧩 Product Overview\n\nOracle Fusion Cloud ERP is an enterprise resource planning suite covering financials, procurement, project accounting, supply chain, and more. This integration supports generic record operations (CRUD + search + watch) across business objects in Fusion ERP, enabling automation and data synchronization. \n\n---\n\n## ​​ ⚠️ Important Note for Contributors\n\nThis feature must be submitted as a [Piece](https://www.activepieces.com/docs/developers/building-pieces/piece-definition) following the Activepieces architecture. Submissions not following this format will not be accepted. Please make sure to review the [Piece Development Guidelines](https://www.activepieces.com/docs/developers/building-pieces/overview) before starting development.\n\n---\n\n## 🚨 Triggers\n\n| **Trigger** | **Description** | \n|:--|:--|\n| **New Record** | Fires when new records are created in a specified business object (e.g. Invoice, Purchase Order, Customer) in Oracle ERP. | \n\n\n---\n\n## ​​ 🛠️ Write Actions\n\n| **Action** | **Description** | **Use Case Example** |\n|:--|:--|:--|\n| **Create Record**     | Create a new record in a specified object (e.g. Invoice, PO, Customer). | Automate creating purchase orders from purchase requests.  |\n| **Update Record**     | Update fields of an existing record (by object + ID).                      | Update invoice status, adjust amounts, modify due dates. |\n| **Delete a Record**    | Delete (or mark for deletion) a record by ID.                             | Remove test or obsolete records.  |\n| **Get a Record**     | Retrieve the details of a specific record (by object type and ID). | Fetch detailed invoice or supplier info when needed.  |\n\n\n\n---\n\n## 🔍 Search Actions\n\n| Action Name       | Description                                                                 | \n|--------------------|-----------------------------------------------------------------------------|\n| **Search Records**   | Retrieve a list of records matching filter criteria (object + query). |\n\n---\n\n## ​ 📚 API Reference\n\n- [Oracle Fusion Cloud ERP API Documentation](https://docs.oracle.com/en/cloud/saas/financials/25d/farfa/index.html)\n\n---\n\n## ​ 🧪 Test Account Access\n\n- You can create free trial at https://www.oracle.com/in/erp/financials/.\n\n---\n\n## ​​​🧑‍💻 New to Activepieces?\n\nActivepieces is the leading open source AI automation platform. We have many apps (we call them Pieces), that are available within the builder and as MCPs. These apps are build with our TypeScript framework and are easy to build. Once they're merged to our repo, they will available as pieces in our automation builder and as MCPs to be used with AI agents and MCP clients.\n\nWe welcome contributions and in fact, we get excited over them. Start your journey here: https://www.activepieces.com/docs/developers/building-pieces/overview\n",
                  "html_url": "https://github.com/activepieces/activepieces/issues/9703"
                },
                "type": "github"
              },
              "hash": "activepieces/activepieces#9703",
              "body": "## ​ 🧩 Product Overview\n\nOracle Fusion Cloud ERP is an enterprise resource planning suite covering financials, procurement, project accounting, supply chain, and more. This integration supports generic record operations (CRUD + search + watch) across business objects in Fusion ERP, enabling automation and data synchronization. \n\n---\n\n## ​​ ⚠️ Important Note for Contributors\n\nThis feature must be submitted as a [Piece](https://www.activepieces.com/docs/developers/building-pieces/piece-definition) following the Activepieces architecture. Submissions not following this format will not be accepted. Please make sure to review the [Piece Development Guidelines](https://www.activepieces.com/docs/developers/building-pieces/overview) before starting development.\n\n---\n\n## 🚨 Triggers\n\n| **Trigger** | **Description** | \n|:--|:--|\n| **New Record** | Fires when new records are created in a specified business object (e.g. Invoice, Purchase Order, Customer) in Oracle ERP. | \n\n\n---\n\n## ​​ 🛠️ Write Actions\n\n| **Action** | **Description** | **Use Case Example** |\n|:--|:--|:--|\n| **Create Record**     | Create a new record in a specified object (e.g. Invoice, PO, Customer). | Automate creating purchase orders from purchase requests.  |\n| **Update Record**     | Update fields of an existing record (by object + ID).                      | Update invoice status, adjust amounts, modify due dates. |\n| **Delete a Record**    | Delete (or mark for deletion) a record by ID.                             | Remove test or obsolete records.  |\n| **Get a Record**     | Retrieve the details of a specific record (by object type and ID). | Fetch detailed invoice or supplier info when needed.  |\n\n\n\n---\n\n## 🔍 Search Actions\n\n| Action Name       | Description                                                                 | \n|--------------------|-----------------------------------------------------------------------------|\n| **Search Records**   | Retrieve a list of records matching filter criteria (object + query). |\n\n---\n\n## ​ 📚 API Reference\n\n- [Oracle Fusion Cloud ERP API Documentation](https://docs.oracle.com/en/cloud/saas/financials/25d/farfa/index.html)\n\n---\n\n## ​ 🧪 Test Account Access\n\n- You can create free trial at https://www.oracle.com/in/erp/financials/.\n\n---\n\n## ​​​🧑‍💻 New to Activepieces?\n\nActivepieces is the leading open source AI automation platform. We have many apps (we call them Pieces), that are available within the builder and as MCPs. These apps are build with our TypeScript framework and are easy to build. Once they're merged to our repo, they will available as pieces in our automation builder and as MCPs to be used with AI agents and MCP clients.\n\nWe welcome contributions and in fact, we get excited over them. Start your journey here: https://www.activepieces.com/docs/developers/building-pieces/overview\n",
              "url": "https://github.com/activepieces/activepieces/issues/9703",
              "tech": [],
              "repo_name": "activepieces",
              "repo_owner": "activepieces",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "activepieces#8284",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "activepieces",
              "id": "generated-activepieces",
              "name": "Activepieces",
              "description": "",
              "members": [],
              "display_name": "Activepieces",
              "created_at": "2026-01-23T05:52:19.094Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/activepieces?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "activepieces",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-23T05:52:19.094Z",
            "created_at": "2026-01-23T05:52:19.094Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-activepieces#8284",
              "status": "open",
              "type": "issue",
              "number": 8284,
              "title": "[MCP] Klaviyo",
              "source": {
                "data": {
                  "id": "source-activepieces#8284",
                  "user": {
                    "login": "kishanprmr",
                    "id": 135701940,
                    "node_id": "U_kgDOCBaltA",
                    "avatar_url": "https://avatars.githubusercontent.com/u/135701940?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/kishanprmr",
                    "html_url": "https://github.com/kishanprmr",
                    "followers_url": "https://api.github.com/users/kishanprmr/followers",
                    "following_url": "https://api.github.com/users/kishanprmr/following{/other_user}",
                    "gists_url": "https://api.github.com/users/kishanprmr/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/kishanprmr/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/kishanprmr/subscriptions",
                    "organizations_url": "https://api.github.com/users/kishanprmr/orgs",
                    "repos_url": "https://api.github.com/users/kishanprmr/repos",
                    "events_url": "https://api.github.com/users/kishanprmr/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/kishanprmr/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "[MCP] Klaviyo",
                  "body": "## 🧩 Product Overview\n\nKlaviyo is a marketing automation platform for email, SMS, and customer data.  \nThis integration enables AI agents and workflows to create, manage, and interact with profiles, lists, events, campaigns, and segments, automating customer engagement and analytics.\n\n---\n\n## ⚠️ Important Note for Contributors\n\nTo ensure consistency and maintainability, this feature must be submitted as a [Piece](https://www.activepieces.com/docs/developers/building-pieces/piece-definition) following the Activepieces architecture. Submissions that do not follow this format will not be accepted. Please make sure to review the [Piece Development Guidelines](https://www.activepieces.com/docs/developers/building-pieces/overview) before starting development.\n\n---\n\n## 🚨 Triggers\n\n| **Trigger** | **Use Case** |\n|-------------|---------------|\n| **New Profile** | Triggers when a new profile is created in the account. |\n| **Profile Added to List/Segment** | Fires when a profile is added to a specific list or segment. |\n\n---\n\n## 🛠️ Write Actions\n\n| **Action Item** | **Use Case** |\n|-----------------|---------------|\n| **Create Profile** | Add a new user profile to Klaviyo, optionally subscribing to email/SMS. |\n| **Update Profile** | Update existing profile data and preferences. |\n| **Subscribe Profile** | Subscribe a profile to email or SMS lists. |\n| **Unsubscribe Profile** | Remove a profile from email or SMS lists. |\n| **Add Profile to List** | Add a profile to a specific list. |\n| **Remove Profile from List** | Remove a profile from a specific list. |\n| **Create List** | Create a new subscriber list. |\n\n---\n\n## 🔍 Search Actions\n\n| **Action Item** | **Use Case** |\n|-----------------|---------------|\n| **Find Profile by Email/Phone** | Locate a profile using email or phone number. |\n| **Find List by Name** | Look up a list by name to get its ID. |\n| **Find Tag by Name** | Locate a tag to manage tagging workflows. |\n\n---\n\n## 📚 API Reference\n\n- [Official Klaviyo API Documentation](https://developers.klaviyo.com/en/reference)\n\n---\n\n## 🧪 Test Account Access\n\nYou can test Klaviyo APIs by creating a free account on [Klaviyo](https://www.klaviyo.com/) and generating a private API key from your account settings.\n\n---\n\n## 🧑‍💻 New to Activepieces?\n\nActivepieces is the leading open source AI automation platform. We have many apps (we call them Pieces), that are available within the builder and as MCPs. These apps are built with our TypeScript framework and are easy to develop. Once merged into our repository, they become available as pieces in our automation builder and as MCPs usable by AI agents and MCP clients.\n\nStart building here: [Piece Development Docs](https://www.activepieces.com/docs/developers/building-pieces/overview)\n",
                  "html_url": "https://github.com/activepieces/activepieces/issues/8284"
                },
                "type": "github"
              },
              "hash": "activepieces/activepieces#8284",
              "body": "## 🧩 Product Overview\n\nKlaviyo is a marketing automation platform for email, SMS, and customer data.  \nThis integration enables AI agents and workflows to create, manage, and interact with profiles, lists, events, campaigns, and segments, automating customer engagement and analytics.\n\n---\n\n## ⚠️ Important Note for Contributors\n\nTo ensure consistency and maintainability, this feature must be submitted as a [Piece](https://www.activepieces.com/docs/developers/building-pieces/piece-definition) following the Activepieces architecture. Submissions that do not follow this format will not be accepted. Please make sure to review the [Piece Development Guidelines](https://www.activepieces.com/docs/developers/building-pieces/overview) before starting development.\n\n---\n\n## 🚨 Triggers\n\n| **Trigger** | **Use Case** |\n|-------------|---------------|\n| **New Profile** | Triggers when a new profile is created in the account. |\n| **Profile Added to List/Segment** | Fires when a profile is added to a specific list or segment. |\n\n---\n\n## 🛠️ Write Actions\n\n| **Action Item** | **Use Case** |\n|-----------------|---------------|\n| **Create Profile** | Add a new user profile to Klaviyo, optionally subscribing to email/SMS. |\n| **Update Profile** | Update existing profile data and preferences. |\n| **Subscribe Profile** | Subscribe a profile to email or SMS lists. |\n| **Unsubscribe Profile** | Remove a profile from email or SMS lists. |\n| **Add Profile to List** | Add a profile to a specific list. |\n| **Remove Profile from List** | Remove a profile from a specific list. |\n| **Create List** | Create a new subscriber list. |\n\n---\n\n## 🔍 Search Actions\n\n| **Action Item** | **Use Case** |\n|-----------------|---------------|\n| **Find Profile by Email/Phone** | Locate a profile using email or phone number. |\n| **Find List by Name** | Look up a list by name to get its ID. |\n| **Find Tag by Name** | Locate a tag to manage tagging workflows. |\n\n---\n\n## 📚 API Reference\n\n- [Official Klaviyo API Documentation](https://developers.klaviyo.com/en/reference)\n\n---\n\n## 🧪 Test Account Access\n\nYou can test Klaviyo APIs by creating a free account on [Klaviyo](https://www.klaviyo.com/) and generating a private API key from your account settings.\n\n---\n\n## 🧑‍💻 New to Activepieces?\n\nActivepieces is the leading open source AI automation platform. We have many apps (we call them Pieces), that are available within the builder and as MCPs. These apps are built with our TypeScript framework and are easy to develop. Once merged into our repository, they become available as pieces in our automation builder and as MCPs usable by AI agents and MCP clients.\n\nStart building here: [Piece Development Docs](https://www.activepieces.com/docs/developers/building-pieces/overview)\n",
              "url": "https://github.com/activepieces/activepieces/issues/8284",
              "tech": [],
              "repo_name": "activepieces",
              "repo_owner": "activepieces",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "activepieces#8135",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "activepieces",
              "id": "generated-activepieces",
              "name": "Activepieces",
              "description": "",
              "members": [],
              "display_name": "Activepieces",
              "created_at": "2026-01-23T05:52:19.209Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/activepieces?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "activepieces",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-23T05:52:19.209Z",
            "created_at": "2026-01-23T05:52:19.209Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-activepieces#8135",
              "status": "open",
              "type": "issue",
              "number": 8135,
              "title": "[MCP] Canva",
              "source": {
                "data": {
                  "id": "source-activepieces#8135",
                  "user": {
                    "login": "kishanprmr",
                    "id": 135701940,
                    "node_id": "U_kgDOCBaltA",
                    "avatar_url": "https://avatars.githubusercontent.com/u/135701940?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/kishanprmr",
                    "html_url": "https://github.com/kishanprmr",
                    "followers_url": "https://api.github.com/users/kishanprmr/followers",
                    "following_url": "https://api.github.com/users/kishanprmr/following{/other_user}",
                    "gists_url": "https://api.github.com/users/kishanprmr/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/kishanprmr/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/kishanprmr/subscriptions",
                    "organizations_url": "https://api.github.com/users/kishanprmr/orgs",
                    "repos_url": "https://api.github.com/users/kishanprmr/repos",
                    "events_url": "https://api.github.com/users/kishanprmr/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/kishanprmr/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "[MCP] Canva",
                  "body": "## 🧩 Product Overview  \n\nCanva is an online design platform that enables users to create visual content like social graphics, presentations, and posters. This integration empowers automation builders and AI agents to streamline tasks such as design creation, asset uploads, exports, folder organization, and more.\n\n---\n\n## ⚠️ Important Note for Contributors  \n\nTo ensure consistency and maintainability, this feature must be submitted as a [Piece](https://www.activepieces.com/docs/developers/building-pieces/piece-definition) following the Activepieces architecture. Submissions that do not follow this format will not be accepted. Please make sure to review the [Piece Development Guidelines](https://www.activepieces.com/docs/developers/building-pieces/overview) before starting development.\n\n---\n\n## 🛠️ Write Actions  \n\n| **Action Item**               | **Use Case** |\n|:--------------------------|:---------------------------------------|\n| **Upload Asset** | Auto-upload brand assets when a campaign starts. |\n| **Create Design** | Automatically generate Instagram templates on new blog posts.|\n| **Import Design** | Convert user-submitted PDFs into editable Canva designs. |\n|**Export Design**| Export a brochure as a PDF and save it.|\n|**Move Folder Item**| Organize completed designs into an “Archive” folder.|\n\n---\n\n## 🔍 Search Actions  \n\n| **Action Item**               | **Use Case**                                                                                                                                     |\n|:------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------|\n| **Find Design** | Ensure a design doesn’t already exist before creation.|\n\n---\n\n## 📖 Read Actions\n\n| **Action Item**               | **Use Case**                                                                                                                                     |\n|:------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------|\n| **Get a Folder** | Retrieves details about an existing folder.|\n|**Get an Image**| Retrieves details about an existing image.|\n\n---\n\n## 📚 API Reference  \n- [Official Canva API Documentation](https://www.canva.dev/docs/connect/api-reference/designs/create-design/)\n\n---\n\n## 🧪 Test Account Access  \nYou can sign up for a free account at https://www.canva.com/en_in/.\n\n---\n\n## 🧑‍💻 New to Activepieces?\n\nActivepieces is the leading open source AI automation platform. We have many apps (we call them Pieces), that are available within the builder and as MCPs. These apps are built with our TypeScript framework and are easy to develop. Once merged into our repository, they become available as pieces in our automation builder and as MCPs usable by AI agents and MCP clients.\n\nStart building here: [Piece Development Docs](https://www.activepieces.com/docs/developers/building-pieces/overview)\n",
                  "html_url": "https://github.com/activepieces/activepieces/issues/8135"
                },
                "type": "github"
              },
              "hash": "activepieces/activepieces#8135",
              "body": "## 🧩 Product Overview  \n\nCanva is an online design platform that enables users to create visual content like social graphics, presentations, and posters. This integration empowers automation builders and AI agents to streamline tasks such as design creation, asset uploads, exports, folder organization, and more.\n\n---\n\n## ⚠️ Important Note for Contributors  \n\nTo ensure consistency and maintainability, this feature must be submitted as a [Piece](https://www.activepieces.com/docs/developers/building-pieces/piece-definition) following the Activepieces architecture. Submissions that do not follow this format will not be accepted. Please make sure to review the [Piece Development Guidelines](https://www.activepieces.com/docs/developers/building-pieces/overview) before starting development.\n\n---\n\n## 🛠️ Write Actions  \n\n| **Action Item**               | **Use Case** |\n|:--------------------------|:---------------------------------------|\n| **Upload Asset** | Auto-upload brand assets when a campaign starts. |\n| **Create Design** | Automatically generate Instagram templates on new blog posts.|\n| **Import Design** | Convert user-submitted PDFs into editable Canva designs. |\n|**Export Design**| Export a brochure as a PDF and save it.|\n|**Move Folder Item**| Organize completed designs into an “Archive” folder.|\n\n---\n\n## 🔍 Search Actions  \n\n| **Action Item**               | **Use Case**                                                                                                                                     |\n|:------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------|\n| **Find Design** | Ensure a design doesn’t already exist before creation.|\n\n---\n\n## 📖 Read Actions\n\n| **Action Item**               | **Use Case**                                                                                                                                     |\n|:------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------|\n| **Get a Folder** | Retrieves details about an existing folder.|\n|**Get an Image**| Retrieves details about an existing image.|\n\n---\n\n## 📚 API Reference  \n- [Official Canva API Documentation](https://www.canva.dev/docs/connect/api-reference/designs/create-design/)\n\n---\n\n## 🧪 Test Account Access  \nYou can sign up for a free account at https://www.canva.com/en_in/.\n\n---\n\n## 🧑‍💻 New to Activepieces?\n\nActivepieces is the leading open source AI automation platform. We have many apps (we call them Pieces), that are available within the builder and as MCPs. These apps are built with our TypeScript framework and are easy to develop. Once merged into our repository, they become available as pieces in our automation builder and as MCPs usable by AI agents and MCP clients.\n\nStart building here: [Piece Development Docs](https://www.activepieces.com/docs/developers/building-pieces/overview)\n",
              "url": "https://github.com/activepieces/activepieces/issues/8135",
              "tech": [],
              "repo_name": "activepieces",
              "repo_owner": "activepieces",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "activepieces#8135",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "activepieces",
              "id": "generated-activepieces",
              "name": "Activepieces",
              "description": "",
              "members": [],
              "display_name": "Activepieces",
              "created_at": "2026-01-23T05:52:19.213Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/activepieces?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "activepieces",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-23T05:52:19.213Z",
            "created_at": "2026-01-23T05:52:19.213Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-activepieces#8135",
              "status": "open",
              "type": "issue",
              "number": 8135,
              "title": "[MCP] Canva",
              "source": {
                "data": {
                  "id": "source-activepieces#8135",
                  "user": {
                    "login": "kishanprmr",
                    "id": 135701940,
                    "node_id": "U_kgDOCBaltA",
                    "avatar_url": "https://avatars.githubusercontent.com/u/135701940?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/kishanprmr",
                    "html_url": "https://github.com/kishanprmr",
                    "followers_url": "https://api.github.com/users/kishanprmr/followers",
                    "following_url": "https://api.github.com/users/kishanprmr/following{/other_user}",
                    "gists_url": "https://api.github.com/users/kishanprmr/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/kishanprmr/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/kishanprmr/subscriptions",
                    "organizations_url": "https://api.github.com/users/kishanprmr/orgs",
                    "repos_url": "https://api.github.com/users/kishanprmr/repos",
                    "events_url": "https://api.github.com/users/kishanprmr/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/kishanprmr/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "[MCP] Canva",
                  "body": "## 🧩 Product Overview  \n\nCanva is an online design platform that enables users to create visual content like social graphics, presentations, and posters. This integration empowers automation builders and AI agents to streamline tasks such as design creation, asset uploads, exports, folder organization, and more.\n\n---\n\n## ⚠️ Important Note for Contributors  \n\nTo ensure consistency and maintainability, this feature must be submitted as a [Piece](https://www.activepieces.com/docs/developers/building-pieces/piece-definition) following the Activepieces architecture. Submissions that do not follow this format will not be accepted. Please make sure to review the [Piece Development Guidelines](https://www.activepieces.com/docs/developers/building-pieces/overview) before starting development.\n\n---\n\n## 🛠️ Write Actions  \n\n| **Action Item**               | **Use Case** |\n|:--------------------------|:---------------------------------------|\n| **Upload Asset** | Auto-upload brand assets when a campaign starts. |\n| **Create Design** | Automatically generate Instagram templates on new blog posts.|\n| **Import Design** | Convert user-submitted PDFs into editable Canva designs. |\n|**Export Design**| Export a brochure as a PDF and save it.|\n|**Move Folder Item**| Organize completed designs into an “Archive” folder.|\n\n---\n\n## 🔍 Search Actions  \n\n| **Action Item**               | **Use Case**                                                                                                                                     |\n|:------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------|\n| **Find Design** | Ensure a design doesn’t already exist before creation.|\n\n---\n\n## 📖 Read Actions\n\n| **Action Item**               | **Use Case**                                                                                                                                     |\n|:------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------|\n| **Get a Folder** | Retrieves details about an existing folder.|\n|**Get an Image**| Retrieves details about an existing image.|\n\n---\n\n## 📚 API Reference  \n- [Official Canva API Documentation](https://www.canva.dev/docs/connect/api-reference/designs/create-design/)\n\n---\n\n## 🧪 Test Account Access  \nYou can sign up for a free account at https://www.canva.com/en_in/.\n\n---\n\n## 🧑‍💻 New to Activepieces?\n\nActivepieces is the leading open source AI automation platform. We have many apps (we call them Pieces), that are available within the builder and as MCPs. These apps are built with our TypeScript framework and are easy to develop. Once merged into our repository, they become available as pieces in our automation builder and as MCPs usable by AI agents and MCP clients.\n\nStart building here: [Piece Development Docs](https://www.activepieces.com/docs/developers/building-pieces/overview)\n",
                  "html_url": "https://github.com/activepieces/activepieces/issues/8135"
                },
                "type": "github"
              },
              "hash": "activepieces/activepieces#8135",
              "body": "## 🧩 Product Overview  \n\nCanva is an online design platform that enables users to create visual content like social graphics, presentations, and posters. This integration empowers automation builders and AI agents to streamline tasks such as design creation, asset uploads, exports, folder organization, and more.\n\n---\n\n## ⚠️ Important Note for Contributors  \n\nTo ensure consistency and maintainability, this feature must be submitted as a [Piece](https://www.activepieces.com/docs/developers/building-pieces/piece-definition) following the Activepieces architecture. Submissions that do not follow this format will not be accepted. Please make sure to review the [Piece Development Guidelines](https://www.activepieces.com/docs/developers/building-pieces/overview) before starting development.\n\n---\n\n## 🛠️ Write Actions  \n\n| **Action Item**               | **Use Case** |\n|:--------------------------|:---------------------------------------|\n| **Upload Asset** | Auto-upload brand assets when a campaign starts. |\n| **Create Design** | Automatically generate Instagram templates on new blog posts.|\n| **Import Design** | Convert user-submitted PDFs into editable Canva designs. |\n|**Export Design**| Export a brochure as a PDF and save it.|\n|**Move Folder Item**| Organize completed designs into an “Archive” folder.|\n\n---\n\n## 🔍 Search Actions  \n\n| **Action Item**               | **Use Case**                                                                                                                                     |\n|:------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------|\n| **Find Design** | Ensure a design doesn’t already exist before creation.|\n\n---\n\n## 📖 Read Actions\n\n| **Action Item**               | **Use Case**                                                                                                                                     |\n|:------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------|\n| **Get a Folder** | Retrieves details about an existing folder.|\n|**Get an Image**| Retrieves details about an existing image.|\n\n---\n\n## 📚 API Reference  \n- [Official Canva API Documentation](https://www.canva.dev/docs/connect/api-reference/designs/create-design/)\n\n---\n\n## 🧪 Test Account Access  \nYou can sign up for a free account at https://www.canva.com/en_in/.\n\n---\n\n## 🧑‍💻 New to Activepieces?\n\nActivepieces is the leading open source AI automation platform. We have many apps (we call them Pieces), that are available within the builder and as MCPs. These apps are built with our TypeScript framework and are easy to develop. Once merged into our repository, they become available as pieces in our automation builder and as MCPs usable by AI agents and MCP clients.\n\nStart building here: [Piece Development Docs](https://www.activepieces.com/docs/developers/building-pieces/overview)\n",
              "url": "https://github.com/activepieces/activepieces/issues/8135",
              "tech": [],
              "repo_name": "activepieces",
              "repo_owner": "activepieces",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "activepieces#8072",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "activepieces",
              "id": "generated-activepieces",
              "name": "Activepieces",
              "description": "",
              "members": [],
              "display_name": "Activepieces",
              "created_at": "2026-01-23T05:52:19.309Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/activepieces?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "activepieces",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-23T05:52:19.309Z",
            "created_at": "2026-01-23T05:52:19.309Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-activepieces#8072",
              "status": "open",
              "type": "issue",
              "number": 8072,
              "title": "[MCP] Gmail",
              "source": {
                "data": {
                  "id": "source-activepieces#8072",
                  "user": {
                    "login": "kishanprmr",
                    "id": 135701940,
                    "node_id": "U_kgDOCBaltA",
                    "avatar_url": "https://avatars.githubusercontent.com/u/135701940?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/kishanprmr",
                    "html_url": "https://github.com/kishanprmr",
                    "followers_url": "https://api.github.com/users/kishanprmr/followers",
                    "following_url": "https://api.github.com/users/kishanprmr/following{/other_user}",
                    "gists_url": "https://api.github.com/users/kishanprmr/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/kishanprmr/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/kishanprmr/subscriptions",
                    "organizations_url": "https://api.github.com/users/kishanprmr/orgs",
                    "repos_url": "https://api.github.com/users/kishanprmr/repos",
                    "events_url": "https://api.github.com/users/kishanprmr/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/kishanprmr/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "[MCP] Gmail",
                  "body": "## 🧩 Product Overview  \n\nGmail is Google’s email platform for sending, receiving, labeling, archiving, and organizing messages.\nThis integration empowers AI agents and workflows to automate email-based processes, from detection to response, labeling, and thread management.\n\n\n---\n\n## ⚠️ Important Note for Contributors  \n\nThis Gmail piece already exists in Activepieces. Your task is to extend the current piece by adding additional actions and triggers as outlined in the documentation and reference materials.\nPlease avoid duplicating existing functionality. Review the current implementation before making changes, and ensure that all new features follow existing coding patterns and standards.\n\n---\n\n## 🚨 Triggers  \n\n| **Trigger** | **Use Case** |\n|:--------------------------|:---------------------------------------|\n| **New Starred Email** | Fires when an email is starred (within 2 days).|\n| **New Conversation** | Fires when a new conversation (thread) begins.|\n|**New Attachment**|Fires when an email with an attachment arrives (with optional filters).|\n|**New Label**|Triggers when a new label is created.|\n---\n\n## 🛠️ Write Actions  \n\n| **Action Item**               | **Use Case** |\n|:--------------------------|:---------------------------------------|\n| **Reply to Email** | Reply within an existing thread, maintaining context. |\n| **Create Draft Reply** | Generate a reply draft within an existing thread.|\n| **Add Label to Email** | Attach a label to an individual email.|\n|**Remove Label from Email**|Remove a specific label from an email.Remove a specific label from an email.|\n|**Create Label**|Create a new user label in Gmail.|\n|**Archive Email**|Archive (move to “All Mail”) rather than deleting.|\n|**Delete Email**|Permanently move an email to Trash.|\n|**Remove Label from Thread**|Strip a label from all emails in a thread.|\n---\n\n## 🔍 Search Actions  \n\n| **Action Item**               | **Use Case**                                                                                                                                     |\n|:------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------|\n| **Find Email** | Locate a specific email using search keywords like subject, sender, or content.|\n\n---\n\n\n## 📚 API Reference  \n- [Official Gmail API Documentation](https://developers.google.com/workspace/gmail/api/guides)\n\n---\n\n## 🧪 Test Account Access  \nYou can test Gmail APIs using a Google account with enabled Gmail API in a [Google Cloud Project Console](https://console.cloud.google.com/).\n\n---\n\n## 🧑‍💻 New to Activepieces?\n\nActivepieces is the leading open source AI automation platform. We have many apps (we call them Pieces), that are available within the builder and as MCPs. These apps are built with our TypeScript framework and are easy to develop. Once merged into our repository, they become available as pieces in our automation builder and as MCPs usable by AI agents and MCP clients.\n\nStart building here: [Piece Development Docs](https://www.activepieces.com/docs/developers/building-pieces/overview)\n",
                  "html_url": "https://github.com/activepieces/activepieces/issues/8072"
                },
                "type": "github"
              },
              "hash": "activepieces/activepieces#8072",
              "body": "## 🧩 Product Overview  \n\nGmail is Google’s email platform for sending, receiving, labeling, archiving, and organizing messages.\nThis integration empowers AI agents and workflows to automate email-based processes, from detection to response, labeling, and thread management.\n\n\n---\n\n## ⚠️ Important Note for Contributors  \n\nThis Gmail piece already exists in Activepieces. Your task is to extend the current piece by adding additional actions and triggers as outlined in the documentation and reference materials.\nPlease avoid duplicating existing functionality. Review the current implementation before making changes, and ensure that all new features follow existing coding patterns and standards.\n\n---\n\n## 🚨 Triggers  \n\n| **Trigger** | **Use Case** |\n|:--------------------------|:---------------------------------------|\n| **New Starred Email** | Fires when an email is starred (within 2 days).|\n| **New Conversation** | Fires when a new conversation (thread) begins.|\n|**New Attachment**|Fires when an email with an attachment arrives (with optional filters).|\n|**New Label**|Triggers when a new label is created.|\n---\n\n## 🛠️ Write Actions  \n\n| **Action Item**               | **Use Case** |\n|:--------------------------|:---------------------------------------|\n| **Reply to Email** | Reply within an existing thread, maintaining context. |\n| **Create Draft Reply** | Generate a reply draft within an existing thread.|\n| **Add Label to Email** | Attach a label to an individual email.|\n|**Remove Label from Email**|Remove a specific label from an email.Remove a specific label from an email.|\n|**Create Label**|Create a new user label in Gmail.|\n|**Archive Email**|Archive (move to “All Mail”) rather than deleting.|\n|**Delete Email**|Permanently move an email to Trash.|\n|**Remove Label from Thread**|Strip a label from all emails in a thread.|\n---\n\n## 🔍 Search Actions  \n\n| **Action Item**               | **Use Case**                                                                                                                                     |\n|:------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------|\n| **Find Email** | Locate a specific email using search keywords like subject, sender, or content.|\n\n---\n\n\n## 📚 API Reference  \n- [Official Gmail API Documentation](https://developers.google.com/workspace/gmail/api/guides)\n\n---\n\n## 🧪 Test Account Access  \nYou can test Gmail APIs using a Google account with enabled Gmail API in a [Google Cloud Project Console](https://console.cloud.google.com/).\n\n---\n\n## 🧑‍💻 New to Activepieces?\n\nActivepieces is the leading open source AI automation platform. We have many apps (we call them Pieces), that are available within the builder and as MCPs. These apps are built with our TypeScript framework and are easy to develop. Once merged into our repository, they become available as pieces in our automation builder and as MCPs usable by AI agents and MCP clients.\n\nStart building here: [Piece Development Docs](https://www.activepieces.com/docs/developers/building-pieces/overview)\n",
              "url": "https://github.com/activepieces/activepieces/issues/8072",
              "tech": [],
              "repo_name": "activepieces",
              "repo_owner": "activepieces",
              "forge": "github"
            },
            "timeouts_disabled": false
          }
        ],
        "next_cursor": null
      }
    }
  }
}