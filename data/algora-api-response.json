{
  "result": {
    "data": {
      "json": {
        "items": [
          {
            "id": "ZIO#755",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "ZIO",
              "id": "generated-ZIO",
              "name": "ZIO",
              "description": "",
              "members": [],
              "display_name": "ZIO",
              "created_at": "2026-01-19T14:47:39.934Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/ZIO?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "zio",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-19T14:47:39.934Z",
            "created_at": "2026-01-19T14:47:39.934Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-ZIO#755",
              "status": "open",
              "type": "issue",
              "number": 755,
              "title": "Implement p Path Interpolator Macro for DynamicOptic",
              "source": {
                "data": {
                  "id": "source-ZIO#755",
                  "user": {
                    "login": "jdegoes",
                    "id": 156745,
                    "node_id": "MDQ6VXNlcjE1Njc0NQ==",
                    "avatar_url": "https://avatars.githubusercontent.com/u/156745?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/jdegoes",
                    "html_url": "https://github.com/jdegoes",
                    "followers_url": "https://api.github.com/users/jdegoes/followers",
                    "following_url": "https://api.github.com/users/jdegoes/following{/other_user}",
                    "gists_url": "https://api.github.com/users/jdegoes/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/jdegoes/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/jdegoes/subscriptions",
                    "organizations_url": "https://api.github.com/users/jdegoes/orgs",
                    "repos_url": "https://api.github.com/users/jdegoes/repos",
                    "events_url": "https://api.github.com/users/jdegoes/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/jdegoes/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Implement p Path Interpolator Macro for DynamicOptic",
                  "body": "<html><head></head><body><h1>Implement <code>p</code> Path Interpolator Macro for DynamicOptic</h1>\n<h2>Summary</h2>\n<p>Implement a compile-time string interpolator macro <code>p\"...\"</code> that parses a path selector language and produces a <code>DynamicOptic</code>. The macro should validate syntax at compile time and report errors with accurate source positions.</p>\n<h2>Background</h2>\n<p><code>DynamicOptic</code> provides a way to navigate through dynamic data structures (records, sequences, maps, variants). Currently, constructing these paths requires verbose builder-style calls:</p>\n<pre><code class=\"language-scala\">DynamicOptic.root.field(\"users\").elements.field(\"email\")\n</code></pre>\n<p>The <code>p</code> interpolator will allow concise path expressions:</p>\n<pre><code class=\"language-scala\">p\".users[*].email\"\n</code></pre>\n<h2>Syntax Specification</h2>\n<h3>Record Field Access</h3>\n<ul>\n<li><code>.fieldName</code> or <code>fieldName</code> â€” Field with optional leading dot</li>\n<li>Valid identifiers: start with letter or underscore, followed by letters, digits, underscores</li>\n<li>Unicode letters allowed (e.g., <code>.cafÃ©</code>)</li>\n<li>Keywords like <code>true</code>, <code>false</code>, <code>null</code> are valid field names</li>\n</ul>\n<h3>Sequence Index Access</h3>\n<ul>\n<li><code>[n]</code> â€” Single index (non-negative integer) â†’ <code>Node.AtIndex(n)</code></li>\n<li><code>[a,b,c]</code> â€” Multiple indices â†’ <code>Node.AtIndices(Seq(a,b,c))</code></li>\n<li><code>[a:b]</code> â€” Range [a,b) expanded at compile time â†’ <code>Node.AtIndices(Seq(a,a+1,...,b-1))</code>\n<ul>\n<li>Empty if <code>a &gt;= b</code></li>\n</ul>\n</li>\n<li><code>[*]</code> or <code>[:*]</code> â€” All elements â†’ <code>Node.Elements</code></li>\n<li>Integers are decimal only, leading zeros allowed (treated as decimal)</li>\n</ul>\n<h3>Map Key Access</h3>\n<ul>\n<li><code>{\"string\"}</code> â€” String key â†’ <code>Node.AtMapKey(Primitive(String(...)))</code></li>\n<li><code>{123}</code> or <code>{-123}</code> â€” Integer key â†’ <code>Node.AtMapKey(Primitive(Int(...)))</code></li>\n<li><code>{'c'}</code> â€” Char key â†’ <code>Node.AtMapKey(Primitive(Char(...)))</code></li>\n<li><code>{true}</code> or <code>{false}</code> â€” Boolean key â†’ <code>Node.AtMapKey(Primitive(Boolean(...)))</code></li>\n<li><code>{k1, k2, k3}</code> â€” Multiple keys (may be mixed types) â†’ <code>Node.AtMapKeys(Seq(...))</code></li>\n<li><code>{*}</code> or <code>{:*}</code> â€” All values â†’ <code>Node.MapValues</code></li>\n<li><code>{*:}</code> â€” All keys â†’ <code>Node.MapKeys</code></li>\n</ul>\n<p><strong>String escapes:</strong> <code>\\\"</code>, <code>\\\\</code>, <code>\\n</code>, <code>\\t</code>, <code>\\r</code></p>\n<p><strong>Char escapes:</strong> <code>\\'</code>, <code>\\\\</code>, <code>\\n</code>, <code>\\t</code>, <code>\\r</code></p>\n<h3>Variant Case Access</h3>\n<ul>\n<li><code>&lt;CaseName&gt;</code> â€” Match case â†’ <code>Node.Case(\"CaseName\")</code></li>\n<li>Same identifier rules as field names</li>\n<li>Keywords allowed as case names</li>\n</ul>\n<h3>Whitespace</h3>\n<ul>\n<li>Allowed inside brackets <code>[]</code>, braces <code>{}</code>, and angle brackets <code>&lt;&gt;</code></li>\n<li>Not allowed around dots or between segments</li>\n</ul>\n<h3>Composition</h3>\n<p>Segments can be composed without separators where unambiguous:</p>\n<pre><code>.field[0]{\"key\"}&lt;Variant&gt;.next\n</code></pre>\n<h2>Target Node Types</h2>\n\nSyntax | Node\n-- | --\n.foo / foo | Field(\"foo\")\n[n] | AtIndex(n)\n[a,b,c] | AtIndices(Seq(a,b,c))\n[a:b] | AtIndices(Seq(a..b))\n[*] / [:*] | Elements\n{\"s\"} | AtMapKey(Primitive(String(\"s\")))\n{n} | AtMapKey(Primitive(Int(n)))\n{'c'} | AtMapKey(Primitive(Char('c')))\n{true/false} | AtMapKey(Primitive(Boolean(...)))\n{k1,k2} | AtMapKeys(Seq(...))\n{*} / {:*} | MapValues\n{*:} | MapKeys\n<Case> | Case(\"Case\")\n\n\n<h2>Implementation Requirements</h2>\n<h3>Scala Version Support</h3>\n<p>Requires separate source files for Scala 2.13 and Scala 3.5+:</p>\n<pre><code>src/main/scala-2/zio/blocks/schema/PathMacros.scala\nsrc/main/scala-3/zio/blocks/schema/PathMacros.scala\n</code></pre>\n<h3>Public API</h3>\n<p>The interpolator should be available via wildcard import:</p>\n<pre><code class=\"language-scala\">import zio.blocks.schema._\n\nval path = p\".users[0].name\"\n</code></pre>\n<p>Suggested approach â€” add to the package object:</p>\n<pre><code class=\"language-scala\">// In shared source\npackage object schema {\n  // ... existing contents ...\n  \n  implicit class PathInterpolator(val sc: StringContext) extends AnyVal {\n    def p(args: Any*): DynamicOptic = macro PathMacros.pImpl // Scala 2\n    // or\n    inline def p(inline args: Any*): DynamicOptic = ${ PathMacros.pImpl('sc, 'args) } // Scala 3\n  }\n}\n</code></pre>\n<p>The implementation may require the implicit class to be defined in version-specific sources if the macro linkage differs too much.</p>\n<h3>Compile-Time Behavior</h3>\n<ol>\n<li>\n<p><strong>No interpolation arguments</strong> â€” The macro should reject <code>p\"foo${x}bar\"</code> at compile time. Only literal strings are supported.</p>\n</li>\n<li>\n<p><strong>Syntax validation</strong> â€” All parsing happens at compile time. Invalid syntax should produce a compile error with a meaningful message.</p>\n</li>\n<li>\n<p><strong>Error positions</strong> â€” Where possible, error messages should point to the problematic location within the string literal.</p>\n</li>\n<li>\n<p><strong>Output</strong> â€” The macro should generate code equivalent to:</p>\n<pre><code class=\"language-scala\">DynamicOptic(Vector(Node.Field(\"...\"), Node.AtIndex(...), ...))\n</code></pre>\n</li>\n</ol>\n<h3>Parser Notes</h3>\n<p>The parser needs lookahead in several places:</p>\n<ul>\n<li>After <code>[</code> + digits: <code>,</code> means AtIndices, <code>:</code> means range, <code>]</code> means AtIndex</li>\n<li>After <code>{</code> + first key: <code>,</code> means AtMapKeys, <code>}</code> means AtMapKey</li>\n<li><code>[*</code> could be <code>[*]</code> (Elements) or <code>[*:]</code> (invalidâ€”no node for this)</li>\n<li><code>{*</code> could be <code>{*}</code> (MapValues) or <code>{*:}</code> (MapKeys)</li>\n</ul>\n<p>Integer parsing:</p>\n<ul>\n<li>Decimal only, no <code>+</code> prefix, <code>-</code> allowed for map keys but not array indices</li>\n<li>Leading zeros treated as decimal (e.g., <code>007</code> â†’ <code>7</code>)</li>\n<li>Overflow beyond Int.MaxValue should be a compile error</li>\n</ul>\n<p>Range expansion:</p>\n<ul>\n<li><code>[a:b]</code> expands to the sequence <code>a, a+1, ..., b-1</code></li>\n<li>If <code>a &gt;= b</code>, produces empty <code>Seq.empty</code></li>\n<li>Consider using Scala's <code>Range</code> internally for memory efficiency during compilation</li>\n</ul>\n<h2>Test Suite</h2>\n<p>A comprehensive test suite is provided separately.</p>\n<p><strong>Note:</strong> The test suite may contain errors or edge cases that don't align with this specification. The implementer is responsible for:</p>\n<ol>\n<li>Reviewing tests against this spec</li>\n<li>Identifying and fixing any incorrect test expectations</li>\n<li>Adding additional tests if gaps are discovered</li>\n<li>Flagging any spec ambiguities for clarification</li>\n</ol>\n<h2>Out of Scope</h2>\n<p>The following are explicitly <strong>not</strong> supported:</p>\n<ul>\n<li>Backtick escaping for field/case names (e.g., <code>.`field name`</code>)</li>\n<li><code>[*:]</code> (sequence indices selector â€” no <code>Node</code> for this)</li>\n<li><code>&lt;*&gt;</code>, <code>&lt;:*&gt;</code>, <code>&lt;*:&gt;</code> (variant value/tag selectors â€” no <code>Node</code> for these)</li>\n<li>Floating point map keys</li>\n<li>Long map keys (no <code>L</code> suffix)</li>\n<li>Unicode escape sequences (<code>\\uXXXX</code>)</li>\n<li>Runtime interpolation arguments (<code>p\"foo${x}\"</code>)</li>\n<li><code>Wrapped</code> / newtype navigation</li>\n</ul>\n<h2>Acceptance Criteria</h2>\n<ul>\n<li>[ ] Compiles and passes tests on Scala 2.13.x</li>\n<li>[ ] Compiles and passes tests on Scala 3.5.x</li>\n<li>[ ] Wildcard import brings <code>p</code> interpolator into scope</li>\n<li>[ ] Compile-time errors for invalid syntax</li>\n<li>[ ] Error messages include position information where feasible</li>\n<li>[ ] No runtime parsing â€” all work done at compile time</li>\n<li>[ ] Generated code is efficient (constructs <code>Vector</code> directly, no builder overhead)</li>\n</ul></body></html>\n\n\n# Sketch of Test Suite\n\n```scala\nimport zio.test._\nimport zio.blocks.schema.{DynamicOptic, DynamicValue, PrimitiveValue}\nimport DynamicOptic.Node\n\nobject DynamicOpticParserSpec extends ZIOSpecDefault {\n  def spec = suite(\"DynamicOptic path interpolator p\\\"\\\"\")(\n\n    suite(\"Record field access\")(\n      test(\"single field with leading dot\") {\n        assertTrue(p\".foo\" == DynamicOptic(Vector(Node.Field(\"foo\"))))\n      },\n      test(\"single field without leading dot\") {\n        assertTrue(p\"foo\" == DynamicOptic(Vector(Node.Field(\"foo\"))))\n      },\n      test(\"chained fields with leading dot\") {\n        assertTrue(p\".foo.bar.baz\" == DynamicOptic(Vector(\n          Node.Field(\"foo\"),\n          Node.Field(\"bar\"),\n          Node.Field(\"baz\")\n        )))\n      },\n      test(\"chained fields without leading dot\") {\n        assertTrue(p\"foo.bar.baz\" == DynamicOptic(Vector(\n          Node.Field(\"foo\"),\n          Node.Field(\"bar\"),\n          Node.Field(\"baz\")\n        )))\n      },\n      test(\"field with leading underscore\") {\n        assertTrue(p\"._private\" == DynamicOptic(Vector(Node.Field(\"_private\"))))\n      },\n      test(\"field underscore only\") {\n        assertTrue(p\"._\" == DynamicOptic(Vector(Node.Field(\"_\"))))\n      },\n      test(\"field with digits\") {\n        assertTrue(p\".field123\" == DynamicOptic(Vector(Node.Field(\"field123\"))))\n      },\n      test(\"field starting with underscore and digits\") {\n        assertTrue(p\"._123\" == DynamicOptic(Vector(Node.Field(\"_123\"))))\n      },\n      test(\"field that looks like keyword true\") {\n        assertTrue(p\".true\" == DynamicOptic(Vector(Node.Field(\"true\"))))\n      },\n      test(\"field that looks like keyword false\") {\n        assertTrue(p\".false\" == DynamicOptic(Vector(Node.Field(\"false\"))))\n      },\n      test(\"field that looks like keyword null\") {\n        assertTrue(p\".null\" == DynamicOptic(Vector(Node.Field(\"null\"))))\n      },\n      test(\"unicode field name\") {\n        assertTrue(p\".cafÃ©\" == DynamicOptic(Vector(Node.Field(\"cafÃ©\"))))\n      },\n      test(\"unicode field name without leading dot\") {\n        assertTrue(p\"cafÃ©\" == DynamicOptic(Vector(Node.Field(\"cafÃ©\"))))\n      },\n      test(\"field with many underscores\") {\n        assertTrue(p\".__foo__bar__\" == DynamicOptic(Vector(Node.Field(\"__foo__bar__\"))))\n      }\n    ),\n\n    suite(\"Sequence index access - single index\")(\n      test(\"index zero\") {\n        assertTrue(p\"[0]\" == DynamicOptic(Vector(Node.AtIndex(0))))\n      },\n      test(\"index positive\") {\n        assertTrue(p\"[42]\" == DynamicOptic(Vector(Node.AtIndex(42))))\n      },\n      test(\"index large\") {\n        assertTrue(p\"[999999]\" == DynamicOptic(Vector(Node.AtIndex(999999))))\n      },\n      test(\"index max int\") {\n        assertTrue(p\"[2147483647]\" == DynamicOptic(Vector(Node.AtIndex(2147483647))))\n      },\n      test(\"index with leading zeros\") {\n        assertTrue(p\"[007]\" == DynamicOptic(Vector(Node.AtIndex(7))))\n      },\n      test(\"index with many leading zeros\") {\n        assertTrue(p\"[00000042]\" == DynamicOptic(Vector(Node.AtIndex(42))))\n      },\n      test(\"index with spaces\") {\n        assertTrue(p\"[ 42 ]\" == DynamicOptic(Vector(Node.AtIndex(42))))\n      }\n    ),\n\n    suite(\"Sequence index access - multiple indices\")(\n      test(\"two indices\") {\n        assertTrue(p\"[0,1]\" == DynamicOptic(Vector(Node.AtIndices(Seq(0, 1)))))\n      },\n      test(\"several indices\") {\n        assertTrue(p\"[0,2,5,10]\" == DynamicOptic(Vector(Node.AtIndices(Seq(0, 2, 5, 10)))))\n      },\n      test(\"indices with spaces\") {\n        assertTrue(p\"[0, 2, 5]\" == DynamicOptic(Vector(Node.AtIndices(Seq(0, 2, 5)))))\n      },\n      test(\"indices with inconsistent spacing\") {\n        assertTrue(p\"[0 ,1, 2 ,3]\" == DynamicOptic(Vector(Node.AtIndices(Seq(0, 1, 2, 3)))))\n      },\n      test(\"duplicate indices allowed\") {\n        assertTrue(p\"[0,0,1,1]\" == DynamicOptic(Vector(Node.AtIndices(Seq(0, 0, 1, 1)))))\n      },\n      test(\"out of order indices allowed\") {\n        assertTrue(p\"[5,2,8,1]\" == DynamicOptic(Vector(Node.AtIndices(Seq(5, 2, 8, 1)))))\n      },\n      test(\"indices with leading zeros\") {\n        assertTrue(p\"[001,002,003]\" == DynamicOptic(Vector(Node.AtIndices(Seq(1, 2, 3)))))\n      }\n    ),\n\n    suite(\"Sequence index access - ranges\")(\n      test(\"range basic\") {\n        assertTrue(p\"[0:5]\" == DynamicOptic(Vector(\n          Node.AtIndices(Seq(0, 1, 2, 3, 4))\n        )))\n      },\n      test(\"range zero to ten\") {\n        assertTrue(p\"[0:10]\" == DynamicOptic(Vector(\n          Node.AtIndices(Seq(0, 1, 2, 3, 4, 5, 6, 7, 8, 9))\n        )))\n      },\n      test(\"range with spaces\") {\n        assertTrue(p\"[ 0 : 5 ]\" == DynamicOptic(Vector(\n          Node.AtIndices(Seq(0, 1, 2, 3, 4))\n        )))\n      },\n      test(\"range starting nonzero\") {\n        assertTrue(p\"[5:8]\" == DynamicOptic(Vector(\n          Node.AtIndices(Seq(5, 6, 7))\n        )))\n      },\n      test(\"range single element\") {\n        assertTrue(p\"[3:4]\" == DynamicOptic(Vector(\n          Node.AtIndices(Seq(3))\n        )))\n      },\n      test(\"range empty when start equals end\") {\n        assertTrue(p\"[5:5]\" == DynamicOptic(Vector(\n          Node.AtIndices(Seq.empty)\n        )))\n      },\n      test(\"range inverted produces empty\") {\n        assertTrue(p\"[10:5]\" == DynamicOptic(Vector(\n          Node.AtIndices(Seq.empty)\n        )))\n      },\n      test(\"range with leading zeros\") {\n        assertTrue(p\"[001:005]\" == DynamicOptic(Vector(\n          Node.AtIndices(Seq(1, 2, 3, 4))\n        )))\n      }\n    ),\n\n    suite(\"Sequence index access - element selectors\")(\n      test(\"select all elements with star\") {\n        assertTrue(p\"[*]\" == DynamicOptic(Vector(Node.Elements)))\n      },\n      test(\"select all elements with colon star\") {\n        assertTrue(p\"[:*]\" == DynamicOptic(Vector(Node.Elements)))\n      },\n      test(\"star with spaces\") {\n        assertTrue(p\"[ * ]\" == DynamicOptic(Vector(Node.Elements)))\n      },\n      test(\"colon star with spaces\") {\n        assertTrue(p\"[ :* ]\" == DynamicOptic(Vector(Node.Elements)))\n      },\n      test(\"chained single indices\") {\n        assertTrue(p\"[0][1][2]\" == DynamicOptic(Vector(\n          Node.AtIndex(0),\n          Node.AtIndex(1),\n          Node.AtIndex(2)\n        )))\n      },\n      test(\"chained elements selectors\") {\n        assertTrue(p\"[*][*]\" == DynamicOptic(Vector(\n          Node.Elements,\n          Node.Elements\n        )))\n      },\n      test(\"chained colon star selectors\") {\n        assertTrue(p\"[:*][:*]\" == DynamicOptic(Vector(\n          Node.Elements,\n          Node.Elements\n        )))\n      },\n      test(\"mixed elements and indices\") {\n        assertTrue(p\"[*][0][*]\" == DynamicOptic(Vector(\n          Node.Elements,\n          Node.AtIndex(0),\n          Node.Elements\n        )))\n      }\n    ),\n\n    suite(\"Map key access - string keys\")(\n      test(\"simple string key\") {\n        assertTrue(p\"\"\"{\"foo\"}\"\"\" == DynamicOptic(Vector(\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.String(\"foo\")))\n        )))\n      },\n      test(\"string key with spaces\") {\n        assertTrue(p\"\"\"{\"foo bar\"}\"\"\" == DynamicOptic(Vector(\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.String(\"foo bar\")))\n        )))\n      },\n      test(\"string key with escaped quote\") {\n        assertTrue(p\"\"\"{\"foo\\\"bar\"}\"\"\" == DynamicOptic(Vector(\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.String(\"foo\\\"bar\")))\n        )))\n      },\n      test(\"string key with escaped backslash\") {\n        assertTrue(p\"\"\"{\"foo\\\\bar\"}\"\"\" == DynamicOptic(Vector(\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.String(\"foo\\\\bar\")))\n        )))\n      },\n      test(\"string key with newline escape\") {\n        assertTrue(p\"\"\"{\"foo\\nbar\"}\"\"\" == DynamicOptic(Vector(\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.String(\"foo\\nbar\")))\n        )))\n      },\n      test(\"string key with tab escape\") {\n        assertTrue(p\"\"\"{\"foo\\tbar\"}\"\"\" == DynamicOptic(Vector(\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.String(\"foo\\tbar\")))\n        )))\n      },\n      test(\"string key with carriage return escape\") {\n        assertTrue(p\"\"\"{\"foo\\rbar\"}\"\"\" == DynamicOptic(Vector(\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.String(\"foo\\rbar\")))\n        )))\n      },\n      test(\"string key only backslash\") {\n        assertTrue(p\"\"\"{\"\\\\\"}\"\"\" == DynamicOptic(Vector(\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.String(\"\\\\\")))\n        )))\n      },\n      test(\"string key only quote\") {\n        assertTrue(p\"\"\"{\"\\\"\"}\"\"\" == DynamicOptic(Vector(\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.String(\"\\\"\")))\n        )))\n      },\n      test(\"empty string key\") {\n        assertTrue(p\"\"\"{\"\"}\"\"\" == DynamicOptic(Vector(\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.String(\"\")))\n        )))\n      },\n      test(\"string key with unicode\") {\n        assertTrue(p\"\"\"{\"æ—¥æœ¬èªž\"}\"\"\" == DynamicOptic(Vector(\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.String(\"æ—¥æœ¬èªž\")))\n        )))\n      },\n      test(\"string key with emoji\") {\n        assertTrue(p\"\"\"{\"ðŸŽ‰\"}\"\"\" == DynamicOptic(Vector(\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.String(\"ðŸŽ‰\")))\n        )))\n      },\n      test(\"multiple string keys\") {\n        assertTrue(p\"\"\"{\"foo\", \"bar\", \"baz\"}\"\"\" == DynamicOptic(Vector(\n          Node.AtMapKeys(Seq(\n            DynamicValue.Primitive(PrimitiveValue.String(\"foo\")),\n            DynamicValue.Primitive(PrimitiveValue.String(\"bar\")),\n            DynamicValue.Primitive(PrimitiveValue.String(\"baz\"))\n          ))\n        )))\n      },\n      test(\"two string keys\") {\n        assertTrue(p\"\"\"{\"a\", \"b\"}\"\"\" == DynamicOptic(Vector(\n          Node.AtMapKeys(Seq(\n            DynamicValue.Primitive(PrimitiveValue.String(\"a\")),\n            DynamicValue.Primitive(PrimitiveValue.String(\"b\"))\n          ))\n        )))\n      }\n    ),\n\n    suite(\"Map key access - integer keys\")(\n      test(\"positive integer\") {\n        assertTrue(p\"{42}\" == DynamicOptic(Vector(\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.Int(42)))\n        )))\n      },\n      test(\"zero\") {\n        assertTrue(p\"{0}\" == DynamicOptic(Vector(\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.Int(0)))\n        )))\n      },\n      test(\"negative integer\") {\n        assertTrue(p\"{-42}\" == DynamicOptic(Vector(\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.Int(-42)))\n        )))\n      },\n      test(\"max int\") {\n        assertTrue(p\"{2147483647}\" == DynamicOptic(Vector(\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.Int(2147483647)))\n        )))\n      },\n      test(\"min int\") {\n        assertTrue(p\"{-2147483648}\" == DynamicOptic(Vector(\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.Int(-2147483648)))\n        )))\n      },\n      test(\"leading zeros\") {\n        assertTrue(p\"{007}\" == DynamicOptic(Vector(\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.Int(7)))\n        )))\n      },\n      test(\"negative with leading zeros\") {\n        assertTrue(p\"{-007}\" == DynamicOptic(Vector(\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.Int(-7)))\n        )))\n      },\n      test(\"multiple integer keys\") {\n        assertTrue(p\"{1, 2, 3}\" == DynamicOptic(Vector(\n          Node.AtMapKeys(Seq(\n            DynamicValue.Primitive(PrimitiveValue.Int(1)),\n            DynamicValue.Primitive(PrimitiveValue.Int(2)),\n            DynamicValue.Primitive(PrimitiveValue.Int(3))\n          ))\n        )))\n      },\n      test(\"multiple integer keys with negatives\") {\n        assertTrue(p\"{-1, 0, 1}\" == DynamicOptic(Vector(\n          Node.AtMapKeys(Seq(\n            DynamicValue.Primitive(PrimitiveValue.Int(-1)),\n            DynamicValue.Primitive(PrimitiveValue.Int(0)),\n            DynamicValue.Primitive(PrimitiveValue.Int(1))\n          ))\n        )))\n      }\n    ),\n\n    suite(\"Map key access - boolean keys\")(\n      test(\"true\") {\n        assertTrue(p\"{true}\" == DynamicOptic(Vector(\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.Boolean(true)))\n        )))\n      },\n      test(\"false\") {\n        assertTrue(p\"{false}\" == DynamicOptic(Vector(\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.Boolean(false)))\n        )))\n      },\n      test(\"multiple booleans\") {\n        assertTrue(p\"{true, false}\" == DynamicOptic(Vector(\n          Node.AtMapKeys(Seq(\n            DynamicValue.Primitive(PrimitiveValue.Boolean(true)),\n            DynamicValue.Primitive(PrimitiveValue.Boolean(false))\n          ))\n        )))\n      },\n      test(\"duplicate booleans\") {\n        assertTrue(p\"{true, true, false}\" == DynamicOptic(Vector(\n          Node.AtMapKeys(Seq(\n            DynamicValue.Primitive(PrimitiveValue.Boolean(true)),\n            DynamicValue.Primitive(PrimitiveValue.Boolean(true)),\n            DynamicValue.Primitive(PrimitiveValue.Boolean(false))\n          ))\n        )))\n      }\n    ),\n\n    suite(\"Map key access - char keys\")(\n      test(\"simple char\") {\n        assertTrue(p\"{'a'}\" == DynamicOptic(Vector(\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.Char('a')))\n        )))\n      },\n      test(\"char space\") {\n        assertTrue(p\"{' '}\" == DynamicOptic(Vector(\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.Char(' ')))\n        )))\n      },\n      test(\"char digit\") {\n        assertTrue(p\"{'9'}\" == DynamicOptic(Vector(\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.Char('9')))\n        )))\n      },\n      test(\"char escaped newline\") {\n        assertTrue(p\"{'\\\\n'}\" == DynamicOptic(Vector(\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.Char('\\n')))\n        )))\n      },\n      test(\"char escaped tab\") {\n        assertTrue(p\"{'\\\\t'}\" == DynamicOptic(Vector(\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.Char('\\t')))\n        )))\n      },\n      test(\"char escaped carriage return\") {\n        assertTrue(p\"{'\\\\r'}\" == DynamicOptic(Vector(\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.Char('\\r')))\n        )))\n      },\n      test(\"char escaped single quote\") {\n        assertTrue(p\"{'\\\\''}\" == DynamicOptic(Vector(\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.Char('\\'')))\n        )))\n      },\n      test(\"char escaped backslash\") {\n        assertTrue(p\"{'\\\\\\\\'}\" == DynamicOptic(Vector(\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.Char('\\\\')))\n        )))\n      },\n      test(\"multiple char keys\") {\n        assertTrue(p\"{'a', 'b', 'c'}\" == DynamicOptic(Vector(\n          Node.AtMapKeys(Seq(\n            DynamicValue.Primitive(PrimitiveValue.Char('a')),\n            DynamicValue.Primitive(PrimitiveValue.Char('b')),\n            DynamicValue.Primitive(PrimitiveValue.Char('c'))\n          ))\n        )))\n      }\n    ),\n\n    suite(\"Map key access - mixed types\")(\n      test(\"string and integer\") {\n        assertTrue(p\"\"\"{\"foo\", 42}\"\"\" == DynamicOptic(Vector(\n          Node.AtMapKeys(Seq(\n            DynamicValue.Primitive(PrimitiveValue.String(\"foo\")),\n            DynamicValue.Primitive(PrimitiveValue.Int(42))\n          ))\n        )))\n      },\n      test(\"integer and boolean\") {\n        assertTrue(p\"{1, true, 2, false}\" == DynamicOptic(Vector(\n          Node.AtMapKeys(Seq(\n            DynamicValue.Primitive(PrimitiveValue.Int(1)),\n            DynamicValue.Primitive(PrimitiveValue.Boolean(true)),\n            DynamicValue.Primitive(PrimitiveValue.Int(2)),\n            DynamicValue.Primitive(PrimitiveValue.Boolean(false))\n          ))\n        )))\n      },\n      test(\"string and char\") {\n        assertTrue(p\"\"\"{\"foo\", 'x'}\"\"\" == DynamicOptic(Vector(\n          Node.AtMapKeys(Seq(\n            DynamicValue.Primitive(PrimitiveValue.String(\"foo\")),\n            DynamicValue.Primitive(PrimitiveValue.Char('x'))\n          ))\n        )))\n      },\n      test(\"all supported primitive types\") {\n        assertTrue(p\"\"\"{\"s\", 'c', 42, true}\"\"\" == DynamicOptic(Vector(\n          Node.AtMapKeys(Seq(\n            DynamicValue.Primitive(PrimitiveValue.String(\"s\")),\n            DynamicValue.Primitive(PrimitiveValue.Char('c')),\n            DynamicValue.Primitive(PrimitiveValue.Int(42)),\n            DynamicValue.Primitive(PrimitiveValue.Boolean(true))\n          ))\n        )))\n      },\n      test(\"negative int with string and bool\") {\n        assertTrue(p\"\"\"{\"key\", -99, false}\"\"\" == DynamicOptic(Vector(\n          Node.AtMapKeys(Seq(\n            DynamicValue.Primitive(PrimitiveValue.String(\"key\")),\n            DynamicValue.Primitive(PrimitiveValue.Int(-99)),\n            DynamicValue.Primitive(PrimitiveValue.Boolean(false))\n          ))\n        )))\n      }\n    ),\n\n    suite(\"Map key/value selectors\")(\n      test(\"select all values with star\") {\n        assertTrue(p\"{*}\" == DynamicOptic(Vector(Node.MapValues)))\n      },\n      test(\"select all values with colon star\") {\n        assertTrue(p\"{:*}\" == DynamicOptic(Vector(Node.MapValues)))\n      },\n      test(\"select all keys with star colon\") {\n        assertTrue(p\"{*:}\" == DynamicOptic(Vector(Node.MapKeys)))\n      },\n      test(\"star with spaces\") {\n        assertTrue(p\"{ * }\" == DynamicOptic(Vector(Node.MapValues)))\n      },\n      test(\"colon star with spaces\") {\n        assertTrue(p\"{ :* }\" == DynamicOptic(Vector(Node.MapValues)))\n      },\n      test(\"star colon with spaces\") {\n        assertTrue(p\"{ *: }\" == DynamicOptic(Vector(Node.MapKeys)))\n      },\n      test(\"chained map values\") {\n        assertTrue(p\"{*}{*}\" == DynamicOptic(Vector(\n          Node.MapValues,\n          Node.MapValues\n        )))\n      },\n      test(\"chained map keys\") {\n        assertTrue(p\"{*:}{*:}\" == DynamicOptic(Vector(\n          Node.MapKeys,\n          Node.MapKeys\n        )))\n      },\n      test(\"map values then map keys\") {\n        assertTrue(p\"{*}{*:}\" == DynamicOptic(Vector(\n          Node.MapValues,\n          Node.MapKeys\n        )))\n      }\n    ),\n\n    suite(\"Variant case access\")(\n      test(\"simple case\") {\n        assertTrue(p\"<Left>\" == DynamicOptic(Vector(Node.Case(\"Left\"))))\n      },\n      test(\"case with digits\") {\n        assertTrue(p\"<Case1>\" == DynamicOptic(Vector(Node.Case(\"Case1\"))))\n      },\n      test(\"case lowercase\") {\n        assertTrue(p\"<none>\" == DynamicOptic(Vector(Node.Case(\"none\"))))\n      },\n      test(\"case underscore prefix\") {\n        assertTrue(p\"<_Empty>\" == DynamicOptic(Vector(Node.Case(\"_Empty\"))))\n      },\n      test(\"case underscore only\") {\n        assertTrue(p\"<_>\" == DynamicOptic(Vector(Node.Case(\"_\"))))\n      },\n      test(\"case that looks like keyword true\") {\n        assertTrue(p\"<true>\" == DynamicOptic(Vector(Node.Case(\"true\"))))\n      },\n      test(\"case that looks like keyword false\") {\n        assertTrue(p\"<false>\" == DynamicOptic(Vector(Node.Case(\"false\"))))\n      },\n      test(\"case that looks like keyword null\") {\n        assertTrue(p\"<null>\" == DynamicOptic(Vector(Node.Case(\"null\"))))\n      },\n      test(\"case with spaces around name\") {\n        assertTrue(p\"< Left >\" == DynamicOptic(Vector(Node.Case(\"Left\"))))\n      },\n      test(\"unicode case name\") {\n        assertTrue(p\"<Ã‘oÃ±o>\" == DynamicOptic(Vector(Node.Case(\"Ã‘oÃ±o\"))))\n      },\n      test(\"unicode case name cafÃ©\") {\n        assertTrue(p\"<cafÃ©>\" == DynamicOptic(Vector(Node.Case(\"cafÃ©\"))))\n      },\n      test(\"chained cases\") {\n        assertTrue(p\"<A><B>\" == DynamicOptic(Vector(\n          Node.Case(\"A\"),\n          Node.Case(\"B\")\n        )))\n      },\n      test(\"chained cases three\") {\n        assertTrue(p\"<A><B><C>\" == DynamicOptic(Vector(\n          Node.Case(\"A\"),\n          Node.Case(\"B\"),\n          Node.Case(\"C\")\n        )))\n      }\n    ),\n\n    suite(\"Combined paths - field then sequence\")(\n      test(\"field then index\") {\n        assertTrue(p\".items[0]\" == DynamicOptic(Vector(\n          Node.Field(\"items\"),\n          Node.AtIndex(0)\n        )))\n      },\n      test(\"field then indices\") {\n        assertTrue(p\".items[0,1,2]\" == DynamicOptic(Vector(\n          Node.Field(\"items\"),\n          Node.AtIndices(Seq(0, 1, 2))\n        )))\n      },\n      test(\"field then range\") {\n        assertTrue(p\".items[0:5]\" == DynamicOptic(Vector(\n          Node.Field(\"items\"),\n          Node.AtIndices(Seq(0, 1, 2, 3, 4))\n        )))\n      },\n      test(\"field then elements\") {\n        assertTrue(p\".items[*]\" == DynamicOptic(Vector(\n          Node.Field(\"items\"),\n          Node.Elements\n        )))\n      },\n      test(\"field without dot then index\") {\n        assertTrue(p\"items[0]\" == DynamicOptic(Vector(\n          Node.Field(\"items\"),\n          Node.AtIndex(0)\n        )))\n      }\n    ),\n\n    suite(\"Combined paths - field then map\")(\n      test(\"field then string map key\") {\n        assertTrue(p\"\"\".config{\"host\"}\"\"\" == DynamicOptic(Vector(\n          Node.Field(\"config\"),\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.String(\"host\")))\n        )))\n      },\n      test(\"field then int map key\") {\n        assertTrue(p\".lookup{42}\" == DynamicOptic(Vector(\n          Node.Field(\"lookup\"),\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.Int(42)))\n        )))\n      },\n      test(\"field then map values\") {\n        assertTrue(p\".lookup{*}\" == DynamicOptic(Vector(\n          Node.Field(\"lookup\"),\n          Node.MapValues\n        )))\n      },\n      test(\"field then map keys\") {\n        assertTrue(p\".lookup{*:}\" == DynamicOptic(Vector(\n          Node.Field(\"lookup\"),\n          Node.MapKeys\n        )))\n      },\n      test(\"field without dot then map key\") {\n        assertTrue(p\"\"\"config{\"host\"}\"\"\" == DynamicOptic(Vector(\n          Node.Field(\"config\"),\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.String(\"host\")))\n        )))\n      }\n    ),\n\n    suite(\"Combined paths - field then variant\")(\n      test(\"field then variant case\") {\n        assertTrue(p\".result<Success>\" == DynamicOptic(Vector(\n          Node.Field(\"result\"),\n          Node.Case(\"Success\")\n        )))\n      },\n      test(\"field without dot then variant\") {\n        assertTrue(p\"result<Success>\" == DynamicOptic(Vector(\n          Node.Field(\"result\"),\n          Node.Case(\"Success\")\n        )))\n      }\n    ),\n\n    suite(\"Combined paths - nested structures\")(\n      test(\"record in sequence\") {\n        assertTrue(p\".users[0].name\" == DynamicOptic(Vector(\n          Node.Field(\"users\"),\n          Node.AtIndex(0),\n          Node.Field(\"name\")\n        )))\n      },\n      test(\"all elements then field\") {\n        assertTrue(p\".users[*].email\" == DynamicOptic(Vector(\n          Node.Field(\"users\"),\n          Node.Elements,\n          Node.Field(\"email\")\n        )))\n      },\n      test(\"map values then field\") {\n        assertTrue(p\".lookup{*}.value\" == DynamicOptic(Vector(\n          Node.Field(\"lookup\"),\n          Node.MapValues,\n          Node.Field(\"value\")\n        )))\n      },\n      test(\"map keys then field\") {\n        assertTrue(p\".lookup{*:}.id\" == DynamicOptic(Vector(\n          Node.Field(\"lookup\"),\n          Node.MapKeys,\n          Node.Field(\"id\")\n        )))\n      },\n      test(\"variant then field\") {\n        assertTrue(p\".response<Ok>.body\" == DynamicOptic(Vector(\n          Node.Field(\"response\"),\n          Node.Case(\"Ok\"),\n          Node.Field(\"body\")\n        )))\n      },\n      test(\"variant then index\") {\n        assertTrue(p\"<Right>[0]\" == DynamicOptic(Vector(\n          Node.Case(\"Right\"),\n          Node.AtIndex(0)\n        )))\n      },\n      test(\"variant then map access\") {\n        assertTrue(p\"\"\"<Some>{\"key\"}\"\"\" == DynamicOptic(Vector(\n          Node.Case(\"Some\"),\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.String(\"key\")))\n        )))\n      },\n      test(\"variant then elements\") {\n        assertTrue(p\"<Items>[*]\" == DynamicOptic(Vector(\n          Node.Case(\"Items\"),\n          Node.Elements\n        )))\n      },\n      test(\"variant then map values\") {\n        assertTrue(p\"<Data>{*}\" == DynamicOptic(Vector(\n          Node.Case(\"Data\"),\n          Node.MapValues\n        )))\n      }\n    ),\n\n    suite(\"Combined paths - deeply nested\")(\n      test(\"four levels of fields\") {\n        assertTrue(p\".a.b.c.d\" == DynamicOptic(Vector(\n          Node.Field(\"a\"),\n          Node.Field(\"b\"),\n          Node.Field(\"c\"),\n          Node.Field(\"d\")\n        )))\n      },\n      test(\"field sequence field sequence\") {\n        assertTrue(p\".items[0].children[1]\" == DynamicOptic(Vector(\n          Node.Field(\"items\"),\n          Node.AtIndex(0),\n          Node.Field(\"children\"),\n          Node.AtIndex(1)\n        )))\n      },\n      test(\"deeply nested with elements\") {\n        assertTrue(p\"\"\".root.children[*].metadata{\"tags\"}[0]\"\"\" == DynamicOptic(Vector(\n          Node.Field(\"root\"),\n          Node.Field(\"children\"),\n          Node.Elements,\n          Node.Field(\"metadata\"),\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.String(\"tags\"))),\n          Node.AtIndex(0)\n        )))\n      },\n      test(\"complex with variant\") {\n        assertTrue(p\".data<Some>.items[0,1,2].props{*:}\" == DynamicOptic(Vector(\n          Node.Field(\"data\"),\n          Node.Case(\"Some\"),\n          Node.Field(\"items\"),\n          Node.AtIndices(Seq(0, 1, 2)),\n          Node.Field(\"props\"),\n          Node.MapKeys\n        )))\n      },\n      test(\"all node types in sequence\") {\n        assertTrue(p\"\"\".a[0]{\"k\"}<V>.b[*]{*}.c{*:}\"\"\" == DynamicOptic(Vector(\n          Node.Field(\"a\"),\n          Node.AtIndex(0),\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.String(\"k\"))),\n          Node.Case(\"V\"),\n          Node.Field(\"b\"),\n          Node.Elements,\n          Node.MapValues,\n          Node.Field(\"c\"),\n          Node.MapKeys\n        )))\n      },\n      test(\"alternating field and index\") {\n        assertTrue(p\".a[0].b[1].c[2]\" == DynamicOptic(Vector(\n          Node.Field(\"a\"),\n          Node.AtIndex(0),\n          Node.Field(\"b\"),\n          Node.AtIndex(1),\n          Node.Field(\"c\"),\n          Node.AtIndex(2)\n        )))\n      },\n      test(\"alternating field and map key\") {\n        assertTrue(p\"\"\".a{\"x\"}.b{\"y\"}.c{\"z\"}\"\"\" == DynamicOptic(Vector(\n          Node.Field(\"a\"),\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.String(\"x\"))),\n          Node.Field(\"b\"),\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.String(\"y\"))),\n          Node.Field(\"c\"),\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.String(\"z\")))\n        )))\n      }\n    ),\n\n    suite(\"Root and empty paths\")(\n      test(\"empty string is root\") {\n        assertTrue(p\"\" == DynamicOptic.root)\n      },\n      test(\"root equals empty vector\") {\n        assertTrue(p\"\" == DynamicOptic(Vector.empty))\n      }\n    ),\n\n    suite(\"Whitespace handling\")(\n      test(\"spaces in index list\") {\n        assertTrue(p\"[ 0 , 1 , 2 ]\" == DynamicOptic(Vector(Node.AtIndices(Seq(0, 1, 2)))))\n      },\n      test(\"spaces in range\") {\n        assertTrue(p\"[ 0 : 5 ]\" == DynamicOptic(Vector(Node.AtIndices(Seq(0, 1, 2, 3, 4)))))\n      },\n      test(\"spaces in key list\") {\n        assertTrue(p\"\"\"{ \"a\" , \"b\" }\"\"\" == DynamicOptic(Vector(\n          Node.AtMapKeys(Seq(\n            DynamicValue.Primitive(PrimitiveValue.String(\"a\")),\n            DynamicValue.Primitive(PrimitiveValue.String(\"b\"))\n          ))\n        )))\n      },\n      test(\"spaces around single index\") {\n        assertTrue(p\"[ 0 ]\" == DynamicOptic(Vector(Node.AtIndex(0))))\n      },\n      test(\"spaces around single key\") {\n        assertTrue(p\"\"\"{ \"foo\" }\"\"\" == DynamicOptic(Vector(\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.String(\"foo\")))\n        )))\n      },\n      test(\"spaces in variant\") {\n        assertTrue(p\"< Foo >\" == DynamicOptic(Vector(Node.Case(\"Foo\"))))\n      },\n      test(\"mixed spacing in complex path\") {\n        assertTrue(p\".foo[ 0 ].bar{ \\\"key\\\" }<Baz>\" == DynamicOptic(Vector(\n          Node.Field(\"foo\"),\n          Node.AtIndex(0),\n          Node.Field(\"bar\"),\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.String(\"key\"))),\n          Node.Case(\"Baz\")\n        )))\n      }\n    ),\n\n    suite(\"Parser robustness - unusual but valid\")(\n      test(\"index then field\") {\n        assertTrue(p\"[0].foo\" == DynamicOptic(Vector(\n          Node.AtIndex(0),\n          Node.Field(\"foo\")\n        )))\n      },\n      test(\"map key then field\") {\n        assertTrue(p\"\"\"{\"k\"}.foo\"\"\" == DynamicOptic(Vector(\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.String(\"k\"))),\n          Node.Field(\"foo\")\n        )))\n      },\n      test(\"variant then variant\") {\n        assertTrue(p\"<A><B>\" == DynamicOptic(Vector(\n          Node.Case(\"A\"),\n          Node.Case(\"B\")\n        )))\n      },\n      test(\"elements then elements\") {\n        assertTrue(p\"[*][*]\" == DynamicOptic(Vector(\n          Node.Elements,\n          Node.Elements\n        )))\n      },\n      test(\"map values then map values\") {\n        assertTrue(p\"{*}{*}\" == DynamicOptic(Vector(\n          Node.MapValues,\n          Node.MapValues\n        )))\n      },\n      test(\"map keys then map keys\") {\n        assertTrue(p\"{*:}{*:}\" == DynamicOptic(Vector(\n          Node.MapKeys,\n          Node.MapKeys\n        )))\n      },\n      test(\"elements then map values\") {\n        assertTrue(p\"[*]{*}\" == DynamicOptic(Vector(\n          Node.Elements,\n          Node.MapValues\n        )))\n      },\n      test(\"map values then elements\") {\n        assertTrue(p\"{*}[*]\" == DynamicOptic(Vector(\n          Node.MapValues,\n          Node.Elements\n        )))\n      },\n      test(\"variant at start then index\") {\n        assertTrue(p\"<Some>[0]\" == DynamicOptic(Vector(\n          Node.Case(\"Some\"),\n          Node.AtIndex(0)\n        )))\n      },\n      test(\"index at start then variant\") {\n        assertTrue(p\"[0]<Some>\" == DynamicOptic(Vector(\n          Node.AtIndex(0),\n          Node.Case(\"Some\")\n        )))\n      },\n      test(\"map key at start\") {\n        assertTrue(p\"\"\"{\"key\"}\"\"\" == DynamicOptic(Vector(\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.String(\"key\")))\n        )))\n      },\n      test(\"index at start\") {\n        assertTrue(p\"[0]\" == DynamicOptic(Vector(Node.AtIndex(0))))\n      },\n      test(\"variant at start\") {\n        assertTrue(p\"<Foo>\" == DynamicOptic(Vector(Node.Case(\"Foo\"))))\n      },\n      test(\"elements at start\") {\n        assertTrue(p\"[*]\" == DynamicOptic(Vector(Node.Elements)))\n      },\n      test(\"map values at start\") {\n        assertTrue(p\"{*}\" == DynamicOptic(Vector(Node.MapValues)))\n      },\n      test(\"map keys at start\") {\n        assertTrue(p\"{*:}\" == DynamicOptic(Vector(Node.MapKeys)))\n      },\n      test(\"long chain of same type\") {\n        assertTrue(p\".a.b.c.d.e.f.g.h\" == DynamicOptic(Vector(\n          Node.Field(\"a\"),\n          Node.Field(\"b\"),\n          Node.Field(\"c\"),\n          Node.Field(\"d\"),\n          Node.Field(\"e\"),\n          Node.Field(\"f\"),\n          Node.Field(\"g\"),\n          Node.Field(\"h\")\n        )))\n      },\n      test(\"many indices in sequence\") {\n        assertTrue(p\"[0][1][2][3][4]\" == DynamicOptic(Vector(\n          Node.AtIndex(0),\n          Node.AtIndex(1),\n          Node.AtIndex(2),\n          Node.AtIndex(3),\n          Node.AtIndex(4)\n        )))\n      },\n      test(\"large index list\") {\n        assertTrue(p\"[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]\" == DynamicOptic(Vector(\n          Node.AtIndices(Seq(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15))\n        )))\n      }\n    )\n  )\n}\n```",
                  "html_url": "https://github.com/zio/zio-blocks/issues/755"
                },
                "type": "github"
              },
              "hash": "zio/zio-blocks#755",
              "body": "<html><head></head><body><h1>Implement <code>p</code> Path Interpolator Macro for DynamicOptic</h1>\n<h2>Summary</h2>\n<p>Implement a compile-time string interpolator macro <code>p\"...\"</code> that parses a path selector language and produces a <code>DynamicOptic</code>. The macro should validate syntax at compile time and report errors with accurate source positions.</p>\n<h2>Background</h2>\n<p><code>DynamicOptic</code> provides a way to navigate through dynamic data structures (records, sequences, maps, variants). Currently, constructing these paths requires verbose builder-style calls:</p>\n<pre><code class=\"language-scala\">DynamicOptic.root.field(\"users\").elements.field(\"email\")\n</code></pre>\n<p>The <code>p</code> interpolator will allow concise path expressions:</p>\n<pre><code class=\"language-scala\">p\".users[*].email\"\n</code></pre>\n<h2>Syntax Specification</h2>\n<h3>Record Field Access</h3>\n<ul>\n<li><code>.fieldName</code> or <code>fieldName</code> â€” Field with optional leading dot</li>\n<li>Valid identifiers: start with letter or underscore, followed by letters, digits, underscores</li>\n<li>Unicode letters allowed (e.g., <code>.cafÃ©</code>)</li>\n<li>Keywords like <code>true</code>, <code>false</code>, <code>null</code> are valid field names</li>\n</ul>\n<h3>Sequence Index Access</h3>\n<ul>\n<li><code>[n]</code> â€” Single index (non-negative integer) â†’ <code>Node.AtIndex(n)</code></li>\n<li><code>[a,b,c]</code> â€” Multiple indices â†’ <code>Node.AtIndices(Seq(a,b,c))</code></li>\n<li><code>[a:b]</code> â€” Range [a,b) expanded at compile time â†’ <code>Node.AtIndices(Seq(a,a+1,...,b-1))</code>\n<ul>\n<li>Empty if <code>a &gt;= b</code></li>\n</ul>\n</li>\n<li><code>[*]</code> or <code>[:*]</code> â€” All elements â†’ <code>Node.Elements</code></li>\n<li>Integers are decimal only, leading zeros allowed (treated as decimal)</li>\n</ul>\n<h3>Map Key Access</h3>\n<ul>\n<li><code>{\"string\"}</code> â€” String key â†’ <code>Node.AtMapKey(Primitive(String(...)))</code></li>\n<li><code>{123}</code> or <code>{-123}</code> â€” Integer key â†’ <code>Node.AtMapKey(Primitive(Int(...)))</code></li>\n<li><code>{'c'}</code> â€” Char key â†’ <code>Node.AtMapKey(Primitive(Char(...)))</code></li>\n<li><code>{true}</code> or <code>{false}</code> â€” Boolean key â†’ <code>Node.AtMapKey(Primitive(Boolean(...)))</code></li>\n<li><code>{k1, k2, k3}</code> â€” Multiple keys (may be mixed types) â†’ <code>Node.AtMapKeys(Seq(...))</code></li>\n<li><code>{*}</code> or <code>{:*}</code> â€” All values â†’ <code>Node.MapValues</code></li>\n<li><code>{*:}</code> â€” All keys â†’ <code>Node.MapKeys</code></li>\n</ul>\n<p><strong>String escapes:</strong> <code>\\\"</code>, <code>\\\\</code>, <code>\\n</code>, <code>\\t</code>, <code>\\r</code></p>\n<p><strong>Char escapes:</strong> <code>\\'</code>, <code>\\\\</code>, <code>\\n</code>, <code>\\t</code>, <code>\\r</code></p>\n<h3>Variant Case Access</h3>\n<ul>\n<li><code>&lt;CaseName&gt;</code> â€” Match case â†’ <code>Node.Case(\"CaseName\")</code></li>\n<li>Same identifier rules as field names</li>\n<li>Keywords allowed as case names</li>\n</ul>\n<h3>Whitespace</h3>\n<ul>\n<li>Allowed inside brackets <code>[]</code>, braces <code>{}</code>, and angle brackets <code>&lt;&gt;</code></li>\n<li>Not allowed around dots or between segments</li>\n</ul>\n<h3>Composition</h3>\n<p>Segments can be composed without separators where unambiguous:</p>\n<pre><code>.field[0]{\"key\"}&lt;Variant&gt;.next\n</code></pre>\n<h2>Target Node Types</h2>\n\nSyntax | Node\n-- | --\n.foo / foo | Field(\"foo\")\n[n] | AtIndex(n)\n[a,b,c] | AtIndices(Seq(a,b,c))\n[a:b] | AtIndices(Seq(a..b))\n[*] / [:*] | Elements\n{\"s\"} | AtMapKey(Primitive(String(\"s\")))\n{n} | AtMapKey(Primitive(Int(n)))\n{'c'} | AtMapKey(Primitive(Char('c')))\n{true/false} | AtMapKey(Primitive(Boolean(...)))\n{k1,k2} | AtMapKeys(Seq(...))\n{*} / {:*} | MapValues\n{*:} | MapKeys\n<Case> | Case(\"Case\")\n\n\n<h2>Implementation Requirements</h2>\n<h3>Scala Version Support</h3>\n<p>Requires separate source files for Scala 2.13 and Scala 3.5+:</p>\n<pre><code>src/main/scala-2/zio/blocks/schema/PathMacros.scala\nsrc/main/scala-3/zio/blocks/schema/PathMacros.scala\n</code></pre>\n<h3>Public API</h3>\n<p>The interpolator should be available via wildcard import:</p>\n<pre><code class=\"language-scala\">import zio.blocks.schema._\n\nval path = p\".users[0].name\"\n</code></pre>\n<p>Suggested approach â€” add to the package object:</p>\n<pre><code class=\"language-scala\">// In shared source\npackage object schema {\n  // ... existing contents ...\n  \n  implicit class PathInterpolator(val sc: StringContext) extends AnyVal {\n    def p(args: Any*): DynamicOptic = macro PathMacros.pImpl // Scala 2\n    // or\n    inline def p(inline args: Any*): DynamicOptic = ${ PathMacros.pImpl('sc, 'args) } // Scala 3\n  }\n}\n</code></pre>\n<p>The implementation may require the implicit class to be defined in version-specific sources if the macro linkage differs too much.</p>\n<h3>Compile-Time Behavior</h3>\n<ol>\n<li>\n<p><strong>No interpolation arguments</strong> â€” The macro should reject <code>p\"foo${x}bar\"</code> at compile time. Only literal strings are supported.</p>\n</li>\n<li>\n<p><strong>Syntax validation</strong> â€” All parsing happens at compile time. Invalid syntax should produce a compile error with a meaningful message.</p>\n</li>\n<li>\n<p><strong>Error positions</strong> â€” Where possible, error messages should point to the problematic location within the string literal.</p>\n</li>\n<li>\n<p><strong>Output</strong> â€” The macro should generate code equivalent to:</p>\n<pre><code class=\"language-scala\">DynamicOptic(Vector(Node.Field(\"...\"), Node.AtIndex(...), ...))\n</code></pre>\n</li>\n</ol>\n<h3>Parser Notes</h3>\n<p>The parser needs lookahead in several places:</p>\n<ul>\n<li>After <code>[</code> + digits: <code>,</code> means AtIndices, <code>:</code> means range, <code>]</code> means AtIndex</li>\n<li>After <code>{</code> + first key: <code>,</code> means AtMapKeys, <code>}</code> means AtMapKey</li>\n<li><code>[*</code> could be <code>[*]</code> (Elements) or <code>[*:]</code> (invalidâ€”no node for this)</li>\n<li><code>{*</code> could be <code>{*}</code> (MapValues) or <code>{*:}</code> (MapKeys)</li>\n</ul>\n<p>Integer parsing:</p>\n<ul>\n<li>Decimal only, no <code>+</code> prefix, <code>-</code> allowed for map keys but not array indices</li>\n<li>Leading zeros treated as decimal (e.g., <code>007</code> â†’ <code>7</code>)</li>\n<li>Overflow beyond Int.MaxValue should be a compile error</li>\n</ul>\n<p>Range expansion:</p>\n<ul>\n<li><code>[a:b]</code> expands to the sequence <code>a, a+1, ..., b-1</code></li>\n<li>If <code>a &gt;= b</code>, produces empty <code>Seq.empty</code></li>\n<li>Consider using Scala's <code>Range</code> internally for memory efficiency during compilation</li>\n</ul>\n<h2>Test Suite</h2>\n<p>A comprehensive test suite is provided separately.</p>\n<p><strong>Note:</strong> The test suite may contain errors or edge cases that don't align with this specification. The implementer is responsible for:</p>\n<ol>\n<li>Reviewing tests against this spec</li>\n<li>Identifying and fixing any incorrect test expectations</li>\n<li>Adding additional tests if gaps are discovered</li>\n<li>Flagging any spec ambiguities for clarification</li>\n</ol>\n<h2>Out of Scope</h2>\n<p>The following are explicitly <strong>not</strong> supported:</p>\n<ul>\n<li>Backtick escaping for field/case names (e.g., <code>.`field name`</code>)</li>\n<li><code>[*:]</code> (sequence indices selector â€” no <code>Node</code> for this)</li>\n<li><code>&lt;*&gt;</code>, <code>&lt;:*&gt;</code>, <code>&lt;*:&gt;</code> (variant value/tag selectors â€” no <code>Node</code> for these)</li>\n<li>Floating point map keys</li>\n<li>Long map keys (no <code>L</code> suffix)</li>\n<li>Unicode escape sequences (<code>\\uXXXX</code>)</li>\n<li>Runtime interpolation arguments (<code>p\"foo${x}\"</code>)</li>\n<li><code>Wrapped</code> / newtype navigation</li>\n</ul>\n<h2>Acceptance Criteria</h2>\n<ul>\n<li>[ ] Compiles and passes tests on Scala 2.13.x</li>\n<li>[ ] Compiles and passes tests on Scala 3.5.x</li>\n<li>[ ] Wildcard import brings <code>p</code> interpolator into scope</li>\n<li>[ ] Compile-time errors for invalid syntax</li>\n<li>[ ] Error messages include position information where feasible</li>\n<li>[ ] No runtime parsing â€” all work done at compile time</li>\n<li>[ ] Generated code is efficient (constructs <code>Vector</code> directly, no builder overhead)</li>\n</ul></body></html>\n\n\n# Sketch of Test Suite\n\n```scala\nimport zio.test._\nimport zio.blocks.schema.{DynamicOptic, DynamicValue, PrimitiveValue}\nimport DynamicOptic.Node\n\nobject DynamicOpticParserSpec extends ZIOSpecDefault {\n  def spec = suite(\"DynamicOptic path interpolator p\\\"\\\"\")(\n\n    suite(\"Record field access\")(\n      test(\"single field with leading dot\") {\n        assertTrue(p\".foo\" == DynamicOptic(Vector(Node.Field(\"foo\"))))\n      },\n      test(\"single field without leading dot\") {\n        assertTrue(p\"foo\" == DynamicOptic(Vector(Node.Field(\"foo\"))))\n      },\n      test(\"chained fields with leading dot\") {\n        assertTrue(p\".foo.bar.baz\" == DynamicOptic(Vector(\n          Node.Field(\"foo\"),\n          Node.Field(\"bar\"),\n          Node.Field(\"baz\")\n        )))\n      },\n      test(\"chained fields without leading dot\") {\n        assertTrue(p\"foo.bar.baz\" == DynamicOptic(Vector(\n          Node.Field(\"foo\"),\n          Node.Field(\"bar\"),\n          Node.Field(\"baz\")\n        )))\n      },\n      test(\"field with leading underscore\") {\n        assertTrue(p\"._private\" == DynamicOptic(Vector(Node.Field(\"_private\"))))\n      },\n      test(\"field underscore only\") {\n        assertTrue(p\"._\" == DynamicOptic(Vector(Node.Field(\"_\"))))\n      },\n      test(\"field with digits\") {\n        assertTrue(p\".field123\" == DynamicOptic(Vector(Node.Field(\"field123\"))))\n      },\n      test(\"field starting with underscore and digits\") {\n        assertTrue(p\"._123\" == DynamicOptic(Vector(Node.Field(\"_123\"))))\n      },\n      test(\"field that looks like keyword true\") {\n        assertTrue(p\".true\" == DynamicOptic(Vector(Node.Field(\"true\"))))\n      },\n      test(\"field that looks like keyword false\") {\n        assertTrue(p\".false\" == DynamicOptic(Vector(Node.Field(\"false\"))))\n      },\n      test(\"field that looks like keyword null\") {\n        assertTrue(p\".null\" == DynamicOptic(Vector(Node.Field(\"null\"))))\n      },\n      test(\"unicode field name\") {\n        assertTrue(p\".cafÃ©\" == DynamicOptic(Vector(Node.Field(\"cafÃ©\"))))\n      },\n      test(\"unicode field name without leading dot\") {\n        assertTrue(p\"cafÃ©\" == DynamicOptic(Vector(Node.Field(\"cafÃ©\"))))\n      },\n      test(\"field with many underscores\") {\n        assertTrue(p\".__foo__bar__\" == DynamicOptic(Vector(Node.Field(\"__foo__bar__\"))))\n      }\n    ),\n\n    suite(\"Sequence index access - single index\")(\n      test(\"index zero\") {\n        assertTrue(p\"[0]\" == DynamicOptic(Vector(Node.AtIndex(0))))\n      },\n      test(\"index positive\") {\n        assertTrue(p\"[42]\" == DynamicOptic(Vector(Node.AtIndex(42))))\n      },\n      test(\"index large\") {\n        assertTrue(p\"[999999]\" == DynamicOptic(Vector(Node.AtIndex(999999))))\n      },\n      test(\"index max int\") {\n        assertTrue(p\"[2147483647]\" == DynamicOptic(Vector(Node.AtIndex(2147483647))))\n      },\n      test(\"index with leading zeros\") {\n        assertTrue(p\"[007]\" == DynamicOptic(Vector(Node.AtIndex(7))))\n      },\n      test(\"index with many leading zeros\") {\n        assertTrue(p\"[00000042]\" == DynamicOptic(Vector(Node.AtIndex(42))))\n      },\n      test(\"index with spaces\") {\n        assertTrue(p\"[ 42 ]\" == DynamicOptic(Vector(Node.AtIndex(42))))\n      }\n    ),\n\n    suite(\"Sequence index access - multiple indices\")(\n      test(\"two indices\") {\n        assertTrue(p\"[0,1]\" == DynamicOptic(Vector(Node.AtIndices(Seq(0, 1)))))\n      },\n      test(\"several indices\") {\n        assertTrue(p\"[0,2,5,10]\" == DynamicOptic(Vector(Node.AtIndices(Seq(0, 2, 5, 10)))))\n      },\n      test(\"indices with spaces\") {\n        assertTrue(p\"[0, 2, 5]\" == DynamicOptic(Vector(Node.AtIndices(Seq(0, 2, 5)))))\n      },\n      test(\"indices with inconsistent spacing\") {\n        assertTrue(p\"[0 ,1, 2 ,3]\" == DynamicOptic(Vector(Node.AtIndices(Seq(0, 1, 2, 3)))))\n      },\n      test(\"duplicate indices allowed\") {\n        assertTrue(p\"[0,0,1,1]\" == DynamicOptic(Vector(Node.AtIndices(Seq(0, 0, 1, 1)))))\n      },\n      test(\"out of order indices allowed\") {\n        assertTrue(p\"[5,2,8,1]\" == DynamicOptic(Vector(Node.AtIndices(Seq(5, 2, 8, 1)))))\n      },\n      test(\"indices with leading zeros\") {\n        assertTrue(p\"[001,002,003]\" == DynamicOptic(Vector(Node.AtIndices(Seq(1, 2, 3)))))\n      }\n    ),\n\n    suite(\"Sequence index access - ranges\")(\n      test(\"range basic\") {\n        assertTrue(p\"[0:5]\" == DynamicOptic(Vector(\n          Node.AtIndices(Seq(0, 1, 2, 3, 4))\n        )))\n      },\n      test(\"range zero to ten\") {\n        assertTrue(p\"[0:10]\" == DynamicOptic(Vector(\n          Node.AtIndices(Seq(0, 1, 2, 3, 4, 5, 6, 7, 8, 9))\n        )))\n      },\n      test(\"range with spaces\") {\n        assertTrue(p\"[ 0 : 5 ]\" == DynamicOptic(Vector(\n          Node.AtIndices(Seq(0, 1, 2, 3, 4))\n        )))\n      },\n      test(\"range starting nonzero\") {\n        assertTrue(p\"[5:8]\" == DynamicOptic(Vector(\n          Node.AtIndices(Seq(5, 6, 7))\n        )))\n      },\n      test(\"range single element\") {\n        assertTrue(p\"[3:4]\" == DynamicOptic(Vector(\n          Node.AtIndices(Seq(3))\n        )))\n      },\n      test(\"range empty when start equals end\") {\n        assertTrue(p\"[5:5]\" == DynamicOptic(Vector(\n          Node.AtIndices(Seq.empty)\n        )))\n      },\n      test(\"range inverted produces empty\") {\n        assertTrue(p\"[10:5]\" == DynamicOptic(Vector(\n          Node.AtIndices(Seq.empty)\n        )))\n      },\n      test(\"range with leading zeros\") {\n        assertTrue(p\"[001:005]\" == DynamicOptic(Vector(\n          Node.AtIndices(Seq(1, 2, 3, 4))\n        )))\n      }\n    ),\n\n    suite(\"Sequence index access - element selectors\")(\n      test(\"select all elements with star\") {\n        assertTrue(p\"[*]\" == DynamicOptic(Vector(Node.Elements)))\n      },\n      test(\"select all elements with colon star\") {\n        assertTrue(p\"[:*]\" == DynamicOptic(Vector(Node.Elements)))\n      },\n      test(\"star with spaces\") {\n        assertTrue(p\"[ * ]\" == DynamicOptic(Vector(Node.Elements)))\n      },\n      test(\"colon star with spaces\") {\n        assertTrue(p\"[ :* ]\" == DynamicOptic(Vector(Node.Elements)))\n      },\n      test(\"chained single indices\") {\n        assertTrue(p\"[0][1][2]\" == DynamicOptic(Vector(\n          Node.AtIndex(0),\n          Node.AtIndex(1),\n          Node.AtIndex(2)\n        )))\n      },\n      test(\"chained elements selectors\") {\n        assertTrue(p\"[*][*]\" == DynamicOptic(Vector(\n          Node.Elements,\n          Node.Elements\n        )))\n      },\n      test(\"chained colon star selectors\") {\n        assertTrue(p\"[:*][:*]\" == DynamicOptic(Vector(\n          Node.Elements,\n          Node.Elements\n        )))\n      },\n      test(\"mixed elements and indices\") {\n        assertTrue(p\"[*][0][*]\" == DynamicOptic(Vector(\n          Node.Elements,\n          Node.AtIndex(0),\n          Node.Elements\n        )))\n      }\n    ),\n\n    suite(\"Map key access - string keys\")(\n      test(\"simple string key\") {\n        assertTrue(p\"\"\"{\"foo\"}\"\"\" == DynamicOptic(Vector(\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.String(\"foo\")))\n        )))\n      },\n      test(\"string key with spaces\") {\n        assertTrue(p\"\"\"{\"foo bar\"}\"\"\" == DynamicOptic(Vector(\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.String(\"foo bar\")))\n        )))\n      },\n      test(\"string key with escaped quote\") {\n        assertTrue(p\"\"\"{\"foo\\\"bar\"}\"\"\" == DynamicOptic(Vector(\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.String(\"foo\\\"bar\")))\n        )))\n      },\n      test(\"string key with escaped backslash\") {\n        assertTrue(p\"\"\"{\"foo\\\\bar\"}\"\"\" == DynamicOptic(Vector(\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.String(\"foo\\\\bar\")))\n        )))\n      },\n      test(\"string key with newline escape\") {\n        assertTrue(p\"\"\"{\"foo\\nbar\"}\"\"\" == DynamicOptic(Vector(\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.String(\"foo\\nbar\")))\n        )))\n      },\n      test(\"string key with tab escape\") {\n        assertTrue(p\"\"\"{\"foo\\tbar\"}\"\"\" == DynamicOptic(Vector(\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.String(\"foo\\tbar\")))\n        )))\n      },\n      test(\"string key with carriage return escape\") {\n        assertTrue(p\"\"\"{\"foo\\rbar\"}\"\"\" == DynamicOptic(Vector(\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.String(\"foo\\rbar\")))\n        )))\n      },\n      test(\"string key only backslash\") {\n        assertTrue(p\"\"\"{\"\\\\\"}\"\"\" == DynamicOptic(Vector(\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.String(\"\\\\\")))\n        )))\n      },\n      test(\"string key only quote\") {\n        assertTrue(p\"\"\"{\"\\\"\"}\"\"\" == DynamicOptic(Vector(\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.String(\"\\\"\")))\n        )))\n      },\n      test(\"empty string key\") {\n        assertTrue(p\"\"\"{\"\"}\"\"\" == DynamicOptic(Vector(\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.String(\"\")))\n        )))\n      },\n      test(\"string key with unicode\") {\n        assertTrue(p\"\"\"{\"æ—¥æœ¬èªž\"}\"\"\" == DynamicOptic(Vector(\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.String(\"æ—¥æœ¬èªž\")))\n        )))\n      },\n      test(\"string key with emoji\") {\n        assertTrue(p\"\"\"{\"ðŸŽ‰\"}\"\"\" == DynamicOptic(Vector(\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.String(\"ðŸŽ‰\")))\n        )))\n      },\n      test(\"multiple string keys\") {\n        assertTrue(p\"\"\"{\"foo\", \"bar\", \"baz\"}\"\"\" == DynamicOptic(Vector(\n          Node.AtMapKeys(Seq(\n            DynamicValue.Primitive(PrimitiveValue.String(\"foo\")),\n            DynamicValue.Primitive(PrimitiveValue.String(\"bar\")),\n            DynamicValue.Primitive(PrimitiveValue.String(\"baz\"))\n          ))\n        )))\n      },\n      test(\"two string keys\") {\n        assertTrue(p\"\"\"{\"a\", \"b\"}\"\"\" == DynamicOptic(Vector(\n          Node.AtMapKeys(Seq(\n            DynamicValue.Primitive(PrimitiveValue.String(\"a\")),\n            DynamicValue.Primitive(PrimitiveValue.String(\"b\"))\n          ))\n        )))\n      }\n    ),\n\n    suite(\"Map key access - integer keys\")(\n      test(\"positive integer\") {\n        assertTrue(p\"{42}\" == DynamicOptic(Vector(\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.Int(42)))\n        )))\n      },\n      test(\"zero\") {\n        assertTrue(p\"{0}\" == DynamicOptic(Vector(\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.Int(0)))\n        )))\n      },\n      test(\"negative integer\") {\n        assertTrue(p\"{-42}\" == DynamicOptic(Vector(\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.Int(-42)))\n        )))\n      },\n      test(\"max int\") {\n        assertTrue(p\"{2147483647}\" == DynamicOptic(Vector(\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.Int(2147483647)))\n        )))\n      },\n      test(\"min int\") {\n        assertTrue(p\"{-2147483648}\" == DynamicOptic(Vector(\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.Int(-2147483648)))\n        )))\n      },\n      test(\"leading zeros\") {\n        assertTrue(p\"{007}\" == DynamicOptic(Vector(\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.Int(7)))\n        )))\n      },\n      test(\"negative with leading zeros\") {\n        assertTrue(p\"{-007}\" == DynamicOptic(Vector(\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.Int(-7)))\n        )))\n      },\n      test(\"multiple integer keys\") {\n        assertTrue(p\"{1, 2, 3}\" == DynamicOptic(Vector(\n          Node.AtMapKeys(Seq(\n            DynamicValue.Primitive(PrimitiveValue.Int(1)),\n            DynamicValue.Primitive(PrimitiveValue.Int(2)),\n            DynamicValue.Primitive(PrimitiveValue.Int(3))\n          ))\n        )))\n      },\n      test(\"multiple integer keys with negatives\") {\n        assertTrue(p\"{-1, 0, 1}\" == DynamicOptic(Vector(\n          Node.AtMapKeys(Seq(\n            DynamicValue.Primitive(PrimitiveValue.Int(-1)),\n            DynamicValue.Primitive(PrimitiveValue.Int(0)),\n            DynamicValue.Primitive(PrimitiveValue.Int(1))\n          ))\n        )))\n      }\n    ),\n\n    suite(\"Map key access - boolean keys\")(\n      test(\"true\") {\n        assertTrue(p\"{true}\" == DynamicOptic(Vector(\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.Boolean(true)))\n        )))\n      },\n      test(\"false\") {\n        assertTrue(p\"{false}\" == DynamicOptic(Vector(\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.Boolean(false)))\n        )))\n      },\n      test(\"multiple booleans\") {\n        assertTrue(p\"{true, false}\" == DynamicOptic(Vector(\n          Node.AtMapKeys(Seq(\n            DynamicValue.Primitive(PrimitiveValue.Boolean(true)),\n            DynamicValue.Primitive(PrimitiveValue.Boolean(false))\n          ))\n        )))\n      },\n      test(\"duplicate booleans\") {\n        assertTrue(p\"{true, true, false}\" == DynamicOptic(Vector(\n          Node.AtMapKeys(Seq(\n            DynamicValue.Primitive(PrimitiveValue.Boolean(true)),\n            DynamicValue.Primitive(PrimitiveValue.Boolean(true)),\n            DynamicValue.Primitive(PrimitiveValue.Boolean(false))\n          ))\n        )))\n      }\n    ),\n\n    suite(\"Map key access - char keys\")(\n      test(\"simple char\") {\n        assertTrue(p\"{'a'}\" == DynamicOptic(Vector(\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.Char('a')))\n        )))\n      },\n      test(\"char space\") {\n        assertTrue(p\"{' '}\" == DynamicOptic(Vector(\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.Char(' ')))\n        )))\n      },\n      test(\"char digit\") {\n        assertTrue(p\"{'9'}\" == DynamicOptic(Vector(\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.Char('9')))\n        )))\n      },\n      test(\"char escaped newline\") {\n        assertTrue(p\"{'\\\\n'}\" == DynamicOptic(Vector(\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.Char('\\n')))\n        )))\n      },\n      test(\"char escaped tab\") {\n        assertTrue(p\"{'\\\\t'}\" == DynamicOptic(Vector(\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.Char('\\t')))\n        )))\n      },\n      test(\"char escaped carriage return\") {\n        assertTrue(p\"{'\\\\r'}\" == DynamicOptic(Vector(\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.Char('\\r')))\n        )))\n      },\n      test(\"char escaped single quote\") {\n        assertTrue(p\"{'\\\\''}\" == DynamicOptic(Vector(\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.Char('\\'')))\n        )))\n      },\n      test(\"char escaped backslash\") {\n        assertTrue(p\"{'\\\\\\\\'}\" == DynamicOptic(Vector(\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.Char('\\\\')))\n        )))\n      },\n      test(\"multiple char keys\") {\n        assertTrue(p\"{'a', 'b', 'c'}\" == DynamicOptic(Vector(\n          Node.AtMapKeys(Seq(\n            DynamicValue.Primitive(PrimitiveValue.Char('a')),\n            DynamicValue.Primitive(PrimitiveValue.Char('b')),\n            DynamicValue.Primitive(PrimitiveValue.Char('c'))\n          ))\n        )))\n      }\n    ),\n\n    suite(\"Map key access - mixed types\")(\n      test(\"string and integer\") {\n        assertTrue(p\"\"\"{\"foo\", 42}\"\"\" == DynamicOptic(Vector(\n          Node.AtMapKeys(Seq(\n            DynamicValue.Primitive(PrimitiveValue.String(\"foo\")),\n            DynamicValue.Primitive(PrimitiveValue.Int(42))\n          ))\n        )))\n      },\n      test(\"integer and boolean\") {\n        assertTrue(p\"{1, true, 2, false}\" == DynamicOptic(Vector(\n          Node.AtMapKeys(Seq(\n            DynamicValue.Primitive(PrimitiveValue.Int(1)),\n            DynamicValue.Primitive(PrimitiveValue.Boolean(true)),\n            DynamicValue.Primitive(PrimitiveValue.Int(2)),\n            DynamicValue.Primitive(PrimitiveValue.Boolean(false))\n          ))\n        )))\n      },\n      test(\"string and char\") {\n        assertTrue(p\"\"\"{\"foo\", 'x'}\"\"\" == DynamicOptic(Vector(\n          Node.AtMapKeys(Seq(\n            DynamicValue.Primitive(PrimitiveValue.String(\"foo\")),\n            DynamicValue.Primitive(PrimitiveValue.Char('x'))\n          ))\n        )))\n      },\n      test(\"all supported primitive types\") {\n        assertTrue(p\"\"\"{\"s\", 'c', 42, true}\"\"\" == DynamicOptic(Vector(\n          Node.AtMapKeys(Seq(\n            DynamicValue.Primitive(PrimitiveValue.String(\"s\")),\n            DynamicValue.Primitive(PrimitiveValue.Char('c')),\n            DynamicValue.Primitive(PrimitiveValue.Int(42)),\n            DynamicValue.Primitive(PrimitiveValue.Boolean(true))\n          ))\n        )))\n      },\n      test(\"negative int with string and bool\") {\n        assertTrue(p\"\"\"{\"key\", -99, false}\"\"\" == DynamicOptic(Vector(\n          Node.AtMapKeys(Seq(\n            DynamicValue.Primitive(PrimitiveValue.String(\"key\")),\n            DynamicValue.Primitive(PrimitiveValue.Int(-99)),\n            DynamicValue.Primitive(PrimitiveValue.Boolean(false))\n          ))\n        )))\n      }\n    ),\n\n    suite(\"Map key/value selectors\")(\n      test(\"select all values with star\") {\n        assertTrue(p\"{*}\" == DynamicOptic(Vector(Node.MapValues)))\n      },\n      test(\"select all values with colon star\") {\n        assertTrue(p\"{:*}\" == DynamicOptic(Vector(Node.MapValues)))\n      },\n      test(\"select all keys with star colon\") {\n        assertTrue(p\"{*:}\" == DynamicOptic(Vector(Node.MapKeys)))\n      },\n      test(\"star with spaces\") {\n        assertTrue(p\"{ * }\" == DynamicOptic(Vector(Node.MapValues)))\n      },\n      test(\"colon star with spaces\") {\n        assertTrue(p\"{ :* }\" == DynamicOptic(Vector(Node.MapValues)))\n      },\n      test(\"star colon with spaces\") {\n        assertTrue(p\"{ *: }\" == DynamicOptic(Vector(Node.MapKeys)))\n      },\n      test(\"chained map values\") {\n        assertTrue(p\"{*}{*}\" == DynamicOptic(Vector(\n          Node.MapValues,\n          Node.MapValues\n        )))\n      },\n      test(\"chained map keys\") {\n        assertTrue(p\"{*:}{*:}\" == DynamicOptic(Vector(\n          Node.MapKeys,\n          Node.MapKeys\n        )))\n      },\n      test(\"map values then map keys\") {\n        assertTrue(p\"{*}{*:}\" == DynamicOptic(Vector(\n          Node.MapValues,\n          Node.MapKeys\n        )))\n      }\n    ),\n\n    suite(\"Variant case access\")(\n      test(\"simple case\") {\n        assertTrue(p\"<Left>\" == DynamicOptic(Vector(Node.Case(\"Left\"))))\n      },\n      test(\"case with digits\") {\n        assertTrue(p\"<Case1>\" == DynamicOptic(Vector(Node.Case(\"Case1\"))))\n      },\n      test(\"case lowercase\") {\n        assertTrue(p\"<none>\" == DynamicOptic(Vector(Node.Case(\"none\"))))\n      },\n      test(\"case underscore prefix\") {\n        assertTrue(p\"<_Empty>\" == DynamicOptic(Vector(Node.Case(\"_Empty\"))))\n      },\n      test(\"case underscore only\") {\n        assertTrue(p\"<_>\" == DynamicOptic(Vector(Node.Case(\"_\"))))\n      },\n      test(\"case that looks like keyword true\") {\n        assertTrue(p\"<true>\" == DynamicOptic(Vector(Node.Case(\"true\"))))\n      },\n      test(\"case that looks like keyword false\") {\n        assertTrue(p\"<false>\" == DynamicOptic(Vector(Node.Case(\"false\"))))\n      },\n      test(\"case that looks like keyword null\") {\n        assertTrue(p\"<null>\" == DynamicOptic(Vector(Node.Case(\"null\"))))\n      },\n      test(\"case with spaces around name\") {\n        assertTrue(p\"< Left >\" == DynamicOptic(Vector(Node.Case(\"Left\"))))\n      },\n      test(\"unicode case name\") {\n        assertTrue(p\"<Ã‘oÃ±o>\" == DynamicOptic(Vector(Node.Case(\"Ã‘oÃ±o\"))))\n      },\n      test(\"unicode case name cafÃ©\") {\n        assertTrue(p\"<cafÃ©>\" == DynamicOptic(Vector(Node.Case(\"cafÃ©\"))))\n      },\n      test(\"chained cases\") {\n        assertTrue(p\"<A><B>\" == DynamicOptic(Vector(\n          Node.Case(\"A\"),\n          Node.Case(\"B\")\n        )))\n      },\n      test(\"chained cases three\") {\n        assertTrue(p\"<A><B><C>\" == DynamicOptic(Vector(\n          Node.Case(\"A\"),\n          Node.Case(\"B\"),\n          Node.Case(\"C\")\n        )))\n      }\n    ),\n\n    suite(\"Combined paths - field then sequence\")(\n      test(\"field then index\") {\n        assertTrue(p\".items[0]\" == DynamicOptic(Vector(\n          Node.Field(\"items\"),\n          Node.AtIndex(0)\n        )))\n      },\n      test(\"field then indices\") {\n        assertTrue(p\".items[0,1,2]\" == DynamicOptic(Vector(\n          Node.Field(\"items\"),\n          Node.AtIndices(Seq(0, 1, 2))\n        )))\n      },\n      test(\"field then range\") {\n        assertTrue(p\".items[0:5]\" == DynamicOptic(Vector(\n          Node.Field(\"items\"),\n          Node.AtIndices(Seq(0, 1, 2, 3, 4))\n        )))\n      },\n      test(\"field then elements\") {\n        assertTrue(p\".items[*]\" == DynamicOptic(Vector(\n          Node.Field(\"items\"),\n          Node.Elements\n        )))\n      },\n      test(\"field without dot then index\") {\n        assertTrue(p\"items[0]\" == DynamicOptic(Vector(\n          Node.Field(\"items\"),\n          Node.AtIndex(0)\n        )))\n      }\n    ),\n\n    suite(\"Combined paths - field then map\")(\n      test(\"field then string map key\") {\n        assertTrue(p\"\"\".config{\"host\"}\"\"\" == DynamicOptic(Vector(\n          Node.Field(\"config\"),\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.String(\"host\")))\n        )))\n      },\n      test(\"field then int map key\") {\n        assertTrue(p\".lookup{42}\" == DynamicOptic(Vector(\n          Node.Field(\"lookup\"),\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.Int(42)))\n        )))\n      },\n      test(\"field then map values\") {\n        assertTrue(p\".lookup{*}\" == DynamicOptic(Vector(\n          Node.Field(\"lookup\"),\n          Node.MapValues\n        )))\n      },\n      test(\"field then map keys\") {\n        assertTrue(p\".lookup{*:}\" == DynamicOptic(Vector(\n          Node.Field(\"lookup\"),\n          Node.MapKeys\n        )))\n      },\n      test(\"field without dot then map key\") {\n        assertTrue(p\"\"\"config{\"host\"}\"\"\" == DynamicOptic(Vector(\n          Node.Field(\"config\"),\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.String(\"host\")))\n        )))\n      }\n    ),\n\n    suite(\"Combined paths - field then variant\")(\n      test(\"field then variant case\") {\n        assertTrue(p\".result<Success>\" == DynamicOptic(Vector(\n          Node.Field(\"result\"),\n          Node.Case(\"Success\")\n        )))\n      },\n      test(\"field without dot then variant\") {\n        assertTrue(p\"result<Success>\" == DynamicOptic(Vector(\n          Node.Field(\"result\"),\n          Node.Case(\"Success\")\n        )))\n      }\n    ),\n\n    suite(\"Combined paths - nested structures\")(\n      test(\"record in sequence\") {\n        assertTrue(p\".users[0].name\" == DynamicOptic(Vector(\n          Node.Field(\"users\"),\n          Node.AtIndex(0),\n          Node.Field(\"name\")\n        )))\n      },\n      test(\"all elements then field\") {\n        assertTrue(p\".users[*].email\" == DynamicOptic(Vector(\n          Node.Field(\"users\"),\n          Node.Elements,\n          Node.Field(\"email\")\n        )))\n      },\n      test(\"map values then field\") {\n        assertTrue(p\".lookup{*}.value\" == DynamicOptic(Vector(\n          Node.Field(\"lookup\"),\n          Node.MapValues,\n          Node.Field(\"value\")\n        )))\n      },\n      test(\"map keys then field\") {\n        assertTrue(p\".lookup{*:}.id\" == DynamicOptic(Vector(\n          Node.Field(\"lookup\"),\n          Node.MapKeys,\n          Node.Field(\"id\")\n        )))\n      },\n      test(\"variant then field\") {\n        assertTrue(p\".response<Ok>.body\" == DynamicOptic(Vector(\n          Node.Field(\"response\"),\n          Node.Case(\"Ok\"),\n          Node.Field(\"body\")\n        )))\n      },\n      test(\"variant then index\") {\n        assertTrue(p\"<Right>[0]\" == DynamicOptic(Vector(\n          Node.Case(\"Right\"),\n          Node.AtIndex(0)\n        )))\n      },\n      test(\"variant then map access\") {\n        assertTrue(p\"\"\"<Some>{\"key\"}\"\"\" == DynamicOptic(Vector(\n          Node.Case(\"Some\"),\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.String(\"key\")))\n        )))\n      },\n      test(\"variant then elements\") {\n        assertTrue(p\"<Items>[*]\" == DynamicOptic(Vector(\n          Node.Case(\"Items\"),\n          Node.Elements\n        )))\n      },\n      test(\"variant then map values\") {\n        assertTrue(p\"<Data>{*}\" == DynamicOptic(Vector(\n          Node.Case(\"Data\"),\n          Node.MapValues\n        )))\n      }\n    ),\n\n    suite(\"Combined paths - deeply nested\")(\n      test(\"four levels of fields\") {\n        assertTrue(p\".a.b.c.d\" == DynamicOptic(Vector(\n          Node.Field(\"a\"),\n          Node.Field(\"b\"),\n          Node.Field(\"c\"),\n          Node.Field(\"d\")\n        )))\n      },\n      test(\"field sequence field sequence\") {\n        assertTrue(p\".items[0].children[1]\" == DynamicOptic(Vector(\n          Node.Field(\"items\"),\n          Node.AtIndex(0),\n          Node.Field(\"children\"),\n          Node.AtIndex(1)\n        )))\n      },\n      test(\"deeply nested with elements\") {\n        assertTrue(p\"\"\".root.children[*].metadata{\"tags\"}[0]\"\"\" == DynamicOptic(Vector(\n          Node.Field(\"root\"),\n          Node.Field(\"children\"),\n          Node.Elements,\n          Node.Field(\"metadata\"),\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.String(\"tags\"))),\n          Node.AtIndex(0)\n        )))\n      },\n      test(\"complex with variant\") {\n        assertTrue(p\".data<Some>.items[0,1,2].props{*:}\" == DynamicOptic(Vector(\n          Node.Field(\"data\"),\n          Node.Case(\"Some\"),\n          Node.Field(\"items\"),\n          Node.AtIndices(Seq(0, 1, 2)),\n          Node.Field(\"props\"),\n          Node.MapKeys\n        )))\n      },\n      test(\"all node types in sequence\") {\n        assertTrue(p\"\"\".a[0]{\"k\"}<V>.b[*]{*}.c{*:}\"\"\" == DynamicOptic(Vector(\n          Node.Field(\"a\"),\n          Node.AtIndex(0),\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.String(\"k\"))),\n          Node.Case(\"V\"),\n          Node.Field(\"b\"),\n          Node.Elements,\n          Node.MapValues,\n          Node.Field(\"c\"),\n          Node.MapKeys\n        )))\n      },\n      test(\"alternating field and index\") {\n        assertTrue(p\".a[0].b[1].c[2]\" == DynamicOptic(Vector(\n          Node.Field(\"a\"),\n          Node.AtIndex(0),\n          Node.Field(\"b\"),\n          Node.AtIndex(1),\n          Node.Field(\"c\"),\n          Node.AtIndex(2)\n        )))\n      },\n      test(\"alternating field and map key\") {\n        assertTrue(p\"\"\".a{\"x\"}.b{\"y\"}.c{\"z\"}\"\"\" == DynamicOptic(Vector(\n          Node.Field(\"a\"),\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.String(\"x\"))),\n          Node.Field(\"b\"),\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.String(\"y\"))),\n          Node.Field(\"c\"),\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.String(\"z\")))\n        )))\n      }\n    ),\n\n    suite(\"Root and empty paths\")(\n      test(\"empty string is root\") {\n        assertTrue(p\"\" == DynamicOptic.root)\n      },\n      test(\"root equals empty vector\") {\n        assertTrue(p\"\" == DynamicOptic(Vector.empty))\n      }\n    ),\n\n    suite(\"Whitespace handling\")(\n      test(\"spaces in index list\") {\n        assertTrue(p\"[ 0 , 1 , 2 ]\" == DynamicOptic(Vector(Node.AtIndices(Seq(0, 1, 2)))))\n      },\n      test(\"spaces in range\") {\n        assertTrue(p\"[ 0 : 5 ]\" == DynamicOptic(Vector(Node.AtIndices(Seq(0, 1, 2, 3, 4)))))\n      },\n      test(\"spaces in key list\") {\n        assertTrue(p\"\"\"{ \"a\" , \"b\" }\"\"\" == DynamicOptic(Vector(\n          Node.AtMapKeys(Seq(\n            DynamicValue.Primitive(PrimitiveValue.String(\"a\")),\n            DynamicValue.Primitive(PrimitiveValue.String(\"b\"))\n          ))\n        )))\n      },\n      test(\"spaces around single index\") {\n        assertTrue(p\"[ 0 ]\" == DynamicOptic(Vector(Node.AtIndex(0))))\n      },\n      test(\"spaces around single key\") {\n        assertTrue(p\"\"\"{ \"foo\" }\"\"\" == DynamicOptic(Vector(\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.String(\"foo\")))\n        )))\n      },\n      test(\"spaces in variant\") {\n        assertTrue(p\"< Foo >\" == DynamicOptic(Vector(Node.Case(\"Foo\"))))\n      },\n      test(\"mixed spacing in complex path\") {\n        assertTrue(p\".foo[ 0 ].bar{ \\\"key\\\" }<Baz>\" == DynamicOptic(Vector(\n          Node.Field(\"foo\"),\n          Node.AtIndex(0),\n          Node.Field(\"bar\"),\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.String(\"key\"))),\n          Node.Case(\"Baz\")\n        )))\n      }\n    ),\n\n    suite(\"Parser robustness - unusual but valid\")(\n      test(\"index then field\") {\n        assertTrue(p\"[0].foo\" == DynamicOptic(Vector(\n          Node.AtIndex(0),\n          Node.Field(\"foo\")\n        )))\n      },\n      test(\"map key then field\") {\n        assertTrue(p\"\"\"{\"k\"}.foo\"\"\" == DynamicOptic(Vector(\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.String(\"k\"))),\n          Node.Field(\"foo\")\n        )))\n      },\n      test(\"variant then variant\") {\n        assertTrue(p\"<A><B>\" == DynamicOptic(Vector(\n          Node.Case(\"A\"),\n          Node.Case(\"B\")\n        )))\n      },\n      test(\"elements then elements\") {\n        assertTrue(p\"[*][*]\" == DynamicOptic(Vector(\n          Node.Elements,\n          Node.Elements\n        )))\n      },\n      test(\"map values then map values\") {\n        assertTrue(p\"{*}{*}\" == DynamicOptic(Vector(\n          Node.MapValues,\n          Node.MapValues\n        )))\n      },\n      test(\"map keys then map keys\") {\n        assertTrue(p\"{*:}{*:}\" == DynamicOptic(Vector(\n          Node.MapKeys,\n          Node.MapKeys\n        )))\n      },\n      test(\"elements then map values\") {\n        assertTrue(p\"[*]{*}\" == DynamicOptic(Vector(\n          Node.Elements,\n          Node.MapValues\n        )))\n      },\n      test(\"map values then elements\") {\n        assertTrue(p\"{*}[*]\" == DynamicOptic(Vector(\n          Node.MapValues,\n          Node.Elements\n        )))\n      },\n      test(\"variant at start then index\") {\n        assertTrue(p\"<Some>[0]\" == DynamicOptic(Vector(\n          Node.Case(\"Some\"),\n          Node.AtIndex(0)\n        )))\n      },\n      test(\"index at start then variant\") {\n        assertTrue(p\"[0]<Some>\" == DynamicOptic(Vector(\n          Node.AtIndex(0),\n          Node.Case(\"Some\")\n        )))\n      },\n      test(\"map key at start\") {\n        assertTrue(p\"\"\"{\"key\"}\"\"\" == DynamicOptic(Vector(\n          Node.AtMapKey(DynamicValue.Primitive(PrimitiveValue.String(\"key\")))\n        )))\n      },\n      test(\"index at start\") {\n        assertTrue(p\"[0]\" == DynamicOptic(Vector(Node.AtIndex(0))))\n      },\n      test(\"variant at start\") {\n        assertTrue(p\"<Foo>\" == DynamicOptic(Vector(Node.Case(\"Foo\"))))\n      },\n      test(\"elements at start\") {\n        assertTrue(p\"[*]\" == DynamicOptic(Vector(Node.Elements)))\n      },\n      test(\"map values at start\") {\n        assertTrue(p\"{*}\" == DynamicOptic(Vector(Node.MapValues)))\n      },\n      test(\"map keys at start\") {\n        assertTrue(p\"{*:}\" == DynamicOptic(Vector(Node.MapKeys)))\n      },\n      test(\"long chain of same type\") {\n        assertTrue(p\".a.b.c.d.e.f.g.h\" == DynamicOptic(Vector(\n          Node.Field(\"a\"),\n          Node.Field(\"b\"),\n          Node.Field(\"c\"),\n          Node.Field(\"d\"),\n          Node.Field(\"e\"),\n          Node.Field(\"f\"),\n          Node.Field(\"g\"),\n          Node.Field(\"h\")\n        )))\n      },\n      test(\"many indices in sequence\") {\n        assertTrue(p\"[0][1][2][3][4]\" == DynamicOptic(Vector(\n          Node.AtIndex(0),\n          Node.AtIndex(1),\n          Node.AtIndex(2),\n          Node.AtIndex(3),\n          Node.AtIndex(4)\n        )))\n      },\n      test(\"large index list\") {\n        assertTrue(p\"[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]\" == DynamicOptic(Vector(\n          Node.AtIndices(Seq(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15))\n        )))\n      }\n    )\n  )\n}\n```",
              "url": "https://github.com/zio/zio-blocks/issues/755",
              "tech": [],
              "repo_name": "zio-blocks",
              "repo_owner": "zio",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "ZIO#679",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "ZIO",
              "id": "generated-ZIO",
              "name": "ZIO",
              "description": "",
              "members": [],
              "display_name": "ZIO",
              "created_at": "2026-01-19T14:47:40.267Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/ZIO?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "zio",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-19T14:47:40.267Z",
            "created_at": "2026-01-19T14:47:40.267Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-ZIO#679",
              "status": "open",
              "type": "issue",
              "number": 679,
              "title": "Add Json data type",
              "source": {
                "data": {
                  "id": "source-ZIO#679",
                  "user": {
                    "login": "jdegoes",
                    "id": 156745,
                    "node_id": "MDQ6VXNlcjE1Njc0NQ==",
                    "avatar_url": "https://avatars.githubusercontent.com/u/156745?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/jdegoes",
                    "html_url": "https://github.com/jdegoes",
                    "followers_url": "https://api.github.com/users/jdegoes/followers",
                    "following_url": "https://api.github.com/users/jdegoes/following{/other_user}",
                    "gists_url": "https://api.github.com/users/jdegoes/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/jdegoes/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/jdegoes/subscriptions",
                    "organizations_url": "https://api.github.com/users/jdegoes/orgs",
                    "repos_url": "https://api.github.com/users/jdegoes/repos",
                    "events_url": "https://api.github.com/users/jdegoes/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/jdegoes/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Add Json data type",
                  "body": "The following is a sketch of what a proper `Json` data type should look like, including constructors, methods, and related types. Note that `DynamicPatch`, `JsonPatch`, and `JsonSchema` are all out-of-scope for this ticket.\n\n## Sketch\n\n```scala\npackage zio.blocks.schema.json\n\nimport zio.blocks.chunk.Chunk\nimport zio.blocks.schema.{DynamicOptic, DynamicValue, PrimitiveValue, Schema, SchemaError}\n\nimport java.io.{Reader, Writer}\nimport java.nio.ByteBuffer\nimport scala.util.control.NoStackTrace\n\n// =============================================================================\n// JSON ERROR\n// =============================================================================\n\n/**\n * Represents an error that occurred during JSON parsing, encoding, or processing.\n *\n * NOTE: This should replace JsonBinaryCodecError and be moved to `zio.block.schema.json`.\n *\n * @param message A human-readable description of the error\n * @param path The location in the JSON structure where the error occurred,\n *             represented as a [[DynamicOptic]]\n * @param offset Optional byte offset in the input where the error occurred\n * @param line Optional 1-indexed line number where the error occurred\n * @param column Optional 1-indexed column number where the error occurred\n */\nfinal case class JsonError(\n  message: String,\n  path: DynamicOptic,\n  offset: Option[Long],\n  line: Option[Int],\n  column: Option[Int]\n) extends Exception with NoStackTrace {\n\n  override def getMessage: String = {\n    val posInfo = (line, column) match {\n      case (Some(l), Some(c)) => s\" at line $l, column $c\"\n      case _                  => offset.map(o => s\" at offset $o\").getOrElse(\"\")\n    }\n    val pathInfo = if (path.nodes.isEmpty) \"\" else s\" at path $path\"\n    s\"$message$pathInfo$posInfo\"\n  }\n\n  /**\n   * Combines this error with another, preserving both error messages.\n   */\n  def ++(other: JsonError): JsonError =\n    JsonError(s\"${this.message}; ${other.message}\", this.path, this.offset, this.line, this.column)\n}\n\nobject JsonError {\n\n  /**\n   * Creates a JsonError with only a message, using root path and no position info.\n   */\n  def apply(message: String): JsonError =\n    JsonError(message, DynamicOptic.root, None, None, None)\n\n  /**\n   * Creates a JsonError with a message and path, no position info.\n   */\n  def apply(message: String, path: DynamicOptic): JsonError =\n    JsonError(message, path, None, None, None)\n\n  /**\n   * Converts a [[SchemaError]] to a [[JsonError]].\n   */\n  def fromSchemaError(error: SchemaError): JsonError =\n    JsonError(error.message, DynamicOptic.root, None, None, None)\n}\n\n// =============================================================================\n// JSON DECODER / ENCODER (implicit priority resolution)\n// =============================================================================\n\n/**\n * Type class for decoding [[Json]] values into Scala types.\n *\n * Implicit resolution prefers explicitly provided [[JsonBinaryCodec]] instances\n * over schema-derived instances, allowing users to override derived behavior.\n */\nsealed trait JsonDecoder[A] {\n\n  /**\n   * Decodes a [[Json]] value into type `A`.\n   *\n   * @param json The JSON value to decode\n   * @return Either a [[JsonError]] on failure, or the decoded value\n   */\n  def decode(json: Json): Either[JsonError, A]\n}\n\nobject JsonDecoder extends JsonDecoderLowPriority {\n\n  def apply[A](implicit decoder: JsonDecoder[A]): JsonDecoder[A] = decoder\n\n  /**\n   * Higher priority: use an explicitly provided [[JsonBinaryCodec]].\n   */\n  implicit def fromCodec[A](implicit codec: JsonBinaryCodec[A]): JsonDecoder[A] =\n    new JsonDecoder[A] {\n      def decode(json: Json): Either[JsonError, A] = json.decodeWith(codec)\n    }\n}\n\n/**\n * Lower priority implicits for [[JsonDecoder]].\n */\ntrait JsonDecoderLowPriority {\n\n  /**\n   * Lower priority: derive a codec from an implicit [[Schema]].\n   */\n  implicit def fromSchema[A](implicit schema: Schema[A]): JsonDecoder[A] =\n    new JsonDecoder[A] {\n      private lazy val codec: JsonBinaryCodec[A] = schema.derive(JsonBinaryCodecDeriver)\n      def decode(json: Json): Either[JsonError, A] = json.decodeWith(codec)\n    }\n}\n\n/**\n * Type class for encoding Scala types into [[Json]] values.\n *\n * Implicit resolution prefers explicitly provided [[JsonBinaryCodec]] instances\n * over schema-derived instances, allowing users to override derived behavior.\n */\nsealed trait JsonEncoder[A] {\n\n  /**\n   * Encodes a value of type `A` into [[Json]].\n   *\n   * @param value The value to encode\n   * @return The encoded JSON value\n   */\n  def encode(value: A): Json\n}\n\nobject JsonEncoder extends JsonEncoderLowPriority {\n\n  def apply[A](implicit encoder: JsonEncoder[A]): JsonEncoder[A] = encoder\n\n  /**\n   * Higher priority: use an explicitly provided [[JsonBinaryCodec]].\n   */\n  implicit def fromCodec[A](implicit codec: JsonBinaryCodec[A]): JsonEncoder[A] =\n    new JsonEncoder[A] {\n      def encode(value: A): Json = Json.encodeWith(value, codec)\n    }\n}\n\n/**\n * Lower priority implicits for [[JsonEncoder]].\n */\ntrait JsonEncoderLowPriority {\n\n  /**\n   * Lower priority: derive a codec from an implicit [[Schema]].\n   */\n  implicit def fromSchema[A](implicit schema: Schema[A]): JsonEncoder[A] =\n    new JsonEncoder[A] {\n      private lazy val codec: JsonBinaryCodec[A] = schema.derive(JsonBinaryCodecDeriver)\n      def encode(value: A): Json = Json.encodeWith(value, codec)\n    }\n}\n\n// =============================================================================\n// JSON SELECTION\n// =============================================================================\n\n/**\n * Represents a selection of zero or more JSON values, with accumulated errors.\n *\n * `JsonSelection` enables fluent chaining of operations that may fail without\n * requiring immediate error handling. Operations are applied to all values in\n * the selection, and errors are accumulated.\n *\n * {{{\n * val selection: JsonSelection = json.get(p\"users[*].name\")\n * val result: Either[SchemaError, Vector[Json]] = selection.toEither\n * }}}\n */\nfinal case class JsonSelection(toEither: Either[SchemaError, Vector[Json]]) { self =>\n\n  /**\n   * Returns true if this selection contains no values (either empty or errored).\n   */\n  def isEmpty: Boolean = toEither.fold(_ => true, _.isEmpty)\n\n  /**\n   * Returns true if this selection contains at least one value.\n   */\n  def nonEmpty: Boolean = toEither.fold(_ => false, _.nonEmpty)\n\n  /**\n   * Returns the number of values in this selection, or 0 if errored.\n   */\n  def size: Int = toEither.fold(_ => 0, _.size)\n\n  // ---------------------------------------------------------------------------\n  // Transformations\n  // ---------------------------------------------------------------------------\n\n  /**\n   * Applies a function to each JSON value in this selection.\n   *\n   * @param f The transformation function\n   * @return A new selection with transformed values\n   */\n  def map(f: Json => Json): JsonSelection =\n    JsonSelection(toEither.map(_.map(f)))\n\n  /**\n   * Applies a function returning a selection to each value, flattening results.\n   *\n   * @param f The function producing selections\n   * @return A new selection with all results combined\n   */\n  def flatMap(f: Json => JsonSelection): JsonSelection =\n    JsonSelection(toEither.flatMap { jsons =>\n      jsons.foldLeft[Either[SchemaError, Vector[Json]]](Right(Vector.empty)) { (acc, json) =>\n        for {\n          existing <- acc\n          next     <- f(json).toEither\n        } yield existing ++ next\n      }\n    })\n\n  /**\n   * Filters values in this selection by a predicate.\n   *\n   * @param p The predicate to test values\n   * @return A new selection containing only values satisfying the predicate\n   */\n  def filter(p: Json => Boolean): JsonSelection =\n    JsonSelection(toEither.map(_.filter(p)))\n\n  /**\n   * Collects values for which the partial function is defined.\n   *\n   * @param pf A partial function to apply\n   * @return A new selection with collected results\n   */\n  def collect(pf: PartialFunction[Json, Json]): JsonSelection =\n    JsonSelection(toEither.map(_.collect(pf)))\n\n  // ---------------------------------------------------------------------------\n  // Navigation\n  // ---------------------------------------------------------------------------\n\n  /**\n   * Navigates to values at the given path within each selected value.\n   *\n   * @param path The path to navigate\n   * @return A new selection with values at the path\n   */\n  def get(path: DynamicOptic): JsonSelection =\n    flatMap(json => json.get(path))\n\n  /**\n   * Alias for [[get]].\n   */\n  def apply(path: DynamicOptic): JsonSelection = get(path)\n\n  /**\n   * Navigates to array element at given index within each selected value.\n   *\n   * @param index The array index\n   * @return A new selection with elements at the index\n   */\n  def apply(index: Int): JsonSelection =\n    flatMap(json => json.apply(index))\n\n  /**\n   * Navigates to object field with given key within each selected value.\n   *\n   * @param key The object key\n   * @return A new selection with values at the key\n   */\n  def apply(key: String): JsonSelection =\n    flatMap(json => json.apply(key))\n\n  // ---------------------------------------------------------------------------\n  // Type Filtering\n  // ---------------------------------------------------------------------------\n\n  /**\n   * Filters to only JSON objects.\n   */\n  def objects: JsonSelection = filter(_.isObject)\n\n  /**\n   * Filters to only JSON arrays.\n   */\n  def arrays: JsonSelection = filter(_.isArray)\n\n  /**\n   * Filters to only JSON strings.\n   */\n  def strings: JsonSelection = filter(_.isString)\n\n  /**\n   * Filters to only JSON numbers.\n   */\n  def numbers: JsonSelection = filter(_.isNumber)\n\n  /**\n   * Filters to only JSON booleans.\n   */\n  def booleans: JsonSelection = filter(_.isBoolean)\n\n  /**\n   * Filters to only JSON nulls.\n   */\n  def nulls: JsonSelection = filter(_.isNull)\n\n  // ---------------------------------------------------------------------------\n  // Combination\n  // ---------------------------------------------------------------------------\n\n  /**\n   * Combines this selection with another, concatenating values or errors.\n   *\n   * @param other The other selection\n   * @return A combined selection\n   */\n  def ++(other: JsonSelection): JsonSelection =\n    (toEither, other.toEither) match {\n      case (Right(a), Right(b)) => JsonSelection(Right(a ++ b))\n      case (Left(a), Left(b))   => JsonSelection(Left(a ++ b))\n      case (Left(a), _)         => JsonSelection(Left(a))\n      case (_, Left(b))         => JsonSelection(Left(b))\n    }\n\n  // ---------------------------------------------------------------------------\n  // Terminal Operations\n  // ---------------------------------------------------------------------------\n\n  /**\n   * Returns the single value if exactly one, an array of values if there are many, or \n   * otherwise an error.\n   */\n  def one: Either[SchemaError, Json] =\n    toEither.flatMap { jsons =>\n      if (jsons.size == 1) Right(jsons.head)\n      else if (jsons.size > 1) toArray\n      else Left(SchemaError.expectationMismatch(Nil, s\"expected exactly one value, got ${jsons.size}\"))\n    }\n\n  /**\n   * Returns the first value if any, otherwise an error.\n   */\n  def first: Either[SchemaError, Json] =\n    toEither.flatMap { jsons =>\n      jsons.headOption.toRight(SchemaError.expectationMismatch(Nil, \"expected at least one value, got none\"))\n    }\n\n  /**\n   * Returns all values as a [[Json.Array]], or an error.\n   */\n  def toArray: Either[SchemaError, Json] =\n    toEither.map(jsons => Json.Array(jsons))\n\n  /**\n   * Unsafe version of [[one]], throws on error or wrong count.\n   */\n  def oneUnsafe: Json = one.fold(e => throw JsonError.fromSchemaError(e), identity)\n\n  /**\n   * Unsafe version of [[first]], throws on error or empty.\n   */\n  def firstUnsafe: Json = first.fold(e => throw JsonError.fromSchemaError(e), identity)\n}\n\nobject JsonSelection {\n\n  /**\n   * Creates a selection containing a single value.\n   */\n  def apply(json: Json): JsonSelection = JsonSelection(Right(Vector(json)))\n\n  /**\n   * Creates a selection containing multiple values.\n   */\n  def fromVector(jsons: Vector[Json]): JsonSelection = JsonSelection(Right(jsons))\n\n  /**\n   * Creates an empty selection (no values, no error).\n   */\n  val empty: JsonSelection = JsonSelection(Right(Vector.empty))\n\n  /**\n   * Creates a failed selection with the given error.\n   */\n  def fail(error: SchemaError): JsonSelection = JsonSelection(Left(error))\n\n  /**\n   * Creates a failed selection with the given message.\n   */\n  def fail(message: String): JsonSelection =\n    JsonSelection(Left(SchemaError.expectationMismatch(Nil, message)))\n}\n\n// =============================================================================\n// JSON ADT\n// =============================================================================\n\n/**\n * Represents a JSON value.\n *\n * The JSON data model consists of:\n *  - '''Objects''': Unordered collections of key-value pairs\n *  - '''Arrays''': Ordered sequences of values\n *  - '''Strings''': Unicode text\n *  - '''Numbers''': Numeric values (stored as strings for precision)\n *  - '''Booleans''': `true` or `false`\n *  - '''Null''': The null value\n *\n * ==Construction==\n * {{{\n * val obj = Json.Object(\"name\" -> Json.String(\"Alice\"), \"age\" -> Json.number(30))\n * val arr = Json.Array(Json.String(\"a\"), Json.String(\"b\"))\n * val str = Json.String(\"hello\")\n * val num = Json.number(42)\n * val bool = Json.Boolean(true)\n * val nul = Json.Null\n * }}}\n *\n * ==Navigation==\n * {{{\n * json.get(p\"users[0].name\")   // JsonSelection\n * json(\"users\")(0)(\"name\")     // JsonSelection\n * json.fields                  // for objects\n * json.elements                // for arrays\n * }}}\n *\n * ==Pattern Matching==\n * {{{\n * json match {\n *   case Json.Object(fields) => ...\n *   case Json.Array(elements) => ...\n *   case Json.String(value) => ...\n *   case Json.Number(value) => ...\n *   case Json.Boolean(value) => ...\n *   case Json.Null => ...\n * }\n * }}}\n */\nsealed trait Json { self =>\n\n  // ===========================================================================\n  // Type Testing\n  // ===========================================================================\n\n  /**\n   * Returns `true` if this is a JSON object.\n   */\n  def isObject: Boolean = false\n\n  /**\n   * Returns `true` if this is a JSON array.\n   */\n  def isArray: Boolean = false\n\n  /**\n   * Returns `true` if this is a JSON string.\n   */\n  def isString: Boolean = false\n\n  /**\n   * Returns `true` if this is a JSON number.\n   */\n  def isNumber: Boolean = false\n\n  /**\n   * Returns `true` if this is a JSON boolean.\n   */\n  def isBoolean: Boolean = false\n\n  /**\n   * Returns `true` if this is JSON null.\n   */\n  def isNull: Boolean = false\n\n  // ===========================================================================\n  // Type Filtering (returns JsonSelection)\n  // ===========================================================================\n\n  /**\n   * Returns a [[JsonSelection]] containing this value if it is an object,\n   * otherwise an empty selection.\n   */\n  def asObject: JsonSelection = if (isObject) JsonSelection(self) else JsonSelection.empty\n\n  /**\n   * Returns a [[JsonSelection]] containing this value if it is an array,\n   * otherwise an empty selection.\n   */\n  def asArray: JsonSelection = if (isArray) JsonSelection(self) else JsonSelection.empty\n\n  /**\n   * Returns a [[JsonSelection]] containing this value if it is a string,\n   * otherwise an empty selection.\n   */\n  def asString: JsonSelection = if (isString) JsonSelection(self) else JsonSelection.empty\n\n  /**\n   * Returns a [[JsonSelection]] containing this value if it is a number,\n   * otherwise an empty selection.\n   */\n  def asNumber: JsonSelection = if (isNumber) JsonSelection(self) else JsonSelection.empty\n\n  /**\n   * Returns a [[JsonSelection]] containing this value if it is a boolean,\n   * otherwise an empty selection.\n   */\n  def asBoolean: JsonSelection = if (isBoolean) JsonSelection(self) else JsonSelection.empty\n\n  /**\n   * Returns a [[JsonSelection]] containing this value if it is null,\n   * otherwise an empty selection.\n   */\n  def asNull: JsonSelection = if (isNull) JsonSelection(self) else JsonSelection.empty\n\n  // ===========================================================================\n  // Direct Accessors\n  // ===========================================================================\n\n  /**\n   * If this is an object, returns its fields as key-value pairs.\n   * Otherwise returns an empty sequence.\n   */\n  def fields: Seq[(String, Json)] = Seq.empty\n\n  /**\n   * If this is an array, returns its elements.\n   * Otherwise returns an empty sequence.\n   */\n  def elements: Seq[Json] = Seq.empty\n\n  /**\n   * If this is a string, returns its value.\n   * Otherwise returns `None`.\n   */\n  def stringValue: Option[String] = None\n\n  /**\n   * If this is a number, returns its string representation.\n   * Otherwise returns `None`.\n   */\n  def numberValue: Option[String] = None\n\n  /**\n   * If this is a boolean, returns its value.\n   * Otherwise returns `None`.\n   */\n  def booleanValue: Option[scala.Boolean] = None\n\n  // ===========================================================================\n  // Navigation\n  // ===========================================================================\n\n  /**\n   * Navigates to values at the given path.\n   *\n   * {{{\n   * json.get(p\"users[0].name\")\n   * json.get(DynamicOptic.root.field(\"users\").at(0).field(\"name\"))\n   * }}}\n   *\n   * @param path The path to navigate\n   * @return A [[JsonSelection]] containing values at the path\n   */\n  def get(path: DynamicOptic): JsonSelection = ???\n\n  /**\n   * Alias for [[get]].\n   */\n  def apply(path: DynamicOptic): JsonSelection = get(path)\n\n  /**\n   * If this is an array, returns a selection containing the element at the given index.\n   * Returns an empty selection if not an array or index is out of bounds.\n   *\n   * @param index The array index (0-based)\n   */\n  def apply(index: Int): JsonSelection = self match {\n    case Json.Array(elems) if index >= 0 && index < elems.size =>\n      JsonSelection(elems(index))\n    case _ =>\n      JsonSelection.empty\n  }\n\n  /**\n   * If this is an object, returns a selection containing the value at the given key.\n   * Returns an empty selection if not an object or key is not present.\n   *\n   * @param key The object key\n   */\n  def apply(key: String): JsonSelection = self match {\n    case Json.Object(flds) =>\n      flds.collectFirst { case (k, v) if k == key => v } match {\n        case Some(v) => JsonSelection(v)\n        case None    => JsonSelection.empty\n      }\n    case _ =>\n      JsonSelection.empty\n  }\n\n  // ===========================================================================\n  // Modification (Json => Json)\n  // ===========================================================================\n\n  /**\n   * Modifies values at the given path using the provided function.\n   *\n   * If the path does not exist, returns this JSON unchanged.\n   *\n   * {{{\n   * json.modify(p\"users[*].age\", {\n   *   case Json.Number(n) => Json.number(n.toInt + 1)\n   *   case other => other\n   * })\n   * }}}\n   *\n   * @param path The path to values to modify\n   * @param f The modification function\n   * @return The modified JSON\n   */\n  def modify(path: DynamicOptic, f: Json => Json): Json = ???\n\n  /**\n   * Modifies values at the given path using a partial function.\n   *\n   * Values for which the partial function is not defined are left unchanged.\n   *\n   * @param path The path to values to modify\n   * @param pf The partial modification function\n   * @return Either an error if the path is invalid, or the modified JSON\n   */\n  def modifyOrFail(path: DynamicOptic, pf: PartialFunction[Json, Json]): Either[JsonError, Json] = ???\n\n  /**\n   * Sets the value at the given path.\n   *\n   * If the path does not exist, attempts to create intermediate structure.\n   * For array indices, the array must already exist and have sufficient length.\n   *\n   * {{{\n   * json.set(p\"user.name\", Json.String(\"Bob\"))\n   * }}}\n   *\n   * @param path The path to set\n   * @param value The value to set\n   * @return The modified JSON\n   */\n  def set(path: DynamicOptic, value: Json): Json = ???\n\n  /**\n   * Sets the value at the given path, returning an error if the path is invalid.\n   *\n   * @param path The path to set\n   * @param value The value to set\n   * @return Either an error or the modified JSON\n   */\n  def setOrFail(path: DynamicOptic, value: Json): Either[JsonError, Json] = ???\n\n  /**\n   * Deletes values at the given path.\n   *\n   * For object fields, removes the key-value pair.\n   * For array elements, removes the element and shifts subsequent elements.\n   *\n   * @param path The path to delete\n   * @return The modified JSON\n   */\n  def delete(path: DynamicOptic): Json = ???\n\n  /**\n   * Deletes values at the given path, returning an error if the path is invalid.\n   *\n   * @param path The path to delete\n   * @return Either an error or the modified JSON\n   */\n  def deleteOrFail(path: DynamicOptic): Either[JsonError, Json] = ???\n\n  /**\n   * Inserts a value at the given path.\n   *\n   * For arrays, inserts at the specified index, shifting subsequent elements.\n   * For objects, adds or replaces the key.\n   *\n   * @param path The path where to insert\n   * @param value The value to insert\n   * @return The modified JSON\n   */\n  def insert(path: DynamicOptic, value: Json): Json = ???\n\n  /**\n   * Inserts a value at the given path, returning an error if invalid.\n   *\n   * @param path The path where to insert\n   * @param value The value to insert\n   * @return Either an error or the modified JSON\n   */\n  def insertOrFail(path: DynamicOptic, value: Json): Either[JsonError, Json] = ???\n\n  // ===========================================================================\n  // Merging\n  // ===========================================================================\n\n  /**\n   * Merges this JSON with another using the specified strategy.\n   *\n   * {{{\n   * val merged = json1.merge(json2, MergeStrategy.Deep)\n   * }}}\n   *\n   * @param other The JSON to merge with\n   * @param strategy The merge strategy (default: [[MergeStrategy.Auto]])\n   * @return The merged JSON\n   */\n  def merge(other: Json, strategy: MergeStrategy = MergeStrategy.Auto): Json = ???\n\n  // ===========================================================================\n  // Patching\n  // ===========================================================================\n\n  /**\n   * Applies a [[JsonPatch]] to this JSON.\n   *\n   * @param patch The patch to apply\n   * @return Either an error if the patch cannot be applied, or the patched JSON\n   */\n  def patch(patch: JsonPatch): Either[JsonError, Json] = ???\n\n  /**\n   * Applies a [[JsonPatch]], throwing on failure.\n   *\n   * @param patch The patch to apply\n   * @return The patched JSON\n   * @throws JsonError if the patch cannot be applied\n   */\n  def patchUnsafe(patch: JsonPatch): Json = this.patch(patch).fold(throw _, identity)\n\n  // ===========================================================================\n  // Transformation\n  // ===========================================================================\n\n  /**\n   * Transforms all values in this JSON bottom-up (children before parents).\n   *\n   * @param f The transformation function receiving path and value\n   * @return The transformed JSON\n   */\n  def transformUp(f: (DynamicOptic, Json) => Json): Json = ???\n\n  /**\n   * Transforms all values in this JSON top-down (parents before children).\n   *\n   * @param f The transformation function receiving path and value\n   * @return The transformed JSON\n   */\n  def transformDown(f: (DynamicOptic, Json) => Json): Json = ???\n\n  /**\n   * Transforms all object keys in this JSON.\n   *\n   * @param f The key transformation function receiving path and key\n   * @return The transformed JSON\n   */\n  def transformKeys(f: (DynamicOptic, String) => String): Json = ???\n\n  // ===========================================================================\n  // Filtering\n  // ===========================================================================\n\n  /**\n   * Removes entries matching the predicate.\n   *\n   * For objects, removes matching key-value pairs.\n   * For arrays, removes matching elements.\n   *\n   * @param p The predicate receiving path and value\n   * @return The filtered JSON\n   */\n  def filterNot(p: (DynamicOptic, Json) => scala.Boolean): Json = ???\n\n  /**\n   * Keeps only entries matching the predicate.\n   *\n   * @param p The predicate receiving path and value\n   * @return The filtered JSON\n   */\n  def filter(p: (DynamicOptic, Json) => scala.Boolean): Json =\n    filterNot((path, json) => !p(path, json))\n\n  // ===========================================================================\n  // Projection\n  // ===========================================================================\n\n  /**\n   * Projects this JSON to include only the specified paths.\n   *\n   * Paths that don't exist are ignored. Structure is preserved.\n   *\n   * {{{\n   * json.project(p\"user.name\", p\"user.email\", p\"meta.created\")\n   * }}}\n   *\n   * @param paths The paths to include\n   * @return A new JSON containing only the specified paths\n   */\n  def project(paths: DynamicOptic*): Json = ???\n\n  // ===========================================================================\n  // Splitting / Partitioning\n  // ===========================================================================\n\n  /**\n   * Partitions this JSON into two based on a predicate.\n   *\n   * Returns a tuple where the first element contains entries satisfying\n   * the predicate, and the second contains entries that don't.\n   *\n   * @param p The predicate receiving path and value\n   * @return A tuple of (matching, non-matching) JSON values\n   */\n  def partition(p: (DynamicOptic, Json) => scala.Boolean): (Json, Json) = ???\n\n  // ===========================================================================\n  // Normalization\n  // ===========================================================================\n\n  /**\n   * Returns a normalized version of this JSON.\n   *\n   * Normalization includes:\n   *  - Sorting object keys alphabetically\n   *  - Normalizing number representations\n   *\n   * Useful for comparison and hashing.\n   */\n  def normalize: Json = ???\n\n  /**\n   * Returns this JSON with all object keys sorted alphabetically (recursive).\n   */\n  def sortKeys: Json = self match {\n    case Json.Object(flds) =>\n      Json.Object(flds.map { case (k, v) => (k, v.sortKeys) }.sortBy(_._1))\n    case Json.Array(elems) =>\n      Json.Array(elems.map(_.sortKeys))\n    case other =>\n      other\n  }\n\n  /**\n   * Returns this JSON with all null values removed from objects.\n   */\n  def dropNulls: Json = self match {\n    case Json.Object(flds) =>\n      Json.Object(flds.collect { case (k, v) if !v.isNull => (k, v.dropNulls) })\n    case Json.Array(elems) =>\n      Json.Array(elems.map(_.dropNulls))\n    case other =>\n      other\n  }\n\n  /**\n   * Returns this JSON with empty objects and arrays removed.\n   */\n  def dropEmpty: Json = self match {\n    case Json.Object(flds) =>\n      val filtered = flds.collect {\n        case (k, v) =>\n          val dropped = v.dropEmpty\n          dropped match {\n            case Json.Object(f) if f.isEmpty => None\n            case Json.Array(e) if e.isEmpty  => None\n            case other                       => Some((k, other))\n          }\n      }.flatten\n      Json.Object(filtered)\n    case Json.Array(elems) =>\n      val filtered = elems.map(_.dropEmpty).filter {\n        case Json.Object(f) if f.isEmpty => false\n        case Json.Array(e) if e.isEmpty  => false\n        case _                           => true\n      }\n      Json.Array(filtered)\n    case other =>\n      other\n  }\n\n  // ===========================================================================\n  // Diffing\n  // ===========================================================================\n\n  /**\n   * Computes a [[JsonPatch]] that transforms this JSON into the target.\n   *\n   * {{{\n   * val patch = source.diff(target)\n   * source.patch(patch) == Right(target) // true\n   * }}}\n   *\n   * @param target The target JSON\n   * @return A patch that transforms this into target\n   */\n  def diff(target: Json): JsonPatch = ???\n\n  // ===========================================================================\n  // Folding\n  // ===========================================================================\n\n  /**\n   * Folds over this JSON top-down (parents before children).\n   *\n   * @param z The initial accumulator value\n   * @param f The fold function receiving path, value, and accumulator\n   * @tparam B The accumulator type\n   * @return The final accumulated value\n   */\n  def foldDown[B](z: B)(f: (DynamicOptic, Json, B) => B): B = ???\n\n  /**\n   * Folds over this JSON bottom-up (children before parents).\n   *\n   * @param z The initial accumulator value\n   * @param f The fold function receiving path, value, and accumulator\n   * @tparam B The accumulator type\n   * @return The final accumulated value\n   */\n  def foldUp[B](z: B)(f: (DynamicOptic, Json, B) => B): B = ???\n\n  /**\n   * Folds over this JSON top-down, allowing the fold function to fail.\n   *\n   * Short-circuits on first failure.\n   *\n   * @param z The initial accumulator value\n   * @param f The fold function that may fail\n   * @tparam B The accumulator type\n   * @return Either an error or the final accumulated value\n   */\n  def foldDownOrFail[B](z: B)(f: (DynamicOptic, Json, B) => Either[JsonError, B]): Either[JsonError, B] = ???\n\n  /**\n   * Folds over this JSON bottom-up, allowing the fold function to fail.\n   *\n   * Short-circuits on first failure.\n   *\n   * @param z The initial accumulator value\n   * @param f The fold function that may fail\n   * @tparam B The accumulator type\n   * @return Either an error or the final accumulated value\n   */\n  def foldUpOrFail[B](z: B)(f: (DynamicOptic, Json, B) => Either[JsonError, B]): Either[JsonError, B] = ???\n\n  // ===========================================================================\n  // Querying\n  // ===========================================================================\n\n  /**\n   * Selects all values matching the predicate.\n   *\n   * @param p The predicate receiving path and value\n   * @return A [[JsonSelection]] containing matching values\n   */\n  def query(p: (DynamicOptic, Json) => scala.Boolean): JsonSelection = ???\n\n  // ===========================================================================\n  // Validation\n  // ===========================================================================\n\n  /**\n   * Validates this JSON against a [[JsonSchema]].\n   *\n   * @param schema The schema to validate against\n   * @return `None` if valid, `Some(error)` if invalid\n   */\n  def check(schema: JsonSchema): Option[SchemaError] = ???\n\n  /**\n   * Returns `true` if this JSON conforms to the given [[JsonSchema]].\n   */\n  def conforms(schema: JsonSchema): scala.Boolean = check(schema).isEmpty\n\n  // ===========================================================================\n  // KV Representation\n  // ===========================================================================\n\n  /**\n   * Flattens this JSON to a sequence of path-value pairs.\n   *\n   * Only leaf values (primitives, empty arrays, empty objects) are included.\n   *\n   * {{{\n   * Json.parse(\"\"\"{\"a\": {\"b\": 1}, \"c\": [2, 3]}\"\"\").toKV\n   * // Seq(\n   * //   (p\"a.b\", Json.Number(\"1\")),\n   * //   (p\"c[0]\", Json.Number(\"2\")),\n   * //   (p\"c[1]\", Json.Number(\"3\"))\n   * // )\n   * }}}\n   */\n  def toKV: Seq[(DynamicOptic, Json)] = ???\n\n  // ===========================================================================\n  // Comparison\n  // ===========================================================================\n\n  /**\n   * Compares this JSON to another for ordering.\n   *\n   * Ordering is defined as:\n   *  1. Null < Boolean < Number < String < Array < Object\n   *  2. Within types, natural ordering applies\n   */\n  def compare(that: Json): Int = (self, that) match {\n    case (Json.Null, Json.Null)               => 0\n    case (Json.Null, _)                       => -1\n    case (_, Json.Null)                       => 1\n    case (Json.Boolean(a), Json.Boolean(b))   => a.compare(b)\n    case (Json.Boolean(_), _)                 => -1\n    case (_, Json.Boolean(_))                 => 1\n    case (Json.Number(a), Json.Number(b))     => BigDecimal(a).compare(BigDecimal(b))\n    case (Json.Number(_), _)                  => -1\n    case (_, Json.Number(_))                  => 1\n    case (Json.String(a), Json.String(b))     => a.compare(b)\n    case (Json.String(_), _)                  => -1\n    case (_, Json.String(_))                  => 1\n    case (Json.Array(a), Json.Array(b))       => compareArrays(a, b)\n    case (Json.Array(_), _)                   => -1\n    case (_, Json.Array(_))                   => 1\n    case (Json.Object(a), Json.Object(b))     => compareObjects(a, b)\n  }\n\n  private def compareArrays(a: Vector[Json], b: Vector[Json]): Int = {\n    val len = math.min(a.size, b.size)\n    var i   = 0\n    while (i < len) {\n      val cmp = a(i).compare(b(i))\n      if (cmp != 0) return cmp\n      i += 1\n    }\n    a.size.compare(b.size)\n  }\n\n  private def compareObjects(a: Vector[(String, Json)], b: Vector[(String, Json)]): Int = {\n    val aSorted = a.sortBy(_._1)\n    val bSorted = b.sortBy(_._1)\n    val len     = math.min(aSorted.size, bSorted.size)\n    var i       = 0\n    while (i < len) {\n      val (ak, av) = aSorted(i)\n      val (bk, bv) = bSorted(i)\n      val keyCmp   = ak.compare(bk)\n      if (keyCmp != 0) return keyCmp\n      val valCmp = av.compare(bv)\n      if (valCmp != 0) return valCmp\n      i += 1\n    }\n    aSorted.size.compare(bSorted.size)\n  }\n\n  // ===========================================================================\n  // DynamicValue Interop\n  // ===========================================================================\n\n  /**\n   * Converts this JSON to a [[DynamicValue]].\n   *\n   * This conversion is lossless; all JSON values can be represented as DynamicValue.\n   */\n  def toDynamicValue: DynamicValue = self match {\n    case Json.Null =>\n      DynamicValue.Primitive(PrimitiveValue.Unit)\n    case Json.Boolean(v) =>\n      DynamicValue.Primitive(PrimitiveValue.Boolean(v))\n    case Json.Number(v) =>\n      // Preserve as BigDecimal for maximum precision\n      DynamicValue.Primitive(PrimitiveValue.BigDecimal(BigDecimal(v)))\n    case Json.String(v) =>\n      DynamicValue.Primitive(PrimitiveValue.String(v))\n    case Json.Array(elems) =>\n      DynamicValue.Sequence(elems.map(_.toDynamicValue))\n    case Json.Object(flds) =>\n      DynamicValue.Record(flds.map { case (k, v) => (k, v.toDynamicValue) })\n  }\n\n  // ===========================================================================\n  // Typed Decoding (Json => A)\n  // ===========================================================================\n\n  /**\n   * Decodes this JSON to a typed value.\n   *\n   * Uses implicit [[JsonDecoder]] which prefers explicit codecs over schema derivation.\n   *\n   * {{{\n   * val person: Either[JsonError, Person] = json.as[Person]\n   * }}}\n   *\n   * @tparam A The target type\n   * @return Either an error or the decoded value\n   */\n  def as[A](implicit decoder: JsonDecoder[A]): Either[JsonError, A] = decoder.decode(self)\n\n  /**\n   * Decodes this JSON to a typed value, throwing on failure.\n   *\n   * @tparam A The target type\n   * @return The decoded value\n   * @throws JsonError if decoding fails\n   */\n  def asUnsafe[A](implicit decoder: JsonDecoder[A]): A = as[A].fold(throw _, identity)\n\n  /**\n   * Internal: decode using an explicit codec.\n   */\n  private[json] def decodeWith[A](codec: JsonBinaryCodec[A]): Either[JsonError, A] = ???\n\n  // ===========================================================================\n  // Encoding (Json => String/Bytes)\n  // ===========================================================================\n\n  /**\n   * Encodes this JSON to a compact string (no extra whitespace).\n   */\n  def print: String = encode(WriterConfig)\n\n  /**\n   * Encodes this JSON to a string using the specified configuration.\n   *\n   * @param config Writer configuration (indentation, unicode escaping, etc.)\n   */\n  def print(config: WriterConfig): String = encode(config)\n\n  /**\n   * Alias for [[print]].\n   */\n  def encode: String = encode(WriterConfig)\n\n  /**\n   * Encodes this JSON to a string using the specified configuration.\n   *\n   * @param config Writer configuration\n   */\n  def encode(config: WriterConfig): String = ???\n\n  /**\n   * Encodes this JSON and writes to the provided [[Writer]].\n   *\n   * @param writer The writer to write to\n   */\n  def printTo(writer: Writer): Unit = printTo(writer, WriterConfig)\n\n  /**\n   * Encodes this JSON and writes to the provided [[Writer]] with configuration.\n   *\n   * @param writer The writer to write to\n   * @param config Writer configuration\n   */\n  def printTo(writer: Writer, config: WriterConfig): Unit = ???\n\n  /**\n   * Encodes this JSON to a byte array (UTF-8).\n   */\n  def encodeToBytes: Array[Byte] = encodeToBytes(WriterConfig)\n\n  /**\n   * Encodes this JSON to a byte array (UTF-8) with configuration.\n   *\n   * @param config Writer configuration\n   */\n  def encodeToBytes(config: WriterConfig): Array[Byte] = ???\n\n  /**\n   * Encodes this JSON to a [[Chunk]] of bytes (UTF-8).\n   */\n  def encodeToChunk: Chunk[Byte] = encodeToChunk(WriterConfig)\n\n  /**\n   * Encodes this JSON to a [[Chunk]] of bytes (UTF-8) with configuration.\n   *\n   * @param config Writer configuration\n   */\n  def encodeToChunk(config: WriterConfig): Chunk[Byte] = ???\n\n  /**\n   * Encodes this JSON into the provided [[ByteBuffer]].\n   *\n   * @param buffer The buffer to write to\n   */\n  def encodeTo(buffer: ByteBuffer): Unit = encodeTo(buffer, WriterConfig)\n\n  /**\n   * Encodes this JSON into the provided [[ByteBuffer]] with configuration.\n   *\n   * @param buffer The buffer to write to\n   * @param config Writer configuration\n   */\n  def encodeTo(buffer: ByteBuffer, config: WriterConfig): Unit = ???\n\n  // ===========================================================================\n  // Standard Methods\n  // ===========================================================================\n\n  override def hashCode(): Int = self match {\n    case Json.Null           => 0\n    case Json.Boolean(v)     => v.hashCode()\n    case Json.Number(v)      => BigDecimal(v).hashCode()\n    case Json.String(v)      => v.hashCode()\n    case Json.Array(elems)   => elems.hashCode()\n    case Json.Object(flds)   => flds.sortBy(_._1).hashCode()\n  }\n\n  override def equals(that: Any): Boolean = that match {\n    case other: Json => compare(other) == 0\n    case _           => false\n  }\n\n  override def toString: String = print\n}\n\nobject Json {\n\n  // ===========================================================================\n  // ADT Cases\n  // ===========================================================================\n\n  /**\n   * A JSON object: an unordered collection of key-value pairs.\n   *\n   * @param fields The key-value pairs. Keys should be unique; if duplicates\n   *               are present, behavior of accessors is undefined.\n   */\n  final case class Object(fields: Vector[(String, Json)]) extends Json {\n    override def isObject: scala.Boolean                = true\n    override def fields: Seq[(String, Json)]            = fields\n  }\n\n  object Object {\n\n    /**\n     * Creates an empty JSON object.\n     */\n    val empty: Object = Object(Vector.empty)\n\n    /**\n     * Creates a JSON object from key-value pairs.\n     */\n    def apply(fields: (String, Json)*): Object = Object(fields.toVector)\n  }\n\n  /**\n   * A JSON array: an ordered sequence of values.\n   *\n   * @param elements The array elements\n   */\n  final case class Array(elements: Vector[Json]) extends Json {\n    override def isArray: scala.Boolean  = true\n    override def elements: Seq[Json]     = elements\n  }\n\n  object Array {\n\n    /**\n     * Creates an empty JSON array.\n     */\n    val empty: Array = Array(Vector.empty)\n\n    /**\n     * Creates a JSON array from elements.\n     */\n    def apply(elements: Json*): Array = Array(elements.toVector)\n  }\n\n  /**\n   * A JSON string.\n   *\n   * @param value The string value (unescaped)\n   */\n  final case class String(value: java.lang.String) extends Json {\n    override def isString: scala.Boolean              = true\n    override def stringValue: Option[java.lang.String] = Some(value)\n  }\n\n  /**\n   * A JSON number.\n   *\n   * Stored as a string to preserve exact representation (precision, trailing zeros, etc.).\n   * Provides lazy conversion to numeric types.\n   *\n   * @param value The number as a string (should be valid JSON number syntax)\n   */\n  final case class Number(value: java.lang.String) extends Json {\n    override def isNumber: scala.Boolean                = true\n    override def numberValue: Option[java.lang.String]  = Some(value)\n\n    /**\n     * Converts to `Int`, truncating if necessary.\n     */\n    lazy val toInt: Int = toBigDecimal.toInt\n\n    /**\n     * Converts to `Long`, truncating if necessary.\n     */\n    lazy val toLong: Long = toBigDecimal.toLong\n\n    /**\n     * Converts to `Float`.\n     */\n    lazy val toFloat: Float = value.toFloat\n\n    /**\n     * Converts to `Double`.\n     */\n    lazy val toDouble: Double = value.toDouble\n\n    /**\n     * Converts to `BigInt`, truncating fractional part.\n     */\n    lazy val toBigInt: BigInt = toBigDecimal.toBigInt\n\n    /**\n     * Converts to `BigDecimal` (lossless).\n     */\n    lazy val toBigDecimal: BigDecimal = BigDecimal(value)\n  }\n\n  /**\n   * A JSON boolean.\n   *\n   * @param value The boolean value\n   */\n  final case class Boolean(value: scala.Boolean) extends Json {\n    override def isBoolean: scala.Boolean              = true\n    override def booleanValue: Option[scala.Boolean]   = Some(value)\n  }\n\n  object Boolean {\n    val True: Boolean  = Boolean(true)\n    val False: Boolean = Boolean(false)\n  }\n\n  /**\n   * The JSON null value.\n   */\n  case object Null extends Json {\n    override def isNull: scala.Boolean = true\n  }\n\n  // ===========================================================================\n  // Convenience Constructors\n  // ===========================================================================\n\n  /**\n   * Creates a JSON number from an `Int`.\n   */\n  def number(n: Int): Number = Number(n.toString)\n\n  /**\n   * Creates a JSON number from a `Long`.\n   */\n  def number(n: Long): Number = Number(n.toString)\n\n  /**\n   * Creates a JSON number from a `Float`.\n   */\n  def number(n: Float): Number = Number(n.toString)\n\n  /**\n   * Creates a JSON number from a `Double`.\n   */\n  def number(n: Double): Number = Number(n.toString)\n\n  /**\n   * Creates a JSON number from a `BigInt`.\n   */\n  def number(n: BigInt): Number = Number(n.toString)\n\n  /**\n   * Creates a JSON number from a `BigDecimal`.\n   */\n  def number(n: BigDecimal): Number = Number(n.toString)\n\n  /**\n   * Creates a JSON number from a `Short`.\n   */\n  def number(n: Short): Number = Number(n.toString)\n\n  /**\n   * Creates a JSON number from a `Byte`.\n   */\n  def number(n: Byte): Number = Number(n.toString)\n\n  // ===========================================================================\n  // Parsing / Decoding (String/Bytes => Json)\n  // ===========================================================================\n\n  /**\n   * Parses a JSON value from a string.\n   *\n   * @param s The JSON string\n   * @return Either a [[JsonError]] or the parsed JSON\n   */\n  def parse(s: java.lang.String): Either[JsonError, Json] = decode(s)\n\n  /**\n   * Parses a JSON value from a `CharSequence`.\n   *\n   * @param s The JSON character sequence\n   * @return Either a [[JsonError]] or the parsed JSON\n   */\n  def parse(s: CharSequence): Either[JsonError, Json] = decode(s)\n\n  /**\n   * Parses a JSON value from a byte array (UTF-8).\n   *\n   * @param bytes The JSON bytes\n   * @return Either a [[JsonError]] or the parsed JSON\n   */\n  def parse(bytes: scala.Array[Byte]): Either[JsonError, Json] = decode(bytes)\n\n  /**\n   * Parses a JSON value from a [[Chunk]] of bytes (UTF-8).\n   *\n   * @param chunk The JSON bytes\n   * @return Either a [[JsonError]] or the parsed JSON\n   */\n  def parse(chunk: Chunk[Byte]): Either[JsonError, Json] = decode(chunk)\n\n  /**\n   * Parses a JSON value from a [[ByteBuffer]] (UTF-8).\n   *\n   * @param buffer The JSON bytes\n   * @return Either a [[JsonError]] or the parsed JSON\n   */\n  def parse(buffer: ByteBuffer): Either[JsonError, Json] = decode(buffer)\n\n  /**\n   * Parses a JSON value from a [[Reader]].\n   *\n   * @param reader The reader to read from\n   * @return Either a [[JsonError]] or the parsed JSON\n   */\n  def parse(reader: Reader): Either[JsonError, Json] = decode(reader)\n\n  /**\n   * Decodes a JSON value from a string.\n   */\n  def decode(s: java.lang.String): Either[JsonError, Json] = ???\n\n  /**\n   * Decodes a JSON value from a `CharSequence`.\n   */\n  def decode(s: CharSequence): Either[JsonError, Json] = ???\n\n  /**\n   * Decodes a JSON value from a byte array (UTF-8).\n   */\n  def decode(bytes: scala.Array[Byte]): Either[JsonError, Json] = ???\n\n  /**\n   * Decodes a JSON value from a [[Chunk]] of bytes (UTF-8).\n   */\n  def decode(chunk: Chunk[Byte]): Either[JsonError, Json] = ???\n\n  /**\n   * Decodes a JSON value from a [[ByteBuffer]] (UTF-8).\n   */\n  def decode(buffer: ByteBuffer): Either[JsonError, Json] = ???\n\n  /**\n   * Decodes a JSON value from a [[Reader]].\n   */\n  def decode(reader: Reader): Either[JsonError, Json] = ???\n\n  /**\n   * Parses a JSON value from a string, throwing on failure.\n   *\n   * @param s The JSON string\n   * @return The parsed JSON\n   * @throws JsonError if parsing fails\n   */\n  def parseUnsafe(s: java.lang.String): Json = decode(s).fold(throw _, identity)\n\n  /**\n   * Alias for [[parseUnsafe]].\n   */\n  def decodeUnsafe(s: java.lang.String): Json = parseUnsafe(s)\n\n  // ===========================================================================\n  // Typed Encoding (A => Json)\n  // ===========================================================================\n\n  /**\n   * Encodes a typed value to JSON.\n   *\n   * Uses implicit [[JsonEncoder]] which prefers explicit codecs over schema derivation.\n   *\n   * {{{\n   * val json = Json.from(Person(\"Alice\", 30))\n   * }}}\n   *\n   * @param value The value to encode\n   * @return The encoded JSON\n   */\n  def from[A](value: A)(implicit encoder: JsonEncoder[A]): Json = encoder.encode(value)\n\n  /**\n   * Internal: encode using an explicit codec.\n   */\n  private[json] def encodeWith[A](value: A, codec: JsonBinaryCodec[A]): Json = ???\n\n  // ===========================================================================\n  // DynamicValue Interop\n  // ===========================================================================\n\n  /**\n   * Converts a [[DynamicValue]] to JSON.\n   *\n   * This conversion is lossy for `DynamicValue` types that have no JSON equivalent:\n   *  - `PrimitiveValue` types like `java.time.*` are converted to strings\n   *  - `DynamicValue.Variant` uses a discriminator field\n   *\n   * @param value The dynamic value to convert\n   * @return The JSON representation\n   */\n  def fromDynamicValue(value: DynamicValue): Json = value match {\n    case DynamicValue.Primitive(pv) => fromPrimitiveValue(pv)\n    case DynamicValue.Record(flds) =>\n      Object(flds.map { case (k, v) => (k, fromDynamicValue(v)) })\n    case DynamicValue.Variant(caseName, v) =>\n      Object(Vector(\"_type\" -> String(caseName), \"_value\" -> fromDynamicValue(v)))\n    case DynamicValue.Sequence(elems) =>\n      Array(elems.map(fromDynamicValue))\n    case DynamicValue.Map(entries) =>\n      Array(entries.map { case (k, v) =>\n        Object(Vector(\"key\" -> fromDynamicValue(k), \"value\" -> fromDynamicValue(v)))\n      })\n  }\n\n  private def fromPrimitiveValue(pv: PrimitiveValue): Json = pv match {\n    case PrimitiveValue.Unit              => Null\n    case PrimitiveValue.Boolean(v)        => Boolean(v)\n    case PrimitiveValue.Byte(v)           => number(v)\n    case PrimitiveValue.Short(v)          => number(v)\n    case PrimitiveValue.Int(v)            => number(v)\n    case PrimitiveValue.Long(v)           => number(v)\n    case PrimitiveValue.Float(v)          => number(v)\n    case PrimitiveValue.Double(v)         => number(v)\n    case PrimitiveValue.Char(v)           => String(v.toString)\n    case PrimitiveValue.String(v)         => String(v)\n    case PrimitiveValue.BigInt(v)         => number(v)\n    case PrimitiveValue.BigDecimal(v)     => number(v)\n    case PrimitiveValue.DayOfWeek(v)      => String(v.toString)\n    case PrimitiveValue.Duration(v)       => String(v.toString)\n    case PrimitiveValue.Instant(v)        => String(v.toString)\n    case PrimitiveValue.LocalDate(v)      => String(v.toString)\n    case PrimitiveValue.LocalDateTime(v)  => String(v.toString)\n    case PrimitiveValue.LocalTime(v)      => String(v.toString)\n    case PrimitiveValue.Month(v)          => String(v.toString)\n    case PrimitiveValue.MonthDay(v)       => String(v.toString)\n    case PrimitiveValue.OffsetDateTime(v) => String(v.toString)\n    case PrimitiveValue.OffsetTime(v)     => String(v.toString)\n    case PrimitiveValue.Period(v)         => String(v.toString)\n    case PrimitiveValue.Year(v)           => String(v.toString)\n    case PrimitiveValue.YearMonth(v)      => String(v.toString)\n    case PrimitiveValue.ZoneId(v)         => String(v.getId)\n    case PrimitiveValue.ZoneOffset(v)     => String(v.toString)\n    case PrimitiveValue.ZonedDateTime(v)  => String(v.toString)\n    case PrimitiveValue.Currency(v)       => String(v.getCurrencyCode)\n    case PrimitiveValue.UUID(v)           => String(v.toString)\n  }\n\n  // ===========================================================================\n  // KV Interop\n  // ===========================================================================\n\n  /**\n   * Assembles JSON from a sequence of path-value pairs.\n   *\n   * {{{\n   * Json.fromKV(Seq(\n   *   p\"a.b\" -> Json.number(1),\n   *   p\"a.c\" -> Json.String(\"x\"),\n   *   p\"d[0]\" -> Json.Boolean(true)\n   * ))\n   * // {\"a\": {\"b\": 1, \"c\": \"x\"}, \"d\": [true]}\n   * }}}\n   *\n   * @param kvs The path-value pairs\n   * @return Either an error (for conflicting paths) or the assembled JSON\n   */\n  def fromKV(kvs: Seq[(DynamicOptic, Json)]): Either[JsonError, Json] = ???\n\n  /**\n   * Assembles JSON from path-value pairs, throwing on conflict.\n   */\n  def fromKVUnsafe(kvs: Seq[(DynamicOptic, Json)]): Json = fromKV(kvs).fold(throw _, identity)\n\n  // ===========================================================================\n  // Patch Interop\n  // ===========================================================================\n\n  /**\n   * Serializes a [[JsonPatch]] to its JSON representation.\n   *\n   * The format follows RFC 6902 (JSON Patch) for standard operations,\n   * with extensions for LCS-based sequence diffs.\n   *\n   * @param patch The patch to serialize\n   * @return The JSON representation of the patch\n   */\n  def fromJsonPatch(patch: JsonPatch): Json = ???\n\n  /**\n   * Deserializes a JSON representation into a [[JsonPatch]].\n   *\n   * @param json The JSON patch representation\n   * @return Either an error or the parsed patch\n   */\n  def toJsonPatch(json: Json): Either[JsonError, JsonPatch] = ???\n\n  // ===========================================================================\n  // Ordering\n  // ===========================================================================\n\n  /**\n   * Ordering for JSON values.\n   *\n   * Order: Null < Boolean < Number < String < Array < Object\n   */\n  implicit val ordering: Ordering[Json] = (x: Json, y: Json) => x.compare(y)\n}\n\n// =============================================================================\n// MERGE STRATEGY\n// =============================================================================\n\n/**\n * Strategy for merging JSON values.\n */\nsealed trait MergeStrategy\n\nobject MergeStrategy {\n\n  /**\n   * Automatically determines merge behavior based on value types:\n   *  - Objects: deep merge (recurse into matching keys)\n   *  - Arrays: concatenate\n   *  - Primitives: right wins\n   */\n  case object Auto extends MergeStrategy\n\n  /**\n   * Deep merge for objects; concatenate arrays.\n   */\n  case object Deep extends MergeStrategy\n\n  /**\n   * Shallow merge: right value wins for any key conflict.\n   */\n  case object Shallow extends MergeStrategy\n\n  /**\n   * Concatenate arrays; for objects and primitives, right wins.\n   */\n  case object Concat extends MergeStrategy\n\n  /**\n   * Right value always wins (replacement).\n   */\n  case object Replace extends MergeStrategy\n\n  /**\n   * Custom merge function.\n   *\n   * @param f A function receiving path and both values, returning merged result\n   */\n  final case class Custom(f: (DynamicOptic, Json, Json) => Json) extends MergeStrategy\n}\n\n// =============================================================================\n// STRING INTERPOLATORS\n// =============================================================================\n\n/**\n * Provides string interpolators for JSON paths and literals.\n *\n * Import with:\n * {{{\n * import zio.blocks.schema.json.interpolators._\n * }}}\n *\n * ==Path Syntax==\n *\n * The `p` interpolator creates [[DynamicOptic]] paths using a JSONPath-compatible dialect:\n *\n * {{{\n * p\"foo.bar\"           // fields \"foo\" then \"bar\"\n * p\"users[0]\"          // field \"users\", then index 0\n * p\"users[0].name\"     // field \"users\", index 0, field \"name\"\n * p\"items[*]\"          // field \"items\", then all array elements\n * p\"config{*}\"         // field \"config\", then all object values\n * p\"config{*:}\"        // field \"config\", then all object keys\n * p\"[0,2,5]\"           // indices 0, 2, and 5\n * p\"[0:5]\"             // slice: indices 0 through 4\n * p\"[::2]\"             // slice: every other element\n * p\"`field.name`\"      // field with dots in name (backtick escaping)\n * p\"\"\"[\"field\"]\"\"\"     // alternate field syntax (bracket notation)\n * }}}\n *\n * ===JSONPath Compatibility===\n *\n * This syntax is a dialect of JSONPath (RFC 9535). Most JSONPath expressions work:\n *  - `$.foo.bar` - root prefix is optional and ignored\n *  - `.field`, `[\"field\"]` - field access\n *  - `[n]`, `[*]`, `[m,n]`, `[m:n]` - array access\n *\n * '''Not supported:'''\n *  - `..` (recursive descent)\n *  - `[?()]` (filter expressions)\n *\n * ===Extensions beyond JSONPath:===\n *  - `{*}` - all object values (explicit, vs `[*]` which is array-focused in JSONPath)\n *  - `{*:}` - all object keys (not expressible in standard JSONPath)\n *  - Backtick escaping for field names\n */\nobject interpolators {\n\n  implicit class JsonPathInterpolator(val sc: StringContext) extends AnyVal {\n\n    /**\n     * Creates a [[DynamicOptic]] from a path string at compile time.\n     *\n     * @return The parsed [[DynamicOptic]]\n     */\n    def p(args: Any*): DynamicOptic = macro PathMacros.pathInterpolator\n  }\n\n  implicit class JsonLiteralInterpolator(val sc: StringContext) extends AnyVal {\n\n    /**\n     * Creates a [[Json]] value from a JSON literal at compile time.\n     *\n     * {{{\n     * j\"\"\"{\"name\": \"Alice\", \"age\": 30}\"\"\"\n     * j\"[1, 2, 3]\"\n     * j\"null\"\n     * }}}\n     *\n     * Interpolated values are converted to JSON:\n     * {{{\n     * val name = \"Bob\"\n     * val age = 25\n     * j\"\"\"{\"name\": $name, \"age\": $age}\"\"\"\n     * }}}\n     *\n     * @return The parsed [[Json]] value\n     */\n    def j(args: Any*): Json = macro PathMacros.jsonInterpolator\n  }\n}\n\n/**\n * Macro implementations for string interpolators.\n * \n * Separate implementations would be needed for Scala 2 and Scala 3.\n */\nobject PathMacros {\n  import scala.reflect.macros.blackbox\n\n  def pathInterpolator(c: blackbox.Context)(args: c.Expr[Any]*): c.Expr[DynamicOptic] = ???\n\n  def jsonInterpolator(c: blackbox.Context)(args: c.Expr[Any]*): c.Expr[Json] = ???\n}\n\n// =============================================================================\n// PLACEHOLDER TYPES (assumed to exist)\n// =============================================================================\n\n/**\n * Represents a JSON Schema for validation.\n *\n * Placeholder - actual implementation TBD.\n */\nsealed trait JsonSchema\n\nobject JsonSchema {\n  // Placeholder\n}\n\n/**\n * Represents a patch that can be applied to JSON values.\n *\n * Supports RFC 6902 operations (add, remove, replace, move, copy, test)\n * plus extensions for LCS-based sequence diffs and string diffs.\n *\n * Placeholder - actual implementation TBD.\n */\nsealed trait JsonPatch {\n\n  /**\n   * Converts this JSON patch to a [[DynamicPatch]].\n   */\n  def toDynamicPatch: DynamicPatch\n}\n\nobject JsonPatch {\n\n  /**\n   * Creates an empty patch (no operations).\n   */\n  val empty: JsonPatch = ???\n\n  /**\n   * Creates a patch from a [[DynamicPatch]].\n   *\n   * May fail if the DynamicPatch contains operations not representable in JSON.\n   */\n  def fromDynamicPatch(patch: DynamicPatch): Either[JsonError, JsonPatch] = ???\n}\n\n/**\n * Represents a patch that can be applied to [[DynamicValue]].\n *\n * Placeholder - actual implementation TBD.\n */\nsealed trait DynamicPatch\n\nobject DynamicPatch {\n\n  /**\n   * Creates an empty patch (no operations).\n   */\n  val empty: DynamicPatch = ???\n}\n```",
                  "html_url": "https://github.com/zio/zio-blocks/issues/679"
                },
                "type": "github"
              },
              "hash": "zio/zio-blocks#679",
              "body": "The following is a sketch of what a proper `Json` data type should look like, including constructors, methods, and related types. Note that `DynamicPatch`, `JsonPatch`, and `JsonSchema` are all out-of-scope for this ticket.\n\n## Sketch\n\n```scala\npackage zio.blocks.schema.json\n\nimport zio.blocks.chunk.Chunk\nimport zio.blocks.schema.{DynamicOptic, DynamicValue, PrimitiveValue, Schema, SchemaError}\n\nimport java.io.{Reader, Writer}\nimport java.nio.ByteBuffer\nimport scala.util.control.NoStackTrace\n\n// =============================================================================\n// JSON ERROR\n// =============================================================================\n\n/**\n * Represents an error that occurred during JSON parsing, encoding, or processing.\n *\n * NOTE: This should replace JsonBinaryCodecError and be moved to `zio.block.schema.json`.\n *\n * @param message A human-readable description of the error\n * @param path The location in the JSON structure where the error occurred,\n *             represented as a [[DynamicOptic]]\n * @param offset Optional byte offset in the input where the error occurred\n * @param line Optional 1-indexed line number where the error occurred\n * @param column Optional 1-indexed column number where the error occurred\n */\nfinal case class JsonError(\n  message: String,\n  path: DynamicOptic,\n  offset: Option[Long],\n  line: Option[Int],\n  column: Option[Int]\n) extends Exception with NoStackTrace {\n\n  override def getMessage: String = {\n    val posInfo = (line, column) match {\n      case (Some(l), Some(c)) => s\" at line $l, column $c\"\n      case _                  => offset.map(o => s\" at offset $o\").getOrElse(\"\")\n    }\n    val pathInfo = if (path.nodes.isEmpty) \"\" else s\" at path $path\"\n    s\"$message$pathInfo$posInfo\"\n  }\n\n  /**\n   * Combines this error with another, preserving both error messages.\n   */\n  def ++(other: JsonError): JsonError =\n    JsonError(s\"${this.message}; ${other.message}\", this.path, this.offset, this.line, this.column)\n}\n\nobject JsonError {\n\n  /**\n   * Creates a JsonError with only a message, using root path and no position info.\n   */\n  def apply(message: String): JsonError =\n    JsonError(message, DynamicOptic.root, None, None, None)\n\n  /**\n   * Creates a JsonError with a message and path, no position info.\n   */\n  def apply(message: String, path: DynamicOptic): JsonError =\n    JsonError(message, path, None, None, None)\n\n  /**\n   * Converts a [[SchemaError]] to a [[JsonError]].\n   */\n  def fromSchemaError(error: SchemaError): JsonError =\n    JsonError(error.message, DynamicOptic.root, None, None, None)\n}\n\n// =============================================================================\n// JSON DECODER / ENCODER (implicit priority resolution)\n// =============================================================================\n\n/**\n * Type class for decoding [[Json]] values into Scala types.\n *\n * Implicit resolution prefers explicitly provided [[JsonBinaryCodec]] instances\n * over schema-derived instances, allowing users to override derived behavior.\n */\nsealed trait JsonDecoder[A] {\n\n  /**\n   * Decodes a [[Json]] value into type `A`.\n   *\n   * @param json The JSON value to decode\n   * @return Either a [[JsonError]] on failure, or the decoded value\n   */\n  def decode(json: Json): Either[JsonError, A]\n}\n\nobject JsonDecoder extends JsonDecoderLowPriority {\n\n  def apply[A](implicit decoder: JsonDecoder[A]): JsonDecoder[A] = decoder\n\n  /**\n   * Higher priority: use an explicitly provided [[JsonBinaryCodec]].\n   */\n  implicit def fromCodec[A](implicit codec: JsonBinaryCodec[A]): JsonDecoder[A] =\n    new JsonDecoder[A] {\n      def decode(json: Json): Either[JsonError, A] = json.decodeWith(codec)\n    }\n}\n\n/**\n * Lower priority implicits for [[JsonDecoder]].\n */\ntrait JsonDecoderLowPriority {\n\n  /**\n   * Lower priority: derive a codec from an implicit [[Schema]].\n   */\n  implicit def fromSchema[A](implicit schema: Schema[A]): JsonDecoder[A] =\n    new JsonDecoder[A] {\n      private lazy val codec: JsonBinaryCodec[A] = schema.derive(JsonBinaryCodecDeriver)\n      def decode(json: Json): Either[JsonError, A] = json.decodeWith(codec)\n    }\n}\n\n/**\n * Type class for encoding Scala types into [[Json]] values.\n *\n * Implicit resolution prefers explicitly provided [[JsonBinaryCodec]] instances\n * over schema-derived instances, allowing users to override derived behavior.\n */\nsealed trait JsonEncoder[A] {\n\n  /**\n   * Encodes a value of type `A` into [[Json]].\n   *\n   * @param value The value to encode\n   * @return The encoded JSON value\n   */\n  def encode(value: A): Json\n}\n\nobject JsonEncoder extends JsonEncoderLowPriority {\n\n  def apply[A](implicit encoder: JsonEncoder[A]): JsonEncoder[A] = encoder\n\n  /**\n   * Higher priority: use an explicitly provided [[JsonBinaryCodec]].\n   */\n  implicit def fromCodec[A](implicit codec: JsonBinaryCodec[A]): JsonEncoder[A] =\n    new JsonEncoder[A] {\n      def encode(value: A): Json = Json.encodeWith(value, codec)\n    }\n}\n\n/**\n * Lower priority implicits for [[JsonEncoder]].\n */\ntrait JsonEncoderLowPriority {\n\n  /**\n   * Lower priority: derive a codec from an implicit [[Schema]].\n   */\n  implicit def fromSchema[A](implicit schema: Schema[A]): JsonEncoder[A] =\n    new JsonEncoder[A] {\n      private lazy val codec: JsonBinaryCodec[A] = schema.derive(JsonBinaryCodecDeriver)\n      def encode(value: A): Json = Json.encodeWith(value, codec)\n    }\n}\n\n// =============================================================================\n// JSON SELECTION\n// =============================================================================\n\n/**\n * Represents a selection of zero or more JSON values, with accumulated errors.\n *\n * `JsonSelection` enables fluent chaining of operations that may fail without\n * requiring immediate error handling. Operations are applied to all values in\n * the selection, and errors are accumulated.\n *\n * {{{\n * val selection: JsonSelection = json.get(p\"users[*].name\")\n * val result: Either[SchemaError, Vector[Json]] = selection.toEither\n * }}}\n */\nfinal case class JsonSelection(toEither: Either[SchemaError, Vector[Json]]) { self =>\n\n  /**\n   * Returns true if this selection contains no values (either empty or errored).\n   */\n  def isEmpty: Boolean = toEither.fold(_ => true, _.isEmpty)\n\n  /**\n   * Returns true if this selection contains at least one value.\n   */\n  def nonEmpty: Boolean = toEither.fold(_ => false, _.nonEmpty)\n\n  /**\n   * Returns the number of values in this selection, or 0 if errored.\n   */\n  def size: Int = toEither.fold(_ => 0, _.size)\n\n  // ---------------------------------------------------------------------------\n  // Transformations\n  // ---------------------------------------------------------------------------\n\n  /**\n   * Applies a function to each JSON value in this selection.\n   *\n   * @param f The transformation function\n   * @return A new selection with transformed values\n   */\n  def map(f: Json => Json): JsonSelection =\n    JsonSelection(toEither.map(_.map(f)))\n\n  /**\n   * Applies a function returning a selection to each value, flattening results.\n   *\n   * @param f The function producing selections\n   * @return A new selection with all results combined\n   */\n  def flatMap(f: Json => JsonSelection): JsonSelection =\n    JsonSelection(toEither.flatMap { jsons =>\n      jsons.foldLeft[Either[SchemaError, Vector[Json]]](Right(Vector.empty)) { (acc, json) =>\n        for {\n          existing <- acc\n          next     <- f(json).toEither\n        } yield existing ++ next\n      }\n    })\n\n  /**\n   * Filters values in this selection by a predicate.\n   *\n   * @param p The predicate to test values\n   * @return A new selection containing only values satisfying the predicate\n   */\n  def filter(p: Json => Boolean): JsonSelection =\n    JsonSelection(toEither.map(_.filter(p)))\n\n  /**\n   * Collects values for which the partial function is defined.\n   *\n   * @param pf A partial function to apply\n   * @return A new selection with collected results\n   */\n  def collect(pf: PartialFunction[Json, Json]): JsonSelection =\n    JsonSelection(toEither.map(_.collect(pf)))\n\n  // ---------------------------------------------------------------------------\n  // Navigation\n  // ---------------------------------------------------------------------------\n\n  /**\n   * Navigates to values at the given path within each selected value.\n   *\n   * @param path The path to navigate\n   * @return A new selection with values at the path\n   */\n  def get(path: DynamicOptic): JsonSelection =\n    flatMap(json => json.get(path))\n\n  /**\n   * Alias for [[get]].\n   */\n  def apply(path: DynamicOptic): JsonSelection = get(path)\n\n  /**\n   * Navigates to array element at given index within each selected value.\n   *\n   * @param index The array index\n   * @return A new selection with elements at the index\n   */\n  def apply(index: Int): JsonSelection =\n    flatMap(json => json.apply(index))\n\n  /**\n   * Navigates to object field with given key within each selected value.\n   *\n   * @param key The object key\n   * @return A new selection with values at the key\n   */\n  def apply(key: String): JsonSelection =\n    flatMap(json => json.apply(key))\n\n  // ---------------------------------------------------------------------------\n  // Type Filtering\n  // ---------------------------------------------------------------------------\n\n  /**\n   * Filters to only JSON objects.\n   */\n  def objects: JsonSelection = filter(_.isObject)\n\n  /**\n   * Filters to only JSON arrays.\n   */\n  def arrays: JsonSelection = filter(_.isArray)\n\n  /**\n   * Filters to only JSON strings.\n   */\n  def strings: JsonSelection = filter(_.isString)\n\n  /**\n   * Filters to only JSON numbers.\n   */\n  def numbers: JsonSelection = filter(_.isNumber)\n\n  /**\n   * Filters to only JSON booleans.\n   */\n  def booleans: JsonSelection = filter(_.isBoolean)\n\n  /**\n   * Filters to only JSON nulls.\n   */\n  def nulls: JsonSelection = filter(_.isNull)\n\n  // ---------------------------------------------------------------------------\n  // Combination\n  // ---------------------------------------------------------------------------\n\n  /**\n   * Combines this selection with another, concatenating values or errors.\n   *\n   * @param other The other selection\n   * @return A combined selection\n   */\n  def ++(other: JsonSelection): JsonSelection =\n    (toEither, other.toEither) match {\n      case (Right(a), Right(b)) => JsonSelection(Right(a ++ b))\n      case (Left(a), Left(b))   => JsonSelection(Left(a ++ b))\n      case (Left(a), _)         => JsonSelection(Left(a))\n      case (_, Left(b))         => JsonSelection(Left(b))\n    }\n\n  // ---------------------------------------------------------------------------\n  // Terminal Operations\n  // ---------------------------------------------------------------------------\n\n  /**\n   * Returns the single value if exactly one, an array of values if there are many, or \n   * otherwise an error.\n   */\n  def one: Either[SchemaError, Json] =\n    toEither.flatMap { jsons =>\n      if (jsons.size == 1) Right(jsons.head)\n      else if (jsons.size > 1) toArray\n      else Left(SchemaError.expectationMismatch(Nil, s\"expected exactly one value, got ${jsons.size}\"))\n    }\n\n  /**\n   * Returns the first value if any, otherwise an error.\n   */\n  def first: Either[SchemaError, Json] =\n    toEither.flatMap { jsons =>\n      jsons.headOption.toRight(SchemaError.expectationMismatch(Nil, \"expected at least one value, got none\"))\n    }\n\n  /**\n   * Returns all values as a [[Json.Array]], or an error.\n   */\n  def toArray: Either[SchemaError, Json] =\n    toEither.map(jsons => Json.Array(jsons))\n\n  /**\n   * Unsafe version of [[one]], throws on error or wrong count.\n   */\n  def oneUnsafe: Json = one.fold(e => throw JsonError.fromSchemaError(e), identity)\n\n  /**\n   * Unsafe version of [[first]], throws on error or empty.\n   */\n  def firstUnsafe: Json = first.fold(e => throw JsonError.fromSchemaError(e), identity)\n}\n\nobject JsonSelection {\n\n  /**\n   * Creates a selection containing a single value.\n   */\n  def apply(json: Json): JsonSelection = JsonSelection(Right(Vector(json)))\n\n  /**\n   * Creates a selection containing multiple values.\n   */\n  def fromVector(jsons: Vector[Json]): JsonSelection = JsonSelection(Right(jsons))\n\n  /**\n   * Creates an empty selection (no values, no error).\n   */\n  val empty: JsonSelection = JsonSelection(Right(Vector.empty))\n\n  /**\n   * Creates a failed selection with the given error.\n   */\n  def fail(error: SchemaError): JsonSelection = JsonSelection(Left(error))\n\n  /**\n   * Creates a failed selection with the given message.\n   */\n  def fail(message: String): JsonSelection =\n    JsonSelection(Left(SchemaError.expectationMismatch(Nil, message)))\n}\n\n// =============================================================================\n// JSON ADT\n// =============================================================================\n\n/**\n * Represents a JSON value.\n *\n * The JSON data model consists of:\n *  - '''Objects''': Unordered collections of key-value pairs\n *  - '''Arrays''': Ordered sequences of values\n *  - '''Strings''': Unicode text\n *  - '''Numbers''': Numeric values (stored as strings for precision)\n *  - '''Booleans''': `true` or `false`\n *  - '''Null''': The null value\n *\n * ==Construction==\n * {{{\n * val obj = Json.Object(\"name\" -> Json.String(\"Alice\"), \"age\" -> Json.number(30))\n * val arr = Json.Array(Json.String(\"a\"), Json.String(\"b\"))\n * val str = Json.String(\"hello\")\n * val num = Json.number(42)\n * val bool = Json.Boolean(true)\n * val nul = Json.Null\n * }}}\n *\n * ==Navigation==\n * {{{\n * json.get(p\"users[0].name\")   // JsonSelection\n * json(\"users\")(0)(\"name\")     // JsonSelection\n * json.fields                  // for objects\n * json.elements                // for arrays\n * }}}\n *\n * ==Pattern Matching==\n * {{{\n * json match {\n *   case Json.Object(fields) => ...\n *   case Json.Array(elements) => ...\n *   case Json.String(value) => ...\n *   case Json.Number(value) => ...\n *   case Json.Boolean(value) => ...\n *   case Json.Null => ...\n * }\n * }}}\n */\nsealed trait Json { self =>\n\n  // ===========================================================================\n  // Type Testing\n  // ===========================================================================\n\n  /**\n   * Returns `true` if this is a JSON object.\n   */\n  def isObject: Boolean = false\n\n  /**\n   * Returns `true` if this is a JSON array.\n   */\n  def isArray: Boolean = false\n\n  /**\n   * Returns `true` if this is a JSON string.\n   */\n  def isString: Boolean = false\n\n  /**\n   * Returns `true` if this is a JSON number.\n   */\n  def isNumber: Boolean = false\n\n  /**\n   * Returns `true` if this is a JSON boolean.\n   */\n  def isBoolean: Boolean = false\n\n  /**\n   * Returns `true` if this is JSON null.\n   */\n  def isNull: Boolean = false\n\n  // ===========================================================================\n  // Type Filtering (returns JsonSelection)\n  // ===========================================================================\n\n  /**\n   * Returns a [[JsonSelection]] containing this value if it is an object,\n   * otherwise an empty selection.\n   */\n  def asObject: JsonSelection = if (isObject) JsonSelection(self) else JsonSelection.empty\n\n  /**\n   * Returns a [[JsonSelection]] containing this value if it is an array,\n   * otherwise an empty selection.\n   */\n  def asArray: JsonSelection = if (isArray) JsonSelection(self) else JsonSelection.empty\n\n  /**\n   * Returns a [[JsonSelection]] containing this value if it is a string,\n   * otherwise an empty selection.\n   */\n  def asString: JsonSelection = if (isString) JsonSelection(self) else JsonSelection.empty\n\n  /**\n   * Returns a [[JsonSelection]] containing this value if it is a number,\n   * otherwise an empty selection.\n   */\n  def asNumber: JsonSelection = if (isNumber) JsonSelection(self) else JsonSelection.empty\n\n  /**\n   * Returns a [[JsonSelection]] containing this value if it is a boolean,\n   * otherwise an empty selection.\n   */\n  def asBoolean: JsonSelection = if (isBoolean) JsonSelection(self) else JsonSelection.empty\n\n  /**\n   * Returns a [[JsonSelection]] containing this value if it is null,\n   * otherwise an empty selection.\n   */\n  def asNull: JsonSelection = if (isNull) JsonSelection(self) else JsonSelection.empty\n\n  // ===========================================================================\n  // Direct Accessors\n  // ===========================================================================\n\n  /**\n   * If this is an object, returns its fields as key-value pairs.\n   * Otherwise returns an empty sequence.\n   */\n  def fields: Seq[(String, Json)] = Seq.empty\n\n  /**\n   * If this is an array, returns its elements.\n   * Otherwise returns an empty sequence.\n   */\n  def elements: Seq[Json] = Seq.empty\n\n  /**\n   * If this is a string, returns its value.\n   * Otherwise returns `None`.\n   */\n  def stringValue: Option[String] = None\n\n  /**\n   * If this is a number, returns its string representation.\n   * Otherwise returns `None`.\n   */\n  def numberValue: Option[String] = None\n\n  /**\n   * If this is a boolean, returns its value.\n   * Otherwise returns `None`.\n   */\n  def booleanValue: Option[scala.Boolean] = None\n\n  // ===========================================================================\n  // Navigation\n  // ===========================================================================\n\n  /**\n   * Navigates to values at the given path.\n   *\n   * {{{\n   * json.get(p\"users[0].name\")\n   * json.get(DynamicOptic.root.field(\"users\").at(0).field(\"name\"))\n   * }}}\n   *\n   * @param path The path to navigate\n   * @return A [[JsonSelection]] containing values at the path\n   */\n  def get(path: DynamicOptic): JsonSelection = ???\n\n  /**\n   * Alias for [[get]].\n   */\n  def apply(path: DynamicOptic): JsonSelection = get(path)\n\n  /**\n   * If this is an array, returns a selection containing the element at the given index.\n   * Returns an empty selection if not an array or index is out of bounds.\n   *\n   * @param index The array index (0-based)\n   */\n  def apply(index: Int): JsonSelection = self match {\n    case Json.Array(elems) if index >= 0 && index < elems.size =>\n      JsonSelection(elems(index))\n    case _ =>\n      JsonSelection.empty\n  }\n\n  /**\n   * If this is an object, returns a selection containing the value at the given key.\n   * Returns an empty selection if not an object or key is not present.\n   *\n   * @param key The object key\n   */\n  def apply(key: String): JsonSelection = self match {\n    case Json.Object(flds) =>\n      flds.collectFirst { case (k, v) if k == key => v } match {\n        case Some(v) => JsonSelection(v)\n        case None    => JsonSelection.empty\n      }\n    case _ =>\n      JsonSelection.empty\n  }\n\n  // ===========================================================================\n  // Modification (Json => Json)\n  // ===========================================================================\n\n  /**\n   * Modifies values at the given path using the provided function.\n   *\n   * If the path does not exist, returns this JSON unchanged.\n   *\n   * {{{\n   * json.modify(p\"users[*].age\", {\n   *   case Json.Number(n) => Json.number(n.toInt + 1)\n   *   case other => other\n   * })\n   * }}}\n   *\n   * @param path The path to values to modify\n   * @param f The modification function\n   * @return The modified JSON\n   */\n  def modify(path: DynamicOptic, f: Json => Json): Json = ???\n\n  /**\n   * Modifies values at the given path using a partial function.\n   *\n   * Values for which the partial function is not defined are left unchanged.\n   *\n   * @param path The path to values to modify\n   * @param pf The partial modification function\n   * @return Either an error if the path is invalid, or the modified JSON\n   */\n  def modifyOrFail(path: DynamicOptic, pf: PartialFunction[Json, Json]): Either[JsonError, Json] = ???\n\n  /**\n   * Sets the value at the given path.\n   *\n   * If the path does not exist, attempts to create intermediate structure.\n   * For array indices, the array must already exist and have sufficient length.\n   *\n   * {{{\n   * json.set(p\"user.name\", Json.String(\"Bob\"))\n   * }}}\n   *\n   * @param path The path to set\n   * @param value The value to set\n   * @return The modified JSON\n   */\n  def set(path: DynamicOptic, value: Json): Json = ???\n\n  /**\n   * Sets the value at the given path, returning an error if the path is invalid.\n   *\n   * @param path The path to set\n   * @param value The value to set\n   * @return Either an error or the modified JSON\n   */\n  def setOrFail(path: DynamicOptic, value: Json): Either[JsonError, Json] = ???\n\n  /**\n   * Deletes values at the given path.\n   *\n   * For object fields, removes the key-value pair.\n   * For array elements, removes the element and shifts subsequent elements.\n   *\n   * @param path The path to delete\n   * @return The modified JSON\n   */\n  def delete(path: DynamicOptic): Json = ???\n\n  /**\n   * Deletes values at the given path, returning an error if the path is invalid.\n   *\n   * @param path The path to delete\n   * @return Either an error or the modified JSON\n   */\n  def deleteOrFail(path: DynamicOptic): Either[JsonError, Json] = ???\n\n  /**\n   * Inserts a value at the given path.\n   *\n   * For arrays, inserts at the specified index, shifting subsequent elements.\n   * For objects, adds or replaces the key.\n   *\n   * @param path The path where to insert\n   * @param value The value to insert\n   * @return The modified JSON\n   */\n  def insert(path: DynamicOptic, value: Json): Json = ???\n\n  /**\n   * Inserts a value at the given path, returning an error if invalid.\n   *\n   * @param path The path where to insert\n   * @param value The value to insert\n   * @return Either an error or the modified JSON\n   */\n  def insertOrFail(path: DynamicOptic, value: Json): Either[JsonError, Json] = ???\n\n  // ===========================================================================\n  // Merging\n  // ===========================================================================\n\n  /**\n   * Merges this JSON with another using the specified strategy.\n   *\n   * {{{\n   * val merged = json1.merge(json2, MergeStrategy.Deep)\n   * }}}\n   *\n   * @param other The JSON to merge with\n   * @param strategy The merge strategy (default: [[MergeStrategy.Auto]])\n   * @return The merged JSON\n   */\n  def merge(other: Json, strategy: MergeStrategy = MergeStrategy.Auto): Json = ???\n\n  // ===========================================================================\n  // Patching\n  // ===========================================================================\n\n  /**\n   * Applies a [[JsonPatch]] to this JSON.\n   *\n   * @param patch The patch to apply\n   * @return Either an error if the patch cannot be applied, or the patched JSON\n   */\n  def patch(patch: JsonPatch): Either[JsonError, Json] = ???\n\n  /**\n   * Applies a [[JsonPatch]], throwing on failure.\n   *\n   * @param patch The patch to apply\n   * @return The patched JSON\n   * @throws JsonError if the patch cannot be applied\n   */\n  def patchUnsafe(patch: JsonPatch): Json = this.patch(patch).fold(throw _, identity)\n\n  // ===========================================================================\n  // Transformation\n  // ===========================================================================\n\n  /**\n   * Transforms all values in this JSON bottom-up (children before parents).\n   *\n   * @param f The transformation function receiving path and value\n   * @return The transformed JSON\n   */\n  def transformUp(f: (DynamicOptic, Json) => Json): Json = ???\n\n  /**\n   * Transforms all values in this JSON top-down (parents before children).\n   *\n   * @param f The transformation function receiving path and value\n   * @return The transformed JSON\n   */\n  def transformDown(f: (DynamicOptic, Json) => Json): Json = ???\n\n  /**\n   * Transforms all object keys in this JSON.\n   *\n   * @param f The key transformation function receiving path and key\n   * @return The transformed JSON\n   */\n  def transformKeys(f: (DynamicOptic, String) => String): Json = ???\n\n  // ===========================================================================\n  // Filtering\n  // ===========================================================================\n\n  /**\n   * Removes entries matching the predicate.\n   *\n   * For objects, removes matching key-value pairs.\n   * For arrays, removes matching elements.\n   *\n   * @param p The predicate receiving path and value\n   * @return The filtered JSON\n   */\n  def filterNot(p: (DynamicOptic, Json) => scala.Boolean): Json = ???\n\n  /**\n   * Keeps only entries matching the predicate.\n   *\n   * @param p The predicate receiving path and value\n   * @return The filtered JSON\n   */\n  def filter(p: (DynamicOptic, Json) => scala.Boolean): Json =\n    filterNot((path, json) => !p(path, json))\n\n  // ===========================================================================\n  // Projection\n  // ===========================================================================\n\n  /**\n   * Projects this JSON to include only the specified paths.\n   *\n   * Paths that don't exist are ignored. Structure is preserved.\n   *\n   * {{{\n   * json.project(p\"user.name\", p\"user.email\", p\"meta.created\")\n   * }}}\n   *\n   * @param paths The paths to include\n   * @return A new JSON containing only the specified paths\n   */\n  def project(paths: DynamicOptic*): Json = ???\n\n  // ===========================================================================\n  // Splitting / Partitioning\n  // ===========================================================================\n\n  /**\n   * Partitions this JSON into two based on a predicate.\n   *\n   * Returns a tuple where the first element contains entries satisfying\n   * the predicate, and the second contains entries that don't.\n   *\n   * @param p The predicate receiving path and value\n   * @return A tuple of (matching, non-matching) JSON values\n   */\n  def partition(p: (DynamicOptic, Json) => scala.Boolean): (Json, Json) = ???\n\n  // ===========================================================================\n  // Normalization\n  // ===========================================================================\n\n  /**\n   * Returns a normalized version of this JSON.\n   *\n   * Normalization includes:\n   *  - Sorting object keys alphabetically\n   *  - Normalizing number representations\n   *\n   * Useful for comparison and hashing.\n   */\n  def normalize: Json = ???\n\n  /**\n   * Returns this JSON with all object keys sorted alphabetically (recursive).\n   */\n  def sortKeys: Json = self match {\n    case Json.Object(flds) =>\n      Json.Object(flds.map { case (k, v) => (k, v.sortKeys) }.sortBy(_._1))\n    case Json.Array(elems) =>\n      Json.Array(elems.map(_.sortKeys))\n    case other =>\n      other\n  }\n\n  /**\n   * Returns this JSON with all null values removed from objects.\n   */\n  def dropNulls: Json = self match {\n    case Json.Object(flds) =>\n      Json.Object(flds.collect { case (k, v) if !v.isNull => (k, v.dropNulls) })\n    case Json.Array(elems) =>\n      Json.Array(elems.map(_.dropNulls))\n    case other =>\n      other\n  }\n\n  /**\n   * Returns this JSON with empty objects and arrays removed.\n   */\n  def dropEmpty: Json = self match {\n    case Json.Object(flds) =>\n      val filtered = flds.collect {\n        case (k, v) =>\n          val dropped = v.dropEmpty\n          dropped match {\n            case Json.Object(f) if f.isEmpty => None\n            case Json.Array(e) if e.isEmpty  => None\n            case other                       => Some((k, other))\n          }\n      }.flatten\n      Json.Object(filtered)\n    case Json.Array(elems) =>\n      val filtered = elems.map(_.dropEmpty).filter {\n        case Json.Object(f) if f.isEmpty => false\n        case Json.Array(e) if e.isEmpty  => false\n        case _                           => true\n      }\n      Json.Array(filtered)\n    case other =>\n      other\n  }\n\n  // ===========================================================================\n  // Diffing\n  // ===========================================================================\n\n  /**\n   * Computes a [[JsonPatch]] that transforms this JSON into the target.\n   *\n   * {{{\n   * val patch = source.diff(target)\n   * source.patch(patch) == Right(target) // true\n   * }}}\n   *\n   * @param target The target JSON\n   * @return A patch that transforms this into target\n   */\n  def diff(target: Json): JsonPatch = ???\n\n  // ===========================================================================\n  // Folding\n  // ===========================================================================\n\n  /**\n   * Folds over this JSON top-down (parents before children).\n   *\n   * @param z The initial accumulator value\n   * @param f The fold function receiving path, value, and accumulator\n   * @tparam B The accumulator type\n   * @return The final accumulated value\n   */\n  def foldDown[B](z: B)(f: (DynamicOptic, Json, B) => B): B = ???\n\n  /**\n   * Folds over this JSON bottom-up (children before parents).\n   *\n   * @param z The initial accumulator value\n   * @param f The fold function receiving path, value, and accumulator\n   * @tparam B The accumulator type\n   * @return The final accumulated value\n   */\n  def foldUp[B](z: B)(f: (DynamicOptic, Json, B) => B): B = ???\n\n  /**\n   * Folds over this JSON top-down, allowing the fold function to fail.\n   *\n   * Short-circuits on first failure.\n   *\n   * @param z The initial accumulator value\n   * @param f The fold function that may fail\n   * @tparam B The accumulator type\n   * @return Either an error or the final accumulated value\n   */\n  def foldDownOrFail[B](z: B)(f: (DynamicOptic, Json, B) => Either[JsonError, B]): Either[JsonError, B] = ???\n\n  /**\n   * Folds over this JSON bottom-up, allowing the fold function to fail.\n   *\n   * Short-circuits on first failure.\n   *\n   * @param z The initial accumulator value\n   * @param f The fold function that may fail\n   * @tparam B The accumulator type\n   * @return Either an error or the final accumulated value\n   */\n  def foldUpOrFail[B](z: B)(f: (DynamicOptic, Json, B) => Either[JsonError, B]): Either[JsonError, B] = ???\n\n  // ===========================================================================\n  // Querying\n  // ===========================================================================\n\n  /**\n   * Selects all values matching the predicate.\n   *\n   * @param p The predicate receiving path and value\n   * @return A [[JsonSelection]] containing matching values\n   */\n  def query(p: (DynamicOptic, Json) => scala.Boolean): JsonSelection = ???\n\n  // ===========================================================================\n  // Validation\n  // ===========================================================================\n\n  /**\n   * Validates this JSON against a [[JsonSchema]].\n   *\n   * @param schema The schema to validate against\n   * @return `None` if valid, `Some(error)` if invalid\n   */\n  def check(schema: JsonSchema): Option[SchemaError] = ???\n\n  /**\n   * Returns `true` if this JSON conforms to the given [[JsonSchema]].\n   */\n  def conforms(schema: JsonSchema): scala.Boolean = check(schema).isEmpty\n\n  // ===========================================================================\n  // KV Representation\n  // ===========================================================================\n\n  /**\n   * Flattens this JSON to a sequence of path-value pairs.\n   *\n   * Only leaf values (primitives, empty arrays, empty objects) are included.\n   *\n   * {{{\n   * Json.parse(\"\"\"{\"a\": {\"b\": 1}, \"c\": [2, 3]}\"\"\").toKV\n   * // Seq(\n   * //   (p\"a.b\", Json.Number(\"1\")),\n   * //   (p\"c[0]\", Json.Number(\"2\")),\n   * //   (p\"c[1]\", Json.Number(\"3\"))\n   * // )\n   * }}}\n   */\n  def toKV: Seq[(DynamicOptic, Json)] = ???\n\n  // ===========================================================================\n  // Comparison\n  // ===========================================================================\n\n  /**\n   * Compares this JSON to another for ordering.\n   *\n   * Ordering is defined as:\n   *  1. Null < Boolean < Number < String < Array < Object\n   *  2. Within types, natural ordering applies\n   */\n  def compare(that: Json): Int = (self, that) match {\n    case (Json.Null, Json.Null)               => 0\n    case (Json.Null, _)                       => -1\n    case (_, Json.Null)                       => 1\n    case (Json.Boolean(a), Json.Boolean(b))   => a.compare(b)\n    case (Json.Boolean(_), _)                 => -1\n    case (_, Json.Boolean(_))                 => 1\n    case (Json.Number(a), Json.Number(b))     => BigDecimal(a).compare(BigDecimal(b))\n    case (Json.Number(_), _)                  => -1\n    case (_, Json.Number(_))                  => 1\n    case (Json.String(a), Json.String(b))     => a.compare(b)\n    case (Json.String(_), _)                  => -1\n    case (_, Json.String(_))                  => 1\n    case (Json.Array(a), Json.Array(b))       => compareArrays(a, b)\n    case (Json.Array(_), _)                   => -1\n    case (_, Json.Array(_))                   => 1\n    case (Json.Object(a), Json.Object(b))     => compareObjects(a, b)\n  }\n\n  private def compareArrays(a: Vector[Json], b: Vector[Json]): Int = {\n    val len = math.min(a.size, b.size)\n    var i   = 0\n    while (i < len) {\n      val cmp = a(i).compare(b(i))\n      if (cmp != 0) return cmp\n      i += 1\n    }\n    a.size.compare(b.size)\n  }\n\n  private def compareObjects(a: Vector[(String, Json)], b: Vector[(String, Json)]): Int = {\n    val aSorted = a.sortBy(_._1)\n    val bSorted = b.sortBy(_._1)\n    val len     = math.min(aSorted.size, bSorted.size)\n    var i       = 0\n    while (i < len) {\n      val (ak, av) = aSorted(i)\n      val (bk, bv) = bSorted(i)\n      val keyCmp   = ak.compare(bk)\n      if (keyCmp != 0) return keyCmp\n      val valCmp = av.compare(bv)\n      if (valCmp != 0) return valCmp\n      i += 1\n    }\n    aSorted.size.compare(bSorted.size)\n  }\n\n  // ===========================================================================\n  // DynamicValue Interop\n  // ===========================================================================\n\n  /**\n   * Converts this JSON to a [[DynamicValue]].\n   *\n   * This conversion is lossless; all JSON values can be represented as DynamicValue.\n   */\n  def toDynamicValue: DynamicValue = self match {\n    case Json.Null =>\n      DynamicValue.Primitive(PrimitiveValue.Unit)\n    case Json.Boolean(v) =>\n      DynamicValue.Primitive(PrimitiveValue.Boolean(v))\n    case Json.Number(v) =>\n      // Preserve as BigDecimal for maximum precision\n      DynamicValue.Primitive(PrimitiveValue.BigDecimal(BigDecimal(v)))\n    case Json.String(v) =>\n      DynamicValue.Primitive(PrimitiveValue.String(v))\n    case Json.Array(elems) =>\n      DynamicValue.Sequence(elems.map(_.toDynamicValue))\n    case Json.Object(flds) =>\n      DynamicValue.Record(flds.map { case (k, v) => (k, v.toDynamicValue) })\n  }\n\n  // ===========================================================================\n  // Typed Decoding (Json => A)\n  // ===========================================================================\n\n  /**\n   * Decodes this JSON to a typed value.\n   *\n   * Uses implicit [[JsonDecoder]] which prefers explicit codecs over schema derivation.\n   *\n   * {{{\n   * val person: Either[JsonError, Person] = json.as[Person]\n   * }}}\n   *\n   * @tparam A The target type\n   * @return Either an error or the decoded value\n   */\n  def as[A](implicit decoder: JsonDecoder[A]): Either[JsonError, A] = decoder.decode(self)\n\n  /**\n   * Decodes this JSON to a typed value, throwing on failure.\n   *\n   * @tparam A The target type\n   * @return The decoded value\n   * @throws JsonError if decoding fails\n   */\n  def asUnsafe[A](implicit decoder: JsonDecoder[A]): A = as[A].fold(throw _, identity)\n\n  /**\n   * Internal: decode using an explicit codec.\n   */\n  private[json] def decodeWith[A](codec: JsonBinaryCodec[A]): Either[JsonError, A] = ???\n\n  // ===========================================================================\n  // Encoding (Json => String/Bytes)\n  // ===========================================================================\n\n  /**\n   * Encodes this JSON to a compact string (no extra whitespace).\n   */\n  def print: String = encode(WriterConfig)\n\n  /**\n   * Encodes this JSON to a string using the specified configuration.\n   *\n   * @param config Writer configuration (indentation, unicode escaping, etc.)\n   */\n  def print(config: WriterConfig): String = encode(config)\n\n  /**\n   * Alias for [[print]].\n   */\n  def encode: String = encode(WriterConfig)\n\n  /**\n   * Encodes this JSON to a string using the specified configuration.\n   *\n   * @param config Writer configuration\n   */\n  def encode(config: WriterConfig): String = ???\n\n  /**\n   * Encodes this JSON and writes to the provided [[Writer]].\n   *\n   * @param writer The writer to write to\n   */\n  def printTo(writer: Writer): Unit = printTo(writer, WriterConfig)\n\n  /**\n   * Encodes this JSON and writes to the provided [[Writer]] with configuration.\n   *\n   * @param writer The writer to write to\n   * @param config Writer configuration\n   */\n  def printTo(writer: Writer, config: WriterConfig): Unit = ???\n\n  /**\n   * Encodes this JSON to a byte array (UTF-8).\n   */\n  def encodeToBytes: Array[Byte] = encodeToBytes(WriterConfig)\n\n  /**\n   * Encodes this JSON to a byte array (UTF-8) with configuration.\n   *\n   * @param config Writer configuration\n   */\n  def encodeToBytes(config: WriterConfig): Array[Byte] = ???\n\n  /**\n   * Encodes this JSON to a [[Chunk]] of bytes (UTF-8).\n   */\n  def encodeToChunk: Chunk[Byte] = encodeToChunk(WriterConfig)\n\n  /**\n   * Encodes this JSON to a [[Chunk]] of bytes (UTF-8) with configuration.\n   *\n   * @param config Writer configuration\n   */\n  def encodeToChunk(config: WriterConfig): Chunk[Byte] = ???\n\n  /**\n   * Encodes this JSON into the provided [[ByteBuffer]].\n   *\n   * @param buffer The buffer to write to\n   */\n  def encodeTo(buffer: ByteBuffer): Unit = encodeTo(buffer, WriterConfig)\n\n  /**\n   * Encodes this JSON into the provided [[ByteBuffer]] with configuration.\n   *\n   * @param buffer The buffer to write to\n   * @param config Writer configuration\n   */\n  def encodeTo(buffer: ByteBuffer, config: WriterConfig): Unit = ???\n\n  // ===========================================================================\n  // Standard Methods\n  // ===========================================================================\n\n  override def hashCode(): Int = self match {\n    case Json.Null           => 0\n    case Json.Boolean(v)     => v.hashCode()\n    case Json.Number(v)      => BigDecimal(v).hashCode()\n    case Json.String(v)      => v.hashCode()\n    case Json.Array(elems)   => elems.hashCode()\n    case Json.Object(flds)   => flds.sortBy(_._1).hashCode()\n  }\n\n  override def equals(that: Any): Boolean = that match {\n    case other: Json => compare(other) == 0\n    case _           => false\n  }\n\n  override def toString: String = print\n}\n\nobject Json {\n\n  // ===========================================================================\n  // ADT Cases\n  // ===========================================================================\n\n  /**\n   * A JSON object: an unordered collection of key-value pairs.\n   *\n   * @param fields The key-value pairs. Keys should be unique; if duplicates\n   *               are present, behavior of accessors is undefined.\n   */\n  final case class Object(fields: Vector[(String, Json)]) extends Json {\n    override def isObject: scala.Boolean                = true\n    override def fields: Seq[(String, Json)]            = fields\n  }\n\n  object Object {\n\n    /**\n     * Creates an empty JSON object.\n     */\n    val empty: Object = Object(Vector.empty)\n\n    /**\n     * Creates a JSON object from key-value pairs.\n     */\n    def apply(fields: (String, Json)*): Object = Object(fields.toVector)\n  }\n\n  /**\n   * A JSON array: an ordered sequence of values.\n   *\n   * @param elements The array elements\n   */\n  final case class Array(elements: Vector[Json]) extends Json {\n    override def isArray: scala.Boolean  = true\n    override def elements: Seq[Json]     = elements\n  }\n\n  object Array {\n\n    /**\n     * Creates an empty JSON array.\n     */\n    val empty: Array = Array(Vector.empty)\n\n    /**\n     * Creates a JSON array from elements.\n     */\n    def apply(elements: Json*): Array = Array(elements.toVector)\n  }\n\n  /**\n   * A JSON string.\n   *\n   * @param value The string value (unescaped)\n   */\n  final case class String(value: java.lang.String) extends Json {\n    override def isString: scala.Boolean              = true\n    override def stringValue: Option[java.lang.String] = Some(value)\n  }\n\n  /**\n   * A JSON number.\n   *\n   * Stored as a string to preserve exact representation (precision, trailing zeros, etc.).\n   * Provides lazy conversion to numeric types.\n   *\n   * @param value The number as a string (should be valid JSON number syntax)\n   */\n  final case class Number(value: java.lang.String) extends Json {\n    override def isNumber: scala.Boolean                = true\n    override def numberValue: Option[java.lang.String]  = Some(value)\n\n    /**\n     * Converts to `Int`, truncating if necessary.\n     */\n    lazy val toInt: Int = toBigDecimal.toInt\n\n    /**\n     * Converts to `Long`, truncating if necessary.\n     */\n    lazy val toLong: Long = toBigDecimal.toLong\n\n    /**\n     * Converts to `Float`.\n     */\n    lazy val toFloat: Float = value.toFloat\n\n    /**\n     * Converts to `Double`.\n     */\n    lazy val toDouble: Double = value.toDouble\n\n    /**\n     * Converts to `BigInt`, truncating fractional part.\n     */\n    lazy val toBigInt: BigInt = toBigDecimal.toBigInt\n\n    /**\n     * Converts to `BigDecimal` (lossless).\n     */\n    lazy val toBigDecimal: BigDecimal = BigDecimal(value)\n  }\n\n  /**\n   * A JSON boolean.\n   *\n   * @param value The boolean value\n   */\n  final case class Boolean(value: scala.Boolean) extends Json {\n    override def isBoolean: scala.Boolean              = true\n    override def booleanValue: Option[scala.Boolean]   = Some(value)\n  }\n\n  object Boolean {\n    val True: Boolean  = Boolean(true)\n    val False: Boolean = Boolean(false)\n  }\n\n  /**\n   * The JSON null value.\n   */\n  case object Null extends Json {\n    override def isNull: scala.Boolean = true\n  }\n\n  // ===========================================================================\n  // Convenience Constructors\n  // ===========================================================================\n\n  /**\n   * Creates a JSON number from an `Int`.\n   */\n  def number(n: Int): Number = Number(n.toString)\n\n  /**\n   * Creates a JSON number from a `Long`.\n   */\n  def number(n: Long): Number = Number(n.toString)\n\n  /**\n   * Creates a JSON number from a `Float`.\n   */\n  def number(n: Float): Number = Number(n.toString)\n\n  /**\n   * Creates a JSON number from a `Double`.\n   */\n  def number(n: Double): Number = Number(n.toString)\n\n  /**\n   * Creates a JSON number from a `BigInt`.\n   */\n  def number(n: BigInt): Number = Number(n.toString)\n\n  /**\n   * Creates a JSON number from a `BigDecimal`.\n   */\n  def number(n: BigDecimal): Number = Number(n.toString)\n\n  /**\n   * Creates a JSON number from a `Short`.\n   */\n  def number(n: Short): Number = Number(n.toString)\n\n  /**\n   * Creates a JSON number from a `Byte`.\n   */\n  def number(n: Byte): Number = Number(n.toString)\n\n  // ===========================================================================\n  // Parsing / Decoding (String/Bytes => Json)\n  // ===========================================================================\n\n  /**\n   * Parses a JSON value from a string.\n   *\n   * @param s The JSON string\n   * @return Either a [[JsonError]] or the parsed JSON\n   */\n  def parse(s: java.lang.String): Either[JsonError, Json] = decode(s)\n\n  /**\n   * Parses a JSON value from a `CharSequence`.\n   *\n   * @param s The JSON character sequence\n   * @return Either a [[JsonError]] or the parsed JSON\n   */\n  def parse(s: CharSequence): Either[JsonError, Json] = decode(s)\n\n  /**\n   * Parses a JSON value from a byte array (UTF-8).\n   *\n   * @param bytes The JSON bytes\n   * @return Either a [[JsonError]] or the parsed JSON\n   */\n  def parse(bytes: scala.Array[Byte]): Either[JsonError, Json] = decode(bytes)\n\n  /**\n   * Parses a JSON value from a [[Chunk]] of bytes (UTF-8).\n   *\n   * @param chunk The JSON bytes\n   * @return Either a [[JsonError]] or the parsed JSON\n   */\n  def parse(chunk: Chunk[Byte]): Either[JsonError, Json] = decode(chunk)\n\n  /**\n   * Parses a JSON value from a [[ByteBuffer]] (UTF-8).\n   *\n   * @param buffer The JSON bytes\n   * @return Either a [[JsonError]] or the parsed JSON\n   */\n  def parse(buffer: ByteBuffer): Either[JsonError, Json] = decode(buffer)\n\n  /**\n   * Parses a JSON value from a [[Reader]].\n   *\n   * @param reader The reader to read from\n   * @return Either a [[JsonError]] or the parsed JSON\n   */\n  def parse(reader: Reader): Either[JsonError, Json] = decode(reader)\n\n  /**\n   * Decodes a JSON value from a string.\n   */\n  def decode(s: java.lang.String): Either[JsonError, Json] = ???\n\n  /**\n   * Decodes a JSON value from a `CharSequence`.\n   */\n  def decode(s: CharSequence): Either[JsonError, Json] = ???\n\n  /**\n   * Decodes a JSON value from a byte array (UTF-8).\n   */\n  def decode(bytes: scala.Array[Byte]): Either[JsonError, Json] = ???\n\n  /**\n   * Decodes a JSON value from a [[Chunk]] of bytes (UTF-8).\n   */\n  def decode(chunk: Chunk[Byte]): Either[JsonError, Json] = ???\n\n  /**\n   * Decodes a JSON value from a [[ByteBuffer]] (UTF-8).\n   */\n  def decode(buffer: ByteBuffer): Either[JsonError, Json] = ???\n\n  /**\n   * Decodes a JSON value from a [[Reader]].\n   */\n  def decode(reader: Reader): Either[JsonError, Json] = ???\n\n  /**\n   * Parses a JSON value from a string, throwing on failure.\n   *\n   * @param s The JSON string\n   * @return The parsed JSON\n   * @throws JsonError if parsing fails\n   */\n  def parseUnsafe(s: java.lang.String): Json = decode(s).fold(throw _, identity)\n\n  /**\n   * Alias for [[parseUnsafe]].\n   */\n  def decodeUnsafe(s: java.lang.String): Json = parseUnsafe(s)\n\n  // ===========================================================================\n  // Typed Encoding (A => Json)\n  // ===========================================================================\n\n  /**\n   * Encodes a typed value to JSON.\n   *\n   * Uses implicit [[JsonEncoder]] which prefers explicit codecs over schema derivation.\n   *\n   * {{{\n   * val json = Json.from(Person(\"Alice\", 30))\n   * }}}\n   *\n   * @param value The value to encode\n   * @return The encoded JSON\n   */\n  def from[A](value: A)(implicit encoder: JsonEncoder[A]): Json = encoder.encode(value)\n\n  /**\n   * Internal: encode using an explicit codec.\n   */\n  private[json] def encodeWith[A](value: A, codec: JsonBinaryCodec[A]): Json = ???\n\n  // ===========================================================================\n  // DynamicValue Interop\n  // ===========================================================================\n\n  /**\n   * Converts a [[DynamicValue]] to JSON.\n   *\n   * This conversion is lossy for `DynamicValue` types that have no JSON equivalent:\n   *  - `PrimitiveValue` types like `java.time.*` are converted to strings\n   *  - `DynamicValue.Variant` uses a discriminator field\n   *\n   * @param value The dynamic value to convert\n   * @return The JSON representation\n   */\n  def fromDynamicValue(value: DynamicValue): Json = value match {\n    case DynamicValue.Primitive(pv) => fromPrimitiveValue(pv)\n    case DynamicValue.Record(flds) =>\n      Object(flds.map { case (k, v) => (k, fromDynamicValue(v)) })\n    case DynamicValue.Variant(caseName, v) =>\n      Object(Vector(\"_type\" -> String(caseName), \"_value\" -> fromDynamicValue(v)))\n    case DynamicValue.Sequence(elems) =>\n      Array(elems.map(fromDynamicValue))\n    case DynamicValue.Map(entries) =>\n      Array(entries.map { case (k, v) =>\n        Object(Vector(\"key\" -> fromDynamicValue(k), \"value\" -> fromDynamicValue(v)))\n      })\n  }\n\n  private def fromPrimitiveValue(pv: PrimitiveValue): Json = pv match {\n    case PrimitiveValue.Unit              => Null\n    case PrimitiveValue.Boolean(v)        => Boolean(v)\n    case PrimitiveValue.Byte(v)           => number(v)\n    case PrimitiveValue.Short(v)          => number(v)\n    case PrimitiveValue.Int(v)            => number(v)\n    case PrimitiveValue.Long(v)           => number(v)\n    case PrimitiveValue.Float(v)          => number(v)\n    case PrimitiveValue.Double(v)         => number(v)\n    case PrimitiveValue.Char(v)           => String(v.toString)\n    case PrimitiveValue.String(v)         => String(v)\n    case PrimitiveValue.BigInt(v)         => number(v)\n    case PrimitiveValue.BigDecimal(v)     => number(v)\n    case PrimitiveValue.DayOfWeek(v)      => String(v.toString)\n    case PrimitiveValue.Duration(v)       => String(v.toString)\n    case PrimitiveValue.Instant(v)        => String(v.toString)\n    case PrimitiveValue.LocalDate(v)      => String(v.toString)\n    case PrimitiveValue.LocalDateTime(v)  => String(v.toString)\n    case PrimitiveValue.LocalTime(v)      => String(v.toString)\n    case PrimitiveValue.Month(v)          => String(v.toString)\n    case PrimitiveValue.MonthDay(v)       => String(v.toString)\n    case PrimitiveValue.OffsetDateTime(v) => String(v.toString)\n    case PrimitiveValue.OffsetTime(v)     => String(v.toString)\n    case PrimitiveValue.Period(v)         => String(v.toString)\n    case PrimitiveValue.Year(v)           => String(v.toString)\n    case PrimitiveValue.YearMonth(v)      => String(v.toString)\n    case PrimitiveValue.ZoneId(v)         => String(v.getId)\n    case PrimitiveValue.ZoneOffset(v)     => String(v.toString)\n    case PrimitiveValue.ZonedDateTime(v)  => String(v.toString)\n    case PrimitiveValue.Currency(v)       => String(v.getCurrencyCode)\n    case PrimitiveValue.UUID(v)           => String(v.toString)\n  }\n\n  // ===========================================================================\n  // KV Interop\n  // ===========================================================================\n\n  /**\n   * Assembles JSON from a sequence of path-value pairs.\n   *\n   * {{{\n   * Json.fromKV(Seq(\n   *   p\"a.b\" -> Json.number(1),\n   *   p\"a.c\" -> Json.String(\"x\"),\n   *   p\"d[0]\" -> Json.Boolean(true)\n   * ))\n   * // {\"a\": {\"b\": 1, \"c\": \"x\"}, \"d\": [true]}\n   * }}}\n   *\n   * @param kvs The path-value pairs\n   * @return Either an error (for conflicting paths) or the assembled JSON\n   */\n  def fromKV(kvs: Seq[(DynamicOptic, Json)]): Either[JsonError, Json] = ???\n\n  /**\n   * Assembles JSON from path-value pairs, throwing on conflict.\n   */\n  def fromKVUnsafe(kvs: Seq[(DynamicOptic, Json)]): Json = fromKV(kvs).fold(throw _, identity)\n\n  // ===========================================================================\n  // Patch Interop\n  // ===========================================================================\n\n  /**\n   * Serializes a [[JsonPatch]] to its JSON representation.\n   *\n   * The format follows RFC 6902 (JSON Patch) for standard operations,\n   * with extensions for LCS-based sequence diffs.\n   *\n   * @param patch The patch to serialize\n   * @return The JSON representation of the patch\n   */\n  def fromJsonPatch(patch: JsonPatch): Json = ???\n\n  /**\n   * Deserializes a JSON representation into a [[JsonPatch]].\n   *\n   * @param json The JSON patch representation\n   * @return Either an error or the parsed patch\n   */\n  def toJsonPatch(json: Json): Either[JsonError, JsonPatch] = ???\n\n  // ===========================================================================\n  // Ordering\n  // ===========================================================================\n\n  /**\n   * Ordering for JSON values.\n   *\n   * Order: Null < Boolean < Number < String < Array < Object\n   */\n  implicit val ordering: Ordering[Json] = (x: Json, y: Json) => x.compare(y)\n}\n\n// =============================================================================\n// MERGE STRATEGY\n// =============================================================================\n\n/**\n * Strategy for merging JSON values.\n */\nsealed trait MergeStrategy\n\nobject MergeStrategy {\n\n  /**\n   * Automatically determines merge behavior based on value types:\n   *  - Objects: deep merge (recurse into matching keys)\n   *  - Arrays: concatenate\n   *  - Primitives: right wins\n   */\n  case object Auto extends MergeStrategy\n\n  /**\n   * Deep merge for objects; concatenate arrays.\n   */\n  case object Deep extends MergeStrategy\n\n  /**\n   * Shallow merge: right value wins for any key conflict.\n   */\n  case object Shallow extends MergeStrategy\n\n  /**\n   * Concatenate arrays; for objects and primitives, right wins.\n   */\n  case object Concat extends MergeStrategy\n\n  /**\n   * Right value always wins (replacement).\n   */\n  case object Replace extends MergeStrategy\n\n  /**\n   * Custom merge function.\n   *\n   * @param f A function receiving path and both values, returning merged result\n   */\n  final case class Custom(f: (DynamicOptic, Json, Json) => Json) extends MergeStrategy\n}\n\n// =============================================================================\n// STRING INTERPOLATORS\n// =============================================================================\n\n/**\n * Provides string interpolators for JSON paths and literals.\n *\n * Import with:\n * {{{\n * import zio.blocks.schema.json.interpolators._\n * }}}\n *\n * ==Path Syntax==\n *\n * The `p` interpolator creates [[DynamicOptic]] paths using a JSONPath-compatible dialect:\n *\n * {{{\n * p\"foo.bar\"           // fields \"foo\" then \"bar\"\n * p\"users[0]\"          // field \"users\", then index 0\n * p\"users[0].name\"     // field \"users\", index 0, field \"name\"\n * p\"items[*]\"          // field \"items\", then all array elements\n * p\"config{*}\"         // field \"config\", then all object values\n * p\"config{*:}\"        // field \"config\", then all object keys\n * p\"[0,2,5]\"           // indices 0, 2, and 5\n * p\"[0:5]\"             // slice: indices 0 through 4\n * p\"[::2]\"             // slice: every other element\n * p\"`field.name`\"      // field with dots in name (backtick escaping)\n * p\"\"\"[\"field\"]\"\"\"     // alternate field syntax (bracket notation)\n * }}}\n *\n * ===JSONPath Compatibility===\n *\n * This syntax is a dialect of JSONPath (RFC 9535). Most JSONPath expressions work:\n *  - `$.foo.bar` - root prefix is optional and ignored\n *  - `.field`, `[\"field\"]` - field access\n *  - `[n]`, `[*]`, `[m,n]`, `[m:n]` - array access\n *\n * '''Not supported:'''\n *  - `..` (recursive descent)\n *  - `[?()]` (filter expressions)\n *\n * ===Extensions beyond JSONPath:===\n *  - `{*}` - all object values (explicit, vs `[*]` which is array-focused in JSONPath)\n *  - `{*:}` - all object keys (not expressible in standard JSONPath)\n *  - Backtick escaping for field names\n */\nobject interpolators {\n\n  implicit class JsonPathInterpolator(val sc: StringContext) extends AnyVal {\n\n    /**\n     * Creates a [[DynamicOptic]] from a path string at compile time.\n     *\n     * @return The parsed [[DynamicOptic]]\n     */\n    def p(args: Any*): DynamicOptic = macro PathMacros.pathInterpolator\n  }\n\n  implicit class JsonLiteralInterpolator(val sc: StringContext) extends AnyVal {\n\n    /**\n     * Creates a [[Json]] value from a JSON literal at compile time.\n     *\n     * {{{\n     * j\"\"\"{\"name\": \"Alice\", \"age\": 30}\"\"\"\n     * j\"[1, 2, 3]\"\n     * j\"null\"\n     * }}}\n     *\n     * Interpolated values are converted to JSON:\n     * {{{\n     * val name = \"Bob\"\n     * val age = 25\n     * j\"\"\"{\"name\": $name, \"age\": $age}\"\"\"\n     * }}}\n     *\n     * @return The parsed [[Json]] value\n     */\n    def j(args: Any*): Json = macro PathMacros.jsonInterpolator\n  }\n}\n\n/**\n * Macro implementations for string interpolators.\n * \n * Separate implementations would be needed for Scala 2 and Scala 3.\n */\nobject PathMacros {\n  import scala.reflect.macros.blackbox\n\n  def pathInterpolator(c: blackbox.Context)(args: c.Expr[Any]*): c.Expr[DynamicOptic] = ???\n\n  def jsonInterpolator(c: blackbox.Context)(args: c.Expr[Any]*): c.Expr[Json] = ???\n}\n\n// =============================================================================\n// PLACEHOLDER TYPES (assumed to exist)\n// =============================================================================\n\n/**\n * Represents a JSON Schema for validation.\n *\n * Placeholder - actual implementation TBD.\n */\nsealed trait JsonSchema\n\nobject JsonSchema {\n  // Placeholder\n}\n\n/**\n * Represents a patch that can be applied to JSON values.\n *\n * Supports RFC 6902 operations (add, remove, replace, move, copy, test)\n * plus extensions for LCS-based sequence diffs and string diffs.\n *\n * Placeholder - actual implementation TBD.\n */\nsealed trait JsonPatch {\n\n  /**\n   * Converts this JSON patch to a [[DynamicPatch]].\n   */\n  def toDynamicPatch: DynamicPatch\n}\n\nobject JsonPatch {\n\n  /**\n   * Creates an empty patch (no operations).\n   */\n  val empty: JsonPatch = ???\n\n  /**\n   * Creates a patch from a [[DynamicPatch]].\n   *\n   * May fail if the DynamicPatch contains operations not representable in JSON.\n   */\n  def fromDynamicPatch(patch: DynamicPatch): Either[JsonError, JsonPatch] = ???\n}\n\n/**\n * Represents a patch that can be applied to [[DynamicValue]].\n *\n * Placeholder - actual implementation TBD.\n */\nsealed trait DynamicPatch\n\nobject DynamicPatch {\n\n  /**\n   * Creates an empty patch (no operations).\n   */\n  val empty: DynamicPatch = ???\n}\n```",
              "url": "https://github.com/zio/zio-blocks/issues/679",
              "tech": [],
              "repo_name": "zio-blocks",
              "repo_owner": "zio",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "ZIO#685",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "ZIO",
              "id": "generated-ZIO",
              "name": "ZIO",
              "description": "",
              "members": [],
              "display_name": "ZIO",
              "created_at": "2026-01-19T14:47:40.395Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/ZIO?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "zio",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-19T14:47:40.395Z",
            "created_at": "2026-01-19T14:47:40.395Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-ZIO#685",
              "status": "open",
              "type": "issue",
              "number": 685,
              "title": "Add JsonPatch - Depends on #679",
              "source": {
                "data": {
                  "id": "source-ZIO#685",
                  "user": {
                    "login": "jdegoes",
                    "id": 156745,
                    "node_id": "MDQ6VXNlcjE1Njc0NQ==",
                    "avatar_url": "https://avatars.githubusercontent.com/u/156745?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/jdegoes",
                    "html_url": "https://github.com/jdegoes",
                    "followers_url": "https://api.github.com/users/jdegoes/followers",
                    "following_url": "https://api.github.com/users/jdegoes/following{/other_user}",
                    "gists_url": "https://api.github.com/users/jdegoes/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/jdegoes/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/jdegoes/subscriptions",
                    "organizations_url": "https://api.github.com/users/jdegoes/orgs",
                    "repos_url": "https://api.github.com/users/jdegoes/repos",
                    "events_url": "https://api.github.com/users/jdegoes/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/jdegoes/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Add JsonPatch - Depends on #679",
                  "body": "<html><head></head><body><h1>Add <code>JsonPatch</code> type for diffing and patching JSON values</h1>\n<h2>Summary</h2>\n<p>Implement a <code>JsonPatch</code> type that enables computing diffs between JSON values and applying patches to transform one JSON value into another. This type should mirror the existing <code>DynamicPatch</code> implementation, adapted for JSON's simpler data model.</p>\n<h2>Motivation</h2>\n<p><code>DynamicValue</code> has a well-designed <code>DynamicPatch</code> system with:</p>\n<ul>\n<li>Monoid composition (<code>++</code> with <code>empty</code> identity)</li>\n<li>LCS-based sequence diffing</li>\n<li>Primitive delta operations (numeric deltas, string edits)</li>\n<li>Comprehensive algebraic laws verified by property tests</li>\n</ul>\n<p>The proposed <code>Json</code> type (see #TBD) needs equivalent patching capabilities. Rather than converting <code>Json â†” DynamicValue</code> for every patch operation, a native <code>JsonPatch</code> provides:</p>\n<ul>\n<li>Type safety (no conversion errors for JSON-incompatible DynamicPatch operations)</li>\n<li>API consistency with the <code>Json</code> type</li>\n<li>Potential for JSON-specific optimizations</li>\n</ul>\n<h2>Design Sketch</h2>\n<p>A design sketch is available at <a href=\"https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/json/JsonPatch.scala\"><code>schema/shared/src/main/scala/zio/blocks/schema/json/JsonPatch.scala</code></a>. This sketch is <strong>a guide, not a specification</strong> â€” implementers should use judgment and deviate where appropriate.</p>\n<h3>Core Types</h3>\n<p>The design mirrors <code>DynamicPatch</code> with JSON-specific adaptations:</p>\n\nDynamicPatch | JsonPatch | Notes\n-- | -- | --\nDynamicPatch(Vector[DynamicPatchOp]) | JsonPatch(Vector[JsonPatchOp]) | Same structure\nOperation.Set | Op.Set | Same\nOperation.PrimitiveDelta | Op.PrimitiveDelta | Simplified for JSON types\nOperation.SequenceEdit | Op.ArrayEdit | Renamed\nOperation.MapEdit | Op.ObjectEdit | String keys only\nOperation.Patch | Op.Nested | Same\nSeqOp | ArrayOp | Same operations\nMapOp | ObjectOp | String keys only\nPrimitiveOp (14 variants) | PrimitiveOp (2 variants) | See below\n\n\n<h3>StringOp</h3>\n<p>Mirror <code>DynamicPatch.StringOp</code> exactly:</p>\n<ul>\n<li><code>Insert(index: Int, text: String)</code></li>\n<li><code>Delete(index: Int, length: Int)</code></li>\n<li><code>Append(text: String)</code></li>\n<li><code>Modify(index: Int, length: Int, text: String)</code></li>\n</ul>\n<h3>ArrayOp</h3>\n<p>Mirror <code>DynamicPatch.SeqOp</code>:</p>\n<ul>\n<li><code>Insert(index: Int, values: Vector[Json])</code></li>\n<li><code>Append(values: Vector[Json])</code></li>\n<li><code>Delete(index: Int, count: Int)</code></li>\n<li><code>Modify(index: Int, op: Op)</code></li>\n</ul>\n<h3>ObjectOp</h3>\n<p>Mirror <code>DynamicPatch.MapOp</code> with string keys:</p>\n<ul>\n<li><code>Add(key: String, value: Json)</code></li>\n<li><code>Remove(key: String)</code></li>\n<li><code>Modify(key: String, patch: JsonPatch)</code></li>\n</ul>\n<h2>Requirements</h2>\n<h3>Functional Requirements</h3>\n<ul>\n<li>[ ] <strong>F1</strong>: <code>JsonPatch.diff(source, target)</code> computes a patch transforming source to target</li>\n<li>[ ] <strong>F2</strong>: <code>patch.apply(json, mode)</code> applies a patch with configurable failure handling</li>\n<li>[ ] <strong>F3</strong>: <code>patch1 ++ patch2</code> composes patches (apply first, then second)</li>\n<li>[ ] <strong>F4</strong>: <code>JsonPatch.empty</code> is the identity element for composition</li>\n<li>[ ] <strong>F5</strong>: Support <code>JsonPatchMode.Strict</code>, <code>Lenient</code>, and <code>Clobber</code> modes</li>\n<li>[ ] <strong>F6</strong>: Bidirectional conversion: <code>toDynamicPatch</code> / <code>fromDynamicPatch</code></li>\n</ul>\n<h3>Algebraic Laws</h3>\n<p>All laws must be verified with property-based tests (see <code>PatchLawsSpec</code> for reference):</p>\n<ul>\n<li>[ ] <strong>L1</strong>: Left identity â€” <code>(empty ++ p)(j) == p(j)</code></li>\n<li>[ ] <strong>L2</strong>: Right identity â€” <code>(p ++ empty)(j) == p(j)</code></li>\n<li>[ ] <strong>L3</strong>: Associativity â€” <code>((p1 ++ p2) ++ p3)(j) == (p1 ++ (p2 ++ p3))(j)</code></li>\n<li>[ ] <strong>L4</strong>: Roundtrip â€” <code>diff(a, b)(a) == Right(b)</code></li>\n<li>[ ] <strong>L5</strong>: Identity diff â€” <code>diff(j, j).isEmpty</code></li>\n<li>[ ] <strong>L6</strong>: Diff composition â€” <code>(diff(a, b) ++ diff(b, c))(a) == Right(c)</code></li>\n<li>[ ] <strong>L7</strong>: Lenient subsumes Strict â€” if <code>p(j, Strict) == Right(r)</code> then <code>p(j, Lenient) == Right(r)</code></li>\n</ul>\n<h3>Testing Requirements</h3>\n<ul>\n<li>[ ] <strong>T1</strong>: Property-based tests for all algebraic laws (see <code>PatchLawsSpec</code>)</li>\n<li>[ ] <strong>T2</strong>: Test each operation type (<code>Set</code>, <code>PrimitiveDelta</code>, <code>ArrayEdit</code>, <code>ObjectEdit</code>, <code>Nested</code>)</li>\n<li>[ ] <strong>T3</strong>: Test each <code>ArrayOp</code> variant (<code>Insert</code>, <code>Append</code>, <code>Delete</code>, <code>Modify</code>)</li>\n<li>[ ] <strong>T4</strong>: Test each <code>ObjectOp</code> variant (<code>Add</code>, <code>Remove</code>, <code>Modify</code>)</li>\n<li>[ ] <strong>T5</strong>: Test each <code>StringOp</code> variant (<code>Insert</code>, <code>Delete</code>, <code>Append</code>, <code>Modify</code>)</li>\n<li>[ ] <strong>T6</strong>: Test <code>NumberDelta</code> with positive, negative, zero, and decimal deltas</li>\n<li>[ ] <strong>T7</strong>: Test all three <code>JsonPatchMode</code> behaviors</li>\n<li>[ ] <strong>T8</strong>: Test <code>toDynamicPatch</code> / <code>fromDynamicPatch</code> roundtrip</li>\n<li>[ ] <strong>T9</strong>: Test edge cases: empty arrays, empty objects, empty strings, nested structures</li>\n<li>[ ] <strong>T10</strong>: Test error cases: invalid paths, type mismatches, out-of-bounds indices</li>\n</ul>\n<h3>Documentation Requirements</h3>\n<ul>\n<li>[ ] <strong>D1</strong>: ScalaDoc for all public types and methods</li>\n<li>[ ] <strong>D2</strong>: Usage examples in ScalaDoc (see sketch for examples)</li>\n<li>[ ] <strong>D3</strong>: Document algebraic laws in type-level comments</li>\n<li>[ ] <strong>D4</strong>: Document relationship to <code>DynamicPatch</code></li>\n</ul>\n<h3>Implementation Notes</h3>\n<ol>\n<li>\n<p><strong>Follow <code>DynamicPatch</code> patterns</strong>: The implementation in <code>DynamicPatch.scala</code> is the reference. Study <code>Differ.scala</code> for diff algorithms (especially LCS for sequences and strings).</p>\n</li>\n<li>\n<p><strong>Reuse algorithms where possible</strong>: Consider whether <code>JsonPatch</code> can delegate to <code>DynamicPatch</code> internally, or share algorithm implementations.</p>\n</li>\n<li>\n<p><strong>Keep it minimal</strong>: Resist adding operations not present in <code>DynamicPatch</code>. The design is intentionally minimal and principled.</p>\n</li>\n<li>\n<p><strong>Performance considerations</strong>: The register-based design of ZIO Blocks prioritizes performance. Avoid unnecessary allocations in hot paths.</p>\n</li>\n</ol>\n<h2>Out of Scope</h2>\n<p>The following are explicitly <strong>not</strong> part of this issue:</p>\n<ul>\n<li>RFC 6902 JSON Patch serialization format (separate issue)</li>\n<li>Patch inversion / undo support (separate issue)</li>\n<li>Patch optimization / compaction (separate issue)</li>\n<li>Integration with <code>Json</code> type methods like <code>json.diff(other)</code> (depends on <code>Json</code> implementation)</li>\n</ul>\n<h2>Related</h2>\n<ul>\n<li><code>DynamicPatch</code> â€” <a href=\"https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/DynamicPatch.scala\"><code>schema/shared/src/main/scala/zio/blocks/schema/patch/DynamicPatch.scala</code></a></li>\n<li><code>Differ</code> â€” <a href=\"https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/Differ.scala\"><code>schema/shared/src/main/scala/zio/blocks/schema/patch/Differ.scala</code></a></li>\n<li><code>PatchLawsSpec</code> â€” <a href=\"https://claude.ai/chat/schema/shared/src/test/scala/zio/blocks/schema/patch/PatchLawsSpec.scala\"><code>schema/shared/src/test/scala/zio/blocks/schema/patch/PatchLawsSpec.scala</code></a></li>\n<li><code>PatchMode</code> â€” <a href=\"https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/PatchMode.scala\"><code>schema/shared/src/main/scala/zio/blocks/schema/patch/PatchMode.scala</code></a></li>\n</ul>\n<h2>Acceptance Criteria</h2>\n<ul>\n<li>[ ] All functional requirements (F1-F6) implemented</li>\n<li>[ ] All algebraic laws (L1-L7) pass property-based tests</li>\n<li>[ ] All testing requirements (T1-T10) have corresponding test cases</li>\n<li>[ ] All documentation requirements (D1-D4) complete</li>\n<li>[ ] Code reviewed and approved</li>\n<li>[ ] CI passing</li>\n</ul></body></html># Add `JsonPatch` type for diffing and patching JSON values\n\n## Summary\n\nImplement a `JsonPatch` type that enables computing diffs between JSON values and applying patches to transform one JSON value into another. This type should mirror the existing `DynamicPatch` implementation, adapted for JSON's simpler data model.\n\n## Motivation\n\n`DynamicValue` has a well-designed `DynamicPatch` system with:\n- Monoid composition (`++` with `empty` identity)\n- LCS-based sequence diffing\n- Primitive delta operations (numeric deltas, string edits)\n- Comprehensive algebraic laws verified by property tests\n\nThe proposed `Json` type (see #TBD) needs equivalent patching capabilities. Rather than converting `Json â†” DynamicValue` for every patch operation, a native `JsonPatch` provides:\n- Type safety (no conversion errors for JSON-incompatible DynamicPatch operations)\n- API consistency with the `Json` type\n- Potential for JSON-specific optimizations\n\n## Design Sketch\n\nA design sketch is available at [`[schema/shared/src/main/scala/zio/blocks/schema/json/JsonPatch.scala](https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/json/JsonPatch.scala)`](./schema/shared/src/main/scala/zio/blocks/schema/json/JsonPatch.scala). This sketch is **a guide, not a specification** â€” implementers should use judgment and deviate where appropriate.\n\n### Core Types\n\nThe design mirrors `DynamicPatch` with JSON-specific adaptations:\n\n| DynamicPatch | JsonPatch | Notes |\n|--------------|-----------|-------|\n| `DynamicPatch(Vector[DynamicPatchOp])` | `JsonPatch(Vector[JsonPatchOp])` | Same structure |\n| `Operation.Set` | `Op.Set` | Same |\n| `Operation.PrimitiveDelta` | `Op.PrimitiveDelta` | Simplified for JSON types |\n| `Operation.SequenceEdit` | `Op.ArrayEdit` | Renamed |\n| `Operation.MapEdit` | `Op.ObjectEdit` | String keys only |\n| `Operation.Patch` | `Op.Nested` | Same |\n| `SeqOp` | `ArrayOp` | Same operations |\n| `MapOp` | `ObjectOp` | String keys only |\n| `PrimitiveOp` (14 variants) | `PrimitiveOp` (2 variants) | See below |\n\n### Primitive Operations\n\nJSON has a simpler type system than `DynamicValue`:\n\n| JSON Type | Delta Operation | Notes |\n|-----------|-----------------|-------|\n| Number | `NumberDelta(BigDecimal)` | Unifies all numeric deltas |\n| String | `StringEdit(Vector[StringOp])` | Same as `DynamicPatch` |\n| Boolean | Use `Op.Set` | No delta (same as `DynamicPatch`) |\n| Null | Use `Op.Set` | No delta |\n\n### StringOp\n\nMirror `DynamicPatch.StringOp` exactly:\n- `Insert(index: Int, text: String)`\n- `Delete(index: Int, length: Int)`\n- `Append(text: String)`\n- `Modify(index: Int, length: Int, text: String)`\n\n### ArrayOp\n\nMirror `DynamicPatch.SeqOp`:\n- `Insert(index: Int, values: Vector[Json])`\n- `Append(values: Vector[Json])`\n- `Delete(index: Int, count: Int)`\n- `Modify(index: Int, op: Op)`\n\n### ObjectOp\n\nMirror `DynamicPatch.MapOp` with string keys:\n- `Add(key: String, value: Json)`\n- `Remove(key: String)`\n- `Modify(key: String, patch: JsonPatch)`\n\n## Requirements\n\n### Functional Requirements\n\n- [ ] **F1**: `JsonPatch.diff(source, target)` computes a patch transforming source to target\n- [ ] **F2**: `patch.apply(json, mode)` applies a patch with configurable failure handling\n- [ ] **F3**: `patch1 ++ patch2` composes patches (apply first, then second)\n- [ ] **F4**: `JsonPatch.empty` is the identity element for composition\n- [ ] **F5**: Support `JsonPatchMode.Strict`, `Lenient`, and `Clobber` modes\n- [ ] **F6**: Bidirectional conversion: `toDynamicPatch` / `fromDynamicPatch`\n\n### Algebraic Laws\n\nAll laws must be verified with property-based tests (see `PatchLawsSpec` for reference):\n\n- [ ] **L1**: Left identity â€” `(empty ++ p)(j) == p(j)`\n- [ ] **L2**: Right identity â€” `(p ++ empty)(j) == p(j)`\n- [ ] **L3**: Associativity â€” `((p1 ++ p2) ++ p3)(j) == (p1 ++ (p2 ++ p3))(j)`\n- [ ] **L4**: Roundtrip â€” `diff(a, b)(a) == Right(b)`\n- [ ] **L5**: Identity diff â€” `diff(j, j).isEmpty`\n- [ ] **L6**: Diff composition â€” `(diff(a, b) ++ diff(b, c))(a) == Right(c)`\n- [ ] **L7**: Lenient subsumes Strict â€” if `p(j, Strict) == Right(r)` then `p(j, Lenient) == Right(r)`\n\n### Testing Requirements\n\n- [ ] **T1**: Property-based tests for all algebraic laws (see `PatchLawsSpec`)\n- [ ] **T2**: Test each operation type (`Set`, `PrimitiveDelta`, `ArrayEdit`, `ObjectEdit`, `Nested`)\n- [ ] **T3**: Test each `ArrayOp` variant (`Insert`, `Append`, `Delete`, `Modify`)\n- [ ] **T4**: Test each `ObjectOp` variant (`Add`, `Remove`, `Modify`)\n- [ ] **T5**: Test each `StringOp` variant (`Insert`, `Delete`, `Append`, `Modify`)\n- [ ] **T6**: Test `NumberDelta` with positive, negative, zero, and decimal deltas\n- [ ] **T7**: Test all three `JsonPatchMode` behaviors\n- [ ] **T8**: Test `toDynamicPatch` / `fromDynamicPatch` roundtrip\n- [ ] **T9**: Test edge cases: empty arrays, empty objects, empty strings, nested structures\n- [ ] **T10**: Test error cases: invalid paths, type mismatches, out-of-bounds indices\n\n### Documentation Requirements\n\n- [ ] **D1**: ScalaDoc for all public types and methods\n- [ ] **D2**: Usage examples in ScalaDoc (see sketch for examples)\n- [ ] **D3**: Document algebraic laws in type-level comments\n- [ ] **D4**: Document relationship to `DynamicPatch`\n\n## Related\n\n- `DynamicPatch` â€” [`[schema/shared/src/main/scala/zio/blocks/schema/patch/DynamicPatch.scala](https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/DynamicPatch.scala)`](./schema/shared/src/main/scala/zio/blocks/schema/patch/DynamicPatch.scala)\n- `Differ` â€” [`[schema/shared/src/main/scala/zio/blocks/schema/patch/Differ.scala](https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/Differ.scala)`](./schema/shared/src/main/scala/zio/blocks/schema/patch/Differ.scala)\n- `PatchLawsSpec` â€” [`[schema/shared/src/test/scala/zio/blocks/schema/patch/PatchLawsSpec.scala](https://claude.ai/chat/schema/shared/src/test/scala/zio/blocks/schema/patch/PatchLawsSpec.scala)`](./schema/shared/src/test/scala/zio/blocks/schema/patch/PatchLawsSpec.scala)\n- `PatchMode` â€” [`[schema/shared/src/main/scala/zio/blocks/schema/patch/PatchMode.scala](https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/PatchMode.scala)`](./schema/shared/src/main/scala/zio/blocks/schema/patch/PatchMode.scala)\n\n## Acceptance Criteria\n\n- [ ] All functional requirements (F1-F6) implemented\n- [ ] All algebraic laws (L1-L7) pass property-based tests\n- [ ] All testing requirements (T1-T10) have corresponding test cases\n- [ ] All documentation requirements (D1-D4) complete\n- [ ] Code reviewed and approved\n- [ ] CI passing\n\n# Sketch\n\n```scala\npackage zio.blocks.schema.json\n\nimport zio.blocks.schema.DynamicOptic\nimport zio.blocks.schema.patch.DynamicPatch\n\n// =============================================================================\n// JSON PATCH\n// =============================================================================\n\n/**\n * An untyped patch that operates on [[Json]] values.\n *\n * `JsonPatch` is the JSON-specific counterpart to [[DynamicPatch]]. It represents\n * a sequence of operations that transform one JSON value into another. Patches\n * are serializable and composable.\n *\n * ==Design==\n *\n * This type directly mirrors [[DynamicPatch]] but is specialized for JSON's\n * simpler data model:\n *  - JSON has 4 leaf types (String, Number, Boolean, Null) vs 30 PrimitiveValues\n *  - JSON objects have string keys only (no arbitrary-keyed maps)\n *  - JSON has no native Variant type\n *\n * ==Algebraic Laws==\n *\n * '''Monoid Laws''' (under `++` composition):\n * {{{\n * // 1. LEFT IDENTITY\n * âˆ€ p: JsonPatch, j: Json.\n *   (JsonPatch.empty ++ p)(j, mode) == p(j, mode)\n *\n * // 2. RIGHT IDENTITY\n * âˆ€ p: JsonPatch, j: Json.\n *   (p ++ JsonPatch.empty)(j, mode) == p(j, mode)\n *\n * // 3. ASSOCIATIVITY\n * âˆ€ p1, p2, p3: JsonPatch, j: Json.\n *   ((p1 ++ p2) ++ p3)(j, mode) == (p1 ++ (p2 ++ p3))(j, mode)\n * }}}\n *\n * '''Diff/Apply Laws''':\n * {{{\n * // 4. ROUNDTRIP\n * âˆ€ source, target: Json.\n *   JsonPatch.diff(source, target)(source, Strict) == Right(target)\n *\n * // 5. IDENTITY DIFF\n * âˆ€ j: Json.\n *   JsonPatch.diff(j, j).isEmpty == true\n *\n * // 6. DIFF COMPOSITION\n * âˆ€ a, b, c: Json.\n *   (JsonPatch.diff(a, b) ++ JsonPatch.diff(b, c))(a, Strict) == Right(c)\n * }}}\n *\n * '''PatchMode Laws''':\n * {{{\n * // 7. STRICT FAILS ON ERROR\n * // Strict mode fails on first precondition violation\n *\n * // 8. LENIENT SKIPS ERRORS\n * // Lenient mode skips failing operations, always returns Right\n *\n * // 9. LENIENT SUBSUMES STRICT\n * âˆ€ p: JsonPatch, j: Json.\n *   p(j, Strict) == Right(r) implies p(j, Lenient) == Right(r)\n *\n * // 10. CLOBBER FORCES SUCCESS\n * // Clobber mode creates missing paths, always returns Right\n * }}}\n *\n * @param ops The sequence of patch operations\n */\nfinal case class JsonPatch(ops: Vector[JsonPatch.JsonPatchOp]) {\n\n  /**\n   * Applies this patch to a JSON value.\n   *\n   * @param json The JSON value to patch\n   * @param mode The patch mode (default: Strict)\n   * @return Either an error or the patched value\n   */\n  def apply(json: Json, mode: JsonPatchMode = JsonPatchMode.Strict): Either[JsonError, Json]\n\n  /**\n   * Composes this patch with another. Applies this patch first, then `that`.\n   *\n   * This is the monoid `combine` operation.\n   */\n  def ++(that: JsonPatch): JsonPatch = JsonPatch(ops ++ that.ops)\n\n  /**\n   * Returns true if this patch contains no operations.\n   */\n  def isEmpty: Boolean = ops.isEmpty\n\n  /**\n   * Converts this JSON patch to a [[DynamicPatch]].\n   */\n  def toDynamicPatch: DynamicPatch\n}\n\nobject JsonPatch {\n\n  /**\n   * Empty patch â€” the identity element for `++` composition.\n   */\n  val empty: JsonPatch = JsonPatch(Vector.empty)\n\n  /**\n   * Creates a patch with a single operation at the root path.\n   */\n  def root(op: Op): JsonPatch =\n    JsonPatch(Vector(JsonPatchOp(DynamicOptic.root, op)))\n\n  /**\n   * Creates a patch with a single operation at the given path.\n   */\n  def apply(path: DynamicOptic, op: Op): JsonPatch =\n    JsonPatch(Vector(JsonPatchOp(path, op)))\n\n  /**\n   * Computes a patch that transforms `oldJson` into `newJson`.\n   *\n   * Law: `diff(old, new)(old, Strict) == Right(new)`\n   */\n  def diff(oldJson: Json, newJson: Json): JsonPatch\n\n  /**\n   * Creates a JSON patch from a [[DynamicPatch]].\n   *\n   * May fail if the DynamicPatch contains operations not representable in JSON\n   * (e.g., non-string map keys, temporal deltas, variant operations).\n   */\n  def fromDynamicPatch(patch: DynamicPatch): Either[JsonError, JsonPatch]\n\n  // ===========================================================================\n  // JsonPatchOp â€” a single operation at a path\n  // ===========================================================================\n\n  /**\n   * A single patch operation: a path and what to do there.\n   *\n   * Mirrors [[DynamicPatch.DynamicPatchOp]].\n   */\n  final case class JsonPatchOp(path: DynamicOptic, op: Op)\n\n  // ===========================================================================\n  // Op â€” the operation to perform at a path\n  // ===========================================================================\n\n  /**\n   * The operation to perform at a target location.\n   *\n   * Mirrors [[DynamicPatch.Operation]] but specialized for JSON.\n   */\n  sealed trait Op\n\n  object Op {\n\n    /**\n     * Set a value directly (replacement).\n     *\n     * Mirrors [[DynamicPatch.Operation.Set]].\n     */\n    final case class Set(value: Json) extends Op\n\n    /**\n     * Apply a primitive delta operation.\n     *\n     * Used for numeric deltas and string edits.\n     * Mirrors [[DynamicPatch.Operation.PrimitiveDelta]].\n     */\n    final case class PrimitiveDelta(op: PrimitiveOp) extends Op\n\n    /**\n     * Apply array edit operations.\n     *\n     * Used for inserting, appending, deleting, or modifying array elements.\n     * Mirrors [[DynamicPatch.Operation.SequenceEdit]].\n     */\n    final case class ArrayEdit(ops: Vector[ArrayOp]) extends Op\n\n    /**\n     * Apply object edit operations.\n     *\n     * Used for adding, removing, or modifying object fields.\n     * Mirrors [[DynamicPatch.Operation.MapEdit]] but with string keys.\n     */\n    final case class ObjectEdit(ops: Vector[ObjectOp]) extends Op\n\n    /**\n     * Apply a nested patch.\n     *\n     * Used to group operations sharing a common path prefix.\n     * Mirrors [[DynamicPatch.Operation.Patch]].\n     */\n    final case class Nested(patch: JsonPatch) extends Op\n  }\n\n  // ===========================================================================\n  // PrimitiveOp â€” delta operations for JSON primitives\n  // ===========================================================================\n\n  /**\n   * Delta operations for JSON primitive values.\n   *\n   * JSON has only one numeric type, so we use BigDecimal for deltas.\n   * Boolean has no delta (use Set to toggle).\n   * Null has no delta (use Set to change).\n   *\n   * Mirrors [[DynamicPatch.PrimitiveOp]] but simplified for JSON's type system.\n   */\n  sealed trait PrimitiveOp\n\n  object PrimitiveOp {\n\n    /**\n     * Add a delta to a JSON number.\n     *\n     * Applied by: `currentValue + delta`\n     *\n     * Mirrors the numeric delta operations in [[DynamicPatch.PrimitiveOp]]\n     * (IntDelta, LongDelta, DoubleDelta, etc.) unified into one type.\n     */\n    final case class NumberDelta(delta: BigDecimal) extends PrimitiveOp\n\n    /**\n     * Apply string edit operations.\n     *\n     * Mirrors [[DynamicPatch.PrimitiveOp.StringEdit]].\n     */\n    final case class StringEdit(ops: Vector[StringOp]) extends PrimitiveOp\n  }\n\n  // ===========================================================================\n  // StringOp â€” edit operations for strings\n  // ===========================================================================\n\n  /**\n   * Edit operations for JSON strings.\n   *\n   * Mirrors [[DynamicPatch.StringOp]] exactly.\n   */\n  sealed trait StringOp\n\n  object StringOp {\n\n    /**\n     * Insert text at the given index.\n     */\n    final case class Insert(index: Int, text: String) extends StringOp\n\n    /**\n     * Delete characters starting at the given index.\n     */\n    final case class Delete(index: Int, length: Int) extends StringOp\n\n    /**\n     * Append text to the end of the string.\n     */\n    final case class Append(text: String) extends StringOp\n\n    /**\n     * Replace characters starting at index with new text.\n     */\n    final case class Modify(index: Int, length: Int, text: String) extends StringOp\n  }\n\n  // ===========================================================================\n  // ArrayOp â€” edit operations for arrays\n  // ===========================================================================\n\n  /**\n   * Edit operations for JSON arrays.\n   *\n   * Mirrors [[DynamicPatch.SeqOp]] but with Json values.\n   */\n  sealed trait ArrayOp\n\n  object ArrayOp {\n\n    /**\n     * Insert values at the given index.\n     */\n    final case class Insert(index: Int, values: Vector[Json]) extends ArrayOp\n\n    /**\n     * Append values to the end of the array.\n     */\n    final case class Append(values: Vector[Json]) extends ArrayOp\n\n    /**\n     * Delete elements starting at the given index.\n     */\n    final case class Delete(index: Int, count: Int) extends ArrayOp\n\n    /**\n     * Modify the element at the given index with a nested operation.\n     */\n    final case class Modify(index: Int, op: Op) extends ArrayOp\n  }\n\n  // ===========================================================================\n  // ObjectOp â€” edit operations for objects\n  // ===========================================================================\n\n  /**\n   * Edit operations for JSON objects.\n   *\n   * Mirrors [[DynamicPatch.MapOp]] but with string keys (JSON constraint).\n   */\n  sealed trait ObjectOp\n\n  object ObjectOp {\n\n    /**\n     * Add a field to the object.\n     */\n    final case class Add(key: String, value: Json) extends ObjectOp\n\n    /**\n     * Remove a field from the object.\n     */\n    final case class Remove(key: String) extends ObjectOp\n\n    /**\n     * Modify a field's value with a nested patch.\n     */\n    final case class Modify(key: String, patch: JsonPatch) extends ObjectOp\n  }\n}\n\n// =============================================================================\n// PATCH MODE\n// =============================================================================\n\n/**\n * Controls how patch application handles failures.\n *\n * Mirrors [[zio.blocks.schema.patch.PatchMode]].\n */\nsealed trait JsonPatchMode\n\nobject JsonPatchMode {\n\n  /**\n   * Fail on precondition violations.\n   */\n  case object Strict extends JsonPatchMode\n\n  /**\n   * Skip operations that fail preconditions.\n   */\n  case object Lenient extends JsonPatchMode\n\n  /**\n   * Replace/overwrite on conflicts (create missing paths).\n   */\n  case object Clobber extends JsonPatchMode\n}\n\n// =============================================================================\n// USAGE EXAMPLES\n// =============================================================================\n\n/*\n * ==Example 1: Basic Patching==\n *\n * {{{\n * import zio.blocks.schema.json._\n *\n * val json = Json.Object(Vector(\n *   \"name\" -> Json.String(\"Alice\"),\n *   \"age\" -> Json.Number(\"30\")\n * ))\n *\n * // Replace name\n * val patch = JsonPatch.root(JsonPatch.Op.Set(Json.String(\"Bob\")))\n *   // Or at a specific path:\n *   // JsonPatch(DynamicOptic.root.field(\"name\"), JsonPatch.Op.Set(Json.String(\"Bob\")))\n *\n * val result = patch(json, JsonPatchMode.Strict)\n * }}}\n *\n * ==Example 2: Diff and Apply (Roundtrip Law)==\n *\n * {{{\n * val source = Json.Object(Vector(\"x\" -> Json.Number(\"1\")))\n * val target = Json.Object(Vector(\"x\" -> Json.Number(\"5\")))\n *\n * val patch = JsonPatch.diff(source, target)\n *\n * // Roundtrip law\n * assert(patch(source, JsonPatchMode.Strict) == Right(target))\n *\n * // Identity diff law\n * assert(JsonPatch.diff(source, source).isEmpty)\n * }}}\n *\n * ==Example 3: Monoid Laws==\n *\n * {{{\n * val p1 = JsonPatch.diff(a, b)\n * val p2 = JsonPatch.diff(b, c)\n * val p3 = JsonPatch.diff(c, d)\n *\n * // Left identity\n * assert((JsonPatch.empty ++ p1)(a, Strict) == p1(a, Strict))\n *\n * // Right identity\n * assert((p1 ++ JsonPatch.empty)(a, Strict) == p1(a, Strict))\n *\n * // Associativity\n * assert(((p1 ++ p2) ++ p3)(a, Strict) == (p1 ++ (p2 ++ p3))(a, Strict))\n * }}}\n *\n * ==Example 4: Numeric Delta==\n *\n * {{{\n * val json = Json.Number(\"10\")\n *\n * // Add 5 to the number (more efficient than Set for large structures)\n * val patch = JsonPatch.root(\n *   JsonPatch.Op.PrimitiveDelta(JsonPatch.PrimitiveOp.NumberDelta(BigDecimal(5)))\n * )\n *\n * assert(patch(json, Strict) == Right(Json.Number(\"15\")))\n * }}}\n *\n * ==Example 5: String Edit==\n *\n * {{{\n * val json = Json.String(\"hello world\")\n *\n * // Change \"hello\" to \"hi\" using LCS-based edits\n * val patch = JsonPatch.root(\n *   JsonPatch.Op.PrimitiveDelta(\n *     JsonPatch.PrimitiveOp.StringEdit(Vector(\n *       JsonPatch.StringOp.Delete(0, 5),\n *       JsonPatch.StringOp.Insert(0, \"hi\")\n *     ))\n *   )\n * )\n *\n * assert(patch(json, Strict) == Right(Json.String(\"hi world\")))\n * }}}\n *\n * ==Example 6: Array Edit==\n *\n * {{{\n * val json = Json.Array(Vector(Json.Number(\"1\"), Json.Number(\"2\"), Json.Number(\"3\")))\n *\n * // Delete element at index 1, append new element\n * val patch = JsonPatch.root(\n *   JsonPatch.Op.ArrayEdit(Vector(\n *     JsonPatch.ArrayOp.Delete(1, 1),\n *     JsonPatch.ArrayOp.Append(Vector(Json.Number(\"4\")))\n *   ))\n * )\n *\n * // Result: [1, 3, 4]\n * }}}\n *\n * ==Example 7: Object Edit==\n *\n * {{{\n * val json = Json.Object(Vector(\"a\" -> Json.Number(\"1\"), \"b\" -> Json.Number(\"2\")))\n *\n * // Remove field \"a\", add field \"c\"\n * val patch = JsonPatch.root(\n *   JsonPatch.Op.ObjectEdit(Vector(\n *     JsonPatch.ObjectOp.Remove(\"a\"),\n *     JsonPatch.ObjectOp.Add(\"c\", Json.Number(\"3\"))\n *   ))\n * )\n *\n * // Result: {\"b\": 2, \"c\": 3}\n * }}}\n *\n * ==Example 8: Nested Patch==\n *\n * {{{\n * val json = Json.Object(Vector(\n *   \"user\" -> Json.Object(Vector(\n *     \"name\" -> Json.String(\"Alice\"),\n *     \"age\" -> Json.Number(\"30\")\n *   ))\n * ))\n *\n * // Patch nested inside \"user\"\n * val innerPatch = JsonPatch(Vector(\n *   JsonPatch.JsonPatchOp(\n *     DynamicOptic.root.field(\"age\"),\n *     JsonPatch.Op.PrimitiveDelta(JsonPatch.PrimitiveOp.NumberDelta(BigDecimal(1)))\n *   )\n * ))\n *\n * val patch = JsonPatch(\n *   DynamicOptic.root.field(\"user\"),\n *   JsonPatch.Op.Nested(innerPatch)\n * )\n *\n * // Increments user.age by 1\n * }}}\n *\n * ==Example 9: Diff Composition Law==\n *\n * {{{\n * val a = Json.Number(\"1\")\n * val b = Json.Number(\"5\")\n * val c = Json.Number(\"10\")\n *\n * val p1 = JsonPatch.diff(a, b)  // delta +4\n * val p2 = JsonPatch.diff(b, c)  // delta +5\n *\n * // Composition law: applying composed patch equals applying sequentially\n * assert((p1 ++ p2)(a, Strict) == Right(c))\n * }}}\n *\n * ==Example 10: PatchMode Behavior==\n *\n * {{{\n * val json = Json.Object(Vector(\"a\" -> Json.Number(\"1\")))\n *\n * // Try to remove non-existent field\n * val patch = JsonPatch.root(\n *   JsonPatch.Op.ObjectEdit(Vector(JsonPatch.ObjectOp.Remove(\"nonexistent\")))\n * )\n *\n * // Strict: fails\n * assert(patch(json, JsonPatchMode.Strict).isLeft)\n *\n * // Lenient: skips, returns unchanged\n * assert(patch(json, JsonPatchMode.Lenient) == Right(json))\n *\n * // Clobber: skips (nothing to clobber), returns unchanged\n * assert(patch(json, JsonPatchMode.Clobber) == Right(json))\n * }}}\n */\n```",
                  "html_url": "https://github.com/zio/zio-blocks/issues/685"
                },
                "type": "github"
              },
              "hash": "zio/zio-blocks#685",
              "body": "<html><head></head><body><h1>Add <code>JsonPatch</code> type for diffing and patching JSON values</h1>\n<h2>Summary</h2>\n<p>Implement a <code>JsonPatch</code> type that enables computing diffs between JSON values and applying patches to transform one JSON value into another. This type should mirror the existing <code>DynamicPatch</code> implementation, adapted for JSON's simpler data model.</p>\n<h2>Motivation</h2>\n<p><code>DynamicValue</code> has a well-designed <code>DynamicPatch</code> system with:</p>\n<ul>\n<li>Monoid composition (<code>++</code> with <code>empty</code> identity)</li>\n<li>LCS-based sequence diffing</li>\n<li>Primitive delta operations (numeric deltas, string edits)</li>\n<li>Comprehensive algebraic laws verified by property tests</li>\n</ul>\n<p>The proposed <code>Json</code> type (see #TBD) needs equivalent patching capabilities. Rather than converting <code>Json â†” DynamicValue</code> for every patch operation, a native <code>JsonPatch</code> provides:</p>\n<ul>\n<li>Type safety (no conversion errors for JSON-incompatible DynamicPatch operations)</li>\n<li>API consistency with the <code>Json</code> type</li>\n<li>Potential for JSON-specific optimizations</li>\n</ul>\n<h2>Design Sketch</h2>\n<p>A design sketch is available at <a href=\"https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/json/JsonPatch.scala\"><code>schema/shared/src/main/scala/zio/blocks/schema/json/JsonPatch.scala</code></a>. This sketch is <strong>a guide, not a specification</strong> â€” implementers should use judgment and deviate where appropriate.</p>\n<h3>Core Types</h3>\n<p>The design mirrors <code>DynamicPatch</code> with JSON-specific adaptations:</p>\n\nDynamicPatch | JsonPatch | Notes\n-- | -- | --\nDynamicPatch(Vector[DynamicPatchOp]) | JsonPatch(Vector[JsonPatchOp]) | Same structure\nOperation.Set | Op.Set | Same\nOperation.PrimitiveDelta | Op.PrimitiveDelta | Simplified for JSON types\nOperation.SequenceEdit | Op.ArrayEdit | Renamed\nOperation.MapEdit | Op.ObjectEdit | String keys only\nOperation.Patch | Op.Nested | Same\nSeqOp | ArrayOp | Same operations\nMapOp | ObjectOp | String keys only\nPrimitiveOp (14 variants) | PrimitiveOp (2 variants) | See below\n\n\n<h3>StringOp</h3>\n<p>Mirror <code>DynamicPatch.StringOp</code> exactly:</p>\n<ul>\n<li><code>Insert(index: Int, text: String)</code></li>\n<li><code>Delete(index: Int, length: Int)</code></li>\n<li><code>Append(text: String)</code></li>\n<li><code>Modify(index: Int, length: Int, text: String)</code></li>\n</ul>\n<h3>ArrayOp</h3>\n<p>Mirror <code>DynamicPatch.SeqOp</code>:</p>\n<ul>\n<li><code>Insert(index: Int, values: Vector[Json])</code></li>\n<li><code>Append(values: Vector[Json])</code></li>\n<li><code>Delete(index: Int, count: Int)</code></li>\n<li><code>Modify(index: Int, op: Op)</code></li>\n</ul>\n<h3>ObjectOp</h3>\n<p>Mirror <code>DynamicPatch.MapOp</code> with string keys:</p>\n<ul>\n<li><code>Add(key: String, value: Json)</code></li>\n<li><code>Remove(key: String)</code></li>\n<li><code>Modify(key: String, patch: JsonPatch)</code></li>\n</ul>\n<h2>Requirements</h2>\n<h3>Functional Requirements</h3>\n<ul>\n<li>[ ] <strong>F1</strong>: <code>JsonPatch.diff(source, target)</code> computes a patch transforming source to target</li>\n<li>[ ] <strong>F2</strong>: <code>patch.apply(json, mode)</code> applies a patch with configurable failure handling</li>\n<li>[ ] <strong>F3</strong>: <code>patch1 ++ patch2</code> composes patches (apply first, then second)</li>\n<li>[ ] <strong>F4</strong>: <code>JsonPatch.empty</code> is the identity element for composition</li>\n<li>[ ] <strong>F5</strong>: Support <code>JsonPatchMode.Strict</code>, <code>Lenient</code>, and <code>Clobber</code> modes</li>\n<li>[ ] <strong>F6</strong>: Bidirectional conversion: <code>toDynamicPatch</code> / <code>fromDynamicPatch</code></li>\n</ul>\n<h3>Algebraic Laws</h3>\n<p>All laws must be verified with property-based tests (see <code>PatchLawsSpec</code> for reference):</p>\n<ul>\n<li>[ ] <strong>L1</strong>: Left identity â€” <code>(empty ++ p)(j) == p(j)</code></li>\n<li>[ ] <strong>L2</strong>: Right identity â€” <code>(p ++ empty)(j) == p(j)</code></li>\n<li>[ ] <strong>L3</strong>: Associativity â€” <code>((p1 ++ p2) ++ p3)(j) == (p1 ++ (p2 ++ p3))(j)</code></li>\n<li>[ ] <strong>L4</strong>: Roundtrip â€” <code>diff(a, b)(a) == Right(b)</code></li>\n<li>[ ] <strong>L5</strong>: Identity diff â€” <code>diff(j, j).isEmpty</code></li>\n<li>[ ] <strong>L6</strong>: Diff composition â€” <code>(diff(a, b) ++ diff(b, c))(a) == Right(c)</code></li>\n<li>[ ] <strong>L7</strong>: Lenient subsumes Strict â€” if <code>p(j, Strict) == Right(r)</code> then <code>p(j, Lenient) == Right(r)</code></li>\n</ul>\n<h3>Testing Requirements</h3>\n<ul>\n<li>[ ] <strong>T1</strong>: Property-based tests for all algebraic laws (see <code>PatchLawsSpec</code>)</li>\n<li>[ ] <strong>T2</strong>: Test each operation type (<code>Set</code>, <code>PrimitiveDelta</code>, <code>ArrayEdit</code>, <code>ObjectEdit</code>, <code>Nested</code>)</li>\n<li>[ ] <strong>T3</strong>: Test each <code>ArrayOp</code> variant (<code>Insert</code>, <code>Append</code>, <code>Delete</code>, <code>Modify</code>)</li>\n<li>[ ] <strong>T4</strong>: Test each <code>ObjectOp</code> variant (<code>Add</code>, <code>Remove</code>, <code>Modify</code>)</li>\n<li>[ ] <strong>T5</strong>: Test each <code>StringOp</code> variant (<code>Insert</code>, <code>Delete</code>, <code>Append</code>, <code>Modify</code>)</li>\n<li>[ ] <strong>T6</strong>: Test <code>NumberDelta</code> with positive, negative, zero, and decimal deltas</li>\n<li>[ ] <strong>T7</strong>: Test all three <code>JsonPatchMode</code> behaviors</li>\n<li>[ ] <strong>T8</strong>: Test <code>toDynamicPatch</code> / <code>fromDynamicPatch</code> roundtrip</li>\n<li>[ ] <strong>T9</strong>: Test edge cases: empty arrays, empty objects, empty strings, nested structures</li>\n<li>[ ] <strong>T10</strong>: Test error cases: invalid paths, type mismatches, out-of-bounds indices</li>\n</ul>\n<h3>Documentation Requirements</h3>\n<ul>\n<li>[ ] <strong>D1</strong>: ScalaDoc for all public types and methods</li>\n<li>[ ] <strong>D2</strong>: Usage examples in ScalaDoc (see sketch for examples)</li>\n<li>[ ] <strong>D3</strong>: Document algebraic laws in type-level comments</li>\n<li>[ ] <strong>D4</strong>: Document relationship to <code>DynamicPatch</code></li>\n</ul>\n<h3>Implementation Notes</h3>\n<ol>\n<li>\n<p><strong>Follow <code>DynamicPatch</code> patterns</strong>: The implementation in <code>DynamicPatch.scala</code> is the reference. Study <code>Differ.scala</code> for diff algorithms (especially LCS for sequences and strings).</p>\n</li>\n<li>\n<p><strong>Reuse algorithms where possible</strong>: Consider whether <code>JsonPatch</code> can delegate to <code>DynamicPatch</code> internally, or share algorithm implementations.</p>\n</li>\n<li>\n<p><strong>Keep it minimal</strong>: Resist adding operations not present in <code>DynamicPatch</code>. The design is intentionally minimal and principled.</p>\n</li>\n<li>\n<p><strong>Performance considerations</strong>: The register-based design of ZIO Blocks prioritizes performance. Avoid unnecessary allocations in hot paths.</p>\n</li>\n</ol>\n<h2>Out of Scope</h2>\n<p>The following are explicitly <strong>not</strong> part of this issue:</p>\n<ul>\n<li>RFC 6902 JSON Patch serialization format (separate issue)</li>\n<li>Patch inversion / undo support (separate issue)</li>\n<li>Patch optimization / compaction (separate issue)</li>\n<li>Integration with <code>Json</code> type methods like <code>json.diff(other)</code> (depends on <code>Json</code> implementation)</li>\n</ul>\n<h2>Related</h2>\n<ul>\n<li><code>DynamicPatch</code> â€” <a href=\"https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/DynamicPatch.scala\"><code>schema/shared/src/main/scala/zio/blocks/schema/patch/DynamicPatch.scala</code></a></li>\n<li><code>Differ</code> â€” <a href=\"https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/Differ.scala\"><code>schema/shared/src/main/scala/zio/blocks/schema/patch/Differ.scala</code></a></li>\n<li><code>PatchLawsSpec</code> â€” <a href=\"https://claude.ai/chat/schema/shared/src/test/scala/zio/blocks/schema/patch/PatchLawsSpec.scala\"><code>schema/shared/src/test/scala/zio/blocks/schema/patch/PatchLawsSpec.scala</code></a></li>\n<li><code>PatchMode</code> â€” <a href=\"https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/PatchMode.scala\"><code>schema/shared/src/main/scala/zio/blocks/schema/patch/PatchMode.scala</code></a></li>\n</ul>\n<h2>Acceptance Criteria</h2>\n<ul>\n<li>[ ] All functional requirements (F1-F6) implemented</li>\n<li>[ ] All algebraic laws (L1-L7) pass property-based tests</li>\n<li>[ ] All testing requirements (T1-T10) have corresponding test cases</li>\n<li>[ ] All documentation requirements (D1-D4) complete</li>\n<li>[ ] Code reviewed and approved</li>\n<li>[ ] CI passing</li>\n</ul></body></html># Add `JsonPatch` type for diffing and patching JSON values\n\n## Summary\n\nImplement a `JsonPatch` type that enables computing diffs between JSON values and applying patches to transform one JSON value into another. This type should mirror the existing `DynamicPatch` implementation, adapted for JSON's simpler data model.\n\n## Motivation\n\n`DynamicValue` has a well-designed `DynamicPatch` system with:\n- Monoid composition (`++` with `empty` identity)\n- LCS-based sequence diffing\n- Primitive delta operations (numeric deltas, string edits)\n- Comprehensive algebraic laws verified by property tests\n\nThe proposed `Json` type (see #TBD) needs equivalent patching capabilities. Rather than converting `Json â†” DynamicValue` for every patch operation, a native `JsonPatch` provides:\n- Type safety (no conversion errors for JSON-incompatible DynamicPatch operations)\n- API consistency with the `Json` type\n- Potential for JSON-specific optimizations\n\n## Design Sketch\n\nA design sketch is available at [`[schema/shared/src/main/scala/zio/blocks/schema/json/JsonPatch.scala](https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/json/JsonPatch.scala)`](./schema/shared/src/main/scala/zio/blocks/schema/json/JsonPatch.scala). This sketch is **a guide, not a specification** â€” implementers should use judgment and deviate where appropriate.\n\n### Core Types\n\nThe design mirrors `DynamicPatch` with JSON-specific adaptations:\n\n| DynamicPatch | JsonPatch | Notes |\n|--------------|-----------|-------|\n| `DynamicPatch(Vector[DynamicPatchOp])` | `JsonPatch(Vector[JsonPatchOp])` | Same structure |\n| `Operation.Set` | `Op.Set` | Same |\n| `Operation.PrimitiveDelta` | `Op.PrimitiveDelta` | Simplified for JSON types |\n| `Operation.SequenceEdit` | `Op.ArrayEdit` | Renamed |\n| `Operation.MapEdit` | `Op.ObjectEdit` | String keys only |\n| `Operation.Patch` | `Op.Nested` | Same |\n| `SeqOp` | `ArrayOp` | Same operations |\n| `MapOp` | `ObjectOp` | String keys only |\n| `PrimitiveOp` (14 variants) | `PrimitiveOp` (2 variants) | See below |\n\n### Primitive Operations\n\nJSON has a simpler type system than `DynamicValue`:\n\n| JSON Type | Delta Operation | Notes |\n|-----------|-----------------|-------|\n| Number | `NumberDelta(BigDecimal)` | Unifies all numeric deltas |\n| String | `StringEdit(Vector[StringOp])` | Same as `DynamicPatch` |\n| Boolean | Use `Op.Set` | No delta (same as `DynamicPatch`) |\n| Null | Use `Op.Set` | No delta |\n\n### StringOp\n\nMirror `DynamicPatch.StringOp` exactly:\n- `Insert(index: Int, text: String)`\n- `Delete(index: Int, length: Int)`\n- `Append(text: String)`\n- `Modify(index: Int, length: Int, text: String)`\n\n### ArrayOp\n\nMirror `DynamicPatch.SeqOp`:\n- `Insert(index: Int, values: Vector[Json])`\n- `Append(values: Vector[Json])`\n- `Delete(index: Int, count: Int)`\n- `Modify(index: Int, op: Op)`\n\n### ObjectOp\n\nMirror `DynamicPatch.MapOp` with string keys:\n- `Add(key: String, value: Json)`\n- `Remove(key: String)`\n- `Modify(key: String, patch: JsonPatch)`\n\n## Requirements\n\n### Functional Requirements\n\n- [ ] **F1**: `JsonPatch.diff(source, target)` computes a patch transforming source to target\n- [ ] **F2**: `patch.apply(json, mode)` applies a patch with configurable failure handling\n- [ ] **F3**: `patch1 ++ patch2` composes patches (apply first, then second)\n- [ ] **F4**: `JsonPatch.empty` is the identity element for composition\n- [ ] **F5**: Support `JsonPatchMode.Strict`, `Lenient`, and `Clobber` modes\n- [ ] **F6**: Bidirectional conversion: `toDynamicPatch` / `fromDynamicPatch`\n\n### Algebraic Laws\n\nAll laws must be verified with property-based tests (see `PatchLawsSpec` for reference):\n\n- [ ] **L1**: Left identity â€” `(empty ++ p)(j) == p(j)`\n- [ ] **L2**: Right identity â€” `(p ++ empty)(j) == p(j)`\n- [ ] **L3**: Associativity â€” `((p1 ++ p2) ++ p3)(j) == (p1 ++ (p2 ++ p3))(j)`\n- [ ] **L4**: Roundtrip â€” `diff(a, b)(a) == Right(b)`\n- [ ] **L5**: Identity diff â€” `diff(j, j).isEmpty`\n- [ ] **L6**: Diff composition â€” `(diff(a, b) ++ diff(b, c))(a) == Right(c)`\n- [ ] **L7**: Lenient subsumes Strict â€” if `p(j, Strict) == Right(r)` then `p(j, Lenient) == Right(r)`\n\n### Testing Requirements\n\n- [ ] **T1**: Property-based tests for all algebraic laws (see `PatchLawsSpec`)\n- [ ] **T2**: Test each operation type (`Set`, `PrimitiveDelta`, `ArrayEdit`, `ObjectEdit`, `Nested`)\n- [ ] **T3**: Test each `ArrayOp` variant (`Insert`, `Append`, `Delete`, `Modify`)\n- [ ] **T4**: Test each `ObjectOp` variant (`Add`, `Remove`, `Modify`)\n- [ ] **T5**: Test each `StringOp` variant (`Insert`, `Delete`, `Append`, `Modify`)\n- [ ] **T6**: Test `NumberDelta` with positive, negative, zero, and decimal deltas\n- [ ] **T7**: Test all three `JsonPatchMode` behaviors\n- [ ] **T8**: Test `toDynamicPatch` / `fromDynamicPatch` roundtrip\n- [ ] **T9**: Test edge cases: empty arrays, empty objects, empty strings, nested structures\n- [ ] **T10**: Test error cases: invalid paths, type mismatches, out-of-bounds indices\n\n### Documentation Requirements\n\n- [ ] **D1**: ScalaDoc for all public types and methods\n- [ ] **D2**: Usage examples in ScalaDoc (see sketch for examples)\n- [ ] **D3**: Document algebraic laws in type-level comments\n- [ ] **D4**: Document relationship to `DynamicPatch`\n\n## Related\n\n- `DynamicPatch` â€” [`[schema/shared/src/main/scala/zio/blocks/schema/patch/DynamicPatch.scala](https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/DynamicPatch.scala)`](./schema/shared/src/main/scala/zio/blocks/schema/patch/DynamicPatch.scala)\n- `Differ` â€” [`[schema/shared/src/main/scala/zio/blocks/schema/patch/Differ.scala](https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/Differ.scala)`](./schema/shared/src/main/scala/zio/blocks/schema/patch/Differ.scala)\n- `PatchLawsSpec` â€” [`[schema/shared/src/test/scala/zio/blocks/schema/patch/PatchLawsSpec.scala](https://claude.ai/chat/schema/shared/src/test/scala/zio/blocks/schema/patch/PatchLawsSpec.scala)`](./schema/shared/src/test/scala/zio/blocks/schema/patch/PatchLawsSpec.scala)\n- `PatchMode` â€” [`[schema/shared/src/main/scala/zio/blocks/schema/patch/PatchMode.scala](https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/PatchMode.scala)`](./schema/shared/src/main/scala/zio/blocks/schema/patch/PatchMode.scala)\n\n## Acceptance Criteria\n\n- [ ] All functional requirements (F1-F6) implemented\n- [ ] All algebraic laws (L1-L7) pass property-based tests\n- [ ] All testing requirements (T1-T10) have corresponding test cases\n- [ ] All documentation requirements (D1-D4) complete\n- [ ] Code reviewed and approved\n- [ ] CI passing\n\n# Sketch\n\n```scala\npackage zio.blocks.schema.json\n\nimport zio.blocks.schema.DynamicOptic\nimport zio.blocks.schema.patch.DynamicPatch\n\n// =============================================================================\n// JSON PATCH\n// =============================================================================\n\n/**\n * An untyped patch that operates on [[Json]] values.\n *\n * `JsonPatch` is the JSON-specific counterpart to [[DynamicPatch]]. It represents\n * a sequence of operations that transform one JSON value into another. Patches\n * are serializable and composable.\n *\n * ==Design==\n *\n * This type directly mirrors [[DynamicPatch]] but is specialized for JSON's\n * simpler data model:\n *  - JSON has 4 leaf types (String, Number, Boolean, Null) vs 30 PrimitiveValues\n *  - JSON objects have string keys only (no arbitrary-keyed maps)\n *  - JSON has no native Variant type\n *\n * ==Algebraic Laws==\n *\n * '''Monoid Laws''' (under `++` composition):\n * {{{\n * // 1. LEFT IDENTITY\n * âˆ€ p: JsonPatch, j: Json.\n *   (JsonPatch.empty ++ p)(j, mode) == p(j, mode)\n *\n * // 2. RIGHT IDENTITY\n * âˆ€ p: JsonPatch, j: Json.\n *   (p ++ JsonPatch.empty)(j, mode) == p(j, mode)\n *\n * // 3. ASSOCIATIVITY\n * âˆ€ p1, p2, p3: JsonPatch, j: Json.\n *   ((p1 ++ p2) ++ p3)(j, mode) == (p1 ++ (p2 ++ p3))(j, mode)\n * }}}\n *\n * '''Diff/Apply Laws''':\n * {{{\n * // 4. ROUNDTRIP\n * âˆ€ source, target: Json.\n *   JsonPatch.diff(source, target)(source, Strict) == Right(target)\n *\n * // 5. IDENTITY DIFF\n * âˆ€ j: Json.\n *   JsonPatch.diff(j, j).isEmpty == true\n *\n * // 6. DIFF COMPOSITION\n * âˆ€ a, b, c: Json.\n *   (JsonPatch.diff(a, b) ++ JsonPatch.diff(b, c))(a, Strict) == Right(c)\n * }}}\n *\n * '''PatchMode Laws''':\n * {{{\n * // 7. STRICT FAILS ON ERROR\n * // Strict mode fails on first precondition violation\n *\n * // 8. LENIENT SKIPS ERRORS\n * // Lenient mode skips failing operations, always returns Right\n *\n * // 9. LENIENT SUBSUMES STRICT\n * âˆ€ p: JsonPatch, j: Json.\n *   p(j, Strict) == Right(r) implies p(j, Lenient) == Right(r)\n *\n * // 10. CLOBBER FORCES SUCCESS\n * // Clobber mode creates missing paths, always returns Right\n * }}}\n *\n * @param ops The sequence of patch operations\n */\nfinal case class JsonPatch(ops: Vector[JsonPatch.JsonPatchOp]) {\n\n  /**\n   * Applies this patch to a JSON value.\n   *\n   * @param json The JSON value to patch\n   * @param mode The patch mode (default: Strict)\n   * @return Either an error or the patched value\n   */\n  def apply(json: Json, mode: JsonPatchMode = JsonPatchMode.Strict): Either[JsonError, Json]\n\n  /**\n   * Composes this patch with another. Applies this patch first, then `that`.\n   *\n   * This is the monoid `combine` operation.\n   */\n  def ++(that: JsonPatch): JsonPatch = JsonPatch(ops ++ that.ops)\n\n  /**\n   * Returns true if this patch contains no operations.\n   */\n  def isEmpty: Boolean = ops.isEmpty\n\n  /**\n   * Converts this JSON patch to a [[DynamicPatch]].\n   */\n  def toDynamicPatch: DynamicPatch\n}\n\nobject JsonPatch {\n\n  /**\n   * Empty patch â€” the identity element for `++` composition.\n   */\n  val empty: JsonPatch = JsonPatch(Vector.empty)\n\n  /**\n   * Creates a patch with a single operation at the root path.\n   */\n  def root(op: Op): JsonPatch =\n    JsonPatch(Vector(JsonPatchOp(DynamicOptic.root, op)))\n\n  /**\n   * Creates a patch with a single operation at the given path.\n   */\n  def apply(path: DynamicOptic, op: Op): JsonPatch =\n    JsonPatch(Vector(JsonPatchOp(path, op)))\n\n  /**\n   * Computes a patch that transforms `oldJson` into `newJson`.\n   *\n   * Law: `diff(old, new)(old, Strict) == Right(new)`\n   */\n  def diff(oldJson: Json, newJson: Json): JsonPatch\n\n  /**\n   * Creates a JSON patch from a [[DynamicPatch]].\n   *\n   * May fail if the DynamicPatch contains operations not representable in JSON\n   * (e.g., non-string map keys, temporal deltas, variant operations).\n   */\n  def fromDynamicPatch(patch: DynamicPatch): Either[JsonError, JsonPatch]\n\n  // ===========================================================================\n  // JsonPatchOp â€” a single operation at a path\n  // ===========================================================================\n\n  /**\n   * A single patch operation: a path and what to do there.\n   *\n   * Mirrors [[DynamicPatch.DynamicPatchOp]].\n   */\n  final case class JsonPatchOp(path: DynamicOptic, op: Op)\n\n  // ===========================================================================\n  // Op â€” the operation to perform at a path\n  // ===========================================================================\n\n  /**\n   * The operation to perform at a target location.\n   *\n   * Mirrors [[DynamicPatch.Operation]] but specialized for JSON.\n   */\n  sealed trait Op\n\n  object Op {\n\n    /**\n     * Set a value directly (replacement).\n     *\n     * Mirrors [[DynamicPatch.Operation.Set]].\n     */\n    final case class Set(value: Json) extends Op\n\n    /**\n     * Apply a primitive delta operation.\n     *\n     * Used for numeric deltas and string edits.\n     * Mirrors [[DynamicPatch.Operation.PrimitiveDelta]].\n     */\n    final case class PrimitiveDelta(op: PrimitiveOp) extends Op\n\n    /**\n     * Apply array edit operations.\n     *\n     * Used for inserting, appending, deleting, or modifying array elements.\n     * Mirrors [[DynamicPatch.Operation.SequenceEdit]].\n     */\n    final case class ArrayEdit(ops: Vector[ArrayOp]) extends Op\n\n    /**\n     * Apply object edit operations.\n     *\n     * Used for adding, removing, or modifying object fields.\n     * Mirrors [[DynamicPatch.Operation.MapEdit]] but with string keys.\n     */\n    final case class ObjectEdit(ops: Vector[ObjectOp]) extends Op\n\n    /**\n     * Apply a nested patch.\n     *\n     * Used to group operations sharing a common path prefix.\n     * Mirrors [[DynamicPatch.Operation.Patch]].\n     */\n    final case class Nested(patch: JsonPatch) extends Op\n  }\n\n  // ===========================================================================\n  // PrimitiveOp â€” delta operations for JSON primitives\n  // ===========================================================================\n\n  /**\n   * Delta operations for JSON primitive values.\n   *\n   * JSON has only one numeric type, so we use BigDecimal for deltas.\n   * Boolean has no delta (use Set to toggle).\n   * Null has no delta (use Set to change).\n   *\n   * Mirrors [[DynamicPatch.PrimitiveOp]] but simplified for JSON's type system.\n   */\n  sealed trait PrimitiveOp\n\n  object PrimitiveOp {\n\n    /**\n     * Add a delta to a JSON number.\n     *\n     * Applied by: `currentValue + delta`\n     *\n     * Mirrors the numeric delta operations in [[DynamicPatch.PrimitiveOp]]\n     * (IntDelta, LongDelta, DoubleDelta, etc.) unified into one type.\n     */\n    final case class NumberDelta(delta: BigDecimal) extends PrimitiveOp\n\n    /**\n     * Apply string edit operations.\n     *\n     * Mirrors [[DynamicPatch.PrimitiveOp.StringEdit]].\n     */\n    final case class StringEdit(ops: Vector[StringOp]) extends PrimitiveOp\n  }\n\n  // ===========================================================================\n  // StringOp â€” edit operations for strings\n  // ===========================================================================\n\n  /**\n   * Edit operations for JSON strings.\n   *\n   * Mirrors [[DynamicPatch.StringOp]] exactly.\n   */\n  sealed trait StringOp\n\n  object StringOp {\n\n    /**\n     * Insert text at the given index.\n     */\n    final case class Insert(index: Int, text: String) extends StringOp\n\n    /**\n     * Delete characters starting at the given index.\n     */\n    final case class Delete(index: Int, length: Int) extends StringOp\n\n    /**\n     * Append text to the end of the string.\n     */\n    final case class Append(text: String) extends StringOp\n\n    /**\n     * Replace characters starting at index with new text.\n     */\n    final case class Modify(index: Int, length: Int, text: String) extends StringOp\n  }\n\n  // ===========================================================================\n  // ArrayOp â€” edit operations for arrays\n  // ===========================================================================\n\n  /**\n   * Edit operations for JSON arrays.\n   *\n   * Mirrors [[DynamicPatch.SeqOp]] but with Json values.\n   */\n  sealed trait ArrayOp\n\n  object ArrayOp {\n\n    /**\n     * Insert values at the given index.\n     */\n    final case class Insert(index: Int, values: Vector[Json]) extends ArrayOp\n\n    /**\n     * Append values to the end of the array.\n     */\n    final case class Append(values: Vector[Json]) extends ArrayOp\n\n    /**\n     * Delete elements starting at the given index.\n     */\n    final case class Delete(index: Int, count: Int) extends ArrayOp\n\n    /**\n     * Modify the element at the given index with a nested operation.\n     */\n    final case class Modify(index: Int, op: Op) extends ArrayOp\n  }\n\n  // ===========================================================================\n  // ObjectOp â€” edit operations for objects\n  // ===========================================================================\n\n  /**\n   * Edit operations for JSON objects.\n   *\n   * Mirrors [[DynamicPatch.MapOp]] but with string keys (JSON constraint).\n   */\n  sealed trait ObjectOp\n\n  object ObjectOp {\n\n    /**\n     * Add a field to the object.\n     */\n    final case class Add(key: String, value: Json) extends ObjectOp\n\n    /**\n     * Remove a field from the object.\n     */\n    final case class Remove(key: String) extends ObjectOp\n\n    /**\n     * Modify a field's value with a nested patch.\n     */\n    final case class Modify(key: String, patch: JsonPatch) extends ObjectOp\n  }\n}\n\n// =============================================================================\n// PATCH MODE\n// =============================================================================\n\n/**\n * Controls how patch application handles failures.\n *\n * Mirrors [[zio.blocks.schema.patch.PatchMode]].\n */\nsealed trait JsonPatchMode\n\nobject JsonPatchMode {\n\n  /**\n   * Fail on precondition violations.\n   */\n  case object Strict extends JsonPatchMode\n\n  /**\n   * Skip operations that fail preconditions.\n   */\n  case object Lenient extends JsonPatchMode\n\n  /**\n   * Replace/overwrite on conflicts (create missing paths).\n   */\n  case object Clobber extends JsonPatchMode\n}\n\n// =============================================================================\n// USAGE EXAMPLES\n// =============================================================================\n\n/*\n * ==Example 1: Basic Patching==\n *\n * {{{\n * import zio.blocks.schema.json._\n *\n * val json = Json.Object(Vector(\n *   \"name\" -> Json.String(\"Alice\"),\n *   \"age\" -> Json.Number(\"30\")\n * ))\n *\n * // Replace name\n * val patch = JsonPatch.root(JsonPatch.Op.Set(Json.String(\"Bob\")))\n *   // Or at a specific path:\n *   // JsonPatch(DynamicOptic.root.field(\"name\"), JsonPatch.Op.Set(Json.String(\"Bob\")))\n *\n * val result = patch(json, JsonPatchMode.Strict)\n * }}}\n *\n * ==Example 2: Diff and Apply (Roundtrip Law)==\n *\n * {{{\n * val source = Json.Object(Vector(\"x\" -> Json.Number(\"1\")))\n * val target = Json.Object(Vector(\"x\" -> Json.Number(\"5\")))\n *\n * val patch = JsonPatch.diff(source, target)\n *\n * // Roundtrip law\n * assert(patch(source, JsonPatchMode.Strict) == Right(target))\n *\n * // Identity diff law\n * assert(JsonPatch.diff(source, source).isEmpty)\n * }}}\n *\n * ==Example 3: Monoid Laws==\n *\n * {{{\n * val p1 = JsonPatch.diff(a, b)\n * val p2 = JsonPatch.diff(b, c)\n * val p3 = JsonPatch.diff(c, d)\n *\n * // Left identity\n * assert((JsonPatch.empty ++ p1)(a, Strict) == p1(a, Strict))\n *\n * // Right identity\n * assert((p1 ++ JsonPatch.empty)(a, Strict) == p1(a, Strict))\n *\n * // Associativity\n * assert(((p1 ++ p2) ++ p3)(a, Strict) == (p1 ++ (p2 ++ p3))(a, Strict))\n * }}}\n *\n * ==Example 4: Numeric Delta==\n *\n * {{{\n * val json = Json.Number(\"10\")\n *\n * // Add 5 to the number (more efficient than Set for large structures)\n * val patch = JsonPatch.root(\n *   JsonPatch.Op.PrimitiveDelta(JsonPatch.PrimitiveOp.NumberDelta(BigDecimal(5)))\n * )\n *\n * assert(patch(json, Strict) == Right(Json.Number(\"15\")))\n * }}}\n *\n * ==Example 5: String Edit==\n *\n * {{{\n * val json = Json.String(\"hello world\")\n *\n * // Change \"hello\" to \"hi\" using LCS-based edits\n * val patch = JsonPatch.root(\n *   JsonPatch.Op.PrimitiveDelta(\n *     JsonPatch.PrimitiveOp.StringEdit(Vector(\n *       JsonPatch.StringOp.Delete(0, 5),\n *       JsonPatch.StringOp.Insert(0, \"hi\")\n *     ))\n *   )\n * )\n *\n * assert(patch(json, Strict) == Right(Json.String(\"hi world\")))\n * }}}\n *\n * ==Example 6: Array Edit==\n *\n * {{{\n * val json = Json.Array(Vector(Json.Number(\"1\"), Json.Number(\"2\"), Json.Number(\"3\")))\n *\n * // Delete element at index 1, append new element\n * val patch = JsonPatch.root(\n *   JsonPatch.Op.ArrayEdit(Vector(\n *     JsonPatch.ArrayOp.Delete(1, 1),\n *     JsonPatch.ArrayOp.Append(Vector(Json.Number(\"4\")))\n *   ))\n * )\n *\n * // Result: [1, 3, 4]\n * }}}\n *\n * ==Example 7: Object Edit==\n *\n * {{{\n * val json = Json.Object(Vector(\"a\" -> Json.Number(\"1\"), \"b\" -> Json.Number(\"2\")))\n *\n * // Remove field \"a\", add field \"c\"\n * val patch = JsonPatch.root(\n *   JsonPatch.Op.ObjectEdit(Vector(\n *     JsonPatch.ObjectOp.Remove(\"a\"),\n *     JsonPatch.ObjectOp.Add(\"c\", Json.Number(\"3\"))\n *   ))\n * )\n *\n * // Result: {\"b\": 2, \"c\": 3}\n * }}}\n *\n * ==Example 8: Nested Patch==\n *\n * {{{\n * val json = Json.Object(Vector(\n *   \"user\" -> Json.Object(Vector(\n *     \"name\" -> Json.String(\"Alice\"),\n *     \"age\" -> Json.Number(\"30\")\n *   ))\n * ))\n *\n * // Patch nested inside \"user\"\n * val innerPatch = JsonPatch(Vector(\n *   JsonPatch.JsonPatchOp(\n *     DynamicOptic.root.field(\"age\"),\n *     JsonPatch.Op.PrimitiveDelta(JsonPatch.PrimitiveOp.NumberDelta(BigDecimal(1)))\n *   )\n * ))\n *\n * val patch = JsonPatch(\n *   DynamicOptic.root.field(\"user\"),\n *   JsonPatch.Op.Nested(innerPatch)\n * )\n *\n * // Increments user.age by 1\n * }}}\n *\n * ==Example 9: Diff Composition Law==\n *\n * {{{\n * val a = Json.Number(\"1\")\n * val b = Json.Number(\"5\")\n * val c = Json.Number(\"10\")\n *\n * val p1 = JsonPatch.diff(a, b)  // delta +4\n * val p2 = JsonPatch.diff(b, c)  // delta +5\n *\n * // Composition law: applying composed patch equals applying sequentially\n * assert((p1 ++ p2)(a, Strict) == Right(c))\n * }}}\n *\n * ==Example 10: PatchMode Behavior==\n *\n * {{{\n * val json = Json.Object(Vector(\"a\" -> Json.Number(\"1\")))\n *\n * // Try to remove non-existent field\n * val patch = JsonPatch.root(\n *   JsonPatch.Op.ObjectEdit(Vector(JsonPatch.ObjectOp.Remove(\"nonexistent\")))\n * )\n *\n * // Strict: fails\n * assert(patch(json, JsonPatchMode.Strict).isLeft)\n *\n * // Lenient: skips, returns unchanged\n * assert(patch(json, JsonPatchMode.Lenient) == Right(json))\n *\n * // Clobber: skips (nothing to clobber), returns unchanged\n * assert(patch(json, JsonPatchMode.Clobber) == Right(json))\n * }}}\n */\n```",
              "url": "https://github.com/zio/zio-blocks/issues/685",
              "tech": [],
              "repo_name": "zio-blocks",
              "repo_owner": "zio",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "ZIO#517",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "ZIO",
              "id": "generated-ZIO",
              "name": "ZIO",
              "description": "",
              "members": [],
              "display_name": "ZIO",
              "created_at": "2026-01-19T14:47:41.195Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/ZIO?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "zio",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-19T14:47:41.195Z",
            "created_at": "2026-01-19T14:47:41.195Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-ZIO#517",
              "status": "open",
              "type": "issue",
              "number": 517,
              "title": "Add structural schemas",
              "source": {
                "data": {
                  "id": "source-ZIO#517",
                  "user": {
                    "login": "jdegoes",
                    "id": 156745,
                    "node_id": "MDQ6VXNlcjE1Njc0NQ==",
                    "avatar_url": "https://avatars.githubusercontent.com/u/156745?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/jdegoes",
                    "html_url": "https://github.com/jdegoes",
                    "followers_url": "https://api.github.com/users/jdegoes/followers",
                    "following_url": "https://api.github.com/users/jdegoes/following{/other_user}",
                    "gists_url": "https://api.github.com/users/jdegoes/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/jdegoes/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/jdegoes/subscriptions",
                    "organizations_url": "https://api.github.com/users/jdegoes/orgs",
                    "repos_url": "https://api.github.com/users/jdegoes/repos",
                    "events_url": "https://api.github.com/users/jdegoes/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/jdegoes/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Add structural schemas",
                  "body": "# Structural Type Schema Support\n\n## Overview\n\nExtend `Schema[A]` to support structural types, enabling schema derivation for types defined by their structure rather than their nominal identity. This allows for duck-typed schema validation and conversion between nominal and structural representations.\n\n## Core Concepts\n\n### Direct Structural Schema Derivation\n\nSchemas can be derived directly for structural types:\n\n```scala\n// Scala 3\ntype Person = { def name: String; def age: Int }\nval schema = Schema.derived[Person]\n\n// Scala 2\ntype Person = { def name: String; def age: Int }\nval schema = Schema.derived[Person]\n```\n\n**Note**: Both Scala 2 and Scala 3 use `def` for uniformity, even though Scala 3 supports `val` in structural types.\n\n**Implementation**: Schemas have bindings, which allow construction / deconstruction of values. Values for structural types are backed by:\n- **Scala 3**: `Selectable` \n- **Scala 2**: `Dynamic`\n\n### Nominal to Structural Conversion\n\nConvert nominal type schemas to their structural equivalents:\n\n```scala\ncase class Person(name: String, age: Int)\n\n// Get the structural schema corresponding to Person's shape\nval structuralSchema: Schema[{ def name: String; def age: Int }] = \n  Schema.derived[Person].structural\n```\n\n### Schema API Extension\n\n```scala\ncase class Schema[A](/* existing fields */) {\n  /**\n   * Convert this schema to a structural type schema.\n   * \n   * The structural type represents the \"shape\" of A without its nominal identity.\n   * This enables duck typing and structural validation.\n   * \n   * @param toStructural Macro-generated conversion to structural representation\n   * @return Schema for the structural type corresponding to A\n   */\n  def structural(implicit toStructural: ToStructural[A]): Schema[toStructural.StructuralType] = \n    toStructural.apply(this)\n}\n\n/**\n * Type class for converting nominal schemas to structural schemas.\n * Generated by macro for all supported types. Macro fails if a structural\n * type cannot be generated.\n *\n * NOTE: This approach has to be tested to yield inferrable types, and revised\n * if necessary. Inferrable types (from calling Schema#structural) are a must-have.\n */\ntrait ToStructural[A] {\n  type StructuralType\n  def apply(schema: Schema[A]): Schema[StructuralType]\n}\n\nobject ToStructural {\n  type Aux[A, S] = ToStructural[A] { type StructuralType = S }\n  \n  // Scala 3\n  transparent inline given [A]: ToStructural[A] = ${toStructuralMacro[A]}\n  \n  // Scala 2\n  implicit def materialize[A]: ToStructural[A] = macro toStructuralImpl[A]\n}\n```\n\n---\n\n## Examples\n\n### 1. Simple Product Types\n\n#### Case Class to Structural\n\n```scala\n// Both Scala 2 and Scala 3\ncase class Person(name: String, age: Int)\n\n// Original nominal schema\nval nominalSchema: Schema[Person] = Schema.derived[Person]\n\n// Convert to structural\nval structuralSchema: Schema[{ def name: String; def age: Int }] = \n  nominalSchema.structural\n\n// Direct structural derivation (equivalent)\nval directStructural: Schema[{ def name: String; def age: Int }] = \n  Schema.derived[{ def name: String; def age: Int }]\n```\n\n### 2. Nested Structures\n\n```scala\ncase class Address(street: String, city: String, zip: Int)\ncase class Person(name: String, age: Int, address: Address)\n\nval structuralSchema = Schema.derived[Person].structural\n// Type: Schema[{ \n//   def name: String\n//   def age: Int\n//   def address: { def street: String; def city: String; def zip: Int }\n// }]\n```\n\n### 3. Collections and Options\n\n```scala\ncase class Team(name: String, members: List[String], leader: Option[String])\n\nval structuralSchema = Schema.derived[Team].structural\n// Type: Schema[{\n//   def name: String\n//   def members: List[String]\n//   def leader: Option[String]\n// }]\n```\n\n### 4. Tuples to Structural\n\n```scala\n// Tuples can be converted to structural types\nval tupleSchema: Schema[(String, Int, Boolean)] = Schema.derived[(String, Int, Boolean)]\n\nval structuralSchema = tupleSchema.structural\n// Type: Schema[{ def _1: String; def _2: Int; def _3: Boolean }]\n```\n\n### 5. Sum Types (Sealed Traits) - Scala 3 Only\n\nSealed traits become union types of structural representations, with tag information stored at the type level:\n\n```scala\n// Scala 3 only\nsealed trait Result\ncase class Success(value: Int) extends Result\ncase class Failure(error: String) extends Result\n\nval structuralSchema = Schema.derived[Result].structural\n// Type: Schema[\n//   { type Tag = \"Success\"; def value: Int } | { type Tag = \"Failure\"; def error: String }\n// ]\n```\n\n**Note**: Sum type to structural conversion is **not supported in Scala 2** because it requires union types. Attempting to call `.structural` on a sealed trait schema in Scala 2 will result in a compile-time error.\n\n### 6. Enums (Scala 3 Only)\n\n```scala\nenum Status:\n  case Active, Inactive, Suspended\n\nval structuralSchema = Schema.derived[Status].structural\n// Type: Schema[{type Tag = \"Active\"} | {type Tag = \"Inactive\"} | {type Tag = \"Suspended\"}]\n```\n\n### 7. Opaque Types (Scala 3)\n\n```scala\nopaque type UserId = String\nobject UserId:\n  def apply(value: String): Either[String, UserId] = \n    if value.nonEmpty then Right(value) else Left(\"Empty user ID\")\n\ncase class User(id: UserId, name: String)\n\nval structuralSchema = Schema.derived[User].structural\n// Type: Schema[{ def id: String; def name: String }]\n// Opaque type is unwrapped to its underlying type\n```\n\n### 8. Bidirectional Conversion\n\nStructural schemas work seamlessly with `Into`/`As` (if this ticket is implemented **after** that ticket):\n\n```scala\ncase class Person(name: String, age: Int)\n\nval structuralSchema = Schema.derived[Person].structural\n\n// Create structural value (Scala 3)\nval structuralPerson = new Selectable {\n  def selectDynamic(field: String): Any = field match {\n    case \"name\" => \"Alice\"\n    case \"age\" => 30\n  }\n}\n\n// Convert structural to nominal using Into\nval person: Either[SchemaError, Person] = \n  Into[{ def name: String; def age: Int }, Person].into(structuralPerson)\n// => Right(Person(\"Alice\", 30))\n\n// Convert nominal to structural\nval backToStructural: Either[SchemaError, { def name: String; def age: Int }] = \n  Into[Person, { def name: String; def age: Int }].into(Person(\"Bob\", 25))\n```\n\n### 9. Empty and Single-Field Products\n\n```scala\n// Empty case class\ncase class Empty()\nval emptyStructural = Schema.derived[Empty].structural\n// Type: Schema[{}]\n\n// Single field\ncase class Id(value: String)\nval idStructural = Schema.derived[Id].structural\n// Type: Schema[{ def value: String }]\n```\n\n### 10. Large Products\n\n```scala\ncase class LargeRecord(\n  f1: String, f2: Int, f3: Boolean, f4: Double, f5: Long,\n  f6: String, f7: Int, f8: Boolean, f9: Double, f10: Long,\n  f11: String, f12: Int, f13: Boolean, f14: Double, f15: Long,\n  f16: String, f17: Int, f18: Boolean, f19: Double, f20: Long,\n  f21: String\n)\n\nval structuralSchema = Schema.derived[LargeRecord].structural\n// Type: Schema[{\n//   def f1: String; def f2: Int; def f3: Boolean; ...\n//   def f21: String\n// }]\n```\n\n---\n\n## Type Name Handling\n\n### Current Limitation\n\nSchemas currently use `TypeName[A]` to identify types. Structural types don't have meaningful nominal type names, which creates a mismatch.\n\n### Temporary Solution\n\nUntil `TypeName[A]` is replaced with `TypeId[A]` (see issue #471), structural schemas will use a normalized string representation of the structural type as a fake type name:\n\n```scala\ncase class Person(name: String, age: Int)\n\nval schema = Schema.derived[Person]\nschema.typeName // => TypeName for \"Person\"\n\nval structural = schema.structural\nstructural.typeName // => TypeName for \"{age:Int,name:String}\"\n// Normalized: fields sorted alphabetically, types fully qualified\n```\n\n### Normalization Rules\n\n1. **Field ordering**: Alphabetical by field name\n2. **Type qualification**: Use simple names for primitives and standard library types\n3. **Whitespace**: No whitespace in generated names\n4. **Collections**: Standard notation (e.g., `List[Int]`)\n5. **Options**: Explicit `Option[T]` notation\n6. **Nested structures**: Recursive application of rules\n7. **Deterministic**: Same structure always produces same normalized name\n\n### Examples\n\n```scala\n// Simple product\ncase class Point(x: Int, y: Int)\nSchema.derived[Point].structural.typeName \n// => \"{x:Int,y:Int}\"\n\n// Nested product\ncase class Address(street: String, zip: Int)\ncase class Person(name: String, address: Address)\nSchema.derived[Person].structural.typeName\n// => \"{address:{street:String,zip:Int},name:String}\"\n\n// With collections\ncase class Team(name: String, members: List[String])\nSchema.derived[Team].structural.typeName\n// => \"{members:List[String],name:String}\"\n\n// Union type (Scala 3)\nsealed trait Result\ncase class Success(value: Int) extends Result\ncase class Failure(error: String) extends Result\nSchema.derived[Result].structural.typeName\n// => \"{error:String}|{value:Int}\"\n```\n\n### Future: TypeId[A]\n\nThe upcoming `TypeId[A]` replacement will properly handle structural types by representing them by their structure rather than a string-based hack. See issue #471 for details.\n\n---\n\n## Limitations and Edge Cases\n\n### 1. Generic Types\n\n**Behavior depends on existing Schema derivation support for generic types.**\n\nIf `Schema.derived[Container[Int]]` already works, then structural conversion should work:\n\n```scala\ncase class Container[T](value: T)\n\n// If this works:\nval schema = Schema.derived[Container[Int]]\n\n// Then this should work:\nval structural = schema.structural\n// Type: Schema[{ def value: Int }]\n```\n\nIf generic type derivation is not currently supported, this ticket **does not require implementing it**. The macro should produce a clear compile-time error for unsupported generic types.\n\n### 2. Recursive Types\n\nRecursive types will **fail at compile-time** because Scala does not support infinite types:\n\n```scala\ncase class Tree(value: Int, children: List[Tree])\n\n// This will FAIL at compile-time:\nval structural = Schema.derived[Tree].structural\n// Compile error: Cannot generate infinite structural type\n\n// The structural type would need to be:\n// { def value: Int; def children: List[{ def value: Int; def children: List[...] }] }\n// which is infinite and unsupported\n```\n\nThe macro must detect recursive types and produce a helpful error message:\n\n```\nCompile error: Cannot generate structural type for recursive type Tree.\nStructural types cannot represent recursive structures.\n```\n\n### 3. Mutually Recursive Types\n\nSimilarly, mutually recursive types are unsupported:\n\n```scala\ncase class Node(id: Int, edges: List[Edge])\ncase class Edge(from: Int, to: Node)\n\n// This will FAIL at compile-time:\nval nodeStructural = Schema.derived[Node].structural\n// Compile error: Cannot generate structural type for mutually recursive types\n```\n\n### 4. Sum Types in Scala 2\n\nSealed traits and sum types **cannot be converted to structural types in Scala 2** because they require union types:\n\n```scala\n// Scala 2\nsealed trait Result\ncase class Success(value: Int) extends Result\ncase class Failure(error: String) extends Result\n\n// This will FAIL at compile-time in Scala 2:\nval structural = Schema.derived[Result].structural\n// Compile error: Cannot generate structural type for sum types in Scala 2.\n// Union types are required, which are only available in Scala 3.\n```\n\nThe macro must detect sum types in Scala 2 and produce a clear error.\n\n### 5. Case Objects\n\nCase objects become empty structural types:\n\n```scala\ncase object Singleton\n\nval structural = Schema.derived[Singleton.type].structural\n// Type: Schema[{}]\n```\n\nFor sum types with case objects (Scala 3):\n\n```scala\nsealed trait Status\ncase object Active extends Status\ncase object Inactive extends Status\n\nval structural = Schema.derived[Status].structural\n// Type: Schema[{} | {}]\n// Not particularly useful, but valid\n```\n\n### 6. Structural Types as Source\n\nDeriving schemas directly for structural types is supported:\n\n```scala\ntype PersonStructure = { def name: String; def age: Int }\n\nval schema = Schema.derived[PersonStructure]\n// Should work if structural type derivation is implemented\n```\n\nThe schema's bindings will use `Selectable` (Scala 3) or `Dynamic` (Scala 2) to construct and deconstruct values.\n\n---\n\n## Integration with Into/As\n\nStructural schemas compose naturally with `Into`/`As` conversions.\n\n### Nominal â†’ Structural\n\n```scala\ncase class Person(name: String, age: Int)\n\n// Auto-derived conversion\nval nominalToStructural: Into[Person, { def name: String; def age: Int }] = \n  Into.derived\n\nval person = Person(\"Alice\", 30)\nval structural = nominalToStructural.into(person)\n// => Right(<Selectable/Dynamic instance>)\n```\n\n### Structural â†’ Nominal\n\n```scala\ntype PersonStructure = { def name: String; def age: Int }\ncase class Person(name: String, age: Int)\n\n// Auto-derived conversion\nval structuralToNominal: Into[PersonStructure, Person] = \n  Into.derived\n\nval structural: PersonStructure = new Selectable {\n  def selectDynamic(field: String): Any = field match {\n    case \"name\" => \"Bob\"\n    case \"age\" => 25\n  }\n}\n\nval person = structuralToNominal.into(structural)\n// => Right(Person(\"Bob\", 25))\n```\n\n### Bidirectional (As)\n\n```scala\ncase class Person(name: String, age: Int)\n\n// Bidirectional conversion\nval personAs: As[Person, { def name: String; def age: Int }] = \n  As.derived\n\n// Nominal â†’ Structural\nval structural = personAs.into(Person(\"Alice\", 30))\n\n// Structural â†’ Nominal\nval nominal = structural.flatMap(personAs.from)\n// Round-trip successful\n```\n\n### Schema-Guided Conversion\n\n```scala\ncase class PersonV1(firstName: String, lastName: String, age: Int)\ncase class PersonV2(name: String, age: Int)\n\n// Use structural type as intermediary\ntype PersonStructure = { def name: String; def age: Int }\n\n// Step 1: Transform V1 to structural (custom logic)\nval v1ToStructural: Into[PersonV1, PersonStructure] = \n  new Into[PersonV1, PersonStructure] {\n    def into(v1: PersonV1): Either[SchemaError, PersonStructure] = {\n      Right(new Selectable {\n        def selectDynamic(field: String): Any = field match {\n          case \"name\" => s\"${v1.firstName} ${v1.lastName}\"\n          case \"age\" => v1.age\n        }\n      })\n    }\n  }\n\n// Step 2: Auto-convert structural to V2\nval structuralToV2: Into[PersonStructure, PersonV2] = Into.derived\n\n// Composed migration\ndef migrate(v1: PersonV1): Either[SchemaError, PersonV2] = {\n  v1ToStructural.into(v1).flatMap(structuralToV2.into)\n}\n```\n\n---\n\n## Testing Requirements\n\n### Test Matrix\n\n1. **Direct Structural Derivation**\n   - Simple products (case classes)\n   - Nested products\n   - Collections (List, Vector, Set, Map, Option, Either)\n   - Tuples (2-22 elements)\n   - Empty case classes\n   - Single-field case classes\n   - Large products (20+ fields)\n   - Case objects\n\n2. **Nominal to Structural Conversion**\n   - Case class â†’ structural\n   - Tuple â†’ structural\n   - Nested case classes â†’ nested structural\n   - Case class with collections â†’ structural with collections\n   - Empty case class â†’ empty structural\n\n3. **Sum Types (Scala 3 Only)**\n   - Sealed trait â†’ union type structural\n   - Sealed trait with case objects\n   - Enum â†’ union type structural\n   - Nested sum types\n\n4. **Type Name Generation**\n   - Simple product normalized name\n   - Nested product normalized name\n   - Name determinism (same structure = same name)\n   - Alphabetical field ordering in names\n   - Union type names (Scala 3)\n\n5. **Selectable/Dynamic Implementation**\n   - Scala 3 Selectable field access\n   - Scala 2 Dynamic field access\n   - Field access correctness\n   - Missing field behavior\n   - Extra field behavior\n\n6. **Integration with Into/As**\n   - Nominal â†’ Structural via Into\n   - Structural â†’ Nominal via Into\n   - Round-trip via As\n   - Composed conversions with structural intermediary\n\n7. **Error Cases (Compile-Time)**\n   - Recursive types produce error\n   - Mutually recursive types produce error\n   - Sum types in Scala 2 produce error\n   - Unsupported types produce helpful errors\n\n8. **Generic Types** (if supported by existing Schema derivation)\n   - Fully applied generic â†’ structural\n   - Generic with nested structural fields\n\n### Scala 2 vs Scala 3 Test Separation\n\n```\nsrc/test/scala/\n  structural/\n    common/\n      SimpleProductSpec.scala\n      NestedProductSpec.scala\n      CollectionsSpec.scala\n      TuplesSpec.scala\n      EmptyProductSpec.scala\n      SingleFieldSpec.scala\n      LargeProductSpec.scala\n      TypeNameNormalizationSpec.scala\n      IntoIntegrationSpec.scala\n      AsIntegrationSpec.scala\n      \n    scala3/\n      UnionTypesSpec.scala\n      SealedTraitToUnionSpec.scala\n      EnumToUnionSpec.scala\n      SelectableImplementationSpec.scala\n      \n    scala2/\n      DynamicImplementationSpec.scala\n      SumTypeErrorSpec.scala (verifies compile error)\n      \n    errors/\n      RecursiveTypeErrorSpec.scala\n      MutualRecursionErrorSpec.scala\n      UnsupportedTypeErrorSpec.scala\n```\n\n### Test Examples\n\n```scala\n// Test: Simple product to structural\ntest(\"case class converts to structural schema\") {\n  case class Person(name: String, age: Int)\n  \n  val structural = Schema.derived[Person].structural\n  \n  // Type check (this is a compile-time test)\n  val _: Schema[{ def name: String; def age: Int }] = structural\n  \n  assert(structural.typeName.toString.contains(\"name\"))\n  assert(structural.typeName.toString.contains(\"age\"))\n}\n\n// Test: Nested products\ntest(\"nested case classes convert to nested structural\") {\n  case class Address(street: String, zip: Int)\n  case class Person(name: String, address: Address)\n  \n  val structural = Schema.derived[Person].structural\n  \n  val _: Schema[{ \n    def name: String\n    def address: { def street: String; def zip: Int }\n  }] = structural\n}\n\n// Test: Tuple to structural\ntest(\"tuple converts to structural with _N fields\") {\n  val structural = Schema.derived[(String, Int, Boolean)].structural\n  \n  val _: Schema[{ def _1: String; def _2: Int; def _3: Boolean }] = structural\n}\n\n// Test: Union type (Scala 3 only)\ntest(\"sealed trait converts to union type structural\") {\n  sealed trait Result\n  case class Success(value: Int) extends Result\n  case class Failure(error: String) extends Result\n  \n  val structural = Schema.derived[Result].structural\n  \n  val _: Schema[{ def value: Int } | { def error: String }] = structural\n}\n\n// Test: Type name normalization\ntest(\"structural type names are normalized and deterministic\") {\n  case class Person(name: String, age: Int)\n  case class User(age: Int, name: String) // Different field order\n  \n  val personStructural = Schema.derived[Person].structural\n  val userStructural = Schema.derived[User].structural\n  \n  // Same structure, same normalized name\n  assert(personStructural.typeName == userStructural.typeName)\n  \n  // Alphabetical ordering\n  assert(personStructural.typeName.toString.contains(\"age\"))\n  assert(personStructural.typeName.toString.indexOf(\"age\") < \n         personStructural.typeName.toString.indexOf(\"name\"))\n}\n\n// Test: Integration with Into\ntest(\"structural to nominal conversion via Into\") {\n  case class Person(name: String, age: Int)\n  type PersonStructure = { def name: String; def age: Int }\n  \n  val structural: PersonStructure = new Selectable {\n    def selectDynamic(field: String): Any = field match {\n      case \"name\" => \"Alice\"\n      case \"age\" => 30\n    }\n  }\n  \n  val person = Into[PersonStructure, Person].into(structural)\n  assert(person == Right(Person(\"Alice\", 30)))\n}\n\n// Test: Round-trip via As\ntest(\"nominal to structural and back preserves data\") {\n  case class Person(name: String, age: Int)\n  type PersonStructure = { def name: String; def age: Int }\n  \n  val original = Person(\"Alice\", 30)\n  \n  val toStructural = As[Person, PersonStructure].into(original)\n  val backToNominal = toStructural.flatMap(As[Person, PersonStructure].from)\n  \n  assert(backToNominal == Right(original))\n}\n\n// Test: Recursive type compile error\ntest(\"recursive types produce compile error\") {\n  case class Tree(value: Int, children: List[Tree])\n  \n  assertDoesNotCompile(\"Schema.derived[Tree].structural\")\n}\n\n// Test: Sum type in Scala 2 compile error\ntest(\"sum types in Scala 2 produce compile error\") {\n  sealed trait Result\n  case class Success(value: Int) extends Result\n  \n  // Scala 2 only\n  assertDoesNotCompile(\"Schema.derived[Result].structural\")\n}\n```\n\n---\n\n## Implementation Notes\n\n### Macro Behavior\n\nThe macro must:\n\n1. **Detect product types** (case classes, tuples) and generate structural types with `def` members\n2. **Detect sum types** (sealed traits, enums) and:\n   - In Scala 3: Generate union types of structural representations\n   - In Scala 2: Fail with clear error message\n3. **Detect recursive types** and fail with clear error message\n4. **Normalize structural type representations** for type name generation\n5. **Generate `ToStructural` instance** with:\n   - `StructuralType` type member set to the generated structural type\n   - `apply` method that transforms the schema appropriately\n6. **Preserve field metadata** from original schema where applicable\n7. **Generate appropriate bindings** using `Selectable` (Scala 3) or `Dynamic` (Scala 2)\n\n### Schema Transformation\n\nWhen converting `Schema[A]` to `Schema[StructuralType]`:\n\n1. **Preserve field information**: Field names, types, optional/required status\n2. **Update type name**: Use normalized structural representation\n3. **Transform bindings**: Replace nominal constructors/deconstructors with structural equivalents\n4. **Preserve validation**: Maintain any validation logic that applies to field values\n5. **Handle nested schemas**: Recursively transform nested product types\n\n### Error Messages\n\nProvide clear compile-time errors:\n\n```scala\n// Recursive type\ncase class Tree(value: Int, children: List[Tree])\nSchema.derived[Tree].structural\n\n// Error:\n\"\"\"\nCannot generate structural type for recursive type Tree.\nStructural types cannot represent recursive structures.\nScala's type system does not support infinite types.\n\"\"\"\n\n// Sum type in Scala 2\nsealed trait Result\ncase class Success(value: Int) extends Result\nSchema.derived[Result].structural\n\n// Error (Scala 2 only):\n\"\"\"\nCannot generate structural type for sum type Result.\nStructural representation of sum types requires union types,\nwhich are only available in Scala 3.\nConsider upgrading to Scala 3 or using a different approach.\n\"\"\"\n```\n\n---\n\n## Deliverables\n\n1. âœ… `ToStructural[A]` trait and macro for Scala 2.13\n2. âœ… `ToStructural[A]` trait and macro for Scala 3.5\n3. âœ… `structural` method on `Schema[A]`\n4. âœ… Support for product types (case classes, tuples)\n5. âœ… Support for sum types (sealed traits, enums) in Scala 3 only\n6. âœ… Normalized type name generation\n7. âœ… `Selectable` bindings (Scala 3) and `Dynamic` bindings (Scala 2)\n8. âœ… Integration with `Into`/`As` for structural â†” nominal conversions\n9. âœ… Comprehensive test suite (300+ test cases)\n10. âœ… Clear error messages for unsupported cases\n11. âœ… Documentation with examples",
                  "html_url": "https://github.com/zio/zio-blocks/issues/517"
                },
                "type": "github"
              },
              "hash": "zio/zio-blocks#517",
              "body": "# Structural Type Schema Support\n\n## Overview\n\nExtend `Schema[A]` to support structural types, enabling schema derivation for types defined by their structure rather than their nominal identity. This allows for duck-typed schema validation and conversion between nominal and structural representations.\n\n## Core Concepts\n\n### Direct Structural Schema Derivation\n\nSchemas can be derived directly for structural types:\n\n```scala\n// Scala 3\ntype Person = { def name: String; def age: Int }\nval schema = Schema.derived[Person]\n\n// Scala 2\ntype Person = { def name: String; def age: Int }\nval schema = Schema.derived[Person]\n```\n\n**Note**: Both Scala 2 and Scala 3 use `def` for uniformity, even though Scala 3 supports `val` in structural types.\n\n**Implementation**: Schemas have bindings, which allow construction / deconstruction of values. Values for structural types are backed by:\n- **Scala 3**: `Selectable` \n- **Scala 2**: `Dynamic`\n\n### Nominal to Structural Conversion\n\nConvert nominal type schemas to their structural equivalents:\n\n```scala\ncase class Person(name: String, age: Int)\n\n// Get the structural schema corresponding to Person's shape\nval structuralSchema: Schema[{ def name: String; def age: Int }] = \n  Schema.derived[Person].structural\n```\n\n### Schema API Extension\n\n```scala\ncase class Schema[A](/* existing fields */) {\n  /**\n   * Convert this schema to a structural type schema.\n   * \n   * The structural type represents the \"shape\" of A without its nominal identity.\n   * This enables duck typing and structural validation.\n   * \n   * @param toStructural Macro-generated conversion to structural representation\n   * @return Schema for the structural type corresponding to A\n   */\n  def structural(implicit toStructural: ToStructural[A]): Schema[toStructural.StructuralType] = \n    toStructural.apply(this)\n}\n\n/**\n * Type class for converting nominal schemas to structural schemas.\n * Generated by macro for all supported types. Macro fails if a structural\n * type cannot be generated.\n *\n * NOTE: This approach has to be tested to yield inferrable types, and revised\n * if necessary. Inferrable types (from calling Schema#structural) are a must-have.\n */\ntrait ToStructural[A] {\n  type StructuralType\n  def apply(schema: Schema[A]): Schema[StructuralType]\n}\n\nobject ToStructural {\n  type Aux[A, S] = ToStructural[A] { type StructuralType = S }\n  \n  // Scala 3\n  transparent inline given [A]: ToStructural[A] = ${toStructuralMacro[A]}\n  \n  // Scala 2\n  implicit def materialize[A]: ToStructural[A] = macro toStructuralImpl[A]\n}\n```\n\n---\n\n## Examples\n\n### 1. Simple Product Types\n\n#### Case Class to Structural\n\n```scala\n// Both Scala 2 and Scala 3\ncase class Person(name: String, age: Int)\n\n// Original nominal schema\nval nominalSchema: Schema[Person] = Schema.derived[Person]\n\n// Convert to structural\nval structuralSchema: Schema[{ def name: String; def age: Int }] = \n  nominalSchema.structural\n\n// Direct structural derivation (equivalent)\nval directStructural: Schema[{ def name: String; def age: Int }] = \n  Schema.derived[{ def name: String; def age: Int }]\n```\n\n### 2. Nested Structures\n\n```scala\ncase class Address(street: String, city: String, zip: Int)\ncase class Person(name: String, age: Int, address: Address)\n\nval structuralSchema = Schema.derived[Person].structural\n// Type: Schema[{ \n//   def name: String\n//   def age: Int\n//   def address: { def street: String; def city: String; def zip: Int }\n// }]\n```\n\n### 3. Collections and Options\n\n```scala\ncase class Team(name: String, members: List[String], leader: Option[String])\n\nval structuralSchema = Schema.derived[Team].structural\n// Type: Schema[{\n//   def name: String\n//   def members: List[String]\n//   def leader: Option[String]\n// }]\n```\n\n### 4. Tuples to Structural\n\n```scala\n// Tuples can be converted to structural types\nval tupleSchema: Schema[(String, Int, Boolean)] = Schema.derived[(String, Int, Boolean)]\n\nval structuralSchema = tupleSchema.structural\n// Type: Schema[{ def _1: String; def _2: Int; def _3: Boolean }]\n```\n\n### 5. Sum Types (Sealed Traits) - Scala 3 Only\n\nSealed traits become union types of structural representations, with tag information stored at the type level:\n\n```scala\n// Scala 3 only\nsealed trait Result\ncase class Success(value: Int) extends Result\ncase class Failure(error: String) extends Result\n\nval structuralSchema = Schema.derived[Result].structural\n// Type: Schema[\n//   { type Tag = \"Success\"; def value: Int } | { type Tag = \"Failure\"; def error: String }\n// ]\n```\n\n**Note**: Sum type to structural conversion is **not supported in Scala 2** because it requires union types. Attempting to call `.structural` on a sealed trait schema in Scala 2 will result in a compile-time error.\n\n### 6. Enums (Scala 3 Only)\n\n```scala\nenum Status:\n  case Active, Inactive, Suspended\n\nval structuralSchema = Schema.derived[Status].structural\n// Type: Schema[{type Tag = \"Active\"} | {type Tag = \"Inactive\"} | {type Tag = \"Suspended\"}]\n```\n\n### 7. Opaque Types (Scala 3)\n\n```scala\nopaque type UserId = String\nobject UserId:\n  def apply(value: String): Either[String, UserId] = \n    if value.nonEmpty then Right(value) else Left(\"Empty user ID\")\n\ncase class User(id: UserId, name: String)\n\nval structuralSchema = Schema.derived[User].structural\n// Type: Schema[{ def id: String; def name: String }]\n// Opaque type is unwrapped to its underlying type\n```\n\n### 8. Bidirectional Conversion\n\nStructural schemas work seamlessly with `Into`/`As` (if this ticket is implemented **after** that ticket):\n\n```scala\ncase class Person(name: String, age: Int)\n\nval structuralSchema = Schema.derived[Person].structural\n\n// Create structural value (Scala 3)\nval structuralPerson = new Selectable {\n  def selectDynamic(field: String): Any = field match {\n    case \"name\" => \"Alice\"\n    case \"age\" => 30\n  }\n}\n\n// Convert structural to nominal using Into\nval person: Either[SchemaError, Person] = \n  Into[{ def name: String; def age: Int }, Person].into(structuralPerson)\n// => Right(Person(\"Alice\", 30))\n\n// Convert nominal to structural\nval backToStructural: Either[SchemaError, { def name: String; def age: Int }] = \n  Into[Person, { def name: String; def age: Int }].into(Person(\"Bob\", 25))\n```\n\n### 9. Empty and Single-Field Products\n\n```scala\n// Empty case class\ncase class Empty()\nval emptyStructural = Schema.derived[Empty].structural\n// Type: Schema[{}]\n\n// Single field\ncase class Id(value: String)\nval idStructural = Schema.derived[Id].structural\n// Type: Schema[{ def value: String }]\n```\n\n### 10. Large Products\n\n```scala\ncase class LargeRecord(\n  f1: String, f2: Int, f3: Boolean, f4: Double, f5: Long,\n  f6: String, f7: Int, f8: Boolean, f9: Double, f10: Long,\n  f11: String, f12: Int, f13: Boolean, f14: Double, f15: Long,\n  f16: String, f17: Int, f18: Boolean, f19: Double, f20: Long,\n  f21: String\n)\n\nval structuralSchema = Schema.derived[LargeRecord].structural\n// Type: Schema[{\n//   def f1: String; def f2: Int; def f3: Boolean; ...\n//   def f21: String\n// }]\n```\n\n---\n\n## Type Name Handling\n\n### Current Limitation\n\nSchemas currently use `TypeName[A]` to identify types. Structural types don't have meaningful nominal type names, which creates a mismatch.\n\n### Temporary Solution\n\nUntil `TypeName[A]` is replaced with `TypeId[A]` (see issue #471), structural schemas will use a normalized string representation of the structural type as a fake type name:\n\n```scala\ncase class Person(name: String, age: Int)\n\nval schema = Schema.derived[Person]\nschema.typeName // => TypeName for \"Person\"\n\nval structural = schema.structural\nstructural.typeName // => TypeName for \"{age:Int,name:String}\"\n// Normalized: fields sorted alphabetically, types fully qualified\n```\n\n### Normalization Rules\n\n1. **Field ordering**: Alphabetical by field name\n2. **Type qualification**: Use simple names for primitives and standard library types\n3. **Whitespace**: No whitespace in generated names\n4. **Collections**: Standard notation (e.g., `List[Int]`)\n5. **Options**: Explicit `Option[T]` notation\n6. **Nested structures**: Recursive application of rules\n7. **Deterministic**: Same structure always produces same normalized name\n\n### Examples\n\n```scala\n// Simple product\ncase class Point(x: Int, y: Int)\nSchema.derived[Point].structural.typeName \n// => \"{x:Int,y:Int}\"\n\n// Nested product\ncase class Address(street: String, zip: Int)\ncase class Person(name: String, address: Address)\nSchema.derived[Person].structural.typeName\n// => \"{address:{street:String,zip:Int},name:String}\"\n\n// With collections\ncase class Team(name: String, members: List[String])\nSchema.derived[Team].structural.typeName\n// => \"{members:List[String],name:String}\"\n\n// Union type (Scala 3)\nsealed trait Result\ncase class Success(value: Int) extends Result\ncase class Failure(error: String) extends Result\nSchema.derived[Result].structural.typeName\n// => \"{error:String}|{value:Int}\"\n```\n\n### Future: TypeId[A]\n\nThe upcoming `TypeId[A]` replacement will properly handle structural types by representing them by their structure rather than a string-based hack. See issue #471 for details.\n\n---\n\n## Limitations and Edge Cases\n\n### 1. Generic Types\n\n**Behavior depends on existing Schema derivation support for generic types.**\n\nIf `Schema.derived[Container[Int]]` already works, then structural conversion should work:\n\n```scala\ncase class Container[T](value: T)\n\n// If this works:\nval schema = Schema.derived[Container[Int]]\n\n// Then this should work:\nval structural = schema.structural\n// Type: Schema[{ def value: Int }]\n```\n\nIf generic type derivation is not currently supported, this ticket **does not require implementing it**. The macro should produce a clear compile-time error for unsupported generic types.\n\n### 2. Recursive Types\n\nRecursive types will **fail at compile-time** because Scala does not support infinite types:\n\n```scala\ncase class Tree(value: Int, children: List[Tree])\n\n// This will FAIL at compile-time:\nval structural = Schema.derived[Tree].structural\n// Compile error: Cannot generate infinite structural type\n\n// The structural type would need to be:\n// { def value: Int; def children: List[{ def value: Int; def children: List[...] }] }\n// which is infinite and unsupported\n```\n\nThe macro must detect recursive types and produce a helpful error message:\n\n```\nCompile error: Cannot generate structural type for recursive type Tree.\nStructural types cannot represent recursive structures.\n```\n\n### 3. Mutually Recursive Types\n\nSimilarly, mutually recursive types are unsupported:\n\n```scala\ncase class Node(id: Int, edges: List[Edge])\ncase class Edge(from: Int, to: Node)\n\n// This will FAIL at compile-time:\nval nodeStructural = Schema.derived[Node].structural\n// Compile error: Cannot generate structural type for mutually recursive types\n```\n\n### 4. Sum Types in Scala 2\n\nSealed traits and sum types **cannot be converted to structural types in Scala 2** because they require union types:\n\n```scala\n// Scala 2\nsealed trait Result\ncase class Success(value: Int) extends Result\ncase class Failure(error: String) extends Result\n\n// This will FAIL at compile-time in Scala 2:\nval structural = Schema.derived[Result].structural\n// Compile error: Cannot generate structural type for sum types in Scala 2.\n// Union types are required, which are only available in Scala 3.\n```\n\nThe macro must detect sum types in Scala 2 and produce a clear error.\n\n### 5. Case Objects\n\nCase objects become empty structural types:\n\n```scala\ncase object Singleton\n\nval structural = Schema.derived[Singleton.type].structural\n// Type: Schema[{}]\n```\n\nFor sum types with case objects (Scala 3):\n\n```scala\nsealed trait Status\ncase object Active extends Status\ncase object Inactive extends Status\n\nval structural = Schema.derived[Status].structural\n// Type: Schema[{} | {}]\n// Not particularly useful, but valid\n```\n\n### 6. Structural Types as Source\n\nDeriving schemas directly for structural types is supported:\n\n```scala\ntype PersonStructure = { def name: String; def age: Int }\n\nval schema = Schema.derived[PersonStructure]\n// Should work if structural type derivation is implemented\n```\n\nThe schema's bindings will use `Selectable` (Scala 3) or `Dynamic` (Scala 2) to construct and deconstruct values.\n\n---\n\n## Integration with Into/As\n\nStructural schemas compose naturally with `Into`/`As` conversions.\n\n### Nominal â†’ Structural\n\n```scala\ncase class Person(name: String, age: Int)\n\n// Auto-derived conversion\nval nominalToStructural: Into[Person, { def name: String; def age: Int }] = \n  Into.derived\n\nval person = Person(\"Alice\", 30)\nval structural = nominalToStructural.into(person)\n// => Right(<Selectable/Dynamic instance>)\n```\n\n### Structural â†’ Nominal\n\n```scala\ntype PersonStructure = { def name: String; def age: Int }\ncase class Person(name: String, age: Int)\n\n// Auto-derived conversion\nval structuralToNominal: Into[PersonStructure, Person] = \n  Into.derived\n\nval structural: PersonStructure = new Selectable {\n  def selectDynamic(field: String): Any = field match {\n    case \"name\" => \"Bob\"\n    case \"age\" => 25\n  }\n}\n\nval person = structuralToNominal.into(structural)\n// => Right(Person(\"Bob\", 25))\n```\n\n### Bidirectional (As)\n\n```scala\ncase class Person(name: String, age: Int)\n\n// Bidirectional conversion\nval personAs: As[Person, { def name: String; def age: Int }] = \n  As.derived\n\n// Nominal â†’ Structural\nval structural = personAs.into(Person(\"Alice\", 30))\n\n// Structural â†’ Nominal\nval nominal = structural.flatMap(personAs.from)\n// Round-trip successful\n```\n\n### Schema-Guided Conversion\n\n```scala\ncase class PersonV1(firstName: String, lastName: String, age: Int)\ncase class PersonV2(name: String, age: Int)\n\n// Use structural type as intermediary\ntype PersonStructure = { def name: String; def age: Int }\n\n// Step 1: Transform V1 to structural (custom logic)\nval v1ToStructural: Into[PersonV1, PersonStructure] = \n  new Into[PersonV1, PersonStructure] {\n    def into(v1: PersonV1): Either[SchemaError, PersonStructure] = {\n      Right(new Selectable {\n        def selectDynamic(field: String): Any = field match {\n          case \"name\" => s\"${v1.firstName} ${v1.lastName}\"\n          case \"age\" => v1.age\n        }\n      })\n    }\n  }\n\n// Step 2: Auto-convert structural to V2\nval structuralToV2: Into[PersonStructure, PersonV2] = Into.derived\n\n// Composed migration\ndef migrate(v1: PersonV1): Either[SchemaError, PersonV2] = {\n  v1ToStructural.into(v1).flatMap(structuralToV2.into)\n}\n```\n\n---\n\n## Testing Requirements\n\n### Test Matrix\n\n1. **Direct Structural Derivation**\n   - Simple products (case classes)\n   - Nested products\n   - Collections (List, Vector, Set, Map, Option, Either)\n   - Tuples (2-22 elements)\n   - Empty case classes\n   - Single-field case classes\n   - Large products (20+ fields)\n   - Case objects\n\n2. **Nominal to Structural Conversion**\n   - Case class â†’ structural\n   - Tuple â†’ structural\n   - Nested case classes â†’ nested structural\n   - Case class with collections â†’ structural with collections\n   - Empty case class â†’ empty structural\n\n3. **Sum Types (Scala 3 Only)**\n   - Sealed trait â†’ union type structural\n   - Sealed trait with case objects\n   - Enum â†’ union type structural\n   - Nested sum types\n\n4. **Type Name Generation**\n   - Simple product normalized name\n   - Nested product normalized name\n   - Name determinism (same structure = same name)\n   - Alphabetical field ordering in names\n   - Union type names (Scala 3)\n\n5. **Selectable/Dynamic Implementation**\n   - Scala 3 Selectable field access\n   - Scala 2 Dynamic field access\n   - Field access correctness\n   - Missing field behavior\n   - Extra field behavior\n\n6. **Integration with Into/As**\n   - Nominal â†’ Structural via Into\n   - Structural â†’ Nominal via Into\n   - Round-trip via As\n   - Composed conversions with structural intermediary\n\n7. **Error Cases (Compile-Time)**\n   - Recursive types produce error\n   - Mutually recursive types produce error\n   - Sum types in Scala 2 produce error\n   - Unsupported types produce helpful errors\n\n8. **Generic Types** (if supported by existing Schema derivation)\n   - Fully applied generic â†’ structural\n   - Generic with nested structural fields\n\n### Scala 2 vs Scala 3 Test Separation\n\n```\nsrc/test/scala/\n  structural/\n    common/\n      SimpleProductSpec.scala\n      NestedProductSpec.scala\n      CollectionsSpec.scala\n      TuplesSpec.scala\n      EmptyProductSpec.scala\n      SingleFieldSpec.scala\n      LargeProductSpec.scala\n      TypeNameNormalizationSpec.scala\n      IntoIntegrationSpec.scala\n      AsIntegrationSpec.scala\n      \n    scala3/\n      UnionTypesSpec.scala\n      SealedTraitToUnionSpec.scala\n      EnumToUnionSpec.scala\n      SelectableImplementationSpec.scala\n      \n    scala2/\n      DynamicImplementationSpec.scala\n      SumTypeErrorSpec.scala (verifies compile error)\n      \n    errors/\n      RecursiveTypeErrorSpec.scala\n      MutualRecursionErrorSpec.scala\n      UnsupportedTypeErrorSpec.scala\n```\n\n### Test Examples\n\n```scala\n// Test: Simple product to structural\ntest(\"case class converts to structural schema\") {\n  case class Person(name: String, age: Int)\n  \n  val structural = Schema.derived[Person].structural\n  \n  // Type check (this is a compile-time test)\n  val _: Schema[{ def name: String; def age: Int }] = structural\n  \n  assert(structural.typeName.toString.contains(\"name\"))\n  assert(structural.typeName.toString.contains(\"age\"))\n}\n\n// Test: Nested products\ntest(\"nested case classes convert to nested structural\") {\n  case class Address(street: String, zip: Int)\n  case class Person(name: String, address: Address)\n  \n  val structural = Schema.derived[Person].structural\n  \n  val _: Schema[{ \n    def name: String\n    def address: { def street: String; def zip: Int }\n  }] = structural\n}\n\n// Test: Tuple to structural\ntest(\"tuple converts to structural with _N fields\") {\n  val structural = Schema.derived[(String, Int, Boolean)].structural\n  \n  val _: Schema[{ def _1: String; def _2: Int; def _3: Boolean }] = structural\n}\n\n// Test: Union type (Scala 3 only)\ntest(\"sealed trait converts to union type structural\") {\n  sealed trait Result\n  case class Success(value: Int) extends Result\n  case class Failure(error: String) extends Result\n  \n  val structural = Schema.derived[Result].structural\n  \n  val _: Schema[{ def value: Int } | { def error: String }] = structural\n}\n\n// Test: Type name normalization\ntest(\"structural type names are normalized and deterministic\") {\n  case class Person(name: String, age: Int)\n  case class User(age: Int, name: String) // Different field order\n  \n  val personStructural = Schema.derived[Person].structural\n  val userStructural = Schema.derived[User].structural\n  \n  // Same structure, same normalized name\n  assert(personStructural.typeName == userStructural.typeName)\n  \n  // Alphabetical ordering\n  assert(personStructural.typeName.toString.contains(\"age\"))\n  assert(personStructural.typeName.toString.indexOf(\"age\") < \n         personStructural.typeName.toString.indexOf(\"name\"))\n}\n\n// Test: Integration with Into\ntest(\"structural to nominal conversion via Into\") {\n  case class Person(name: String, age: Int)\n  type PersonStructure = { def name: String; def age: Int }\n  \n  val structural: PersonStructure = new Selectable {\n    def selectDynamic(field: String): Any = field match {\n      case \"name\" => \"Alice\"\n      case \"age\" => 30\n    }\n  }\n  \n  val person = Into[PersonStructure, Person].into(structural)\n  assert(person == Right(Person(\"Alice\", 30)))\n}\n\n// Test: Round-trip via As\ntest(\"nominal to structural and back preserves data\") {\n  case class Person(name: String, age: Int)\n  type PersonStructure = { def name: String; def age: Int }\n  \n  val original = Person(\"Alice\", 30)\n  \n  val toStructural = As[Person, PersonStructure].into(original)\n  val backToNominal = toStructural.flatMap(As[Person, PersonStructure].from)\n  \n  assert(backToNominal == Right(original))\n}\n\n// Test: Recursive type compile error\ntest(\"recursive types produce compile error\") {\n  case class Tree(value: Int, children: List[Tree])\n  \n  assertDoesNotCompile(\"Schema.derived[Tree].structural\")\n}\n\n// Test: Sum type in Scala 2 compile error\ntest(\"sum types in Scala 2 produce compile error\") {\n  sealed trait Result\n  case class Success(value: Int) extends Result\n  \n  // Scala 2 only\n  assertDoesNotCompile(\"Schema.derived[Result].structural\")\n}\n```\n\n---\n\n## Implementation Notes\n\n### Macro Behavior\n\nThe macro must:\n\n1. **Detect product types** (case classes, tuples) and generate structural types with `def` members\n2. **Detect sum types** (sealed traits, enums) and:\n   - In Scala 3: Generate union types of structural representations\n   - In Scala 2: Fail with clear error message\n3. **Detect recursive types** and fail with clear error message\n4. **Normalize structural type representations** for type name generation\n5. **Generate `ToStructural` instance** with:\n   - `StructuralType` type member set to the generated structural type\n   - `apply` method that transforms the schema appropriately\n6. **Preserve field metadata** from original schema where applicable\n7. **Generate appropriate bindings** using `Selectable` (Scala 3) or `Dynamic` (Scala 2)\n\n### Schema Transformation\n\nWhen converting `Schema[A]` to `Schema[StructuralType]`:\n\n1. **Preserve field information**: Field names, types, optional/required status\n2. **Update type name**: Use normalized structural representation\n3. **Transform bindings**: Replace nominal constructors/deconstructors with structural equivalents\n4. **Preserve validation**: Maintain any validation logic that applies to field values\n5. **Handle nested schemas**: Recursively transform nested product types\n\n### Error Messages\n\nProvide clear compile-time errors:\n\n```scala\n// Recursive type\ncase class Tree(value: Int, children: List[Tree])\nSchema.derived[Tree].structural\n\n// Error:\n\"\"\"\nCannot generate structural type for recursive type Tree.\nStructural types cannot represent recursive structures.\nScala's type system does not support infinite types.\n\"\"\"\n\n// Sum type in Scala 2\nsealed trait Result\ncase class Success(value: Int) extends Result\nSchema.derived[Result].structural\n\n// Error (Scala 2 only):\n\"\"\"\nCannot generate structural type for sum type Result.\nStructural representation of sum types requires union types,\nwhich are only available in Scala 3.\nConsider upgrading to Scala 3 or using a different approach.\n\"\"\"\n```\n\n---\n\n## Deliverables\n\n1. âœ… `ToStructural[A]` trait and macro for Scala 2.13\n2. âœ… `ToStructural[A]` trait and macro for Scala 3.5\n3. âœ… `structural` method on `Schema[A]`\n4. âœ… Support for product types (case classes, tuples)\n5. âœ… Support for sum types (sealed traits, enums) in Scala 3 only\n6. âœ… Normalized type name generation\n7. âœ… `Selectable` bindings (Scala 3) and `Dynamic` bindings (Scala 2)\n8. âœ… Integration with `Into`/`As` for structural â†” nominal conversions\n9. âœ… Comprehensive test suite (300+ test cases)\n10. âœ… Clear error messages for unsupported cases\n11. âœ… Documentation with examples",
              "url": "https://github.com/zio/zio-blocks/issues/517",
              "tech": [],
              "repo_name": "zio-blocks",
              "repo_owner": "zio",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "ZIO#685",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "ZIO",
              "id": "generated-ZIO",
              "name": "ZIO",
              "description": "",
              "members": [],
              "display_name": "ZIO",
              "created_at": "2026-01-19T14:47:42.396Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/ZIO?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "zio",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-19T14:47:42.396Z",
            "created_at": "2026-01-19T14:47:42.396Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-ZIO#685",
              "status": "open",
              "type": "issue",
              "number": 685,
              "title": "Add JsonPatch - Depends on #679",
              "source": {
                "data": {
                  "id": "source-ZIO#685",
                  "user": {
                    "login": "jdegoes",
                    "id": 156745,
                    "node_id": "MDQ6VXNlcjE1Njc0NQ==",
                    "avatar_url": "https://avatars.githubusercontent.com/u/156745?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/jdegoes",
                    "html_url": "https://github.com/jdegoes",
                    "followers_url": "https://api.github.com/users/jdegoes/followers",
                    "following_url": "https://api.github.com/users/jdegoes/following{/other_user}",
                    "gists_url": "https://api.github.com/users/jdegoes/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/jdegoes/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/jdegoes/subscriptions",
                    "organizations_url": "https://api.github.com/users/jdegoes/orgs",
                    "repos_url": "https://api.github.com/users/jdegoes/repos",
                    "events_url": "https://api.github.com/users/jdegoes/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/jdegoes/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Add JsonPatch - Depends on #679",
                  "body": "<html><head></head><body><h1>Add <code>JsonPatch</code> type for diffing and patching JSON values</h1>\n<h2>Summary</h2>\n<p>Implement a <code>JsonPatch</code> type that enables computing diffs between JSON values and applying patches to transform one JSON value into another. This type should mirror the existing <code>DynamicPatch</code> implementation, adapted for JSON's simpler data model.</p>\n<h2>Motivation</h2>\n<p><code>DynamicValue</code> has a well-designed <code>DynamicPatch</code> system with:</p>\n<ul>\n<li>Monoid composition (<code>++</code> with <code>empty</code> identity)</li>\n<li>LCS-based sequence diffing</li>\n<li>Primitive delta operations (numeric deltas, string edits)</li>\n<li>Comprehensive algebraic laws verified by property tests</li>\n</ul>\n<p>The proposed <code>Json</code> type (see #TBD) needs equivalent patching capabilities. Rather than converting <code>Json â†” DynamicValue</code> for every patch operation, a native <code>JsonPatch</code> provides:</p>\n<ul>\n<li>Type safety (no conversion errors for JSON-incompatible DynamicPatch operations)</li>\n<li>API consistency with the <code>Json</code> type</li>\n<li>Potential for JSON-specific optimizations</li>\n</ul>\n<h2>Design Sketch</h2>\n<p>A design sketch is available at <a href=\"https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/json/JsonPatch.scala\"><code>schema/shared/src/main/scala/zio/blocks/schema/json/JsonPatch.scala</code></a>. This sketch is <strong>a guide, not a specification</strong> â€” implementers should use judgment and deviate where appropriate.</p>\n<h3>Core Types</h3>\n<p>The design mirrors <code>DynamicPatch</code> with JSON-specific adaptations:</p>\n\nDynamicPatch | JsonPatch | Notes\n-- | -- | --\nDynamicPatch(Vector[DynamicPatchOp]) | JsonPatch(Vector[JsonPatchOp]) | Same structure\nOperation.Set | Op.Set | Same\nOperation.PrimitiveDelta | Op.PrimitiveDelta | Simplified for JSON types\nOperation.SequenceEdit | Op.ArrayEdit | Renamed\nOperation.MapEdit | Op.ObjectEdit | String keys only\nOperation.Patch | Op.Nested | Same\nSeqOp | ArrayOp | Same operations\nMapOp | ObjectOp | String keys only\nPrimitiveOp (14 variants) | PrimitiveOp (2 variants) | See below\n\n\n<h3>StringOp</h3>\n<p>Mirror <code>DynamicPatch.StringOp</code> exactly:</p>\n<ul>\n<li><code>Insert(index: Int, text: String)</code></li>\n<li><code>Delete(index: Int, length: Int)</code></li>\n<li><code>Append(text: String)</code></li>\n<li><code>Modify(index: Int, length: Int, text: String)</code></li>\n</ul>\n<h3>ArrayOp</h3>\n<p>Mirror <code>DynamicPatch.SeqOp</code>:</p>\n<ul>\n<li><code>Insert(index: Int, values: Vector[Json])</code></li>\n<li><code>Append(values: Vector[Json])</code></li>\n<li><code>Delete(index: Int, count: Int)</code></li>\n<li><code>Modify(index: Int, op: Op)</code></li>\n</ul>\n<h3>ObjectOp</h3>\n<p>Mirror <code>DynamicPatch.MapOp</code> with string keys:</p>\n<ul>\n<li><code>Add(key: String, value: Json)</code></li>\n<li><code>Remove(key: String)</code></li>\n<li><code>Modify(key: String, patch: JsonPatch)</code></li>\n</ul>\n<h2>Requirements</h2>\n<h3>Functional Requirements</h3>\n<ul>\n<li>[ ] <strong>F1</strong>: <code>JsonPatch.diff(source, target)</code> computes a patch transforming source to target</li>\n<li>[ ] <strong>F2</strong>: <code>patch.apply(json, mode)</code> applies a patch with configurable failure handling</li>\n<li>[ ] <strong>F3</strong>: <code>patch1 ++ patch2</code> composes patches (apply first, then second)</li>\n<li>[ ] <strong>F4</strong>: <code>JsonPatch.empty</code> is the identity element for composition</li>\n<li>[ ] <strong>F5</strong>: Support <code>JsonPatchMode.Strict</code>, <code>Lenient</code>, and <code>Clobber</code> modes</li>\n<li>[ ] <strong>F6</strong>: Bidirectional conversion: <code>toDynamicPatch</code> / <code>fromDynamicPatch</code></li>\n</ul>\n<h3>Algebraic Laws</h3>\n<p>All laws must be verified with property-based tests (see <code>PatchLawsSpec</code> for reference):</p>\n<ul>\n<li>[ ] <strong>L1</strong>: Left identity â€” <code>(empty ++ p)(j) == p(j)</code></li>\n<li>[ ] <strong>L2</strong>: Right identity â€” <code>(p ++ empty)(j) == p(j)</code></li>\n<li>[ ] <strong>L3</strong>: Associativity â€” <code>((p1 ++ p2) ++ p3)(j) == (p1 ++ (p2 ++ p3))(j)</code></li>\n<li>[ ] <strong>L4</strong>: Roundtrip â€” <code>diff(a, b)(a) == Right(b)</code></li>\n<li>[ ] <strong>L5</strong>: Identity diff â€” <code>diff(j, j).isEmpty</code></li>\n<li>[ ] <strong>L6</strong>: Diff composition â€” <code>(diff(a, b) ++ diff(b, c))(a) == Right(c)</code></li>\n<li>[ ] <strong>L7</strong>: Lenient subsumes Strict â€” if <code>p(j, Strict) == Right(r)</code> then <code>p(j, Lenient) == Right(r)</code></li>\n</ul>\n<h3>Testing Requirements</h3>\n<ul>\n<li>[ ] <strong>T1</strong>: Property-based tests for all algebraic laws (see <code>PatchLawsSpec</code>)</li>\n<li>[ ] <strong>T2</strong>: Test each operation type (<code>Set</code>, <code>PrimitiveDelta</code>, <code>ArrayEdit</code>, <code>ObjectEdit</code>, <code>Nested</code>)</li>\n<li>[ ] <strong>T3</strong>: Test each <code>ArrayOp</code> variant (<code>Insert</code>, <code>Append</code>, <code>Delete</code>, <code>Modify</code>)</li>\n<li>[ ] <strong>T4</strong>: Test each <code>ObjectOp</code> variant (<code>Add</code>, <code>Remove</code>, <code>Modify</code>)</li>\n<li>[ ] <strong>T5</strong>: Test each <code>StringOp</code> variant (<code>Insert</code>, <code>Delete</code>, <code>Append</code>, <code>Modify</code>)</li>\n<li>[ ] <strong>T6</strong>: Test <code>NumberDelta</code> with positive, negative, zero, and decimal deltas</li>\n<li>[ ] <strong>T7</strong>: Test all three <code>JsonPatchMode</code> behaviors</li>\n<li>[ ] <strong>T8</strong>: Test <code>toDynamicPatch</code> / <code>fromDynamicPatch</code> roundtrip</li>\n<li>[ ] <strong>T9</strong>: Test edge cases: empty arrays, empty objects, empty strings, nested structures</li>\n<li>[ ] <strong>T10</strong>: Test error cases: invalid paths, type mismatches, out-of-bounds indices</li>\n</ul>\n<h3>Documentation Requirements</h3>\n<ul>\n<li>[ ] <strong>D1</strong>: ScalaDoc for all public types and methods</li>\n<li>[ ] <strong>D2</strong>: Usage examples in ScalaDoc (see sketch for examples)</li>\n<li>[ ] <strong>D3</strong>: Document algebraic laws in type-level comments</li>\n<li>[ ] <strong>D4</strong>: Document relationship to <code>DynamicPatch</code></li>\n</ul>\n<h3>Implementation Notes</h3>\n<ol>\n<li>\n<p><strong>Follow <code>DynamicPatch</code> patterns</strong>: The implementation in <code>DynamicPatch.scala</code> is the reference. Study <code>Differ.scala</code> for diff algorithms (especially LCS for sequences and strings).</p>\n</li>\n<li>\n<p><strong>Reuse algorithms where possible</strong>: Consider whether <code>JsonPatch</code> can delegate to <code>DynamicPatch</code> internally, or share algorithm implementations.</p>\n</li>\n<li>\n<p><strong>Keep it minimal</strong>: Resist adding operations not present in <code>DynamicPatch</code>. The design is intentionally minimal and principled.</p>\n</li>\n<li>\n<p><strong>Performance considerations</strong>: The register-based design of ZIO Blocks prioritizes performance. Avoid unnecessary allocations in hot paths.</p>\n</li>\n</ol>\n<h2>Out of Scope</h2>\n<p>The following are explicitly <strong>not</strong> part of this issue:</p>\n<ul>\n<li>RFC 6902 JSON Patch serialization format (separate issue)</li>\n<li>Patch inversion / undo support (separate issue)</li>\n<li>Patch optimization / compaction (separate issue)</li>\n<li>Integration with <code>Json</code> type methods like <code>json.diff(other)</code> (depends on <code>Json</code> implementation)</li>\n</ul>\n<h2>Related</h2>\n<ul>\n<li><code>DynamicPatch</code> â€” <a href=\"https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/DynamicPatch.scala\"><code>schema/shared/src/main/scala/zio/blocks/schema/patch/DynamicPatch.scala</code></a></li>\n<li><code>Differ</code> â€” <a href=\"https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/Differ.scala\"><code>schema/shared/src/main/scala/zio/blocks/schema/patch/Differ.scala</code></a></li>\n<li><code>PatchLawsSpec</code> â€” <a href=\"https://claude.ai/chat/schema/shared/src/test/scala/zio/blocks/schema/patch/PatchLawsSpec.scala\"><code>schema/shared/src/test/scala/zio/blocks/schema/patch/PatchLawsSpec.scala</code></a></li>\n<li><code>PatchMode</code> â€” <a href=\"https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/PatchMode.scala\"><code>schema/shared/src/main/scala/zio/blocks/schema/patch/PatchMode.scala</code></a></li>\n</ul>\n<h2>Acceptance Criteria</h2>\n<ul>\n<li>[ ] All functional requirements (F1-F6) implemented</li>\n<li>[ ] All algebraic laws (L1-L7) pass property-based tests</li>\n<li>[ ] All testing requirements (T1-T10) have corresponding test cases</li>\n<li>[ ] All documentation requirements (D1-D4) complete</li>\n<li>[ ] Code reviewed and approved</li>\n<li>[ ] CI passing</li>\n</ul></body></html># Add `JsonPatch` type for diffing and patching JSON values\n\n## Summary\n\nImplement a `JsonPatch` type that enables computing diffs between JSON values and applying patches to transform one JSON value into another. This type should mirror the existing `DynamicPatch` implementation, adapted for JSON's simpler data model.\n\n## Motivation\n\n`DynamicValue` has a well-designed `DynamicPatch` system with:\n- Monoid composition (`++` with `empty` identity)\n- LCS-based sequence diffing\n- Primitive delta operations (numeric deltas, string edits)\n- Comprehensive algebraic laws verified by property tests\n\nThe proposed `Json` type (see #TBD) needs equivalent patching capabilities. Rather than converting `Json â†” DynamicValue` for every patch operation, a native `JsonPatch` provides:\n- Type safety (no conversion errors for JSON-incompatible DynamicPatch operations)\n- API consistency with the `Json` type\n- Potential for JSON-specific optimizations\n\n## Design Sketch\n\nA design sketch is available at [`[schema/shared/src/main/scala/zio/blocks/schema/json/JsonPatch.scala](https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/json/JsonPatch.scala)`](./schema/shared/src/main/scala/zio/blocks/schema/json/JsonPatch.scala). This sketch is **a guide, not a specification** â€” implementers should use judgment and deviate where appropriate.\n\n### Core Types\n\nThe design mirrors `DynamicPatch` with JSON-specific adaptations:\n\n| DynamicPatch | JsonPatch | Notes |\n|--------------|-----------|-------|\n| `DynamicPatch(Vector[DynamicPatchOp])` | `JsonPatch(Vector[JsonPatchOp])` | Same structure |\n| `Operation.Set` | `Op.Set` | Same |\n| `Operation.PrimitiveDelta` | `Op.PrimitiveDelta` | Simplified for JSON types |\n| `Operation.SequenceEdit` | `Op.ArrayEdit` | Renamed |\n| `Operation.MapEdit` | `Op.ObjectEdit` | String keys only |\n| `Operation.Patch` | `Op.Nested` | Same |\n| `SeqOp` | `ArrayOp` | Same operations |\n| `MapOp` | `ObjectOp` | String keys only |\n| `PrimitiveOp` (14 variants) | `PrimitiveOp` (2 variants) | See below |\n\n### Primitive Operations\n\nJSON has a simpler type system than `DynamicValue`:\n\n| JSON Type | Delta Operation | Notes |\n|-----------|-----------------|-------|\n| Number | `NumberDelta(BigDecimal)` | Unifies all numeric deltas |\n| String | `StringEdit(Vector[StringOp])` | Same as `DynamicPatch` |\n| Boolean | Use `Op.Set` | No delta (same as `DynamicPatch`) |\n| Null | Use `Op.Set` | No delta |\n\n### StringOp\n\nMirror `DynamicPatch.StringOp` exactly:\n- `Insert(index: Int, text: String)`\n- `Delete(index: Int, length: Int)`\n- `Append(text: String)`\n- `Modify(index: Int, length: Int, text: String)`\n\n### ArrayOp\n\nMirror `DynamicPatch.SeqOp`:\n- `Insert(index: Int, values: Vector[Json])`\n- `Append(values: Vector[Json])`\n- `Delete(index: Int, count: Int)`\n- `Modify(index: Int, op: Op)`\n\n### ObjectOp\n\nMirror `DynamicPatch.MapOp` with string keys:\n- `Add(key: String, value: Json)`\n- `Remove(key: String)`\n- `Modify(key: String, patch: JsonPatch)`\n\n## Requirements\n\n### Functional Requirements\n\n- [ ] **F1**: `JsonPatch.diff(source, target)` computes a patch transforming source to target\n- [ ] **F2**: `patch.apply(json, mode)` applies a patch with configurable failure handling\n- [ ] **F3**: `patch1 ++ patch2` composes patches (apply first, then second)\n- [ ] **F4**: `JsonPatch.empty` is the identity element for composition\n- [ ] **F5**: Support `JsonPatchMode.Strict`, `Lenient`, and `Clobber` modes\n- [ ] **F6**: Bidirectional conversion: `toDynamicPatch` / `fromDynamicPatch`\n\n### Algebraic Laws\n\nAll laws must be verified with property-based tests (see `PatchLawsSpec` for reference):\n\n- [ ] **L1**: Left identity â€” `(empty ++ p)(j) == p(j)`\n- [ ] **L2**: Right identity â€” `(p ++ empty)(j) == p(j)`\n- [ ] **L3**: Associativity â€” `((p1 ++ p2) ++ p3)(j) == (p1 ++ (p2 ++ p3))(j)`\n- [ ] **L4**: Roundtrip â€” `diff(a, b)(a) == Right(b)`\n- [ ] **L5**: Identity diff â€” `diff(j, j).isEmpty`\n- [ ] **L6**: Diff composition â€” `(diff(a, b) ++ diff(b, c))(a) == Right(c)`\n- [ ] **L7**: Lenient subsumes Strict â€” if `p(j, Strict) == Right(r)` then `p(j, Lenient) == Right(r)`\n\n### Testing Requirements\n\n- [ ] **T1**: Property-based tests for all algebraic laws (see `PatchLawsSpec`)\n- [ ] **T2**: Test each operation type (`Set`, `PrimitiveDelta`, `ArrayEdit`, `ObjectEdit`, `Nested`)\n- [ ] **T3**: Test each `ArrayOp` variant (`Insert`, `Append`, `Delete`, `Modify`)\n- [ ] **T4**: Test each `ObjectOp` variant (`Add`, `Remove`, `Modify`)\n- [ ] **T5**: Test each `StringOp` variant (`Insert`, `Delete`, `Append`, `Modify`)\n- [ ] **T6**: Test `NumberDelta` with positive, negative, zero, and decimal deltas\n- [ ] **T7**: Test all three `JsonPatchMode` behaviors\n- [ ] **T8**: Test `toDynamicPatch` / `fromDynamicPatch` roundtrip\n- [ ] **T9**: Test edge cases: empty arrays, empty objects, empty strings, nested structures\n- [ ] **T10**: Test error cases: invalid paths, type mismatches, out-of-bounds indices\n\n### Documentation Requirements\n\n- [ ] **D1**: ScalaDoc for all public types and methods\n- [ ] **D2**: Usage examples in ScalaDoc (see sketch for examples)\n- [ ] **D3**: Document algebraic laws in type-level comments\n- [ ] **D4**: Document relationship to `DynamicPatch`\n\n## Related\n\n- `DynamicPatch` â€” [`[schema/shared/src/main/scala/zio/blocks/schema/patch/DynamicPatch.scala](https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/DynamicPatch.scala)`](./schema/shared/src/main/scala/zio/blocks/schema/patch/DynamicPatch.scala)\n- `Differ` â€” [`[schema/shared/src/main/scala/zio/blocks/schema/patch/Differ.scala](https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/Differ.scala)`](./schema/shared/src/main/scala/zio/blocks/schema/patch/Differ.scala)\n- `PatchLawsSpec` â€” [`[schema/shared/src/test/scala/zio/blocks/schema/patch/PatchLawsSpec.scala](https://claude.ai/chat/schema/shared/src/test/scala/zio/blocks/schema/patch/PatchLawsSpec.scala)`](./schema/shared/src/test/scala/zio/blocks/schema/patch/PatchLawsSpec.scala)\n- `PatchMode` â€” [`[schema/shared/src/main/scala/zio/blocks/schema/patch/PatchMode.scala](https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/PatchMode.scala)`](./schema/shared/src/main/scala/zio/blocks/schema/patch/PatchMode.scala)\n\n## Acceptance Criteria\n\n- [ ] All functional requirements (F1-F6) implemented\n- [ ] All algebraic laws (L1-L7) pass property-based tests\n- [ ] All testing requirements (T1-T10) have corresponding test cases\n- [ ] All documentation requirements (D1-D4) complete\n- [ ] Code reviewed and approved\n- [ ] CI passing\n\n# Sketch\n\n```scala\npackage zio.blocks.schema.json\n\nimport zio.blocks.schema.DynamicOptic\nimport zio.blocks.schema.patch.DynamicPatch\n\n// =============================================================================\n// JSON PATCH\n// =============================================================================\n\n/**\n * An untyped patch that operates on [[Json]] values.\n *\n * `JsonPatch` is the JSON-specific counterpart to [[DynamicPatch]]. It represents\n * a sequence of operations that transform one JSON value into another. Patches\n * are serializable and composable.\n *\n * ==Design==\n *\n * This type directly mirrors [[DynamicPatch]] but is specialized for JSON's\n * simpler data model:\n *  - JSON has 4 leaf types (String, Number, Boolean, Null) vs 30 PrimitiveValues\n *  - JSON objects have string keys only (no arbitrary-keyed maps)\n *  - JSON has no native Variant type\n *\n * ==Algebraic Laws==\n *\n * '''Monoid Laws''' (under `++` composition):\n * {{{\n * // 1. LEFT IDENTITY\n * âˆ€ p: JsonPatch, j: Json.\n *   (JsonPatch.empty ++ p)(j, mode) == p(j, mode)\n *\n * // 2. RIGHT IDENTITY\n * âˆ€ p: JsonPatch, j: Json.\n *   (p ++ JsonPatch.empty)(j, mode) == p(j, mode)\n *\n * // 3. ASSOCIATIVITY\n * âˆ€ p1, p2, p3: JsonPatch, j: Json.\n *   ((p1 ++ p2) ++ p3)(j, mode) == (p1 ++ (p2 ++ p3))(j, mode)\n * }}}\n *\n * '''Diff/Apply Laws''':\n * {{{\n * // 4. ROUNDTRIP\n * âˆ€ source, target: Json.\n *   JsonPatch.diff(source, target)(source, Strict) == Right(target)\n *\n * // 5. IDENTITY DIFF\n * âˆ€ j: Json.\n *   JsonPatch.diff(j, j).isEmpty == true\n *\n * // 6. DIFF COMPOSITION\n * âˆ€ a, b, c: Json.\n *   (JsonPatch.diff(a, b) ++ JsonPatch.diff(b, c))(a, Strict) == Right(c)\n * }}}\n *\n * '''PatchMode Laws''':\n * {{{\n * // 7. STRICT FAILS ON ERROR\n * // Strict mode fails on first precondition violation\n *\n * // 8. LENIENT SKIPS ERRORS\n * // Lenient mode skips failing operations, always returns Right\n *\n * // 9. LENIENT SUBSUMES STRICT\n * âˆ€ p: JsonPatch, j: Json.\n *   p(j, Strict) == Right(r) implies p(j, Lenient) == Right(r)\n *\n * // 10. CLOBBER FORCES SUCCESS\n * // Clobber mode creates missing paths, always returns Right\n * }}}\n *\n * @param ops The sequence of patch operations\n */\nfinal case class JsonPatch(ops: Vector[JsonPatch.JsonPatchOp]) {\n\n  /**\n   * Applies this patch to a JSON value.\n   *\n   * @param json The JSON value to patch\n   * @param mode The patch mode (default: Strict)\n   * @return Either an error or the patched value\n   */\n  def apply(json: Json, mode: JsonPatchMode = JsonPatchMode.Strict): Either[JsonError, Json]\n\n  /**\n   * Composes this patch with another. Applies this patch first, then `that`.\n   *\n   * This is the monoid `combine` operation.\n   */\n  def ++(that: JsonPatch): JsonPatch = JsonPatch(ops ++ that.ops)\n\n  /**\n   * Returns true if this patch contains no operations.\n   */\n  def isEmpty: Boolean = ops.isEmpty\n\n  /**\n   * Converts this JSON patch to a [[DynamicPatch]].\n   */\n  def toDynamicPatch: DynamicPatch\n}\n\nobject JsonPatch {\n\n  /**\n   * Empty patch â€” the identity element for `++` composition.\n   */\n  val empty: JsonPatch = JsonPatch(Vector.empty)\n\n  /**\n   * Creates a patch with a single operation at the root path.\n   */\n  def root(op: Op): JsonPatch =\n    JsonPatch(Vector(JsonPatchOp(DynamicOptic.root, op)))\n\n  /**\n   * Creates a patch with a single operation at the given path.\n   */\n  def apply(path: DynamicOptic, op: Op): JsonPatch =\n    JsonPatch(Vector(JsonPatchOp(path, op)))\n\n  /**\n   * Computes a patch that transforms `oldJson` into `newJson`.\n   *\n   * Law: `diff(old, new)(old, Strict) == Right(new)`\n   */\n  def diff(oldJson: Json, newJson: Json): JsonPatch\n\n  /**\n   * Creates a JSON patch from a [[DynamicPatch]].\n   *\n   * May fail if the DynamicPatch contains operations not representable in JSON\n   * (e.g., non-string map keys, temporal deltas, variant operations).\n   */\n  def fromDynamicPatch(patch: DynamicPatch): Either[JsonError, JsonPatch]\n\n  // ===========================================================================\n  // JsonPatchOp â€” a single operation at a path\n  // ===========================================================================\n\n  /**\n   * A single patch operation: a path and what to do there.\n   *\n   * Mirrors [[DynamicPatch.DynamicPatchOp]].\n   */\n  final case class JsonPatchOp(path: DynamicOptic, op: Op)\n\n  // ===========================================================================\n  // Op â€” the operation to perform at a path\n  // ===========================================================================\n\n  /**\n   * The operation to perform at a target location.\n   *\n   * Mirrors [[DynamicPatch.Operation]] but specialized for JSON.\n   */\n  sealed trait Op\n\n  object Op {\n\n    /**\n     * Set a value directly (replacement).\n     *\n     * Mirrors [[DynamicPatch.Operation.Set]].\n     */\n    final case class Set(value: Json) extends Op\n\n    /**\n     * Apply a primitive delta operation.\n     *\n     * Used for numeric deltas and string edits.\n     * Mirrors [[DynamicPatch.Operation.PrimitiveDelta]].\n     */\n    final case class PrimitiveDelta(op: PrimitiveOp) extends Op\n\n    /**\n     * Apply array edit operations.\n     *\n     * Used for inserting, appending, deleting, or modifying array elements.\n     * Mirrors [[DynamicPatch.Operation.SequenceEdit]].\n     */\n    final case class ArrayEdit(ops: Vector[ArrayOp]) extends Op\n\n    /**\n     * Apply object edit operations.\n     *\n     * Used for adding, removing, or modifying object fields.\n     * Mirrors [[DynamicPatch.Operation.MapEdit]] but with string keys.\n     */\n    final case class ObjectEdit(ops: Vector[ObjectOp]) extends Op\n\n    /**\n     * Apply a nested patch.\n     *\n     * Used to group operations sharing a common path prefix.\n     * Mirrors [[DynamicPatch.Operation.Patch]].\n     */\n    final case class Nested(patch: JsonPatch) extends Op\n  }\n\n  // ===========================================================================\n  // PrimitiveOp â€” delta operations for JSON primitives\n  // ===========================================================================\n\n  /**\n   * Delta operations for JSON primitive values.\n   *\n   * JSON has only one numeric type, so we use BigDecimal for deltas.\n   * Boolean has no delta (use Set to toggle).\n   * Null has no delta (use Set to change).\n   *\n   * Mirrors [[DynamicPatch.PrimitiveOp]] but simplified for JSON's type system.\n   */\n  sealed trait PrimitiveOp\n\n  object PrimitiveOp {\n\n    /**\n     * Add a delta to a JSON number.\n     *\n     * Applied by: `currentValue + delta`\n     *\n     * Mirrors the numeric delta operations in [[DynamicPatch.PrimitiveOp]]\n     * (IntDelta, LongDelta, DoubleDelta, etc.) unified into one type.\n     */\n    final case class NumberDelta(delta: BigDecimal) extends PrimitiveOp\n\n    /**\n     * Apply string edit operations.\n     *\n     * Mirrors [[DynamicPatch.PrimitiveOp.StringEdit]].\n     */\n    final case class StringEdit(ops: Vector[StringOp]) extends PrimitiveOp\n  }\n\n  // ===========================================================================\n  // StringOp â€” edit operations for strings\n  // ===========================================================================\n\n  /**\n   * Edit operations for JSON strings.\n   *\n   * Mirrors [[DynamicPatch.StringOp]] exactly.\n   */\n  sealed trait StringOp\n\n  object StringOp {\n\n    /**\n     * Insert text at the given index.\n     */\n    final case class Insert(index: Int, text: String) extends StringOp\n\n    /**\n     * Delete characters starting at the given index.\n     */\n    final case class Delete(index: Int, length: Int) extends StringOp\n\n    /**\n     * Append text to the end of the string.\n     */\n    final case class Append(text: String) extends StringOp\n\n    /**\n     * Replace characters starting at index with new text.\n     */\n    final case class Modify(index: Int, length: Int, text: String) extends StringOp\n  }\n\n  // ===========================================================================\n  // ArrayOp â€” edit operations for arrays\n  // ===========================================================================\n\n  /**\n   * Edit operations for JSON arrays.\n   *\n   * Mirrors [[DynamicPatch.SeqOp]] but with Json values.\n   */\n  sealed trait ArrayOp\n\n  object ArrayOp {\n\n    /**\n     * Insert values at the given index.\n     */\n    final case class Insert(index: Int, values: Vector[Json]) extends ArrayOp\n\n    /**\n     * Append values to the end of the array.\n     */\n    final case class Append(values: Vector[Json]) extends ArrayOp\n\n    /**\n     * Delete elements starting at the given index.\n     */\n    final case class Delete(index: Int, count: Int) extends ArrayOp\n\n    /**\n     * Modify the element at the given index with a nested operation.\n     */\n    final case class Modify(index: Int, op: Op) extends ArrayOp\n  }\n\n  // ===========================================================================\n  // ObjectOp â€” edit operations for objects\n  // ===========================================================================\n\n  /**\n   * Edit operations for JSON objects.\n   *\n   * Mirrors [[DynamicPatch.MapOp]] but with string keys (JSON constraint).\n   */\n  sealed trait ObjectOp\n\n  object ObjectOp {\n\n    /**\n     * Add a field to the object.\n     */\n    final case class Add(key: String, value: Json) extends ObjectOp\n\n    /**\n     * Remove a field from the object.\n     */\n    final case class Remove(key: String) extends ObjectOp\n\n    /**\n     * Modify a field's value with a nested patch.\n     */\n    final case class Modify(key: String, patch: JsonPatch) extends ObjectOp\n  }\n}\n\n// =============================================================================\n// PATCH MODE\n// =============================================================================\n\n/**\n * Controls how patch application handles failures.\n *\n * Mirrors [[zio.blocks.schema.patch.PatchMode]].\n */\nsealed trait JsonPatchMode\n\nobject JsonPatchMode {\n\n  /**\n   * Fail on precondition violations.\n   */\n  case object Strict extends JsonPatchMode\n\n  /**\n   * Skip operations that fail preconditions.\n   */\n  case object Lenient extends JsonPatchMode\n\n  /**\n   * Replace/overwrite on conflicts (create missing paths).\n   */\n  case object Clobber extends JsonPatchMode\n}\n\n// =============================================================================\n// USAGE EXAMPLES\n// =============================================================================\n\n/*\n * ==Example 1: Basic Patching==\n *\n * {{{\n * import zio.blocks.schema.json._\n *\n * val json = Json.Object(Vector(\n *   \"name\" -> Json.String(\"Alice\"),\n *   \"age\" -> Json.Number(\"30\")\n * ))\n *\n * // Replace name\n * val patch = JsonPatch.root(JsonPatch.Op.Set(Json.String(\"Bob\")))\n *   // Or at a specific path:\n *   // JsonPatch(DynamicOptic.root.field(\"name\"), JsonPatch.Op.Set(Json.String(\"Bob\")))\n *\n * val result = patch(json, JsonPatchMode.Strict)\n * }}}\n *\n * ==Example 2: Diff and Apply (Roundtrip Law)==\n *\n * {{{\n * val source = Json.Object(Vector(\"x\" -> Json.Number(\"1\")))\n * val target = Json.Object(Vector(\"x\" -> Json.Number(\"5\")))\n *\n * val patch = JsonPatch.diff(source, target)\n *\n * // Roundtrip law\n * assert(patch(source, JsonPatchMode.Strict) == Right(target))\n *\n * // Identity diff law\n * assert(JsonPatch.diff(source, source).isEmpty)\n * }}}\n *\n * ==Example 3: Monoid Laws==\n *\n * {{{\n * val p1 = JsonPatch.diff(a, b)\n * val p2 = JsonPatch.diff(b, c)\n * val p3 = JsonPatch.diff(c, d)\n *\n * // Left identity\n * assert((JsonPatch.empty ++ p1)(a, Strict) == p1(a, Strict))\n *\n * // Right identity\n * assert((p1 ++ JsonPatch.empty)(a, Strict) == p1(a, Strict))\n *\n * // Associativity\n * assert(((p1 ++ p2) ++ p3)(a, Strict) == (p1 ++ (p2 ++ p3))(a, Strict))\n * }}}\n *\n * ==Example 4: Numeric Delta==\n *\n * {{{\n * val json = Json.Number(\"10\")\n *\n * // Add 5 to the number (more efficient than Set for large structures)\n * val patch = JsonPatch.root(\n *   JsonPatch.Op.PrimitiveDelta(JsonPatch.PrimitiveOp.NumberDelta(BigDecimal(5)))\n * )\n *\n * assert(patch(json, Strict) == Right(Json.Number(\"15\")))\n * }}}\n *\n * ==Example 5: String Edit==\n *\n * {{{\n * val json = Json.String(\"hello world\")\n *\n * // Change \"hello\" to \"hi\" using LCS-based edits\n * val patch = JsonPatch.root(\n *   JsonPatch.Op.PrimitiveDelta(\n *     JsonPatch.PrimitiveOp.StringEdit(Vector(\n *       JsonPatch.StringOp.Delete(0, 5),\n *       JsonPatch.StringOp.Insert(0, \"hi\")\n *     ))\n *   )\n * )\n *\n * assert(patch(json, Strict) == Right(Json.String(\"hi world\")))\n * }}}\n *\n * ==Example 6: Array Edit==\n *\n * {{{\n * val json = Json.Array(Vector(Json.Number(\"1\"), Json.Number(\"2\"), Json.Number(\"3\")))\n *\n * // Delete element at index 1, append new element\n * val patch = JsonPatch.root(\n *   JsonPatch.Op.ArrayEdit(Vector(\n *     JsonPatch.ArrayOp.Delete(1, 1),\n *     JsonPatch.ArrayOp.Append(Vector(Json.Number(\"4\")))\n *   ))\n * )\n *\n * // Result: [1, 3, 4]\n * }}}\n *\n * ==Example 7: Object Edit==\n *\n * {{{\n * val json = Json.Object(Vector(\"a\" -> Json.Number(\"1\"), \"b\" -> Json.Number(\"2\")))\n *\n * // Remove field \"a\", add field \"c\"\n * val patch = JsonPatch.root(\n *   JsonPatch.Op.ObjectEdit(Vector(\n *     JsonPatch.ObjectOp.Remove(\"a\"),\n *     JsonPatch.ObjectOp.Add(\"c\", Json.Number(\"3\"))\n *   ))\n * )\n *\n * // Result: {\"b\": 2, \"c\": 3}\n * }}}\n *\n * ==Example 8: Nested Patch==\n *\n * {{{\n * val json = Json.Object(Vector(\n *   \"user\" -> Json.Object(Vector(\n *     \"name\" -> Json.String(\"Alice\"),\n *     \"age\" -> Json.Number(\"30\")\n *   ))\n * ))\n *\n * // Patch nested inside \"user\"\n * val innerPatch = JsonPatch(Vector(\n *   JsonPatch.JsonPatchOp(\n *     DynamicOptic.root.field(\"age\"),\n *     JsonPatch.Op.PrimitiveDelta(JsonPatch.PrimitiveOp.NumberDelta(BigDecimal(1)))\n *   )\n * ))\n *\n * val patch = JsonPatch(\n *   DynamicOptic.root.field(\"user\"),\n *   JsonPatch.Op.Nested(innerPatch)\n * )\n *\n * // Increments user.age by 1\n * }}}\n *\n * ==Example 9: Diff Composition Law==\n *\n * {{{\n * val a = Json.Number(\"1\")\n * val b = Json.Number(\"5\")\n * val c = Json.Number(\"10\")\n *\n * val p1 = JsonPatch.diff(a, b)  // delta +4\n * val p2 = JsonPatch.diff(b, c)  // delta +5\n *\n * // Composition law: applying composed patch equals applying sequentially\n * assert((p1 ++ p2)(a, Strict) == Right(c))\n * }}}\n *\n * ==Example 10: PatchMode Behavior==\n *\n * {{{\n * val json = Json.Object(Vector(\"a\" -> Json.Number(\"1\")))\n *\n * // Try to remove non-existent field\n * val patch = JsonPatch.root(\n *   JsonPatch.Op.ObjectEdit(Vector(JsonPatch.ObjectOp.Remove(\"nonexistent\")))\n * )\n *\n * // Strict: fails\n * assert(patch(json, JsonPatchMode.Strict).isLeft)\n *\n * // Lenient: skips, returns unchanged\n * assert(patch(json, JsonPatchMode.Lenient) == Right(json))\n *\n * // Clobber: skips (nothing to clobber), returns unchanged\n * assert(patch(json, JsonPatchMode.Clobber) == Right(json))\n * }}}\n */\n```",
                  "html_url": "https://github.com/zio/zio-blocks/issues/685"
                },
                "type": "github"
              },
              "hash": "zio/zio-blocks#685",
              "body": "<html><head></head><body><h1>Add <code>JsonPatch</code> type for diffing and patching JSON values</h1>\n<h2>Summary</h2>\n<p>Implement a <code>JsonPatch</code> type that enables computing diffs between JSON values and applying patches to transform one JSON value into another. This type should mirror the existing <code>DynamicPatch</code> implementation, adapted for JSON's simpler data model.</p>\n<h2>Motivation</h2>\n<p><code>DynamicValue</code> has a well-designed <code>DynamicPatch</code> system with:</p>\n<ul>\n<li>Monoid composition (<code>++</code> with <code>empty</code> identity)</li>\n<li>LCS-based sequence diffing</li>\n<li>Primitive delta operations (numeric deltas, string edits)</li>\n<li>Comprehensive algebraic laws verified by property tests</li>\n</ul>\n<p>The proposed <code>Json</code> type (see #TBD) needs equivalent patching capabilities. Rather than converting <code>Json â†” DynamicValue</code> for every patch operation, a native <code>JsonPatch</code> provides:</p>\n<ul>\n<li>Type safety (no conversion errors for JSON-incompatible DynamicPatch operations)</li>\n<li>API consistency with the <code>Json</code> type</li>\n<li>Potential for JSON-specific optimizations</li>\n</ul>\n<h2>Design Sketch</h2>\n<p>A design sketch is available at <a href=\"https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/json/JsonPatch.scala\"><code>schema/shared/src/main/scala/zio/blocks/schema/json/JsonPatch.scala</code></a>. This sketch is <strong>a guide, not a specification</strong> â€” implementers should use judgment and deviate where appropriate.</p>\n<h3>Core Types</h3>\n<p>The design mirrors <code>DynamicPatch</code> with JSON-specific adaptations:</p>\n\nDynamicPatch | JsonPatch | Notes\n-- | -- | --\nDynamicPatch(Vector[DynamicPatchOp]) | JsonPatch(Vector[JsonPatchOp]) | Same structure\nOperation.Set | Op.Set | Same\nOperation.PrimitiveDelta | Op.PrimitiveDelta | Simplified for JSON types\nOperation.SequenceEdit | Op.ArrayEdit | Renamed\nOperation.MapEdit | Op.ObjectEdit | String keys only\nOperation.Patch | Op.Nested | Same\nSeqOp | ArrayOp | Same operations\nMapOp | ObjectOp | String keys only\nPrimitiveOp (14 variants) | PrimitiveOp (2 variants) | See below\n\n\n<h3>StringOp</h3>\n<p>Mirror <code>DynamicPatch.StringOp</code> exactly:</p>\n<ul>\n<li><code>Insert(index: Int, text: String)</code></li>\n<li><code>Delete(index: Int, length: Int)</code></li>\n<li><code>Append(text: String)</code></li>\n<li><code>Modify(index: Int, length: Int, text: String)</code></li>\n</ul>\n<h3>ArrayOp</h3>\n<p>Mirror <code>DynamicPatch.SeqOp</code>:</p>\n<ul>\n<li><code>Insert(index: Int, values: Vector[Json])</code></li>\n<li><code>Append(values: Vector[Json])</code></li>\n<li><code>Delete(index: Int, count: Int)</code></li>\n<li><code>Modify(index: Int, op: Op)</code></li>\n</ul>\n<h3>ObjectOp</h3>\n<p>Mirror <code>DynamicPatch.MapOp</code> with string keys:</p>\n<ul>\n<li><code>Add(key: String, value: Json)</code></li>\n<li><code>Remove(key: String)</code></li>\n<li><code>Modify(key: String, patch: JsonPatch)</code></li>\n</ul>\n<h2>Requirements</h2>\n<h3>Functional Requirements</h3>\n<ul>\n<li>[ ] <strong>F1</strong>: <code>JsonPatch.diff(source, target)</code> computes a patch transforming source to target</li>\n<li>[ ] <strong>F2</strong>: <code>patch.apply(json, mode)</code> applies a patch with configurable failure handling</li>\n<li>[ ] <strong>F3</strong>: <code>patch1 ++ patch2</code> composes patches (apply first, then second)</li>\n<li>[ ] <strong>F4</strong>: <code>JsonPatch.empty</code> is the identity element for composition</li>\n<li>[ ] <strong>F5</strong>: Support <code>JsonPatchMode.Strict</code>, <code>Lenient</code>, and <code>Clobber</code> modes</li>\n<li>[ ] <strong>F6</strong>: Bidirectional conversion: <code>toDynamicPatch</code> / <code>fromDynamicPatch</code></li>\n</ul>\n<h3>Algebraic Laws</h3>\n<p>All laws must be verified with property-based tests (see <code>PatchLawsSpec</code> for reference):</p>\n<ul>\n<li>[ ] <strong>L1</strong>: Left identity â€” <code>(empty ++ p)(j) == p(j)</code></li>\n<li>[ ] <strong>L2</strong>: Right identity â€” <code>(p ++ empty)(j) == p(j)</code></li>\n<li>[ ] <strong>L3</strong>: Associativity â€” <code>((p1 ++ p2) ++ p3)(j) == (p1 ++ (p2 ++ p3))(j)</code></li>\n<li>[ ] <strong>L4</strong>: Roundtrip â€” <code>diff(a, b)(a) == Right(b)</code></li>\n<li>[ ] <strong>L5</strong>: Identity diff â€” <code>diff(j, j).isEmpty</code></li>\n<li>[ ] <strong>L6</strong>: Diff composition â€” <code>(diff(a, b) ++ diff(b, c))(a) == Right(c)</code></li>\n<li>[ ] <strong>L7</strong>: Lenient subsumes Strict â€” if <code>p(j, Strict) == Right(r)</code> then <code>p(j, Lenient) == Right(r)</code></li>\n</ul>\n<h3>Testing Requirements</h3>\n<ul>\n<li>[ ] <strong>T1</strong>: Property-based tests for all algebraic laws (see <code>PatchLawsSpec</code>)</li>\n<li>[ ] <strong>T2</strong>: Test each operation type (<code>Set</code>, <code>PrimitiveDelta</code>, <code>ArrayEdit</code>, <code>ObjectEdit</code>, <code>Nested</code>)</li>\n<li>[ ] <strong>T3</strong>: Test each <code>ArrayOp</code> variant (<code>Insert</code>, <code>Append</code>, <code>Delete</code>, <code>Modify</code>)</li>\n<li>[ ] <strong>T4</strong>: Test each <code>ObjectOp</code> variant (<code>Add</code>, <code>Remove</code>, <code>Modify</code>)</li>\n<li>[ ] <strong>T5</strong>: Test each <code>StringOp</code> variant (<code>Insert</code>, <code>Delete</code>, <code>Append</code>, <code>Modify</code>)</li>\n<li>[ ] <strong>T6</strong>: Test <code>NumberDelta</code> with positive, negative, zero, and decimal deltas</li>\n<li>[ ] <strong>T7</strong>: Test all three <code>JsonPatchMode</code> behaviors</li>\n<li>[ ] <strong>T8</strong>: Test <code>toDynamicPatch</code> / <code>fromDynamicPatch</code> roundtrip</li>\n<li>[ ] <strong>T9</strong>: Test edge cases: empty arrays, empty objects, empty strings, nested structures</li>\n<li>[ ] <strong>T10</strong>: Test error cases: invalid paths, type mismatches, out-of-bounds indices</li>\n</ul>\n<h3>Documentation Requirements</h3>\n<ul>\n<li>[ ] <strong>D1</strong>: ScalaDoc for all public types and methods</li>\n<li>[ ] <strong>D2</strong>: Usage examples in ScalaDoc (see sketch for examples)</li>\n<li>[ ] <strong>D3</strong>: Document algebraic laws in type-level comments</li>\n<li>[ ] <strong>D4</strong>: Document relationship to <code>DynamicPatch</code></li>\n</ul>\n<h3>Implementation Notes</h3>\n<ol>\n<li>\n<p><strong>Follow <code>DynamicPatch</code> patterns</strong>: The implementation in <code>DynamicPatch.scala</code> is the reference. Study <code>Differ.scala</code> for diff algorithms (especially LCS for sequences and strings).</p>\n</li>\n<li>\n<p><strong>Reuse algorithms where possible</strong>: Consider whether <code>JsonPatch</code> can delegate to <code>DynamicPatch</code> internally, or share algorithm implementations.</p>\n</li>\n<li>\n<p><strong>Keep it minimal</strong>: Resist adding operations not present in <code>DynamicPatch</code>. The design is intentionally minimal and principled.</p>\n</li>\n<li>\n<p><strong>Performance considerations</strong>: The register-based design of ZIO Blocks prioritizes performance. Avoid unnecessary allocations in hot paths.</p>\n</li>\n</ol>\n<h2>Out of Scope</h2>\n<p>The following are explicitly <strong>not</strong> part of this issue:</p>\n<ul>\n<li>RFC 6902 JSON Patch serialization format (separate issue)</li>\n<li>Patch inversion / undo support (separate issue)</li>\n<li>Patch optimization / compaction (separate issue)</li>\n<li>Integration with <code>Json</code> type methods like <code>json.diff(other)</code> (depends on <code>Json</code> implementation)</li>\n</ul>\n<h2>Related</h2>\n<ul>\n<li><code>DynamicPatch</code> â€” <a href=\"https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/DynamicPatch.scala\"><code>schema/shared/src/main/scala/zio/blocks/schema/patch/DynamicPatch.scala</code></a></li>\n<li><code>Differ</code> â€” <a href=\"https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/Differ.scala\"><code>schema/shared/src/main/scala/zio/blocks/schema/patch/Differ.scala</code></a></li>\n<li><code>PatchLawsSpec</code> â€” <a href=\"https://claude.ai/chat/schema/shared/src/test/scala/zio/blocks/schema/patch/PatchLawsSpec.scala\"><code>schema/shared/src/test/scala/zio/blocks/schema/patch/PatchLawsSpec.scala</code></a></li>\n<li><code>PatchMode</code> â€” <a href=\"https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/PatchMode.scala\"><code>schema/shared/src/main/scala/zio/blocks/schema/patch/PatchMode.scala</code></a></li>\n</ul>\n<h2>Acceptance Criteria</h2>\n<ul>\n<li>[ ] All functional requirements (F1-F6) implemented</li>\n<li>[ ] All algebraic laws (L1-L7) pass property-based tests</li>\n<li>[ ] All testing requirements (T1-T10) have corresponding test cases</li>\n<li>[ ] All documentation requirements (D1-D4) complete</li>\n<li>[ ] Code reviewed and approved</li>\n<li>[ ] CI passing</li>\n</ul></body></html># Add `JsonPatch` type for diffing and patching JSON values\n\n## Summary\n\nImplement a `JsonPatch` type that enables computing diffs between JSON values and applying patches to transform one JSON value into another. This type should mirror the existing `DynamicPatch` implementation, adapted for JSON's simpler data model.\n\n## Motivation\n\n`DynamicValue` has a well-designed `DynamicPatch` system with:\n- Monoid composition (`++` with `empty` identity)\n- LCS-based sequence diffing\n- Primitive delta operations (numeric deltas, string edits)\n- Comprehensive algebraic laws verified by property tests\n\nThe proposed `Json` type (see #TBD) needs equivalent patching capabilities. Rather than converting `Json â†” DynamicValue` for every patch operation, a native `JsonPatch` provides:\n- Type safety (no conversion errors for JSON-incompatible DynamicPatch operations)\n- API consistency with the `Json` type\n- Potential for JSON-specific optimizations\n\n## Design Sketch\n\nA design sketch is available at [`[schema/shared/src/main/scala/zio/blocks/schema/json/JsonPatch.scala](https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/json/JsonPatch.scala)`](./schema/shared/src/main/scala/zio/blocks/schema/json/JsonPatch.scala). This sketch is **a guide, not a specification** â€” implementers should use judgment and deviate where appropriate.\n\n### Core Types\n\nThe design mirrors `DynamicPatch` with JSON-specific adaptations:\n\n| DynamicPatch | JsonPatch | Notes |\n|--------------|-----------|-------|\n| `DynamicPatch(Vector[DynamicPatchOp])` | `JsonPatch(Vector[JsonPatchOp])` | Same structure |\n| `Operation.Set` | `Op.Set` | Same |\n| `Operation.PrimitiveDelta` | `Op.PrimitiveDelta` | Simplified for JSON types |\n| `Operation.SequenceEdit` | `Op.ArrayEdit` | Renamed |\n| `Operation.MapEdit` | `Op.ObjectEdit` | String keys only |\n| `Operation.Patch` | `Op.Nested` | Same |\n| `SeqOp` | `ArrayOp` | Same operations |\n| `MapOp` | `ObjectOp` | String keys only |\n| `PrimitiveOp` (14 variants) | `PrimitiveOp` (2 variants) | See below |\n\n### Primitive Operations\n\nJSON has a simpler type system than `DynamicValue`:\n\n| JSON Type | Delta Operation | Notes |\n|-----------|-----------------|-------|\n| Number | `NumberDelta(BigDecimal)` | Unifies all numeric deltas |\n| String | `StringEdit(Vector[StringOp])` | Same as `DynamicPatch` |\n| Boolean | Use `Op.Set` | No delta (same as `DynamicPatch`) |\n| Null | Use `Op.Set` | No delta |\n\n### StringOp\n\nMirror `DynamicPatch.StringOp` exactly:\n- `Insert(index: Int, text: String)`\n- `Delete(index: Int, length: Int)`\n- `Append(text: String)`\n- `Modify(index: Int, length: Int, text: String)`\n\n### ArrayOp\n\nMirror `DynamicPatch.SeqOp`:\n- `Insert(index: Int, values: Vector[Json])`\n- `Append(values: Vector[Json])`\n- `Delete(index: Int, count: Int)`\n- `Modify(index: Int, op: Op)`\n\n### ObjectOp\n\nMirror `DynamicPatch.MapOp` with string keys:\n- `Add(key: String, value: Json)`\n- `Remove(key: String)`\n- `Modify(key: String, patch: JsonPatch)`\n\n## Requirements\n\n### Functional Requirements\n\n- [ ] **F1**: `JsonPatch.diff(source, target)` computes a patch transforming source to target\n- [ ] **F2**: `patch.apply(json, mode)` applies a patch with configurable failure handling\n- [ ] **F3**: `patch1 ++ patch2` composes patches (apply first, then second)\n- [ ] **F4**: `JsonPatch.empty` is the identity element for composition\n- [ ] **F5**: Support `JsonPatchMode.Strict`, `Lenient`, and `Clobber` modes\n- [ ] **F6**: Bidirectional conversion: `toDynamicPatch` / `fromDynamicPatch`\n\n### Algebraic Laws\n\nAll laws must be verified with property-based tests (see `PatchLawsSpec` for reference):\n\n- [ ] **L1**: Left identity â€” `(empty ++ p)(j) == p(j)`\n- [ ] **L2**: Right identity â€” `(p ++ empty)(j) == p(j)`\n- [ ] **L3**: Associativity â€” `((p1 ++ p2) ++ p3)(j) == (p1 ++ (p2 ++ p3))(j)`\n- [ ] **L4**: Roundtrip â€” `diff(a, b)(a) == Right(b)`\n- [ ] **L5**: Identity diff â€” `diff(j, j).isEmpty`\n- [ ] **L6**: Diff composition â€” `(diff(a, b) ++ diff(b, c))(a) == Right(c)`\n- [ ] **L7**: Lenient subsumes Strict â€” if `p(j, Strict) == Right(r)` then `p(j, Lenient) == Right(r)`\n\n### Testing Requirements\n\n- [ ] **T1**: Property-based tests for all algebraic laws (see `PatchLawsSpec`)\n- [ ] **T2**: Test each operation type (`Set`, `PrimitiveDelta`, `ArrayEdit`, `ObjectEdit`, `Nested`)\n- [ ] **T3**: Test each `ArrayOp` variant (`Insert`, `Append`, `Delete`, `Modify`)\n- [ ] **T4**: Test each `ObjectOp` variant (`Add`, `Remove`, `Modify`)\n- [ ] **T5**: Test each `StringOp` variant (`Insert`, `Delete`, `Append`, `Modify`)\n- [ ] **T6**: Test `NumberDelta` with positive, negative, zero, and decimal deltas\n- [ ] **T7**: Test all three `JsonPatchMode` behaviors\n- [ ] **T8**: Test `toDynamicPatch` / `fromDynamicPatch` roundtrip\n- [ ] **T9**: Test edge cases: empty arrays, empty objects, empty strings, nested structures\n- [ ] **T10**: Test error cases: invalid paths, type mismatches, out-of-bounds indices\n\n### Documentation Requirements\n\n- [ ] **D1**: ScalaDoc for all public types and methods\n- [ ] **D2**: Usage examples in ScalaDoc (see sketch for examples)\n- [ ] **D3**: Document algebraic laws in type-level comments\n- [ ] **D4**: Document relationship to `DynamicPatch`\n\n## Related\n\n- `DynamicPatch` â€” [`[schema/shared/src/main/scala/zio/blocks/schema/patch/DynamicPatch.scala](https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/DynamicPatch.scala)`](./schema/shared/src/main/scala/zio/blocks/schema/patch/DynamicPatch.scala)\n- `Differ` â€” [`[schema/shared/src/main/scala/zio/blocks/schema/patch/Differ.scala](https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/Differ.scala)`](./schema/shared/src/main/scala/zio/blocks/schema/patch/Differ.scala)\n- `PatchLawsSpec` â€” [`[schema/shared/src/test/scala/zio/blocks/schema/patch/PatchLawsSpec.scala](https://claude.ai/chat/schema/shared/src/test/scala/zio/blocks/schema/patch/PatchLawsSpec.scala)`](./schema/shared/src/test/scala/zio/blocks/schema/patch/PatchLawsSpec.scala)\n- `PatchMode` â€” [`[schema/shared/src/main/scala/zio/blocks/schema/patch/PatchMode.scala](https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/PatchMode.scala)`](./schema/shared/src/main/scala/zio/blocks/schema/patch/PatchMode.scala)\n\n## Acceptance Criteria\n\n- [ ] All functional requirements (F1-F6) implemented\n- [ ] All algebraic laws (L1-L7) pass property-based tests\n- [ ] All testing requirements (T1-T10) have corresponding test cases\n- [ ] All documentation requirements (D1-D4) complete\n- [ ] Code reviewed and approved\n- [ ] CI passing\n\n# Sketch\n\n```scala\npackage zio.blocks.schema.json\n\nimport zio.blocks.schema.DynamicOptic\nimport zio.blocks.schema.patch.DynamicPatch\n\n// =============================================================================\n// JSON PATCH\n// =============================================================================\n\n/**\n * An untyped patch that operates on [[Json]] values.\n *\n * `JsonPatch` is the JSON-specific counterpart to [[DynamicPatch]]. It represents\n * a sequence of operations that transform one JSON value into another. Patches\n * are serializable and composable.\n *\n * ==Design==\n *\n * This type directly mirrors [[DynamicPatch]] but is specialized for JSON's\n * simpler data model:\n *  - JSON has 4 leaf types (String, Number, Boolean, Null) vs 30 PrimitiveValues\n *  - JSON objects have string keys only (no arbitrary-keyed maps)\n *  - JSON has no native Variant type\n *\n * ==Algebraic Laws==\n *\n * '''Monoid Laws''' (under `++` composition):\n * {{{\n * // 1. LEFT IDENTITY\n * âˆ€ p: JsonPatch, j: Json.\n *   (JsonPatch.empty ++ p)(j, mode) == p(j, mode)\n *\n * // 2. RIGHT IDENTITY\n * âˆ€ p: JsonPatch, j: Json.\n *   (p ++ JsonPatch.empty)(j, mode) == p(j, mode)\n *\n * // 3. ASSOCIATIVITY\n * âˆ€ p1, p2, p3: JsonPatch, j: Json.\n *   ((p1 ++ p2) ++ p3)(j, mode) == (p1 ++ (p2 ++ p3))(j, mode)\n * }}}\n *\n * '''Diff/Apply Laws''':\n * {{{\n * // 4. ROUNDTRIP\n * âˆ€ source, target: Json.\n *   JsonPatch.diff(source, target)(source, Strict) == Right(target)\n *\n * // 5. IDENTITY DIFF\n * âˆ€ j: Json.\n *   JsonPatch.diff(j, j).isEmpty == true\n *\n * // 6. DIFF COMPOSITION\n * âˆ€ a, b, c: Json.\n *   (JsonPatch.diff(a, b) ++ JsonPatch.diff(b, c))(a, Strict) == Right(c)\n * }}}\n *\n * '''PatchMode Laws''':\n * {{{\n * // 7. STRICT FAILS ON ERROR\n * // Strict mode fails on first precondition violation\n *\n * // 8. LENIENT SKIPS ERRORS\n * // Lenient mode skips failing operations, always returns Right\n *\n * // 9. LENIENT SUBSUMES STRICT\n * âˆ€ p: JsonPatch, j: Json.\n *   p(j, Strict) == Right(r) implies p(j, Lenient) == Right(r)\n *\n * // 10. CLOBBER FORCES SUCCESS\n * // Clobber mode creates missing paths, always returns Right\n * }}}\n *\n * @param ops The sequence of patch operations\n */\nfinal case class JsonPatch(ops: Vector[JsonPatch.JsonPatchOp]) {\n\n  /**\n   * Applies this patch to a JSON value.\n   *\n   * @param json The JSON value to patch\n   * @param mode The patch mode (default: Strict)\n   * @return Either an error or the patched value\n   */\n  def apply(json: Json, mode: JsonPatchMode = JsonPatchMode.Strict): Either[JsonError, Json]\n\n  /**\n   * Composes this patch with another. Applies this patch first, then `that`.\n   *\n   * This is the monoid `combine` operation.\n   */\n  def ++(that: JsonPatch): JsonPatch = JsonPatch(ops ++ that.ops)\n\n  /**\n   * Returns true if this patch contains no operations.\n   */\n  def isEmpty: Boolean = ops.isEmpty\n\n  /**\n   * Converts this JSON patch to a [[DynamicPatch]].\n   */\n  def toDynamicPatch: DynamicPatch\n}\n\nobject JsonPatch {\n\n  /**\n   * Empty patch â€” the identity element for `++` composition.\n   */\n  val empty: JsonPatch = JsonPatch(Vector.empty)\n\n  /**\n   * Creates a patch with a single operation at the root path.\n   */\n  def root(op: Op): JsonPatch =\n    JsonPatch(Vector(JsonPatchOp(DynamicOptic.root, op)))\n\n  /**\n   * Creates a patch with a single operation at the given path.\n   */\n  def apply(path: DynamicOptic, op: Op): JsonPatch =\n    JsonPatch(Vector(JsonPatchOp(path, op)))\n\n  /**\n   * Computes a patch that transforms `oldJson` into `newJson`.\n   *\n   * Law: `diff(old, new)(old, Strict) == Right(new)`\n   */\n  def diff(oldJson: Json, newJson: Json): JsonPatch\n\n  /**\n   * Creates a JSON patch from a [[DynamicPatch]].\n   *\n   * May fail if the DynamicPatch contains operations not representable in JSON\n   * (e.g., non-string map keys, temporal deltas, variant operations).\n   */\n  def fromDynamicPatch(patch: DynamicPatch): Either[JsonError, JsonPatch]\n\n  // ===========================================================================\n  // JsonPatchOp â€” a single operation at a path\n  // ===========================================================================\n\n  /**\n   * A single patch operation: a path and what to do there.\n   *\n   * Mirrors [[DynamicPatch.DynamicPatchOp]].\n   */\n  final case class JsonPatchOp(path: DynamicOptic, op: Op)\n\n  // ===========================================================================\n  // Op â€” the operation to perform at a path\n  // ===========================================================================\n\n  /**\n   * The operation to perform at a target location.\n   *\n   * Mirrors [[DynamicPatch.Operation]] but specialized for JSON.\n   */\n  sealed trait Op\n\n  object Op {\n\n    /**\n     * Set a value directly (replacement).\n     *\n     * Mirrors [[DynamicPatch.Operation.Set]].\n     */\n    final case class Set(value: Json) extends Op\n\n    /**\n     * Apply a primitive delta operation.\n     *\n     * Used for numeric deltas and string edits.\n     * Mirrors [[DynamicPatch.Operation.PrimitiveDelta]].\n     */\n    final case class PrimitiveDelta(op: PrimitiveOp) extends Op\n\n    /**\n     * Apply array edit operations.\n     *\n     * Used for inserting, appending, deleting, or modifying array elements.\n     * Mirrors [[DynamicPatch.Operation.SequenceEdit]].\n     */\n    final case class ArrayEdit(ops: Vector[ArrayOp]) extends Op\n\n    /**\n     * Apply object edit operations.\n     *\n     * Used for adding, removing, or modifying object fields.\n     * Mirrors [[DynamicPatch.Operation.MapEdit]] but with string keys.\n     */\n    final case class ObjectEdit(ops: Vector[ObjectOp]) extends Op\n\n    /**\n     * Apply a nested patch.\n     *\n     * Used to group operations sharing a common path prefix.\n     * Mirrors [[DynamicPatch.Operation.Patch]].\n     */\n    final case class Nested(patch: JsonPatch) extends Op\n  }\n\n  // ===========================================================================\n  // PrimitiveOp â€” delta operations for JSON primitives\n  // ===========================================================================\n\n  /**\n   * Delta operations for JSON primitive values.\n   *\n   * JSON has only one numeric type, so we use BigDecimal for deltas.\n   * Boolean has no delta (use Set to toggle).\n   * Null has no delta (use Set to change).\n   *\n   * Mirrors [[DynamicPatch.PrimitiveOp]] but simplified for JSON's type system.\n   */\n  sealed trait PrimitiveOp\n\n  object PrimitiveOp {\n\n    /**\n     * Add a delta to a JSON number.\n     *\n     * Applied by: `currentValue + delta`\n     *\n     * Mirrors the numeric delta operations in [[DynamicPatch.PrimitiveOp]]\n     * (IntDelta, LongDelta, DoubleDelta, etc.) unified into one type.\n     */\n    final case class NumberDelta(delta: BigDecimal) extends PrimitiveOp\n\n    /**\n     * Apply string edit operations.\n     *\n     * Mirrors [[DynamicPatch.PrimitiveOp.StringEdit]].\n     */\n    final case class StringEdit(ops: Vector[StringOp]) extends PrimitiveOp\n  }\n\n  // ===========================================================================\n  // StringOp â€” edit operations for strings\n  // ===========================================================================\n\n  /**\n   * Edit operations for JSON strings.\n   *\n   * Mirrors [[DynamicPatch.StringOp]] exactly.\n   */\n  sealed trait StringOp\n\n  object StringOp {\n\n    /**\n     * Insert text at the given index.\n     */\n    final case class Insert(index: Int, text: String) extends StringOp\n\n    /**\n     * Delete characters starting at the given index.\n     */\n    final case class Delete(index: Int, length: Int) extends StringOp\n\n    /**\n     * Append text to the end of the string.\n     */\n    final case class Append(text: String) extends StringOp\n\n    /**\n     * Replace characters starting at index with new text.\n     */\n    final case class Modify(index: Int, length: Int, text: String) extends StringOp\n  }\n\n  // ===========================================================================\n  // ArrayOp â€” edit operations for arrays\n  // ===========================================================================\n\n  /**\n   * Edit operations for JSON arrays.\n   *\n   * Mirrors [[DynamicPatch.SeqOp]] but with Json values.\n   */\n  sealed trait ArrayOp\n\n  object ArrayOp {\n\n    /**\n     * Insert values at the given index.\n     */\n    final case class Insert(index: Int, values: Vector[Json]) extends ArrayOp\n\n    /**\n     * Append values to the end of the array.\n     */\n    final case class Append(values: Vector[Json]) extends ArrayOp\n\n    /**\n     * Delete elements starting at the given index.\n     */\n    final case class Delete(index: Int, count: Int) extends ArrayOp\n\n    /**\n     * Modify the element at the given index with a nested operation.\n     */\n    final case class Modify(index: Int, op: Op) extends ArrayOp\n  }\n\n  // ===========================================================================\n  // ObjectOp â€” edit operations for objects\n  // ===========================================================================\n\n  /**\n   * Edit operations for JSON objects.\n   *\n   * Mirrors [[DynamicPatch.MapOp]] but with string keys (JSON constraint).\n   */\n  sealed trait ObjectOp\n\n  object ObjectOp {\n\n    /**\n     * Add a field to the object.\n     */\n    final case class Add(key: String, value: Json) extends ObjectOp\n\n    /**\n     * Remove a field from the object.\n     */\n    final case class Remove(key: String) extends ObjectOp\n\n    /**\n     * Modify a field's value with a nested patch.\n     */\n    final case class Modify(key: String, patch: JsonPatch) extends ObjectOp\n  }\n}\n\n// =============================================================================\n// PATCH MODE\n// =============================================================================\n\n/**\n * Controls how patch application handles failures.\n *\n * Mirrors [[zio.blocks.schema.patch.PatchMode]].\n */\nsealed trait JsonPatchMode\n\nobject JsonPatchMode {\n\n  /**\n   * Fail on precondition violations.\n   */\n  case object Strict extends JsonPatchMode\n\n  /**\n   * Skip operations that fail preconditions.\n   */\n  case object Lenient extends JsonPatchMode\n\n  /**\n   * Replace/overwrite on conflicts (create missing paths).\n   */\n  case object Clobber extends JsonPatchMode\n}\n\n// =============================================================================\n// USAGE EXAMPLES\n// =============================================================================\n\n/*\n * ==Example 1: Basic Patching==\n *\n * {{{\n * import zio.blocks.schema.json._\n *\n * val json = Json.Object(Vector(\n *   \"name\" -> Json.String(\"Alice\"),\n *   \"age\" -> Json.Number(\"30\")\n * ))\n *\n * // Replace name\n * val patch = JsonPatch.root(JsonPatch.Op.Set(Json.String(\"Bob\")))\n *   // Or at a specific path:\n *   // JsonPatch(DynamicOptic.root.field(\"name\"), JsonPatch.Op.Set(Json.String(\"Bob\")))\n *\n * val result = patch(json, JsonPatchMode.Strict)\n * }}}\n *\n * ==Example 2: Diff and Apply (Roundtrip Law)==\n *\n * {{{\n * val source = Json.Object(Vector(\"x\" -> Json.Number(\"1\")))\n * val target = Json.Object(Vector(\"x\" -> Json.Number(\"5\")))\n *\n * val patch = JsonPatch.diff(source, target)\n *\n * // Roundtrip law\n * assert(patch(source, JsonPatchMode.Strict) == Right(target))\n *\n * // Identity diff law\n * assert(JsonPatch.diff(source, source).isEmpty)\n * }}}\n *\n * ==Example 3: Monoid Laws==\n *\n * {{{\n * val p1 = JsonPatch.diff(a, b)\n * val p2 = JsonPatch.diff(b, c)\n * val p3 = JsonPatch.diff(c, d)\n *\n * // Left identity\n * assert((JsonPatch.empty ++ p1)(a, Strict) == p1(a, Strict))\n *\n * // Right identity\n * assert((p1 ++ JsonPatch.empty)(a, Strict) == p1(a, Strict))\n *\n * // Associativity\n * assert(((p1 ++ p2) ++ p3)(a, Strict) == (p1 ++ (p2 ++ p3))(a, Strict))\n * }}}\n *\n * ==Example 4: Numeric Delta==\n *\n * {{{\n * val json = Json.Number(\"10\")\n *\n * // Add 5 to the number (more efficient than Set for large structures)\n * val patch = JsonPatch.root(\n *   JsonPatch.Op.PrimitiveDelta(JsonPatch.PrimitiveOp.NumberDelta(BigDecimal(5)))\n * )\n *\n * assert(patch(json, Strict) == Right(Json.Number(\"15\")))\n * }}}\n *\n * ==Example 5: String Edit==\n *\n * {{{\n * val json = Json.String(\"hello world\")\n *\n * // Change \"hello\" to \"hi\" using LCS-based edits\n * val patch = JsonPatch.root(\n *   JsonPatch.Op.PrimitiveDelta(\n *     JsonPatch.PrimitiveOp.StringEdit(Vector(\n *       JsonPatch.StringOp.Delete(0, 5),\n *       JsonPatch.StringOp.Insert(0, \"hi\")\n *     ))\n *   )\n * )\n *\n * assert(patch(json, Strict) == Right(Json.String(\"hi world\")))\n * }}}\n *\n * ==Example 6: Array Edit==\n *\n * {{{\n * val json = Json.Array(Vector(Json.Number(\"1\"), Json.Number(\"2\"), Json.Number(\"3\")))\n *\n * // Delete element at index 1, append new element\n * val patch = JsonPatch.root(\n *   JsonPatch.Op.ArrayEdit(Vector(\n *     JsonPatch.ArrayOp.Delete(1, 1),\n *     JsonPatch.ArrayOp.Append(Vector(Json.Number(\"4\")))\n *   ))\n * )\n *\n * // Result: [1, 3, 4]\n * }}}\n *\n * ==Example 7: Object Edit==\n *\n * {{{\n * val json = Json.Object(Vector(\"a\" -> Json.Number(\"1\"), \"b\" -> Json.Number(\"2\")))\n *\n * // Remove field \"a\", add field \"c\"\n * val patch = JsonPatch.root(\n *   JsonPatch.Op.ObjectEdit(Vector(\n *     JsonPatch.ObjectOp.Remove(\"a\"),\n *     JsonPatch.ObjectOp.Add(\"c\", Json.Number(\"3\"))\n *   ))\n * )\n *\n * // Result: {\"b\": 2, \"c\": 3}\n * }}}\n *\n * ==Example 8: Nested Patch==\n *\n * {{{\n * val json = Json.Object(Vector(\n *   \"user\" -> Json.Object(Vector(\n *     \"name\" -> Json.String(\"Alice\"),\n *     \"age\" -> Json.Number(\"30\")\n *   ))\n * ))\n *\n * // Patch nested inside \"user\"\n * val innerPatch = JsonPatch(Vector(\n *   JsonPatch.JsonPatchOp(\n *     DynamicOptic.root.field(\"age\"),\n *     JsonPatch.Op.PrimitiveDelta(JsonPatch.PrimitiveOp.NumberDelta(BigDecimal(1)))\n *   )\n * ))\n *\n * val patch = JsonPatch(\n *   DynamicOptic.root.field(\"user\"),\n *   JsonPatch.Op.Nested(innerPatch)\n * )\n *\n * // Increments user.age by 1\n * }}}\n *\n * ==Example 9: Diff Composition Law==\n *\n * {{{\n * val a = Json.Number(\"1\")\n * val b = Json.Number(\"5\")\n * val c = Json.Number(\"10\")\n *\n * val p1 = JsonPatch.diff(a, b)  // delta +4\n * val p2 = JsonPatch.diff(b, c)  // delta +5\n *\n * // Composition law: applying composed patch equals applying sequentially\n * assert((p1 ++ p2)(a, Strict) == Right(c))\n * }}}\n *\n * ==Example 10: PatchMode Behavior==\n *\n * {{{\n * val json = Json.Object(Vector(\"a\" -> Json.Number(\"1\")))\n *\n * // Try to remove non-existent field\n * val patch = JsonPatch.root(\n *   JsonPatch.Op.ObjectEdit(Vector(JsonPatch.ObjectOp.Remove(\"nonexistent\")))\n * )\n *\n * // Strict: fails\n * assert(patch(json, JsonPatchMode.Strict).isLeft)\n *\n * // Lenient: skips, returns unchanged\n * assert(patch(json, JsonPatchMode.Lenient) == Right(json))\n *\n * // Clobber: skips (nothing to clobber), returns unchanged\n * assert(patch(json, JsonPatchMode.Clobber) == Right(json))\n * }}}\n */\n```",
              "url": "https://github.com/zio/zio-blocks/issues/685",
              "tech": [],
              "repo_name": "zio-blocks",
              "repo_owner": "zio",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "ZIO#683",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "ZIO",
              "id": "generated-ZIO",
              "name": "ZIO",
              "description": "",
              "members": [],
              "display_name": "ZIO",
              "created_at": "2026-01-19T14:47:44.049Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/ZIO?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "zio",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-19T14:47:44.049Z",
            "created_at": "2026-01-19T14:47:44.049Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-ZIO#683",
              "status": "open",
              "type": "issue",
              "number": 683,
              "title": "Port BSON Support to ZIO Schema 2",
              "source": {
                "data": {
                  "id": "source-ZIO#683",
                  "user": {
                    "login": "jdegoes",
                    "id": 156745,
                    "node_id": "MDQ6VXNlcjE1Njc0NQ==",
                    "avatar_url": "https://avatars.githubusercontent.com/u/156745?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/jdegoes",
                    "html_url": "https://github.com/jdegoes",
                    "followers_url": "https://api.github.com/users/jdegoes/followers",
                    "following_url": "https://api.github.com/users/jdegoes/following{/other_user}",
                    "gists_url": "https://api.github.com/users/jdegoes/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/jdegoes/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/jdegoes/subscriptions",
                    "organizations_url": "https://api.github.com/users/jdegoes/orgs",
                    "repos_url": "https://api.github.com/users/jdegoes/repos",
                    "events_url": "https://api.github.com/users/jdegoes/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/jdegoes/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Port BSON Support to ZIO Schema 2",
                  "body": "In a separate top-level project (schema-bson), port the [old ZIO Schema BSON support](https://github.com/zio/zio-schema/tree/main/zio-schema-bson/src) to ZIO Schema 2.\n\nMust have at least as many tests as the old version, with any known bugs in the implementation identified and fixed.",
                  "html_url": "https://github.com/zio/zio-blocks/issues/683"
                },
                "type": "github"
              },
              "hash": "zio/zio-blocks#683",
              "body": "In a separate top-level project (schema-bson), port the [old ZIO Schema BSON support](https://github.com/zio/zio-schema/tree/main/zio-schema-bson/src) to ZIO Schema 2.\n\nMust have at least as many tests as the old version, with any known bugs in the implementation identified and fixed.",
              "url": "https://github.com/zio/zio-blocks/issues/683",
              "tech": [],
              "repo_name": "zio-blocks",
              "repo_owner": "zio",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "ZIO#682",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "ZIO",
              "id": "generated-ZIO",
              "name": "ZIO",
              "description": "",
              "members": [],
              "display_name": "ZIO",
              "created_at": "2026-01-19T14:47:46.312Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/ZIO?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "zio",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-19T14:47:46.312Z",
            "created_at": "2026-01-19T14:47:46.312Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-ZIO#682",
              "status": "open",
              "type": "issue",
              "number": 682,
              "title": "Port Message Pack Support to ZIO Schema 2",
              "source": {
                "data": {
                  "id": "source-ZIO#682",
                  "user": {
                    "login": "jdegoes",
                    "id": 156745,
                    "node_id": "MDQ6VXNlcjE1Njc0NQ==",
                    "avatar_url": "https://avatars.githubusercontent.com/u/156745?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/jdegoes",
                    "html_url": "https://github.com/jdegoes",
                    "followers_url": "https://api.github.com/users/jdegoes/followers",
                    "following_url": "https://api.github.com/users/jdegoes/following{/other_user}",
                    "gists_url": "https://api.github.com/users/jdegoes/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/jdegoes/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/jdegoes/subscriptions",
                    "organizations_url": "https://api.github.com/users/jdegoes/orgs",
                    "repos_url": "https://api.github.com/users/jdegoes/repos",
                    "events_url": "https://api.github.com/users/jdegoes/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/jdegoes/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Port Message Pack Support to ZIO Schema 2",
                  "body": "In a separate top-level project (schema-messagepack), port the [old ZIO Schema Message Pack support](https://github.com/zio/zio-schema/tree/main/zio-schema-msg-pack/src) to ZIO Schema 2.\n\nMust have at least as many tests as the old version, with any known bugs in the implementation identified and fixed.",
                  "html_url": "https://github.com/zio/zio-blocks/issues/682"
                },
                "type": "github"
              },
              "hash": "zio/zio-blocks#682",
              "body": "In a separate top-level project (schema-messagepack), port the [old ZIO Schema Message Pack support](https://github.com/zio/zio-schema/tree/main/zio-schema-msg-pack/src) to ZIO Schema 2.\n\nMust have at least as many tests as the old version, with any known bugs in the implementation identified and fixed.",
              "url": "https://github.com/zio/zio-blocks/issues/682",
              "tech": [],
              "repo_name": "zio-blocks",
              "repo_owner": "zio",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "ZIO#681",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "ZIO",
              "id": "generated-ZIO",
              "name": "ZIO",
              "description": "",
              "members": [],
              "display_name": "ZIO",
              "created_at": "2026-01-19T14:47:51.103Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/ZIO?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "zio",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-19T14:47:51.103Z",
            "created_at": "2026-01-19T14:47:51.103Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-ZIO#681",
              "status": "open",
              "type": "issue",
              "number": 681,
              "title": "Port Thrift Support to ZIO Schema 2",
              "source": {
                "data": {
                  "id": "source-ZIO#681",
                  "user": {
                    "login": "jdegoes",
                    "id": 156745,
                    "node_id": "MDQ6VXNlcjE1Njc0NQ==",
                    "avatar_url": "https://avatars.githubusercontent.com/u/156745?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/jdegoes",
                    "html_url": "https://github.com/jdegoes",
                    "followers_url": "https://api.github.com/users/jdegoes/followers",
                    "following_url": "https://api.github.com/users/jdegoes/following{/other_user}",
                    "gists_url": "https://api.github.com/users/jdegoes/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/jdegoes/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/jdegoes/subscriptions",
                    "organizations_url": "https://api.github.com/users/jdegoes/orgs",
                    "repos_url": "https://api.github.com/users/jdegoes/repos",
                    "events_url": "https://api.github.com/users/jdegoes/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/jdegoes/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Port Thrift Support to ZIO Schema 2",
                  "body": "In a separate top-level project (schema-thrift), port the [old ZIO Schema Thrift support](https://github.com/zio/zio-schema/tree/main/zio-schema-thrift/src) to ZIO Schema 2.\n\nMust have at least as many tests as the old version, with any known bugs in the implementation identified and fixed.",
                  "html_url": "https://github.com/zio/zio-blocks/issues/681"
                },
                "type": "github"
              },
              "hash": "zio/zio-blocks#681",
              "body": "In a separate top-level project (schema-thrift), port the [old ZIO Schema Thrift support](https://github.com/zio/zio-schema/tree/main/zio-schema-thrift/src) to ZIO Schema 2.\n\nMust have at least as many tests as the old version, with any known bugs in the implementation identified and fixed.",
              "url": "https://github.com/zio/zio-blocks/issues/681",
              "tech": [],
              "repo_name": "zio-blocks",
              "repo_owner": "zio",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "ZIO#679",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "ZIO",
              "id": "generated-ZIO",
              "name": "ZIO",
              "description": "",
              "members": [],
              "display_name": "ZIO",
              "created_at": "2026-01-19T14:47:55.805Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/ZIO?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "zio",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-19T14:47:55.805Z",
            "created_at": "2026-01-19T14:47:55.805Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-ZIO#679",
              "status": "open",
              "type": "issue",
              "number": 679,
              "title": "Add Json data type",
              "source": {
                "data": {
                  "id": "source-ZIO#679",
                  "user": {
                    "login": "jdegoes",
                    "id": 156745,
                    "node_id": "MDQ6VXNlcjE1Njc0NQ==",
                    "avatar_url": "https://avatars.githubusercontent.com/u/156745?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/jdegoes",
                    "html_url": "https://github.com/jdegoes",
                    "followers_url": "https://api.github.com/users/jdegoes/followers",
                    "following_url": "https://api.github.com/users/jdegoes/following{/other_user}",
                    "gists_url": "https://api.github.com/users/jdegoes/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/jdegoes/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/jdegoes/subscriptions",
                    "organizations_url": "https://api.github.com/users/jdegoes/orgs",
                    "repos_url": "https://api.github.com/users/jdegoes/repos",
                    "events_url": "https://api.github.com/users/jdegoes/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/jdegoes/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Add Json data type",
                  "body": "The following is a sketch of what a proper `Json` data type should look like, including constructors, methods, and related types. Note that `DynamicPatch`, `JsonPatch`, and `JsonSchema` are all out-of-scope for this ticket.\n\n## Sketch\n\n```scala\npackage zio.blocks.schema.json\n\nimport zio.blocks.chunk.Chunk\nimport zio.blocks.schema.{DynamicOptic, DynamicValue, PrimitiveValue, Schema, SchemaError}\n\nimport java.io.{Reader, Writer}\nimport java.nio.ByteBuffer\nimport scala.util.control.NoStackTrace\n\n// =============================================================================\n// JSON ERROR\n// =============================================================================\n\n/**\n * Represents an error that occurred during JSON parsing, encoding, or processing.\n *\n * NOTE: This should replace JsonBinaryCodecError and be moved to `zio.block.schema.json`.\n *\n * @param message A human-readable description of the error\n * @param path The location in the JSON structure where the error occurred,\n *             represented as a [[DynamicOptic]]\n * @param offset Optional byte offset in the input where the error occurred\n * @param line Optional 1-indexed line number where the error occurred\n * @param column Optional 1-indexed column number where the error occurred\n */\nfinal case class JsonError(\n  message: String,\n  path: DynamicOptic,\n  offset: Option[Long],\n  line: Option[Int],\n  column: Option[Int]\n) extends Exception with NoStackTrace {\n\n  override def getMessage: String = {\n    val posInfo = (line, column) match {\n      case (Some(l), Some(c)) => s\" at line $l, column $c\"\n      case _                  => offset.map(o => s\" at offset $o\").getOrElse(\"\")\n    }\n    val pathInfo = if (path.nodes.isEmpty) \"\" else s\" at path $path\"\n    s\"$message$pathInfo$posInfo\"\n  }\n\n  /**\n   * Combines this error with another, preserving both error messages.\n   */\n  def ++(other: JsonError): JsonError =\n    JsonError(s\"${this.message}; ${other.message}\", this.path, this.offset, this.line, this.column)\n}\n\nobject JsonError {\n\n  /**\n   * Creates a JsonError with only a message, using root path and no position info.\n   */\n  def apply(message: String): JsonError =\n    JsonError(message, DynamicOptic.root, None, None, None)\n\n  /**\n   * Creates a JsonError with a message and path, no position info.\n   */\n  def apply(message: String, path: DynamicOptic): JsonError =\n    JsonError(message, path, None, None, None)\n\n  /**\n   * Converts a [[SchemaError]] to a [[JsonError]].\n   */\n  def fromSchemaError(error: SchemaError): JsonError =\n    JsonError(error.message, DynamicOptic.root, None, None, None)\n}\n\n// =============================================================================\n// JSON DECODER / ENCODER (implicit priority resolution)\n// =============================================================================\n\n/**\n * Type class for decoding [[Json]] values into Scala types.\n *\n * Implicit resolution prefers explicitly provided [[JsonBinaryCodec]] instances\n * over schema-derived instances, allowing users to override derived behavior.\n */\nsealed trait JsonDecoder[A] {\n\n  /**\n   * Decodes a [[Json]] value into type `A`.\n   *\n   * @param json The JSON value to decode\n   * @return Either a [[JsonError]] on failure, or the decoded value\n   */\n  def decode(json: Json): Either[JsonError, A]\n}\n\nobject JsonDecoder extends JsonDecoderLowPriority {\n\n  def apply[A](implicit decoder: JsonDecoder[A]): JsonDecoder[A] = decoder\n\n  /**\n   * Higher priority: use an explicitly provided [[JsonBinaryCodec]].\n   */\n  implicit def fromCodec[A](implicit codec: JsonBinaryCodec[A]): JsonDecoder[A] =\n    new JsonDecoder[A] {\n      def decode(json: Json): Either[JsonError, A] = json.decodeWith(codec)\n    }\n}\n\n/**\n * Lower priority implicits for [[JsonDecoder]].\n */\ntrait JsonDecoderLowPriority {\n\n  /**\n   * Lower priority: derive a codec from an implicit [[Schema]].\n   */\n  implicit def fromSchema[A](implicit schema: Schema[A]): JsonDecoder[A] =\n    new JsonDecoder[A] {\n      private lazy val codec: JsonBinaryCodec[A] = schema.derive(JsonBinaryCodecDeriver)\n      def decode(json: Json): Either[JsonError, A] = json.decodeWith(codec)\n    }\n}\n\n/**\n * Type class for encoding Scala types into [[Json]] values.\n *\n * Implicit resolution prefers explicitly provided [[JsonBinaryCodec]] instances\n * over schema-derived instances, allowing users to override derived behavior.\n */\nsealed trait JsonEncoder[A] {\n\n  /**\n   * Encodes a value of type `A` into [[Json]].\n   *\n   * @param value The value to encode\n   * @return The encoded JSON value\n   */\n  def encode(value: A): Json\n}\n\nobject JsonEncoder extends JsonEncoderLowPriority {\n\n  def apply[A](implicit encoder: JsonEncoder[A]): JsonEncoder[A] = encoder\n\n  /**\n   * Higher priority: use an explicitly provided [[JsonBinaryCodec]].\n   */\n  implicit def fromCodec[A](implicit codec: JsonBinaryCodec[A]): JsonEncoder[A] =\n    new JsonEncoder[A] {\n      def encode(value: A): Json = Json.encodeWith(value, codec)\n    }\n}\n\n/**\n * Lower priority implicits for [[JsonEncoder]].\n */\ntrait JsonEncoderLowPriority {\n\n  /**\n   * Lower priority: derive a codec from an implicit [[Schema]].\n   */\n  implicit def fromSchema[A](implicit schema: Schema[A]): JsonEncoder[A] =\n    new JsonEncoder[A] {\n      private lazy val codec: JsonBinaryCodec[A] = schema.derive(JsonBinaryCodecDeriver)\n      def encode(value: A): Json = Json.encodeWith(value, codec)\n    }\n}\n\n// =============================================================================\n// JSON SELECTION\n// =============================================================================\n\n/**\n * Represents a selection of zero or more JSON values, with accumulated errors.\n *\n * `JsonSelection` enables fluent chaining of operations that may fail without\n * requiring immediate error handling. Operations are applied to all values in\n * the selection, and errors are accumulated.\n *\n * {{{\n * val selection: JsonSelection = json.get(p\"users[*].name\")\n * val result: Either[SchemaError, Vector[Json]] = selection.toEither\n * }}}\n */\nfinal case class JsonSelection(toEither: Either[SchemaError, Vector[Json]]) { self =>\n\n  /**\n   * Returns true if this selection contains no values (either empty or errored).\n   */\n  def isEmpty: Boolean = toEither.fold(_ => true, _.isEmpty)\n\n  /**\n   * Returns true if this selection contains at least one value.\n   */\n  def nonEmpty: Boolean = toEither.fold(_ => false, _.nonEmpty)\n\n  /**\n   * Returns the number of values in this selection, or 0 if errored.\n   */\n  def size: Int = toEither.fold(_ => 0, _.size)\n\n  // ---------------------------------------------------------------------------\n  // Transformations\n  // ---------------------------------------------------------------------------\n\n  /**\n   * Applies a function to each JSON value in this selection.\n   *\n   * @param f The transformation function\n   * @return A new selection with transformed values\n   */\n  def map(f: Json => Json): JsonSelection =\n    JsonSelection(toEither.map(_.map(f)))\n\n  /**\n   * Applies a function returning a selection to each value, flattening results.\n   *\n   * @param f The function producing selections\n   * @return A new selection with all results combined\n   */\n  def flatMap(f: Json => JsonSelection): JsonSelection =\n    JsonSelection(toEither.flatMap { jsons =>\n      jsons.foldLeft[Either[SchemaError, Vector[Json]]](Right(Vector.empty)) { (acc, json) =>\n        for {\n          existing <- acc\n          next     <- f(json).toEither\n        } yield existing ++ next\n      }\n    })\n\n  /**\n   * Filters values in this selection by a predicate.\n   *\n   * @param p The predicate to test values\n   * @return A new selection containing only values satisfying the predicate\n   */\n  def filter(p: Json => Boolean): JsonSelection =\n    JsonSelection(toEither.map(_.filter(p)))\n\n  /**\n   * Collects values for which the partial function is defined.\n   *\n   * @param pf A partial function to apply\n   * @return A new selection with collected results\n   */\n  def collect(pf: PartialFunction[Json, Json]): JsonSelection =\n    JsonSelection(toEither.map(_.collect(pf)))\n\n  // ---------------------------------------------------------------------------\n  // Navigation\n  // ---------------------------------------------------------------------------\n\n  /**\n   * Navigates to values at the given path within each selected value.\n   *\n   * @param path The path to navigate\n   * @return A new selection with values at the path\n   */\n  def get(path: DynamicOptic): JsonSelection =\n    flatMap(json => json.get(path))\n\n  /**\n   * Alias for [[get]].\n   */\n  def apply(path: DynamicOptic): JsonSelection = get(path)\n\n  /**\n   * Navigates to array element at given index within each selected value.\n   *\n   * @param index The array index\n   * @return A new selection with elements at the index\n   */\n  def apply(index: Int): JsonSelection =\n    flatMap(json => json.apply(index))\n\n  /**\n   * Navigates to object field with given key within each selected value.\n   *\n   * @param key The object key\n   * @return A new selection with values at the key\n   */\n  def apply(key: String): JsonSelection =\n    flatMap(json => json.apply(key))\n\n  // ---------------------------------------------------------------------------\n  // Type Filtering\n  // ---------------------------------------------------------------------------\n\n  /**\n   * Filters to only JSON objects.\n   */\n  def objects: JsonSelection = filter(_.isObject)\n\n  /**\n   * Filters to only JSON arrays.\n   */\n  def arrays: JsonSelection = filter(_.isArray)\n\n  /**\n   * Filters to only JSON strings.\n   */\n  def strings: JsonSelection = filter(_.isString)\n\n  /**\n   * Filters to only JSON numbers.\n   */\n  def numbers: JsonSelection = filter(_.isNumber)\n\n  /**\n   * Filters to only JSON booleans.\n   */\n  def booleans: JsonSelection = filter(_.isBoolean)\n\n  /**\n   * Filters to only JSON nulls.\n   */\n  def nulls: JsonSelection = filter(_.isNull)\n\n  // ---------------------------------------------------------------------------\n  // Combination\n  // ---------------------------------------------------------------------------\n\n  /**\n   * Combines this selection with another, concatenating values or errors.\n   *\n   * @param other The other selection\n   * @return A combined selection\n   */\n  def ++(other: JsonSelection): JsonSelection =\n    (toEither, other.toEither) match {\n      case (Right(a), Right(b)) => JsonSelection(Right(a ++ b))\n      case (Left(a), Left(b))   => JsonSelection(Left(a ++ b))\n      case (Left(a), _)         => JsonSelection(Left(a))\n      case (_, Left(b))         => JsonSelection(Left(b))\n    }\n\n  // ---------------------------------------------------------------------------\n  // Terminal Operations\n  // ---------------------------------------------------------------------------\n\n  /**\n   * Returns the single value if exactly one, an array of values if there are many, or \n   * otherwise an error.\n   */\n  def one: Either[SchemaError, Json] =\n    toEither.flatMap { jsons =>\n      if (jsons.size == 1) Right(jsons.head)\n      else if (jsons.size > 1) toArray\n      else Left(SchemaError.expectationMismatch(Nil, s\"expected exactly one value, got ${jsons.size}\"))\n    }\n\n  /**\n   * Returns the first value if any, otherwise an error.\n   */\n  def first: Either[SchemaError, Json] =\n    toEither.flatMap { jsons =>\n      jsons.headOption.toRight(SchemaError.expectationMismatch(Nil, \"expected at least one value, got none\"))\n    }\n\n  /**\n   * Returns all values as a [[Json.Array]], or an error.\n   */\n  def toArray: Either[SchemaError, Json] =\n    toEither.map(jsons => Json.Array(jsons))\n\n  /**\n   * Unsafe version of [[one]], throws on error or wrong count.\n   */\n  def oneUnsafe: Json = one.fold(e => throw JsonError.fromSchemaError(e), identity)\n\n  /**\n   * Unsafe version of [[first]], throws on error or empty.\n   */\n  def firstUnsafe: Json = first.fold(e => throw JsonError.fromSchemaError(e), identity)\n}\n\nobject JsonSelection {\n\n  /**\n   * Creates a selection containing a single value.\n   */\n  def apply(json: Json): JsonSelection = JsonSelection(Right(Vector(json)))\n\n  /**\n   * Creates a selection containing multiple values.\n   */\n  def fromVector(jsons: Vector[Json]): JsonSelection = JsonSelection(Right(jsons))\n\n  /**\n   * Creates an empty selection (no values, no error).\n   */\n  val empty: JsonSelection = JsonSelection(Right(Vector.empty))\n\n  /**\n   * Creates a failed selection with the given error.\n   */\n  def fail(error: SchemaError): JsonSelection = JsonSelection(Left(error))\n\n  /**\n   * Creates a failed selection with the given message.\n   */\n  def fail(message: String): JsonSelection =\n    JsonSelection(Left(SchemaError.expectationMismatch(Nil, message)))\n}\n\n// =============================================================================\n// JSON ADT\n// =============================================================================\n\n/**\n * Represents a JSON value.\n *\n * The JSON data model consists of:\n *  - '''Objects''': Unordered collections of key-value pairs\n *  - '''Arrays''': Ordered sequences of values\n *  - '''Strings''': Unicode text\n *  - '''Numbers''': Numeric values (stored as strings for precision)\n *  - '''Booleans''': `true` or `false`\n *  - '''Null''': The null value\n *\n * ==Construction==\n * {{{\n * val obj = Json.Object(\"name\" -> Json.String(\"Alice\"), \"age\" -> Json.number(30))\n * val arr = Json.Array(Json.String(\"a\"), Json.String(\"b\"))\n * val str = Json.String(\"hello\")\n * val num = Json.number(42)\n * val bool = Json.Boolean(true)\n * val nul = Json.Null\n * }}}\n *\n * ==Navigation==\n * {{{\n * json.get(p\"users[0].name\")   // JsonSelection\n * json(\"users\")(0)(\"name\")     // JsonSelection\n * json.fields                  // for objects\n * json.elements                // for arrays\n * }}}\n *\n * ==Pattern Matching==\n * {{{\n * json match {\n *   case Json.Object(fields) => ...\n *   case Json.Array(elements) => ...\n *   case Json.String(value) => ...\n *   case Json.Number(value) => ...\n *   case Json.Boolean(value) => ...\n *   case Json.Null => ...\n * }\n * }}}\n */\nsealed trait Json { self =>\n\n  // ===========================================================================\n  // Type Testing\n  // ===========================================================================\n\n  /**\n   * Returns `true` if this is a JSON object.\n   */\n  def isObject: Boolean = false\n\n  /**\n   * Returns `true` if this is a JSON array.\n   */\n  def isArray: Boolean = false\n\n  /**\n   * Returns `true` if this is a JSON string.\n   */\n  def isString: Boolean = false\n\n  /**\n   * Returns `true` if this is a JSON number.\n   */\n  def isNumber: Boolean = false\n\n  /**\n   * Returns `true` if this is a JSON boolean.\n   */\n  def isBoolean: Boolean = false\n\n  /**\n   * Returns `true` if this is JSON null.\n   */\n  def isNull: Boolean = false\n\n  // ===========================================================================\n  // Type Filtering (returns JsonSelection)\n  // ===========================================================================\n\n  /**\n   * Returns a [[JsonSelection]] containing this value if it is an object,\n   * otherwise an empty selection.\n   */\n  def asObject: JsonSelection = if (isObject) JsonSelection(self) else JsonSelection.empty\n\n  /**\n   * Returns a [[JsonSelection]] containing this value if it is an array,\n   * otherwise an empty selection.\n   */\n  def asArray: JsonSelection = if (isArray) JsonSelection(self) else JsonSelection.empty\n\n  /**\n   * Returns a [[JsonSelection]] containing this value if it is a string,\n   * otherwise an empty selection.\n   */\n  def asString: JsonSelection = if (isString) JsonSelection(self) else JsonSelection.empty\n\n  /**\n   * Returns a [[JsonSelection]] containing this value if it is a number,\n   * otherwise an empty selection.\n   */\n  def asNumber: JsonSelection = if (isNumber) JsonSelection(self) else JsonSelection.empty\n\n  /**\n   * Returns a [[JsonSelection]] containing this value if it is a boolean,\n   * otherwise an empty selection.\n   */\n  def asBoolean: JsonSelection = if (isBoolean) JsonSelection(self) else JsonSelection.empty\n\n  /**\n   * Returns a [[JsonSelection]] containing this value if it is null,\n   * otherwise an empty selection.\n   */\n  def asNull: JsonSelection = if (isNull) JsonSelection(self) else JsonSelection.empty\n\n  // ===========================================================================\n  // Direct Accessors\n  // ===========================================================================\n\n  /**\n   * If this is an object, returns its fields as key-value pairs.\n   * Otherwise returns an empty sequence.\n   */\n  def fields: Seq[(String, Json)] = Seq.empty\n\n  /**\n   * If this is an array, returns its elements.\n   * Otherwise returns an empty sequence.\n   */\n  def elements: Seq[Json] = Seq.empty\n\n  /**\n   * If this is a string, returns its value.\n   * Otherwise returns `None`.\n   */\n  def stringValue: Option[String] = None\n\n  /**\n   * If this is a number, returns its string representation.\n   * Otherwise returns `None`.\n   */\n  def numberValue: Option[String] = None\n\n  /**\n   * If this is a boolean, returns its value.\n   * Otherwise returns `None`.\n   */\n  def booleanValue: Option[scala.Boolean] = None\n\n  // ===========================================================================\n  // Navigation\n  // ===========================================================================\n\n  /**\n   * Navigates to values at the given path.\n   *\n   * {{{\n   * json.get(p\"users[0].name\")\n   * json.get(DynamicOptic.root.field(\"users\").at(0).field(\"name\"))\n   * }}}\n   *\n   * @param path The path to navigate\n   * @return A [[JsonSelection]] containing values at the path\n   */\n  def get(path: DynamicOptic): JsonSelection = ???\n\n  /**\n   * Alias for [[get]].\n   */\n  def apply(path: DynamicOptic): JsonSelection = get(path)\n\n  /**\n   * If this is an array, returns a selection containing the element at the given index.\n   * Returns an empty selection if not an array or index is out of bounds.\n   *\n   * @param index The array index (0-based)\n   */\n  def apply(index: Int): JsonSelection = self match {\n    case Json.Array(elems) if index >= 0 && index < elems.size =>\n      JsonSelection(elems(index))\n    case _ =>\n      JsonSelection.empty\n  }\n\n  /**\n   * If this is an object, returns a selection containing the value at the given key.\n   * Returns an empty selection if not an object or key is not present.\n   *\n   * @param key The object key\n   */\n  def apply(key: String): JsonSelection = self match {\n    case Json.Object(flds) =>\n      flds.collectFirst { case (k, v) if k == key => v } match {\n        case Some(v) => JsonSelection(v)\n        case None    => JsonSelection.empty\n      }\n    case _ =>\n      JsonSelection.empty\n  }\n\n  // ===========================================================================\n  // Modification (Json => Json)\n  // ===========================================================================\n\n  /**\n   * Modifies values at the given path using the provided function.\n   *\n   * If the path does not exist, returns this JSON unchanged.\n   *\n   * {{{\n   * json.modify(p\"users[*].age\", {\n   *   case Json.Number(n) => Json.number(n.toInt + 1)\n   *   case other => other\n   * })\n   * }}}\n   *\n   * @param path The path to values to modify\n   * @param f The modification function\n   * @return The modified JSON\n   */\n  def modify(path: DynamicOptic, f: Json => Json): Json = ???\n\n  /**\n   * Modifies values at the given path using a partial function.\n   *\n   * Values for which the partial function is not defined are left unchanged.\n   *\n   * @param path The path to values to modify\n   * @param pf The partial modification function\n   * @return Either an error if the path is invalid, or the modified JSON\n   */\n  def modifyOrFail(path: DynamicOptic, pf: PartialFunction[Json, Json]): Either[JsonError, Json] = ???\n\n  /**\n   * Sets the value at the given path.\n   *\n   * If the path does not exist, attempts to create intermediate structure.\n   * For array indices, the array must already exist and have sufficient length.\n   *\n   * {{{\n   * json.set(p\"user.name\", Json.String(\"Bob\"))\n   * }}}\n   *\n   * @param path The path to set\n   * @param value The value to set\n   * @return The modified JSON\n   */\n  def set(path: DynamicOptic, value: Json): Json = ???\n\n  /**\n   * Sets the value at the given path, returning an error if the path is invalid.\n   *\n   * @param path The path to set\n   * @param value The value to set\n   * @return Either an error or the modified JSON\n   */\n  def setOrFail(path: DynamicOptic, value: Json): Either[JsonError, Json] = ???\n\n  /**\n   * Deletes values at the given path.\n   *\n   * For object fields, removes the key-value pair.\n   * For array elements, removes the element and shifts subsequent elements.\n   *\n   * @param path The path to delete\n   * @return The modified JSON\n   */\n  def delete(path: DynamicOptic): Json = ???\n\n  /**\n   * Deletes values at the given path, returning an error if the path is invalid.\n   *\n   * @param path The path to delete\n   * @return Either an error or the modified JSON\n   */\n  def deleteOrFail(path: DynamicOptic): Either[JsonError, Json] = ???\n\n  /**\n   * Inserts a value at the given path.\n   *\n   * For arrays, inserts at the specified index, shifting subsequent elements.\n   * For objects, adds or replaces the key.\n   *\n   * @param path The path where to insert\n   * @param value The value to insert\n   * @return The modified JSON\n   */\n  def insert(path: DynamicOptic, value: Json): Json = ???\n\n  /**\n   * Inserts a value at the given path, returning an error if invalid.\n   *\n   * @param path The path where to insert\n   * @param value The value to insert\n   * @return Either an error or the modified JSON\n   */\n  def insertOrFail(path: DynamicOptic, value: Json): Either[JsonError, Json] = ???\n\n  // ===========================================================================\n  // Merging\n  // ===========================================================================\n\n  /**\n   * Merges this JSON with another using the specified strategy.\n   *\n   * {{{\n   * val merged = json1.merge(json2, MergeStrategy.Deep)\n   * }}}\n   *\n   * @param other The JSON to merge with\n   * @param strategy The merge strategy (default: [[MergeStrategy.Auto]])\n   * @return The merged JSON\n   */\n  def merge(other: Json, strategy: MergeStrategy = MergeStrategy.Auto): Json = ???\n\n  // ===========================================================================\n  // Patching\n  // ===========================================================================\n\n  /**\n   * Applies a [[JsonPatch]] to this JSON.\n   *\n   * @param patch The patch to apply\n   * @return Either an error if the patch cannot be applied, or the patched JSON\n   */\n  def patch(patch: JsonPatch): Either[JsonError, Json] = ???\n\n  /**\n   * Applies a [[JsonPatch]], throwing on failure.\n   *\n   * @param patch The patch to apply\n   * @return The patched JSON\n   * @throws JsonError if the patch cannot be applied\n   */\n  def patchUnsafe(patch: JsonPatch): Json = this.patch(patch).fold(throw _, identity)\n\n  // ===========================================================================\n  // Transformation\n  // ===========================================================================\n\n  /**\n   * Transforms all values in this JSON bottom-up (children before parents).\n   *\n   * @param f The transformation function receiving path and value\n   * @return The transformed JSON\n   */\n  def transformUp(f: (DynamicOptic, Json) => Json): Json = ???\n\n  /**\n   * Transforms all values in this JSON top-down (parents before children).\n   *\n   * @param f The transformation function receiving path and value\n   * @return The transformed JSON\n   */\n  def transformDown(f: (DynamicOptic, Json) => Json): Json = ???\n\n  /**\n   * Transforms all object keys in this JSON.\n   *\n   * @param f The key transformation function receiving path and key\n   * @return The transformed JSON\n   */\n  def transformKeys(f: (DynamicOptic, String) => String): Json = ???\n\n  // ===========================================================================\n  // Filtering\n  // ===========================================================================\n\n  /**\n   * Removes entries matching the predicate.\n   *\n   * For objects, removes matching key-value pairs.\n   * For arrays, removes matching elements.\n   *\n   * @param p The predicate receiving path and value\n   * @return The filtered JSON\n   */\n  def filterNot(p: (DynamicOptic, Json) => scala.Boolean): Json = ???\n\n  /**\n   * Keeps only entries matching the predicate.\n   *\n   * @param p The predicate receiving path and value\n   * @return The filtered JSON\n   */\n  def filter(p: (DynamicOptic, Json) => scala.Boolean): Json =\n    filterNot((path, json) => !p(path, json))\n\n  // ===========================================================================\n  // Projection\n  // ===========================================================================\n\n  /**\n   * Projects this JSON to include only the specified paths.\n   *\n   * Paths that don't exist are ignored. Structure is preserved.\n   *\n   * {{{\n   * json.project(p\"user.name\", p\"user.email\", p\"meta.created\")\n   * }}}\n   *\n   * @param paths The paths to include\n   * @return A new JSON containing only the specified paths\n   */\n  def project(paths: DynamicOptic*): Json = ???\n\n  // ===========================================================================\n  // Splitting / Partitioning\n  // ===========================================================================\n\n  /**\n   * Partitions this JSON into two based on a predicate.\n   *\n   * Returns a tuple where the first element contains entries satisfying\n   * the predicate, and the second contains entries that don't.\n   *\n   * @param p The predicate receiving path and value\n   * @return A tuple of (matching, non-matching) JSON values\n   */\n  def partition(p: (DynamicOptic, Json) => scala.Boolean): (Json, Json) = ???\n\n  // ===========================================================================\n  // Normalization\n  // ===========================================================================\n\n  /**\n   * Returns a normalized version of this JSON.\n   *\n   * Normalization includes:\n   *  - Sorting object keys alphabetically\n   *  - Normalizing number representations\n   *\n   * Useful for comparison and hashing.\n   */\n  def normalize: Json = ???\n\n  /**\n   * Returns this JSON with all object keys sorted alphabetically (recursive).\n   */\n  def sortKeys: Json = self match {\n    case Json.Object(flds) =>\n      Json.Object(flds.map { case (k, v) => (k, v.sortKeys) }.sortBy(_._1))\n    case Json.Array(elems) =>\n      Json.Array(elems.map(_.sortKeys))\n    case other =>\n      other\n  }\n\n  /**\n   * Returns this JSON with all null values removed from objects.\n   */\n  def dropNulls: Json = self match {\n    case Json.Object(flds) =>\n      Json.Object(flds.collect { case (k, v) if !v.isNull => (k, v.dropNulls) })\n    case Json.Array(elems) =>\n      Json.Array(elems.map(_.dropNulls))\n    case other =>\n      other\n  }\n\n  /**\n   * Returns this JSON with empty objects and arrays removed.\n   */\n  def dropEmpty: Json = self match {\n    case Json.Object(flds) =>\n      val filtered = flds.collect {\n        case (k, v) =>\n          val dropped = v.dropEmpty\n          dropped match {\n            case Json.Object(f) if f.isEmpty => None\n            case Json.Array(e) if e.isEmpty  => None\n            case other                       => Some((k, other))\n          }\n      }.flatten\n      Json.Object(filtered)\n    case Json.Array(elems) =>\n      val filtered = elems.map(_.dropEmpty).filter {\n        case Json.Object(f) if f.isEmpty => false\n        case Json.Array(e) if e.isEmpty  => false\n        case _                           => true\n      }\n      Json.Array(filtered)\n    case other =>\n      other\n  }\n\n  // ===========================================================================\n  // Diffing\n  // ===========================================================================\n\n  /**\n   * Computes a [[JsonPatch]] that transforms this JSON into the target.\n   *\n   * {{{\n   * val patch = source.diff(target)\n   * source.patch(patch) == Right(target) // true\n   * }}}\n   *\n   * @param target The target JSON\n   * @return A patch that transforms this into target\n   */\n  def diff(target: Json): JsonPatch = ???\n\n  // ===========================================================================\n  // Folding\n  // ===========================================================================\n\n  /**\n   * Folds over this JSON top-down (parents before children).\n   *\n   * @param z The initial accumulator value\n   * @param f The fold function receiving path, value, and accumulator\n   * @tparam B The accumulator type\n   * @return The final accumulated value\n   */\n  def foldDown[B](z: B)(f: (DynamicOptic, Json, B) => B): B = ???\n\n  /**\n   * Folds over this JSON bottom-up (children before parents).\n   *\n   * @param z The initial accumulator value\n   * @param f The fold function receiving path, value, and accumulator\n   * @tparam B The accumulator type\n   * @return The final accumulated value\n   */\n  def foldUp[B](z: B)(f: (DynamicOptic, Json, B) => B): B = ???\n\n  /**\n   * Folds over this JSON top-down, allowing the fold function to fail.\n   *\n   * Short-circuits on first failure.\n   *\n   * @param z The initial accumulator value\n   * @param f The fold function that may fail\n   * @tparam B The accumulator type\n   * @return Either an error or the final accumulated value\n   */\n  def foldDownOrFail[B](z: B)(f: (DynamicOptic, Json, B) => Either[JsonError, B]): Either[JsonError, B] = ???\n\n  /**\n   * Folds over this JSON bottom-up, allowing the fold function to fail.\n   *\n   * Short-circuits on first failure.\n   *\n   * @param z The initial accumulator value\n   * @param f The fold function that may fail\n   * @tparam B The accumulator type\n   * @return Either an error or the final accumulated value\n   */\n  def foldUpOrFail[B](z: B)(f: (DynamicOptic, Json, B) => Either[JsonError, B]): Either[JsonError, B] = ???\n\n  // ===========================================================================\n  // Querying\n  // ===========================================================================\n\n  /**\n   * Selects all values matching the predicate.\n   *\n   * @param p The predicate receiving path and value\n   * @return A [[JsonSelection]] containing matching values\n   */\n  def query(p: (DynamicOptic, Json) => scala.Boolean): JsonSelection = ???\n\n  // ===========================================================================\n  // Validation\n  // ===========================================================================\n\n  /**\n   * Validates this JSON against a [[JsonSchema]].\n   *\n   * @param schema The schema to validate against\n   * @return `None` if valid, `Some(error)` if invalid\n   */\n  def check(schema: JsonSchema): Option[SchemaError] = ???\n\n  /**\n   * Returns `true` if this JSON conforms to the given [[JsonSchema]].\n   */\n  def conforms(schema: JsonSchema): scala.Boolean = check(schema).isEmpty\n\n  // ===========================================================================\n  // KV Representation\n  // ===========================================================================\n\n  /**\n   * Flattens this JSON to a sequence of path-value pairs.\n   *\n   * Only leaf values (primitives, empty arrays, empty objects) are included.\n   *\n   * {{{\n   * Json.parse(\"\"\"{\"a\": {\"b\": 1}, \"c\": [2, 3]}\"\"\").toKV\n   * // Seq(\n   * //   (p\"a.b\", Json.Number(\"1\")),\n   * //   (p\"c[0]\", Json.Number(\"2\")),\n   * //   (p\"c[1]\", Json.Number(\"3\"))\n   * // )\n   * }}}\n   */\n  def toKV: Seq[(DynamicOptic, Json)] = ???\n\n  // ===========================================================================\n  // Comparison\n  // ===========================================================================\n\n  /**\n   * Compares this JSON to another for ordering.\n   *\n   * Ordering is defined as:\n   *  1. Null < Boolean < Number < String < Array < Object\n   *  2. Within types, natural ordering applies\n   */\n  def compare(that: Json): Int = (self, that) match {\n    case (Json.Null, Json.Null)               => 0\n    case (Json.Null, _)                       => -1\n    case (_, Json.Null)                       => 1\n    case (Json.Boolean(a), Json.Boolean(b))   => a.compare(b)\n    case (Json.Boolean(_), _)                 => -1\n    case (_, Json.Boolean(_))                 => 1\n    case (Json.Number(a), Json.Number(b))     => BigDecimal(a).compare(BigDecimal(b))\n    case (Json.Number(_), _)                  => -1\n    case (_, Json.Number(_))                  => 1\n    case (Json.String(a), Json.String(b))     => a.compare(b)\n    case (Json.String(_), _)                  => -1\n    case (_, Json.String(_))                  => 1\n    case (Json.Array(a), Json.Array(b))       => compareArrays(a, b)\n    case (Json.Array(_), _)                   => -1\n    case (_, Json.Array(_))                   => 1\n    case (Json.Object(a), Json.Object(b))     => compareObjects(a, b)\n  }\n\n  private def compareArrays(a: Vector[Json], b: Vector[Json]): Int = {\n    val len = math.min(a.size, b.size)\n    var i   = 0\n    while (i < len) {\n      val cmp = a(i).compare(b(i))\n      if (cmp != 0) return cmp\n      i += 1\n    }\n    a.size.compare(b.size)\n  }\n\n  private def compareObjects(a: Vector[(String, Json)], b: Vector[(String, Json)]): Int = {\n    val aSorted = a.sortBy(_._1)\n    val bSorted = b.sortBy(_._1)\n    val len     = math.min(aSorted.size, bSorted.size)\n    var i       = 0\n    while (i < len) {\n      val (ak, av) = aSorted(i)\n      val (bk, bv) = bSorted(i)\n      val keyCmp   = ak.compare(bk)\n      if (keyCmp != 0) return keyCmp\n      val valCmp = av.compare(bv)\n      if (valCmp != 0) return valCmp\n      i += 1\n    }\n    aSorted.size.compare(bSorted.size)\n  }\n\n  // ===========================================================================\n  // DynamicValue Interop\n  // ===========================================================================\n\n  /**\n   * Converts this JSON to a [[DynamicValue]].\n   *\n   * This conversion is lossless; all JSON values can be represented as DynamicValue.\n   */\n  def toDynamicValue: DynamicValue = self match {\n    case Json.Null =>\n      DynamicValue.Primitive(PrimitiveValue.Unit)\n    case Json.Boolean(v) =>\n      DynamicValue.Primitive(PrimitiveValue.Boolean(v))\n    case Json.Number(v) =>\n      // Preserve as BigDecimal for maximum precision\n      DynamicValue.Primitive(PrimitiveValue.BigDecimal(BigDecimal(v)))\n    case Json.String(v) =>\n      DynamicValue.Primitive(PrimitiveValue.String(v))\n    case Json.Array(elems) =>\n      DynamicValue.Sequence(elems.map(_.toDynamicValue))\n    case Json.Object(flds) =>\n      DynamicValue.Record(flds.map { case (k, v) => (k, v.toDynamicValue) })\n  }\n\n  // ===========================================================================\n  // Typed Decoding (Json => A)\n  // ===========================================================================\n\n  /**\n   * Decodes this JSON to a typed value.\n   *\n   * Uses implicit [[JsonDecoder]] which prefers explicit codecs over schema derivation.\n   *\n   * {{{\n   * val person: Either[JsonError, Person] = json.as[Person]\n   * }}}\n   *\n   * @tparam A The target type\n   * @return Either an error or the decoded value\n   */\n  def as[A](implicit decoder: JsonDecoder[A]): Either[JsonError, A] = decoder.decode(self)\n\n  /**\n   * Decodes this JSON to a typed value, throwing on failure.\n   *\n   * @tparam A The target type\n   * @return The decoded value\n   * @throws JsonError if decoding fails\n   */\n  def asUnsafe[A](implicit decoder: JsonDecoder[A]): A = as[A].fold(throw _, identity)\n\n  /**\n   * Internal: decode using an explicit codec.\n   */\n  private[json] def decodeWith[A](codec: JsonBinaryCodec[A]): Either[JsonError, A] = ???\n\n  // ===========================================================================\n  // Encoding (Json => String/Bytes)\n  // ===========================================================================\n\n  /**\n   * Encodes this JSON to a compact string (no extra whitespace).\n   */\n  def print: String = encode(WriterConfig)\n\n  /**\n   * Encodes this JSON to a string using the specified configuration.\n   *\n   * @param config Writer configuration (indentation, unicode escaping, etc.)\n   */\n  def print(config: WriterConfig): String = encode(config)\n\n  /**\n   * Alias for [[print]].\n   */\n  def encode: String = encode(WriterConfig)\n\n  /**\n   * Encodes this JSON to a string using the specified configuration.\n   *\n   * @param config Writer configuration\n   */\n  def encode(config: WriterConfig): String = ???\n\n  /**\n   * Encodes this JSON and writes to the provided [[Writer]].\n   *\n   * @param writer The writer to write to\n   */\n  def printTo(writer: Writer): Unit = printTo(writer, WriterConfig)\n\n  /**\n   * Encodes this JSON and writes to the provided [[Writer]] with configuration.\n   *\n   * @param writer The writer to write to\n   * @param config Writer configuration\n   */\n  def printTo(writer: Writer, config: WriterConfig): Unit = ???\n\n  /**\n   * Encodes this JSON to a byte array (UTF-8).\n   */\n  def encodeToBytes: Array[Byte] = encodeToBytes(WriterConfig)\n\n  /**\n   * Encodes this JSON to a byte array (UTF-8) with configuration.\n   *\n   * @param config Writer configuration\n   */\n  def encodeToBytes(config: WriterConfig): Array[Byte] = ???\n\n  /**\n   * Encodes this JSON to a [[Chunk]] of bytes (UTF-8).\n   */\n  def encodeToChunk: Chunk[Byte] = encodeToChunk(WriterConfig)\n\n  /**\n   * Encodes this JSON to a [[Chunk]] of bytes (UTF-8) with configuration.\n   *\n   * @param config Writer configuration\n   */\n  def encodeToChunk(config: WriterConfig): Chunk[Byte] = ???\n\n  /**\n   * Encodes this JSON into the provided [[ByteBuffer]].\n   *\n   * @param buffer The buffer to write to\n   */\n  def encodeTo(buffer: ByteBuffer): Unit = encodeTo(buffer, WriterConfig)\n\n  /**\n   * Encodes this JSON into the provided [[ByteBuffer]] with configuration.\n   *\n   * @param buffer The buffer to write to\n   * @param config Writer configuration\n   */\n  def encodeTo(buffer: ByteBuffer, config: WriterConfig): Unit = ???\n\n  // ===========================================================================\n  // Standard Methods\n  // ===========================================================================\n\n  override def hashCode(): Int = self match {\n    case Json.Null           => 0\n    case Json.Boolean(v)     => v.hashCode()\n    case Json.Number(v)      => BigDecimal(v).hashCode()\n    case Json.String(v)      => v.hashCode()\n    case Json.Array(elems)   => elems.hashCode()\n    case Json.Object(flds)   => flds.sortBy(_._1).hashCode()\n  }\n\n  override def equals(that: Any): Boolean = that match {\n    case other: Json => compare(other) == 0\n    case _           => false\n  }\n\n  override def toString: String = print\n}\n\nobject Json {\n\n  // ===========================================================================\n  // ADT Cases\n  // ===========================================================================\n\n  /**\n   * A JSON object: an unordered collection of key-value pairs.\n   *\n   * @param fields The key-value pairs. Keys should be unique; if duplicates\n   *               are present, behavior of accessors is undefined.\n   */\n  final case class Object(fields: Vector[(String, Json)]) extends Json {\n    override def isObject: scala.Boolean                = true\n    override def fields: Seq[(String, Json)]            = fields\n  }\n\n  object Object {\n\n    /**\n     * Creates an empty JSON object.\n     */\n    val empty: Object = Object(Vector.empty)\n\n    /**\n     * Creates a JSON object from key-value pairs.\n     */\n    def apply(fields: (String, Json)*): Object = Object(fields.toVector)\n  }\n\n  /**\n   * A JSON array: an ordered sequence of values.\n   *\n   * @param elements The array elements\n   */\n  final case class Array(elements: Vector[Json]) extends Json {\n    override def isArray: scala.Boolean  = true\n    override def elements: Seq[Json]     = elements\n  }\n\n  object Array {\n\n    /**\n     * Creates an empty JSON array.\n     */\n    val empty: Array = Array(Vector.empty)\n\n    /**\n     * Creates a JSON array from elements.\n     */\n    def apply(elements: Json*): Array = Array(elements.toVector)\n  }\n\n  /**\n   * A JSON string.\n   *\n   * @param value The string value (unescaped)\n   */\n  final case class String(value: java.lang.String) extends Json {\n    override def isString: scala.Boolean              = true\n    override def stringValue: Option[java.lang.String] = Some(value)\n  }\n\n  /**\n   * A JSON number.\n   *\n   * Stored as a string to preserve exact representation (precision, trailing zeros, etc.).\n   * Provides lazy conversion to numeric types.\n   *\n   * @param value The number as a string (should be valid JSON number syntax)\n   */\n  final case class Number(value: java.lang.String) extends Json {\n    override def isNumber: scala.Boolean                = true\n    override def numberValue: Option[java.lang.String]  = Some(value)\n\n    /**\n     * Converts to `Int`, truncating if necessary.\n     */\n    lazy val toInt: Int = toBigDecimal.toInt\n\n    /**\n     * Converts to `Long`, truncating if necessary.\n     */\n    lazy val toLong: Long = toBigDecimal.toLong\n\n    /**\n     * Converts to `Float`.\n     */\n    lazy val toFloat: Float = value.toFloat\n\n    /**\n     * Converts to `Double`.\n     */\n    lazy val toDouble: Double = value.toDouble\n\n    /**\n     * Converts to `BigInt`, truncating fractional part.\n     */\n    lazy val toBigInt: BigInt = toBigDecimal.toBigInt\n\n    /**\n     * Converts to `BigDecimal` (lossless).\n     */\n    lazy val toBigDecimal: BigDecimal = BigDecimal(value)\n  }\n\n  /**\n   * A JSON boolean.\n   *\n   * @param value The boolean value\n   */\n  final case class Boolean(value: scala.Boolean) extends Json {\n    override def isBoolean: scala.Boolean              = true\n    override def booleanValue: Option[scala.Boolean]   = Some(value)\n  }\n\n  object Boolean {\n    val True: Boolean  = Boolean(true)\n    val False: Boolean = Boolean(false)\n  }\n\n  /**\n   * The JSON null value.\n   */\n  case object Null extends Json {\n    override def isNull: scala.Boolean = true\n  }\n\n  // ===========================================================================\n  // Convenience Constructors\n  // ===========================================================================\n\n  /**\n   * Creates a JSON number from an `Int`.\n   */\n  def number(n: Int): Number = Number(n.toString)\n\n  /**\n   * Creates a JSON number from a `Long`.\n   */\n  def number(n: Long): Number = Number(n.toString)\n\n  /**\n   * Creates a JSON number from a `Float`.\n   */\n  def number(n: Float): Number = Number(n.toString)\n\n  /**\n   * Creates a JSON number from a `Double`.\n   */\n  def number(n: Double): Number = Number(n.toString)\n\n  /**\n   * Creates a JSON number from a `BigInt`.\n   */\n  def number(n: BigInt): Number = Number(n.toString)\n\n  /**\n   * Creates a JSON number from a `BigDecimal`.\n   */\n  def number(n: BigDecimal): Number = Number(n.toString)\n\n  /**\n   * Creates a JSON number from a `Short`.\n   */\n  def number(n: Short): Number = Number(n.toString)\n\n  /**\n   * Creates a JSON number from a `Byte`.\n   */\n  def number(n: Byte): Number = Number(n.toString)\n\n  // ===========================================================================\n  // Parsing / Decoding (String/Bytes => Json)\n  // ===========================================================================\n\n  /**\n   * Parses a JSON value from a string.\n   *\n   * @param s The JSON string\n   * @return Either a [[JsonError]] or the parsed JSON\n   */\n  def parse(s: java.lang.String): Either[JsonError, Json] = decode(s)\n\n  /**\n   * Parses a JSON value from a `CharSequence`.\n   *\n   * @param s The JSON character sequence\n   * @return Either a [[JsonError]] or the parsed JSON\n   */\n  def parse(s: CharSequence): Either[JsonError, Json] = decode(s)\n\n  /**\n   * Parses a JSON value from a byte array (UTF-8).\n   *\n   * @param bytes The JSON bytes\n   * @return Either a [[JsonError]] or the parsed JSON\n   */\n  def parse(bytes: scala.Array[Byte]): Either[JsonError, Json] = decode(bytes)\n\n  /**\n   * Parses a JSON value from a [[Chunk]] of bytes (UTF-8).\n   *\n   * @param chunk The JSON bytes\n   * @return Either a [[JsonError]] or the parsed JSON\n   */\n  def parse(chunk: Chunk[Byte]): Either[JsonError, Json] = decode(chunk)\n\n  /**\n   * Parses a JSON value from a [[ByteBuffer]] (UTF-8).\n   *\n   * @param buffer The JSON bytes\n   * @return Either a [[JsonError]] or the parsed JSON\n   */\n  def parse(buffer: ByteBuffer): Either[JsonError, Json] = decode(buffer)\n\n  /**\n   * Parses a JSON value from a [[Reader]].\n   *\n   * @param reader The reader to read from\n   * @return Either a [[JsonError]] or the parsed JSON\n   */\n  def parse(reader: Reader): Either[JsonError, Json] = decode(reader)\n\n  /**\n   * Decodes a JSON value from a string.\n   */\n  def decode(s: java.lang.String): Either[JsonError, Json] = ???\n\n  /**\n   * Decodes a JSON value from a `CharSequence`.\n   */\n  def decode(s: CharSequence): Either[JsonError, Json] = ???\n\n  /**\n   * Decodes a JSON value from a byte array (UTF-8).\n   */\n  def decode(bytes: scala.Array[Byte]): Either[JsonError, Json] = ???\n\n  /**\n   * Decodes a JSON value from a [[Chunk]] of bytes (UTF-8).\n   */\n  def decode(chunk: Chunk[Byte]): Either[JsonError, Json] = ???\n\n  /**\n   * Decodes a JSON value from a [[ByteBuffer]] (UTF-8).\n   */\n  def decode(buffer: ByteBuffer): Either[JsonError, Json] = ???\n\n  /**\n   * Decodes a JSON value from a [[Reader]].\n   */\n  def decode(reader: Reader): Either[JsonError, Json] = ???\n\n  /**\n   * Parses a JSON value from a string, throwing on failure.\n   *\n   * @param s The JSON string\n   * @return The parsed JSON\n   * @throws JsonError if parsing fails\n   */\n  def parseUnsafe(s: java.lang.String): Json = decode(s).fold(throw _, identity)\n\n  /**\n   * Alias for [[parseUnsafe]].\n   */\n  def decodeUnsafe(s: java.lang.String): Json = parseUnsafe(s)\n\n  // ===========================================================================\n  // Typed Encoding (A => Json)\n  // ===========================================================================\n\n  /**\n   * Encodes a typed value to JSON.\n   *\n   * Uses implicit [[JsonEncoder]] which prefers explicit codecs over schema derivation.\n   *\n   * {{{\n   * val json = Json.from(Person(\"Alice\", 30))\n   * }}}\n   *\n   * @param value The value to encode\n   * @return The encoded JSON\n   */\n  def from[A](value: A)(implicit encoder: JsonEncoder[A]): Json = encoder.encode(value)\n\n  /**\n   * Internal: encode using an explicit codec.\n   */\n  private[json] def encodeWith[A](value: A, codec: JsonBinaryCodec[A]): Json = ???\n\n  // ===========================================================================\n  // DynamicValue Interop\n  // ===========================================================================\n\n  /**\n   * Converts a [[DynamicValue]] to JSON.\n   *\n   * This conversion is lossy for `DynamicValue` types that have no JSON equivalent:\n   *  - `PrimitiveValue` types like `java.time.*` are converted to strings\n   *  - `DynamicValue.Variant` uses a discriminator field\n   *\n   * @param value The dynamic value to convert\n   * @return The JSON representation\n   */\n  def fromDynamicValue(value: DynamicValue): Json = value match {\n    case DynamicValue.Primitive(pv) => fromPrimitiveValue(pv)\n    case DynamicValue.Record(flds) =>\n      Object(flds.map { case (k, v) => (k, fromDynamicValue(v)) })\n    case DynamicValue.Variant(caseName, v) =>\n      Object(Vector(\"_type\" -> String(caseName), \"_value\" -> fromDynamicValue(v)))\n    case DynamicValue.Sequence(elems) =>\n      Array(elems.map(fromDynamicValue))\n    case DynamicValue.Map(entries) =>\n      Array(entries.map { case (k, v) =>\n        Object(Vector(\"key\" -> fromDynamicValue(k), \"value\" -> fromDynamicValue(v)))\n      })\n  }\n\n  private def fromPrimitiveValue(pv: PrimitiveValue): Json = pv match {\n    case PrimitiveValue.Unit              => Null\n    case PrimitiveValue.Boolean(v)        => Boolean(v)\n    case PrimitiveValue.Byte(v)           => number(v)\n    case PrimitiveValue.Short(v)          => number(v)\n    case PrimitiveValue.Int(v)            => number(v)\n    case PrimitiveValue.Long(v)           => number(v)\n    case PrimitiveValue.Float(v)          => number(v)\n    case PrimitiveValue.Double(v)         => number(v)\n    case PrimitiveValue.Char(v)           => String(v.toString)\n    case PrimitiveValue.String(v)         => String(v)\n    case PrimitiveValue.BigInt(v)         => number(v)\n    case PrimitiveValue.BigDecimal(v)     => number(v)\n    case PrimitiveValue.DayOfWeek(v)      => String(v.toString)\n    case PrimitiveValue.Duration(v)       => String(v.toString)\n    case PrimitiveValue.Instant(v)        => String(v.toString)\n    case PrimitiveValue.LocalDate(v)      => String(v.toString)\n    case PrimitiveValue.LocalDateTime(v)  => String(v.toString)\n    case PrimitiveValue.LocalTime(v)      => String(v.toString)\n    case PrimitiveValue.Month(v)          => String(v.toString)\n    case PrimitiveValue.MonthDay(v)       => String(v.toString)\n    case PrimitiveValue.OffsetDateTime(v) => String(v.toString)\n    case PrimitiveValue.OffsetTime(v)     => String(v.toString)\n    case PrimitiveValue.Period(v)         => String(v.toString)\n    case PrimitiveValue.Year(v)           => String(v.toString)\n    case PrimitiveValue.YearMonth(v)      => String(v.toString)\n    case PrimitiveValue.ZoneId(v)         => String(v.getId)\n    case PrimitiveValue.ZoneOffset(v)     => String(v.toString)\n    case PrimitiveValue.ZonedDateTime(v)  => String(v.toString)\n    case PrimitiveValue.Currency(v)       => String(v.getCurrencyCode)\n    case PrimitiveValue.UUID(v)           => String(v.toString)\n  }\n\n  // ===========================================================================\n  // KV Interop\n  // ===========================================================================\n\n  /**\n   * Assembles JSON from a sequence of path-value pairs.\n   *\n   * {{{\n   * Json.fromKV(Seq(\n   *   p\"a.b\" -> Json.number(1),\n   *   p\"a.c\" -> Json.String(\"x\"),\n   *   p\"d[0]\" -> Json.Boolean(true)\n   * ))\n   * // {\"a\": {\"b\": 1, \"c\": \"x\"}, \"d\": [true]}\n   * }}}\n   *\n   * @param kvs The path-value pairs\n   * @return Either an error (for conflicting paths) or the assembled JSON\n   */\n  def fromKV(kvs: Seq[(DynamicOptic, Json)]): Either[JsonError, Json] = ???\n\n  /**\n   * Assembles JSON from path-value pairs, throwing on conflict.\n   */\n  def fromKVUnsafe(kvs: Seq[(DynamicOptic, Json)]): Json = fromKV(kvs).fold(throw _, identity)\n\n  // ===========================================================================\n  // Patch Interop\n  // ===========================================================================\n\n  /**\n   * Serializes a [[JsonPatch]] to its JSON representation.\n   *\n   * The format follows RFC 6902 (JSON Patch) for standard operations,\n   * with extensions for LCS-based sequence diffs.\n   *\n   * @param patch The patch to serialize\n   * @return The JSON representation of the patch\n   */\n  def fromJsonPatch(patch: JsonPatch): Json = ???\n\n  /**\n   * Deserializes a JSON representation into a [[JsonPatch]].\n   *\n   * @param json The JSON patch representation\n   * @return Either an error or the parsed patch\n   */\n  def toJsonPatch(json: Json): Either[JsonError, JsonPatch] = ???\n\n  // ===========================================================================\n  // Ordering\n  // ===========================================================================\n\n  /**\n   * Ordering for JSON values.\n   *\n   * Order: Null < Boolean < Number < String < Array < Object\n   */\n  implicit val ordering: Ordering[Json] = (x: Json, y: Json) => x.compare(y)\n}\n\n// =============================================================================\n// MERGE STRATEGY\n// =============================================================================\n\n/**\n * Strategy for merging JSON values.\n */\nsealed trait MergeStrategy\n\nobject MergeStrategy {\n\n  /**\n   * Automatically determines merge behavior based on value types:\n   *  - Objects: deep merge (recurse into matching keys)\n   *  - Arrays: concatenate\n   *  - Primitives: right wins\n   */\n  case object Auto extends MergeStrategy\n\n  /**\n   * Deep merge for objects; concatenate arrays.\n   */\n  case object Deep extends MergeStrategy\n\n  /**\n   * Shallow merge: right value wins for any key conflict.\n   */\n  case object Shallow extends MergeStrategy\n\n  /**\n   * Concatenate arrays; for objects and primitives, right wins.\n   */\n  case object Concat extends MergeStrategy\n\n  /**\n   * Right value always wins (replacement).\n   */\n  case object Replace extends MergeStrategy\n\n  /**\n   * Custom merge function.\n   *\n   * @param f A function receiving path and both values, returning merged result\n   */\n  final case class Custom(f: (DynamicOptic, Json, Json) => Json) extends MergeStrategy\n}\n\n// =============================================================================\n// STRING INTERPOLATORS\n// =============================================================================\n\n/**\n * Provides string interpolators for JSON paths and literals.\n *\n * Import with:\n * {{{\n * import zio.blocks.schema.json.interpolators._\n * }}}\n *\n * ==Path Syntax==\n *\n * The `p` interpolator creates [[DynamicOptic]] paths using a JSONPath-compatible dialect:\n *\n * {{{\n * p\"foo.bar\"           // fields \"foo\" then \"bar\"\n * p\"users[0]\"          // field \"users\", then index 0\n * p\"users[0].name\"     // field \"users\", index 0, field \"name\"\n * p\"items[*]\"          // field \"items\", then all array elements\n * p\"config{*}\"         // field \"config\", then all object values\n * p\"config{*:}\"        // field \"config\", then all object keys\n * p\"[0,2,5]\"           // indices 0, 2, and 5\n * p\"[0:5]\"             // slice: indices 0 through 4\n * p\"[::2]\"             // slice: every other element\n * p\"`field.name`\"      // field with dots in name (backtick escaping)\n * p\"\"\"[\"field\"]\"\"\"     // alternate field syntax (bracket notation)\n * }}}\n *\n * ===JSONPath Compatibility===\n *\n * This syntax is a dialect of JSONPath (RFC 9535). Most JSONPath expressions work:\n *  - `$.foo.bar` - root prefix is optional and ignored\n *  - `.field`, `[\"field\"]` - field access\n *  - `[n]`, `[*]`, `[m,n]`, `[m:n]` - array access\n *\n * '''Not supported:'''\n *  - `..` (recursive descent)\n *  - `[?()]` (filter expressions)\n *\n * ===Extensions beyond JSONPath:===\n *  - `{*}` - all object values (explicit, vs `[*]` which is array-focused in JSONPath)\n *  - `{*:}` - all object keys (not expressible in standard JSONPath)\n *  - Backtick escaping for field names\n */\nobject interpolators {\n\n  implicit class JsonPathInterpolator(val sc: StringContext) extends AnyVal {\n\n    /**\n     * Creates a [[DynamicOptic]] from a path string at compile time.\n     *\n     * @return The parsed [[DynamicOptic]]\n     */\n    def p(args: Any*): DynamicOptic = macro PathMacros.pathInterpolator\n  }\n\n  implicit class JsonLiteralInterpolator(val sc: StringContext) extends AnyVal {\n\n    /**\n     * Creates a [[Json]] value from a JSON literal at compile time.\n     *\n     * {{{\n     * j\"\"\"{\"name\": \"Alice\", \"age\": 30}\"\"\"\n     * j\"[1, 2, 3]\"\n     * j\"null\"\n     * }}}\n     *\n     * Interpolated values are converted to JSON:\n     * {{{\n     * val name = \"Bob\"\n     * val age = 25\n     * j\"\"\"{\"name\": $name, \"age\": $age}\"\"\"\n     * }}}\n     *\n     * @return The parsed [[Json]] value\n     */\n    def j(args: Any*): Json = macro PathMacros.jsonInterpolator\n  }\n}\n\n/**\n * Macro implementations for string interpolators.\n * \n * Separate implementations would be needed for Scala 2 and Scala 3.\n */\nobject PathMacros {\n  import scala.reflect.macros.blackbox\n\n  def pathInterpolator(c: blackbox.Context)(args: c.Expr[Any]*): c.Expr[DynamicOptic] = ???\n\n  def jsonInterpolator(c: blackbox.Context)(args: c.Expr[Any]*): c.Expr[Json] = ???\n}\n\n// =============================================================================\n// PLACEHOLDER TYPES (assumed to exist)\n// =============================================================================\n\n/**\n * Represents a JSON Schema for validation.\n *\n * Placeholder - actual implementation TBD.\n */\nsealed trait JsonSchema\n\nobject JsonSchema {\n  // Placeholder\n}\n\n/**\n * Represents a patch that can be applied to JSON values.\n *\n * Supports RFC 6902 operations (add, remove, replace, move, copy, test)\n * plus extensions for LCS-based sequence diffs and string diffs.\n *\n * Placeholder - actual implementation TBD.\n */\nsealed trait JsonPatch {\n\n  /**\n   * Converts this JSON patch to a [[DynamicPatch]].\n   */\n  def toDynamicPatch: DynamicPatch\n}\n\nobject JsonPatch {\n\n  /**\n   * Creates an empty patch (no operations).\n   */\n  val empty: JsonPatch = ???\n\n  /**\n   * Creates a patch from a [[DynamicPatch]].\n   *\n   * May fail if the DynamicPatch contains operations not representable in JSON.\n   */\n  def fromDynamicPatch(patch: DynamicPatch): Either[JsonError, JsonPatch] = ???\n}\n\n/**\n * Represents a patch that can be applied to [[DynamicValue]].\n *\n * Placeholder - actual implementation TBD.\n */\nsealed trait DynamicPatch\n\nobject DynamicPatch {\n\n  /**\n   * Creates an empty patch (no operations).\n   */\n  val empty: DynamicPatch = ???\n}\n```",
                  "html_url": "https://github.com/zio/zio-blocks/issues/679"
                },
                "type": "github"
              },
              "hash": "zio/zio-blocks#679",
              "body": "The following is a sketch of what a proper `Json` data type should look like, including constructors, methods, and related types. Note that `DynamicPatch`, `JsonPatch`, and `JsonSchema` are all out-of-scope for this ticket.\n\n## Sketch\n\n```scala\npackage zio.blocks.schema.json\n\nimport zio.blocks.chunk.Chunk\nimport zio.blocks.schema.{DynamicOptic, DynamicValue, PrimitiveValue, Schema, SchemaError}\n\nimport java.io.{Reader, Writer}\nimport java.nio.ByteBuffer\nimport scala.util.control.NoStackTrace\n\n// =============================================================================\n// JSON ERROR\n// =============================================================================\n\n/**\n * Represents an error that occurred during JSON parsing, encoding, or processing.\n *\n * NOTE: This should replace JsonBinaryCodecError and be moved to `zio.block.schema.json`.\n *\n * @param message A human-readable description of the error\n * @param path The location in the JSON structure where the error occurred,\n *             represented as a [[DynamicOptic]]\n * @param offset Optional byte offset in the input where the error occurred\n * @param line Optional 1-indexed line number where the error occurred\n * @param column Optional 1-indexed column number where the error occurred\n */\nfinal case class JsonError(\n  message: String,\n  path: DynamicOptic,\n  offset: Option[Long],\n  line: Option[Int],\n  column: Option[Int]\n) extends Exception with NoStackTrace {\n\n  override def getMessage: String = {\n    val posInfo = (line, column) match {\n      case (Some(l), Some(c)) => s\" at line $l, column $c\"\n      case _                  => offset.map(o => s\" at offset $o\").getOrElse(\"\")\n    }\n    val pathInfo = if (path.nodes.isEmpty) \"\" else s\" at path $path\"\n    s\"$message$pathInfo$posInfo\"\n  }\n\n  /**\n   * Combines this error with another, preserving both error messages.\n   */\n  def ++(other: JsonError): JsonError =\n    JsonError(s\"${this.message}; ${other.message}\", this.path, this.offset, this.line, this.column)\n}\n\nobject JsonError {\n\n  /**\n   * Creates a JsonError with only a message, using root path and no position info.\n   */\n  def apply(message: String): JsonError =\n    JsonError(message, DynamicOptic.root, None, None, None)\n\n  /**\n   * Creates a JsonError with a message and path, no position info.\n   */\n  def apply(message: String, path: DynamicOptic): JsonError =\n    JsonError(message, path, None, None, None)\n\n  /**\n   * Converts a [[SchemaError]] to a [[JsonError]].\n   */\n  def fromSchemaError(error: SchemaError): JsonError =\n    JsonError(error.message, DynamicOptic.root, None, None, None)\n}\n\n// =============================================================================\n// JSON DECODER / ENCODER (implicit priority resolution)\n// =============================================================================\n\n/**\n * Type class for decoding [[Json]] values into Scala types.\n *\n * Implicit resolution prefers explicitly provided [[JsonBinaryCodec]] instances\n * over schema-derived instances, allowing users to override derived behavior.\n */\nsealed trait JsonDecoder[A] {\n\n  /**\n   * Decodes a [[Json]] value into type `A`.\n   *\n   * @param json The JSON value to decode\n   * @return Either a [[JsonError]] on failure, or the decoded value\n   */\n  def decode(json: Json): Either[JsonError, A]\n}\n\nobject JsonDecoder extends JsonDecoderLowPriority {\n\n  def apply[A](implicit decoder: JsonDecoder[A]): JsonDecoder[A] = decoder\n\n  /**\n   * Higher priority: use an explicitly provided [[JsonBinaryCodec]].\n   */\n  implicit def fromCodec[A](implicit codec: JsonBinaryCodec[A]): JsonDecoder[A] =\n    new JsonDecoder[A] {\n      def decode(json: Json): Either[JsonError, A] = json.decodeWith(codec)\n    }\n}\n\n/**\n * Lower priority implicits for [[JsonDecoder]].\n */\ntrait JsonDecoderLowPriority {\n\n  /**\n   * Lower priority: derive a codec from an implicit [[Schema]].\n   */\n  implicit def fromSchema[A](implicit schema: Schema[A]): JsonDecoder[A] =\n    new JsonDecoder[A] {\n      private lazy val codec: JsonBinaryCodec[A] = schema.derive(JsonBinaryCodecDeriver)\n      def decode(json: Json): Either[JsonError, A] = json.decodeWith(codec)\n    }\n}\n\n/**\n * Type class for encoding Scala types into [[Json]] values.\n *\n * Implicit resolution prefers explicitly provided [[JsonBinaryCodec]] instances\n * over schema-derived instances, allowing users to override derived behavior.\n */\nsealed trait JsonEncoder[A] {\n\n  /**\n   * Encodes a value of type `A` into [[Json]].\n   *\n   * @param value The value to encode\n   * @return The encoded JSON value\n   */\n  def encode(value: A): Json\n}\n\nobject JsonEncoder extends JsonEncoderLowPriority {\n\n  def apply[A](implicit encoder: JsonEncoder[A]): JsonEncoder[A] = encoder\n\n  /**\n   * Higher priority: use an explicitly provided [[JsonBinaryCodec]].\n   */\n  implicit def fromCodec[A](implicit codec: JsonBinaryCodec[A]): JsonEncoder[A] =\n    new JsonEncoder[A] {\n      def encode(value: A): Json = Json.encodeWith(value, codec)\n    }\n}\n\n/**\n * Lower priority implicits for [[JsonEncoder]].\n */\ntrait JsonEncoderLowPriority {\n\n  /**\n   * Lower priority: derive a codec from an implicit [[Schema]].\n   */\n  implicit def fromSchema[A](implicit schema: Schema[A]): JsonEncoder[A] =\n    new JsonEncoder[A] {\n      private lazy val codec: JsonBinaryCodec[A] = schema.derive(JsonBinaryCodecDeriver)\n      def encode(value: A): Json = Json.encodeWith(value, codec)\n    }\n}\n\n// =============================================================================\n// JSON SELECTION\n// =============================================================================\n\n/**\n * Represents a selection of zero or more JSON values, with accumulated errors.\n *\n * `JsonSelection` enables fluent chaining of operations that may fail without\n * requiring immediate error handling. Operations are applied to all values in\n * the selection, and errors are accumulated.\n *\n * {{{\n * val selection: JsonSelection = json.get(p\"users[*].name\")\n * val result: Either[SchemaError, Vector[Json]] = selection.toEither\n * }}}\n */\nfinal case class JsonSelection(toEither: Either[SchemaError, Vector[Json]]) { self =>\n\n  /**\n   * Returns true if this selection contains no values (either empty or errored).\n   */\n  def isEmpty: Boolean = toEither.fold(_ => true, _.isEmpty)\n\n  /**\n   * Returns true if this selection contains at least one value.\n   */\n  def nonEmpty: Boolean = toEither.fold(_ => false, _.nonEmpty)\n\n  /**\n   * Returns the number of values in this selection, or 0 if errored.\n   */\n  def size: Int = toEither.fold(_ => 0, _.size)\n\n  // ---------------------------------------------------------------------------\n  // Transformations\n  // ---------------------------------------------------------------------------\n\n  /**\n   * Applies a function to each JSON value in this selection.\n   *\n   * @param f The transformation function\n   * @return A new selection with transformed values\n   */\n  def map(f: Json => Json): JsonSelection =\n    JsonSelection(toEither.map(_.map(f)))\n\n  /**\n   * Applies a function returning a selection to each value, flattening results.\n   *\n   * @param f The function producing selections\n   * @return A new selection with all results combined\n   */\n  def flatMap(f: Json => JsonSelection): JsonSelection =\n    JsonSelection(toEither.flatMap { jsons =>\n      jsons.foldLeft[Either[SchemaError, Vector[Json]]](Right(Vector.empty)) { (acc, json) =>\n        for {\n          existing <- acc\n          next     <- f(json).toEither\n        } yield existing ++ next\n      }\n    })\n\n  /**\n   * Filters values in this selection by a predicate.\n   *\n   * @param p The predicate to test values\n   * @return A new selection containing only values satisfying the predicate\n   */\n  def filter(p: Json => Boolean): JsonSelection =\n    JsonSelection(toEither.map(_.filter(p)))\n\n  /**\n   * Collects values for which the partial function is defined.\n   *\n   * @param pf A partial function to apply\n   * @return A new selection with collected results\n   */\n  def collect(pf: PartialFunction[Json, Json]): JsonSelection =\n    JsonSelection(toEither.map(_.collect(pf)))\n\n  // ---------------------------------------------------------------------------\n  // Navigation\n  // ---------------------------------------------------------------------------\n\n  /**\n   * Navigates to values at the given path within each selected value.\n   *\n   * @param path The path to navigate\n   * @return A new selection with values at the path\n   */\n  def get(path: DynamicOptic): JsonSelection =\n    flatMap(json => json.get(path))\n\n  /**\n   * Alias for [[get]].\n   */\n  def apply(path: DynamicOptic): JsonSelection = get(path)\n\n  /**\n   * Navigates to array element at given index within each selected value.\n   *\n   * @param index The array index\n   * @return A new selection with elements at the index\n   */\n  def apply(index: Int): JsonSelection =\n    flatMap(json => json.apply(index))\n\n  /**\n   * Navigates to object field with given key within each selected value.\n   *\n   * @param key The object key\n   * @return A new selection with values at the key\n   */\n  def apply(key: String): JsonSelection =\n    flatMap(json => json.apply(key))\n\n  // ---------------------------------------------------------------------------\n  // Type Filtering\n  // ---------------------------------------------------------------------------\n\n  /**\n   * Filters to only JSON objects.\n   */\n  def objects: JsonSelection = filter(_.isObject)\n\n  /**\n   * Filters to only JSON arrays.\n   */\n  def arrays: JsonSelection = filter(_.isArray)\n\n  /**\n   * Filters to only JSON strings.\n   */\n  def strings: JsonSelection = filter(_.isString)\n\n  /**\n   * Filters to only JSON numbers.\n   */\n  def numbers: JsonSelection = filter(_.isNumber)\n\n  /**\n   * Filters to only JSON booleans.\n   */\n  def booleans: JsonSelection = filter(_.isBoolean)\n\n  /**\n   * Filters to only JSON nulls.\n   */\n  def nulls: JsonSelection = filter(_.isNull)\n\n  // ---------------------------------------------------------------------------\n  // Combination\n  // ---------------------------------------------------------------------------\n\n  /**\n   * Combines this selection with another, concatenating values or errors.\n   *\n   * @param other The other selection\n   * @return A combined selection\n   */\n  def ++(other: JsonSelection): JsonSelection =\n    (toEither, other.toEither) match {\n      case (Right(a), Right(b)) => JsonSelection(Right(a ++ b))\n      case (Left(a), Left(b))   => JsonSelection(Left(a ++ b))\n      case (Left(a), _)         => JsonSelection(Left(a))\n      case (_, Left(b))         => JsonSelection(Left(b))\n    }\n\n  // ---------------------------------------------------------------------------\n  // Terminal Operations\n  // ---------------------------------------------------------------------------\n\n  /**\n   * Returns the single value if exactly one, an array of values if there are many, or \n   * otherwise an error.\n   */\n  def one: Either[SchemaError, Json] =\n    toEither.flatMap { jsons =>\n      if (jsons.size == 1) Right(jsons.head)\n      else if (jsons.size > 1) toArray\n      else Left(SchemaError.expectationMismatch(Nil, s\"expected exactly one value, got ${jsons.size}\"))\n    }\n\n  /**\n   * Returns the first value if any, otherwise an error.\n   */\n  def first: Either[SchemaError, Json] =\n    toEither.flatMap { jsons =>\n      jsons.headOption.toRight(SchemaError.expectationMismatch(Nil, \"expected at least one value, got none\"))\n    }\n\n  /**\n   * Returns all values as a [[Json.Array]], or an error.\n   */\n  def toArray: Either[SchemaError, Json] =\n    toEither.map(jsons => Json.Array(jsons))\n\n  /**\n   * Unsafe version of [[one]], throws on error or wrong count.\n   */\n  def oneUnsafe: Json = one.fold(e => throw JsonError.fromSchemaError(e), identity)\n\n  /**\n   * Unsafe version of [[first]], throws on error or empty.\n   */\n  def firstUnsafe: Json = first.fold(e => throw JsonError.fromSchemaError(e), identity)\n}\n\nobject JsonSelection {\n\n  /**\n   * Creates a selection containing a single value.\n   */\n  def apply(json: Json): JsonSelection = JsonSelection(Right(Vector(json)))\n\n  /**\n   * Creates a selection containing multiple values.\n   */\n  def fromVector(jsons: Vector[Json]): JsonSelection = JsonSelection(Right(jsons))\n\n  /**\n   * Creates an empty selection (no values, no error).\n   */\n  val empty: JsonSelection = JsonSelection(Right(Vector.empty))\n\n  /**\n   * Creates a failed selection with the given error.\n   */\n  def fail(error: SchemaError): JsonSelection = JsonSelection(Left(error))\n\n  /**\n   * Creates a failed selection with the given message.\n   */\n  def fail(message: String): JsonSelection =\n    JsonSelection(Left(SchemaError.expectationMismatch(Nil, message)))\n}\n\n// =============================================================================\n// JSON ADT\n// =============================================================================\n\n/**\n * Represents a JSON value.\n *\n * The JSON data model consists of:\n *  - '''Objects''': Unordered collections of key-value pairs\n *  - '''Arrays''': Ordered sequences of values\n *  - '''Strings''': Unicode text\n *  - '''Numbers''': Numeric values (stored as strings for precision)\n *  - '''Booleans''': `true` or `false`\n *  - '''Null''': The null value\n *\n * ==Construction==\n * {{{\n * val obj = Json.Object(\"name\" -> Json.String(\"Alice\"), \"age\" -> Json.number(30))\n * val arr = Json.Array(Json.String(\"a\"), Json.String(\"b\"))\n * val str = Json.String(\"hello\")\n * val num = Json.number(42)\n * val bool = Json.Boolean(true)\n * val nul = Json.Null\n * }}}\n *\n * ==Navigation==\n * {{{\n * json.get(p\"users[0].name\")   // JsonSelection\n * json(\"users\")(0)(\"name\")     // JsonSelection\n * json.fields                  // for objects\n * json.elements                // for arrays\n * }}}\n *\n * ==Pattern Matching==\n * {{{\n * json match {\n *   case Json.Object(fields) => ...\n *   case Json.Array(elements) => ...\n *   case Json.String(value) => ...\n *   case Json.Number(value) => ...\n *   case Json.Boolean(value) => ...\n *   case Json.Null => ...\n * }\n * }}}\n */\nsealed trait Json { self =>\n\n  // ===========================================================================\n  // Type Testing\n  // ===========================================================================\n\n  /**\n   * Returns `true` if this is a JSON object.\n   */\n  def isObject: Boolean = false\n\n  /**\n   * Returns `true` if this is a JSON array.\n   */\n  def isArray: Boolean = false\n\n  /**\n   * Returns `true` if this is a JSON string.\n   */\n  def isString: Boolean = false\n\n  /**\n   * Returns `true` if this is a JSON number.\n   */\n  def isNumber: Boolean = false\n\n  /**\n   * Returns `true` if this is a JSON boolean.\n   */\n  def isBoolean: Boolean = false\n\n  /**\n   * Returns `true` if this is JSON null.\n   */\n  def isNull: Boolean = false\n\n  // ===========================================================================\n  // Type Filtering (returns JsonSelection)\n  // ===========================================================================\n\n  /**\n   * Returns a [[JsonSelection]] containing this value if it is an object,\n   * otherwise an empty selection.\n   */\n  def asObject: JsonSelection = if (isObject) JsonSelection(self) else JsonSelection.empty\n\n  /**\n   * Returns a [[JsonSelection]] containing this value if it is an array,\n   * otherwise an empty selection.\n   */\n  def asArray: JsonSelection = if (isArray) JsonSelection(self) else JsonSelection.empty\n\n  /**\n   * Returns a [[JsonSelection]] containing this value if it is a string,\n   * otherwise an empty selection.\n   */\n  def asString: JsonSelection = if (isString) JsonSelection(self) else JsonSelection.empty\n\n  /**\n   * Returns a [[JsonSelection]] containing this value if it is a number,\n   * otherwise an empty selection.\n   */\n  def asNumber: JsonSelection = if (isNumber) JsonSelection(self) else JsonSelection.empty\n\n  /**\n   * Returns a [[JsonSelection]] containing this value if it is a boolean,\n   * otherwise an empty selection.\n   */\n  def asBoolean: JsonSelection = if (isBoolean) JsonSelection(self) else JsonSelection.empty\n\n  /**\n   * Returns a [[JsonSelection]] containing this value if it is null,\n   * otherwise an empty selection.\n   */\n  def asNull: JsonSelection = if (isNull) JsonSelection(self) else JsonSelection.empty\n\n  // ===========================================================================\n  // Direct Accessors\n  // ===========================================================================\n\n  /**\n   * If this is an object, returns its fields as key-value pairs.\n   * Otherwise returns an empty sequence.\n   */\n  def fields: Seq[(String, Json)] = Seq.empty\n\n  /**\n   * If this is an array, returns its elements.\n   * Otherwise returns an empty sequence.\n   */\n  def elements: Seq[Json] = Seq.empty\n\n  /**\n   * If this is a string, returns its value.\n   * Otherwise returns `None`.\n   */\n  def stringValue: Option[String] = None\n\n  /**\n   * If this is a number, returns its string representation.\n   * Otherwise returns `None`.\n   */\n  def numberValue: Option[String] = None\n\n  /**\n   * If this is a boolean, returns its value.\n   * Otherwise returns `None`.\n   */\n  def booleanValue: Option[scala.Boolean] = None\n\n  // ===========================================================================\n  // Navigation\n  // ===========================================================================\n\n  /**\n   * Navigates to values at the given path.\n   *\n   * {{{\n   * json.get(p\"users[0].name\")\n   * json.get(DynamicOptic.root.field(\"users\").at(0).field(\"name\"))\n   * }}}\n   *\n   * @param path The path to navigate\n   * @return A [[JsonSelection]] containing values at the path\n   */\n  def get(path: DynamicOptic): JsonSelection = ???\n\n  /**\n   * Alias for [[get]].\n   */\n  def apply(path: DynamicOptic): JsonSelection = get(path)\n\n  /**\n   * If this is an array, returns a selection containing the element at the given index.\n   * Returns an empty selection if not an array or index is out of bounds.\n   *\n   * @param index The array index (0-based)\n   */\n  def apply(index: Int): JsonSelection = self match {\n    case Json.Array(elems) if index >= 0 && index < elems.size =>\n      JsonSelection(elems(index))\n    case _ =>\n      JsonSelection.empty\n  }\n\n  /**\n   * If this is an object, returns a selection containing the value at the given key.\n   * Returns an empty selection if not an object or key is not present.\n   *\n   * @param key The object key\n   */\n  def apply(key: String): JsonSelection = self match {\n    case Json.Object(flds) =>\n      flds.collectFirst { case (k, v) if k == key => v } match {\n        case Some(v) => JsonSelection(v)\n        case None    => JsonSelection.empty\n      }\n    case _ =>\n      JsonSelection.empty\n  }\n\n  // ===========================================================================\n  // Modification (Json => Json)\n  // ===========================================================================\n\n  /**\n   * Modifies values at the given path using the provided function.\n   *\n   * If the path does not exist, returns this JSON unchanged.\n   *\n   * {{{\n   * json.modify(p\"users[*].age\", {\n   *   case Json.Number(n) => Json.number(n.toInt + 1)\n   *   case other => other\n   * })\n   * }}}\n   *\n   * @param path The path to values to modify\n   * @param f The modification function\n   * @return The modified JSON\n   */\n  def modify(path: DynamicOptic, f: Json => Json): Json = ???\n\n  /**\n   * Modifies values at the given path using a partial function.\n   *\n   * Values for which the partial function is not defined are left unchanged.\n   *\n   * @param path The path to values to modify\n   * @param pf The partial modification function\n   * @return Either an error if the path is invalid, or the modified JSON\n   */\n  def modifyOrFail(path: DynamicOptic, pf: PartialFunction[Json, Json]): Either[JsonError, Json] = ???\n\n  /**\n   * Sets the value at the given path.\n   *\n   * If the path does not exist, attempts to create intermediate structure.\n   * For array indices, the array must already exist and have sufficient length.\n   *\n   * {{{\n   * json.set(p\"user.name\", Json.String(\"Bob\"))\n   * }}}\n   *\n   * @param path The path to set\n   * @param value The value to set\n   * @return The modified JSON\n   */\n  def set(path: DynamicOptic, value: Json): Json = ???\n\n  /**\n   * Sets the value at the given path, returning an error if the path is invalid.\n   *\n   * @param path The path to set\n   * @param value The value to set\n   * @return Either an error or the modified JSON\n   */\n  def setOrFail(path: DynamicOptic, value: Json): Either[JsonError, Json] = ???\n\n  /**\n   * Deletes values at the given path.\n   *\n   * For object fields, removes the key-value pair.\n   * For array elements, removes the element and shifts subsequent elements.\n   *\n   * @param path The path to delete\n   * @return The modified JSON\n   */\n  def delete(path: DynamicOptic): Json = ???\n\n  /**\n   * Deletes values at the given path, returning an error if the path is invalid.\n   *\n   * @param path The path to delete\n   * @return Either an error or the modified JSON\n   */\n  def deleteOrFail(path: DynamicOptic): Either[JsonError, Json] = ???\n\n  /**\n   * Inserts a value at the given path.\n   *\n   * For arrays, inserts at the specified index, shifting subsequent elements.\n   * For objects, adds or replaces the key.\n   *\n   * @param path The path where to insert\n   * @param value The value to insert\n   * @return The modified JSON\n   */\n  def insert(path: DynamicOptic, value: Json): Json = ???\n\n  /**\n   * Inserts a value at the given path, returning an error if invalid.\n   *\n   * @param path The path where to insert\n   * @param value The value to insert\n   * @return Either an error or the modified JSON\n   */\n  def insertOrFail(path: DynamicOptic, value: Json): Either[JsonError, Json] = ???\n\n  // ===========================================================================\n  // Merging\n  // ===========================================================================\n\n  /**\n   * Merges this JSON with another using the specified strategy.\n   *\n   * {{{\n   * val merged = json1.merge(json2, MergeStrategy.Deep)\n   * }}}\n   *\n   * @param other The JSON to merge with\n   * @param strategy The merge strategy (default: [[MergeStrategy.Auto]])\n   * @return The merged JSON\n   */\n  def merge(other: Json, strategy: MergeStrategy = MergeStrategy.Auto): Json = ???\n\n  // ===========================================================================\n  // Patching\n  // ===========================================================================\n\n  /**\n   * Applies a [[JsonPatch]] to this JSON.\n   *\n   * @param patch The patch to apply\n   * @return Either an error if the patch cannot be applied, or the patched JSON\n   */\n  def patch(patch: JsonPatch): Either[JsonError, Json] = ???\n\n  /**\n   * Applies a [[JsonPatch]], throwing on failure.\n   *\n   * @param patch The patch to apply\n   * @return The patched JSON\n   * @throws JsonError if the patch cannot be applied\n   */\n  def patchUnsafe(patch: JsonPatch): Json = this.patch(patch).fold(throw _, identity)\n\n  // ===========================================================================\n  // Transformation\n  // ===========================================================================\n\n  /**\n   * Transforms all values in this JSON bottom-up (children before parents).\n   *\n   * @param f The transformation function receiving path and value\n   * @return The transformed JSON\n   */\n  def transformUp(f: (DynamicOptic, Json) => Json): Json = ???\n\n  /**\n   * Transforms all values in this JSON top-down (parents before children).\n   *\n   * @param f The transformation function receiving path and value\n   * @return The transformed JSON\n   */\n  def transformDown(f: (DynamicOptic, Json) => Json): Json = ???\n\n  /**\n   * Transforms all object keys in this JSON.\n   *\n   * @param f The key transformation function receiving path and key\n   * @return The transformed JSON\n   */\n  def transformKeys(f: (DynamicOptic, String) => String): Json = ???\n\n  // ===========================================================================\n  // Filtering\n  // ===========================================================================\n\n  /**\n   * Removes entries matching the predicate.\n   *\n   * For objects, removes matching key-value pairs.\n   * For arrays, removes matching elements.\n   *\n   * @param p The predicate receiving path and value\n   * @return The filtered JSON\n   */\n  def filterNot(p: (DynamicOptic, Json) => scala.Boolean): Json = ???\n\n  /**\n   * Keeps only entries matching the predicate.\n   *\n   * @param p The predicate receiving path and value\n   * @return The filtered JSON\n   */\n  def filter(p: (DynamicOptic, Json) => scala.Boolean): Json =\n    filterNot((path, json) => !p(path, json))\n\n  // ===========================================================================\n  // Projection\n  // ===========================================================================\n\n  /**\n   * Projects this JSON to include only the specified paths.\n   *\n   * Paths that don't exist are ignored. Structure is preserved.\n   *\n   * {{{\n   * json.project(p\"user.name\", p\"user.email\", p\"meta.created\")\n   * }}}\n   *\n   * @param paths The paths to include\n   * @return A new JSON containing only the specified paths\n   */\n  def project(paths: DynamicOptic*): Json = ???\n\n  // ===========================================================================\n  // Splitting / Partitioning\n  // ===========================================================================\n\n  /**\n   * Partitions this JSON into two based on a predicate.\n   *\n   * Returns a tuple where the first element contains entries satisfying\n   * the predicate, and the second contains entries that don't.\n   *\n   * @param p The predicate receiving path and value\n   * @return A tuple of (matching, non-matching) JSON values\n   */\n  def partition(p: (DynamicOptic, Json) => scala.Boolean): (Json, Json) = ???\n\n  // ===========================================================================\n  // Normalization\n  // ===========================================================================\n\n  /**\n   * Returns a normalized version of this JSON.\n   *\n   * Normalization includes:\n   *  - Sorting object keys alphabetically\n   *  - Normalizing number representations\n   *\n   * Useful for comparison and hashing.\n   */\n  def normalize: Json = ???\n\n  /**\n   * Returns this JSON with all object keys sorted alphabetically (recursive).\n   */\n  def sortKeys: Json = self match {\n    case Json.Object(flds) =>\n      Json.Object(flds.map { case (k, v) => (k, v.sortKeys) }.sortBy(_._1))\n    case Json.Array(elems) =>\n      Json.Array(elems.map(_.sortKeys))\n    case other =>\n      other\n  }\n\n  /**\n   * Returns this JSON with all null values removed from objects.\n   */\n  def dropNulls: Json = self match {\n    case Json.Object(flds) =>\n      Json.Object(flds.collect { case (k, v) if !v.isNull => (k, v.dropNulls) })\n    case Json.Array(elems) =>\n      Json.Array(elems.map(_.dropNulls))\n    case other =>\n      other\n  }\n\n  /**\n   * Returns this JSON with empty objects and arrays removed.\n   */\n  def dropEmpty: Json = self match {\n    case Json.Object(flds) =>\n      val filtered = flds.collect {\n        case (k, v) =>\n          val dropped = v.dropEmpty\n          dropped match {\n            case Json.Object(f) if f.isEmpty => None\n            case Json.Array(e) if e.isEmpty  => None\n            case other                       => Some((k, other))\n          }\n      }.flatten\n      Json.Object(filtered)\n    case Json.Array(elems) =>\n      val filtered = elems.map(_.dropEmpty).filter {\n        case Json.Object(f) if f.isEmpty => false\n        case Json.Array(e) if e.isEmpty  => false\n        case _                           => true\n      }\n      Json.Array(filtered)\n    case other =>\n      other\n  }\n\n  // ===========================================================================\n  // Diffing\n  // ===========================================================================\n\n  /**\n   * Computes a [[JsonPatch]] that transforms this JSON into the target.\n   *\n   * {{{\n   * val patch = source.diff(target)\n   * source.patch(patch) == Right(target) // true\n   * }}}\n   *\n   * @param target The target JSON\n   * @return A patch that transforms this into target\n   */\n  def diff(target: Json): JsonPatch = ???\n\n  // ===========================================================================\n  // Folding\n  // ===========================================================================\n\n  /**\n   * Folds over this JSON top-down (parents before children).\n   *\n   * @param z The initial accumulator value\n   * @param f The fold function receiving path, value, and accumulator\n   * @tparam B The accumulator type\n   * @return The final accumulated value\n   */\n  def foldDown[B](z: B)(f: (DynamicOptic, Json, B) => B): B = ???\n\n  /**\n   * Folds over this JSON bottom-up (children before parents).\n   *\n   * @param z The initial accumulator value\n   * @param f The fold function receiving path, value, and accumulator\n   * @tparam B The accumulator type\n   * @return The final accumulated value\n   */\n  def foldUp[B](z: B)(f: (DynamicOptic, Json, B) => B): B = ???\n\n  /**\n   * Folds over this JSON top-down, allowing the fold function to fail.\n   *\n   * Short-circuits on first failure.\n   *\n   * @param z The initial accumulator value\n   * @param f The fold function that may fail\n   * @tparam B The accumulator type\n   * @return Either an error or the final accumulated value\n   */\n  def foldDownOrFail[B](z: B)(f: (DynamicOptic, Json, B) => Either[JsonError, B]): Either[JsonError, B] = ???\n\n  /**\n   * Folds over this JSON bottom-up, allowing the fold function to fail.\n   *\n   * Short-circuits on first failure.\n   *\n   * @param z The initial accumulator value\n   * @param f The fold function that may fail\n   * @tparam B The accumulator type\n   * @return Either an error or the final accumulated value\n   */\n  def foldUpOrFail[B](z: B)(f: (DynamicOptic, Json, B) => Either[JsonError, B]): Either[JsonError, B] = ???\n\n  // ===========================================================================\n  // Querying\n  // ===========================================================================\n\n  /**\n   * Selects all values matching the predicate.\n   *\n   * @param p The predicate receiving path and value\n   * @return A [[JsonSelection]] containing matching values\n   */\n  def query(p: (DynamicOptic, Json) => scala.Boolean): JsonSelection = ???\n\n  // ===========================================================================\n  // Validation\n  // ===========================================================================\n\n  /**\n   * Validates this JSON against a [[JsonSchema]].\n   *\n   * @param schema The schema to validate against\n   * @return `None` if valid, `Some(error)` if invalid\n   */\n  def check(schema: JsonSchema): Option[SchemaError] = ???\n\n  /**\n   * Returns `true` if this JSON conforms to the given [[JsonSchema]].\n   */\n  def conforms(schema: JsonSchema): scala.Boolean = check(schema).isEmpty\n\n  // ===========================================================================\n  // KV Representation\n  // ===========================================================================\n\n  /**\n   * Flattens this JSON to a sequence of path-value pairs.\n   *\n   * Only leaf values (primitives, empty arrays, empty objects) are included.\n   *\n   * {{{\n   * Json.parse(\"\"\"{\"a\": {\"b\": 1}, \"c\": [2, 3]}\"\"\").toKV\n   * // Seq(\n   * //   (p\"a.b\", Json.Number(\"1\")),\n   * //   (p\"c[0]\", Json.Number(\"2\")),\n   * //   (p\"c[1]\", Json.Number(\"3\"))\n   * // )\n   * }}}\n   */\n  def toKV: Seq[(DynamicOptic, Json)] = ???\n\n  // ===========================================================================\n  // Comparison\n  // ===========================================================================\n\n  /**\n   * Compares this JSON to another for ordering.\n   *\n   * Ordering is defined as:\n   *  1. Null < Boolean < Number < String < Array < Object\n   *  2. Within types, natural ordering applies\n   */\n  def compare(that: Json): Int = (self, that) match {\n    case (Json.Null, Json.Null)               => 0\n    case (Json.Null, _)                       => -1\n    case (_, Json.Null)                       => 1\n    case (Json.Boolean(a), Json.Boolean(b))   => a.compare(b)\n    case (Json.Boolean(_), _)                 => -1\n    case (_, Json.Boolean(_))                 => 1\n    case (Json.Number(a), Json.Number(b))     => BigDecimal(a).compare(BigDecimal(b))\n    case (Json.Number(_), _)                  => -1\n    case (_, Json.Number(_))                  => 1\n    case (Json.String(a), Json.String(b))     => a.compare(b)\n    case (Json.String(_), _)                  => -1\n    case (_, Json.String(_))                  => 1\n    case (Json.Array(a), Json.Array(b))       => compareArrays(a, b)\n    case (Json.Array(_), _)                   => -1\n    case (_, Json.Array(_))                   => 1\n    case (Json.Object(a), Json.Object(b))     => compareObjects(a, b)\n  }\n\n  private def compareArrays(a: Vector[Json], b: Vector[Json]): Int = {\n    val len = math.min(a.size, b.size)\n    var i   = 0\n    while (i < len) {\n      val cmp = a(i).compare(b(i))\n      if (cmp != 0) return cmp\n      i += 1\n    }\n    a.size.compare(b.size)\n  }\n\n  private def compareObjects(a: Vector[(String, Json)], b: Vector[(String, Json)]): Int = {\n    val aSorted = a.sortBy(_._1)\n    val bSorted = b.sortBy(_._1)\n    val len     = math.min(aSorted.size, bSorted.size)\n    var i       = 0\n    while (i < len) {\n      val (ak, av) = aSorted(i)\n      val (bk, bv) = bSorted(i)\n      val keyCmp   = ak.compare(bk)\n      if (keyCmp != 0) return keyCmp\n      val valCmp = av.compare(bv)\n      if (valCmp != 0) return valCmp\n      i += 1\n    }\n    aSorted.size.compare(bSorted.size)\n  }\n\n  // ===========================================================================\n  // DynamicValue Interop\n  // ===========================================================================\n\n  /**\n   * Converts this JSON to a [[DynamicValue]].\n   *\n   * This conversion is lossless; all JSON values can be represented as DynamicValue.\n   */\n  def toDynamicValue: DynamicValue = self match {\n    case Json.Null =>\n      DynamicValue.Primitive(PrimitiveValue.Unit)\n    case Json.Boolean(v) =>\n      DynamicValue.Primitive(PrimitiveValue.Boolean(v))\n    case Json.Number(v) =>\n      // Preserve as BigDecimal for maximum precision\n      DynamicValue.Primitive(PrimitiveValue.BigDecimal(BigDecimal(v)))\n    case Json.String(v) =>\n      DynamicValue.Primitive(PrimitiveValue.String(v))\n    case Json.Array(elems) =>\n      DynamicValue.Sequence(elems.map(_.toDynamicValue))\n    case Json.Object(flds) =>\n      DynamicValue.Record(flds.map { case (k, v) => (k, v.toDynamicValue) })\n  }\n\n  // ===========================================================================\n  // Typed Decoding (Json => A)\n  // ===========================================================================\n\n  /**\n   * Decodes this JSON to a typed value.\n   *\n   * Uses implicit [[JsonDecoder]] which prefers explicit codecs over schema derivation.\n   *\n   * {{{\n   * val person: Either[JsonError, Person] = json.as[Person]\n   * }}}\n   *\n   * @tparam A The target type\n   * @return Either an error or the decoded value\n   */\n  def as[A](implicit decoder: JsonDecoder[A]): Either[JsonError, A] = decoder.decode(self)\n\n  /**\n   * Decodes this JSON to a typed value, throwing on failure.\n   *\n   * @tparam A The target type\n   * @return The decoded value\n   * @throws JsonError if decoding fails\n   */\n  def asUnsafe[A](implicit decoder: JsonDecoder[A]): A = as[A].fold(throw _, identity)\n\n  /**\n   * Internal: decode using an explicit codec.\n   */\n  private[json] def decodeWith[A](codec: JsonBinaryCodec[A]): Either[JsonError, A] = ???\n\n  // ===========================================================================\n  // Encoding (Json => String/Bytes)\n  // ===========================================================================\n\n  /**\n   * Encodes this JSON to a compact string (no extra whitespace).\n   */\n  def print: String = encode(WriterConfig)\n\n  /**\n   * Encodes this JSON to a string using the specified configuration.\n   *\n   * @param config Writer configuration (indentation, unicode escaping, etc.)\n   */\n  def print(config: WriterConfig): String = encode(config)\n\n  /**\n   * Alias for [[print]].\n   */\n  def encode: String = encode(WriterConfig)\n\n  /**\n   * Encodes this JSON to a string using the specified configuration.\n   *\n   * @param config Writer configuration\n   */\n  def encode(config: WriterConfig): String = ???\n\n  /**\n   * Encodes this JSON and writes to the provided [[Writer]].\n   *\n   * @param writer The writer to write to\n   */\n  def printTo(writer: Writer): Unit = printTo(writer, WriterConfig)\n\n  /**\n   * Encodes this JSON and writes to the provided [[Writer]] with configuration.\n   *\n   * @param writer The writer to write to\n   * @param config Writer configuration\n   */\n  def printTo(writer: Writer, config: WriterConfig): Unit = ???\n\n  /**\n   * Encodes this JSON to a byte array (UTF-8).\n   */\n  def encodeToBytes: Array[Byte] = encodeToBytes(WriterConfig)\n\n  /**\n   * Encodes this JSON to a byte array (UTF-8) with configuration.\n   *\n   * @param config Writer configuration\n   */\n  def encodeToBytes(config: WriterConfig): Array[Byte] = ???\n\n  /**\n   * Encodes this JSON to a [[Chunk]] of bytes (UTF-8).\n   */\n  def encodeToChunk: Chunk[Byte] = encodeToChunk(WriterConfig)\n\n  /**\n   * Encodes this JSON to a [[Chunk]] of bytes (UTF-8) with configuration.\n   *\n   * @param config Writer configuration\n   */\n  def encodeToChunk(config: WriterConfig): Chunk[Byte] = ???\n\n  /**\n   * Encodes this JSON into the provided [[ByteBuffer]].\n   *\n   * @param buffer The buffer to write to\n   */\n  def encodeTo(buffer: ByteBuffer): Unit = encodeTo(buffer, WriterConfig)\n\n  /**\n   * Encodes this JSON into the provided [[ByteBuffer]] with configuration.\n   *\n   * @param buffer The buffer to write to\n   * @param config Writer configuration\n   */\n  def encodeTo(buffer: ByteBuffer, config: WriterConfig): Unit = ???\n\n  // ===========================================================================\n  // Standard Methods\n  // ===========================================================================\n\n  override def hashCode(): Int = self match {\n    case Json.Null           => 0\n    case Json.Boolean(v)     => v.hashCode()\n    case Json.Number(v)      => BigDecimal(v).hashCode()\n    case Json.String(v)      => v.hashCode()\n    case Json.Array(elems)   => elems.hashCode()\n    case Json.Object(flds)   => flds.sortBy(_._1).hashCode()\n  }\n\n  override def equals(that: Any): Boolean = that match {\n    case other: Json => compare(other) == 0\n    case _           => false\n  }\n\n  override def toString: String = print\n}\n\nobject Json {\n\n  // ===========================================================================\n  // ADT Cases\n  // ===========================================================================\n\n  /**\n   * A JSON object: an unordered collection of key-value pairs.\n   *\n   * @param fields The key-value pairs. Keys should be unique; if duplicates\n   *               are present, behavior of accessors is undefined.\n   */\n  final case class Object(fields: Vector[(String, Json)]) extends Json {\n    override def isObject: scala.Boolean                = true\n    override def fields: Seq[(String, Json)]            = fields\n  }\n\n  object Object {\n\n    /**\n     * Creates an empty JSON object.\n     */\n    val empty: Object = Object(Vector.empty)\n\n    /**\n     * Creates a JSON object from key-value pairs.\n     */\n    def apply(fields: (String, Json)*): Object = Object(fields.toVector)\n  }\n\n  /**\n   * A JSON array: an ordered sequence of values.\n   *\n   * @param elements The array elements\n   */\n  final case class Array(elements: Vector[Json]) extends Json {\n    override def isArray: scala.Boolean  = true\n    override def elements: Seq[Json]     = elements\n  }\n\n  object Array {\n\n    /**\n     * Creates an empty JSON array.\n     */\n    val empty: Array = Array(Vector.empty)\n\n    /**\n     * Creates a JSON array from elements.\n     */\n    def apply(elements: Json*): Array = Array(elements.toVector)\n  }\n\n  /**\n   * A JSON string.\n   *\n   * @param value The string value (unescaped)\n   */\n  final case class String(value: java.lang.String) extends Json {\n    override def isString: scala.Boolean              = true\n    override def stringValue: Option[java.lang.String] = Some(value)\n  }\n\n  /**\n   * A JSON number.\n   *\n   * Stored as a string to preserve exact representation (precision, trailing zeros, etc.).\n   * Provides lazy conversion to numeric types.\n   *\n   * @param value The number as a string (should be valid JSON number syntax)\n   */\n  final case class Number(value: java.lang.String) extends Json {\n    override def isNumber: scala.Boolean                = true\n    override def numberValue: Option[java.lang.String]  = Some(value)\n\n    /**\n     * Converts to `Int`, truncating if necessary.\n     */\n    lazy val toInt: Int = toBigDecimal.toInt\n\n    /**\n     * Converts to `Long`, truncating if necessary.\n     */\n    lazy val toLong: Long = toBigDecimal.toLong\n\n    /**\n     * Converts to `Float`.\n     */\n    lazy val toFloat: Float = value.toFloat\n\n    /**\n     * Converts to `Double`.\n     */\n    lazy val toDouble: Double = value.toDouble\n\n    /**\n     * Converts to `BigInt`, truncating fractional part.\n     */\n    lazy val toBigInt: BigInt = toBigDecimal.toBigInt\n\n    /**\n     * Converts to `BigDecimal` (lossless).\n     */\n    lazy val toBigDecimal: BigDecimal = BigDecimal(value)\n  }\n\n  /**\n   * A JSON boolean.\n   *\n   * @param value The boolean value\n   */\n  final case class Boolean(value: scala.Boolean) extends Json {\n    override def isBoolean: scala.Boolean              = true\n    override def booleanValue: Option[scala.Boolean]   = Some(value)\n  }\n\n  object Boolean {\n    val True: Boolean  = Boolean(true)\n    val False: Boolean = Boolean(false)\n  }\n\n  /**\n   * The JSON null value.\n   */\n  case object Null extends Json {\n    override def isNull: scala.Boolean = true\n  }\n\n  // ===========================================================================\n  // Convenience Constructors\n  // ===========================================================================\n\n  /**\n   * Creates a JSON number from an `Int`.\n   */\n  def number(n: Int): Number = Number(n.toString)\n\n  /**\n   * Creates a JSON number from a `Long`.\n   */\n  def number(n: Long): Number = Number(n.toString)\n\n  /**\n   * Creates a JSON number from a `Float`.\n   */\n  def number(n: Float): Number = Number(n.toString)\n\n  /**\n   * Creates a JSON number from a `Double`.\n   */\n  def number(n: Double): Number = Number(n.toString)\n\n  /**\n   * Creates a JSON number from a `BigInt`.\n   */\n  def number(n: BigInt): Number = Number(n.toString)\n\n  /**\n   * Creates a JSON number from a `BigDecimal`.\n   */\n  def number(n: BigDecimal): Number = Number(n.toString)\n\n  /**\n   * Creates a JSON number from a `Short`.\n   */\n  def number(n: Short): Number = Number(n.toString)\n\n  /**\n   * Creates a JSON number from a `Byte`.\n   */\n  def number(n: Byte): Number = Number(n.toString)\n\n  // ===========================================================================\n  // Parsing / Decoding (String/Bytes => Json)\n  // ===========================================================================\n\n  /**\n   * Parses a JSON value from a string.\n   *\n   * @param s The JSON string\n   * @return Either a [[JsonError]] or the parsed JSON\n   */\n  def parse(s: java.lang.String): Either[JsonError, Json] = decode(s)\n\n  /**\n   * Parses a JSON value from a `CharSequence`.\n   *\n   * @param s The JSON character sequence\n   * @return Either a [[JsonError]] or the parsed JSON\n   */\n  def parse(s: CharSequence): Either[JsonError, Json] = decode(s)\n\n  /**\n   * Parses a JSON value from a byte array (UTF-8).\n   *\n   * @param bytes The JSON bytes\n   * @return Either a [[JsonError]] or the parsed JSON\n   */\n  def parse(bytes: scala.Array[Byte]): Either[JsonError, Json] = decode(bytes)\n\n  /**\n   * Parses a JSON value from a [[Chunk]] of bytes (UTF-8).\n   *\n   * @param chunk The JSON bytes\n   * @return Either a [[JsonError]] or the parsed JSON\n   */\n  def parse(chunk: Chunk[Byte]): Either[JsonError, Json] = decode(chunk)\n\n  /**\n   * Parses a JSON value from a [[ByteBuffer]] (UTF-8).\n   *\n   * @param buffer The JSON bytes\n   * @return Either a [[JsonError]] or the parsed JSON\n   */\n  def parse(buffer: ByteBuffer): Either[JsonError, Json] = decode(buffer)\n\n  /**\n   * Parses a JSON value from a [[Reader]].\n   *\n   * @param reader The reader to read from\n   * @return Either a [[JsonError]] or the parsed JSON\n   */\n  def parse(reader: Reader): Either[JsonError, Json] = decode(reader)\n\n  /**\n   * Decodes a JSON value from a string.\n   */\n  def decode(s: java.lang.String): Either[JsonError, Json] = ???\n\n  /**\n   * Decodes a JSON value from a `CharSequence`.\n   */\n  def decode(s: CharSequence): Either[JsonError, Json] = ???\n\n  /**\n   * Decodes a JSON value from a byte array (UTF-8).\n   */\n  def decode(bytes: scala.Array[Byte]): Either[JsonError, Json] = ???\n\n  /**\n   * Decodes a JSON value from a [[Chunk]] of bytes (UTF-8).\n   */\n  def decode(chunk: Chunk[Byte]): Either[JsonError, Json] = ???\n\n  /**\n   * Decodes a JSON value from a [[ByteBuffer]] (UTF-8).\n   */\n  def decode(buffer: ByteBuffer): Either[JsonError, Json] = ???\n\n  /**\n   * Decodes a JSON value from a [[Reader]].\n   */\n  def decode(reader: Reader): Either[JsonError, Json] = ???\n\n  /**\n   * Parses a JSON value from a string, throwing on failure.\n   *\n   * @param s The JSON string\n   * @return The parsed JSON\n   * @throws JsonError if parsing fails\n   */\n  def parseUnsafe(s: java.lang.String): Json = decode(s).fold(throw _, identity)\n\n  /**\n   * Alias for [[parseUnsafe]].\n   */\n  def decodeUnsafe(s: java.lang.String): Json = parseUnsafe(s)\n\n  // ===========================================================================\n  // Typed Encoding (A => Json)\n  // ===========================================================================\n\n  /**\n   * Encodes a typed value to JSON.\n   *\n   * Uses implicit [[JsonEncoder]] which prefers explicit codecs over schema derivation.\n   *\n   * {{{\n   * val json = Json.from(Person(\"Alice\", 30))\n   * }}}\n   *\n   * @param value The value to encode\n   * @return The encoded JSON\n   */\n  def from[A](value: A)(implicit encoder: JsonEncoder[A]): Json = encoder.encode(value)\n\n  /**\n   * Internal: encode using an explicit codec.\n   */\n  private[json] def encodeWith[A](value: A, codec: JsonBinaryCodec[A]): Json = ???\n\n  // ===========================================================================\n  // DynamicValue Interop\n  // ===========================================================================\n\n  /**\n   * Converts a [[DynamicValue]] to JSON.\n   *\n   * This conversion is lossy for `DynamicValue` types that have no JSON equivalent:\n   *  - `PrimitiveValue` types like `java.time.*` are converted to strings\n   *  - `DynamicValue.Variant` uses a discriminator field\n   *\n   * @param value The dynamic value to convert\n   * @return The JSON representation\n   */\n  def fromDynamicValue(value: DynamicValue): Json = value match {\n    case DynamicValue.Primitive(pv) => fromPrimitiveValue(pv)\n    case DynamicValue.Record(flds) =>\n      Object(flds.map { case (k, v) => (k, fromDynamicValue(v)) })\n    case DynamicValue.Variant(caseName, v) =>\n      Object(Vector(\"_type\" -> String(caseName), \"_value\" -> fromDynamicValue(v)))\n    case DynamicValue.Sequence(elems) =>\n      Array(elems.map(fromDynamicValue))\n    case DynamicValue.Map(entries) =>\n      Array(entries.map { case (k, v) =>\n        Object(Vector(\"key\" -> fromDynamicValue(k), \"value\" -> fromDynamicValue(v)))\n      })\n  }\n\n  private def fromPrimitiveValue(pv: PrimitiveValue): Json = pv match {\n    case PrimitiveValue.Unit              => Null\n    case PrimitiveValue.Boolean(v)        => Boolean(v)\n    case PrimitiveValue.Byte(v)           => number(v)\n    case PrimitiveValue.Short(v)          => number(v)\n    case PrimitiveValue.Int(v)            => number(v)\n    case PrimitiveValue.Long(v)           => number(v)\n    case PrimitiveValue.Float(v)          => number(v)\n    case PrimitiveValue.Double(v)         => number(v)\n    case PrimitiveValue.Char(v)           => String(v.toString)\n    case PrimitiveValue.String(v)         => String(v)\n    case PrimitiveValue.BigInt(v)         => number(v)\n    case PrimitiveValue.BigDecimal(v)     => number(v)\n    case PrimitiveValue.DayOfWeek(v)      => String(v.toString)\n    case PrimitiveValue.Duration(v)       => String(v.toString)\n    case PrimitiveValue.Instant(v)        => String(v.toString)\n    case PrimitiveValue.LocalDate(v)      => String(v.toString)\n    case PrimitiveValue.LocalDateTime(v)  => String(v.toString)\n    case PrimitiveValue.LocalTime(v)      => String(v.toString)\n    case PrimitiveValue.Month(v)          => String(v.toString)\n    case PrimitiveValue.MonthDay(v)       => String(v.toString)\n    case PrimitiveValue.OffsetDateTime(v) => String(v.toString)\n    case PrimitiveValue.OffsetTime(v)     => String(v.toString)\n    case PrimitiveValue.Period(v)         => String(v.toString)\n    case PrimitiveValue.Year(v)           => String(v.toString)\n    case PrimitiveValue.YearMonth(v)      => String(v.toString)\n    case PrimitiveValue.ZoneId(v)         => String(v.getId)\n    case PrimitiveValue.ZoneOffset(v)     => String(v.toString)\n    case PrimitiveValue.ZonedDateTime(v)  => String(v.toString)\n    case PrimitiveValue.Currency(v)       => String(v.getCurrencyCode)\n    case PrimitiveValue.UUID(v)           => String(v.toString)\n  }\n\n  // ===========================================================================\n  // KV Interop\n  // ===========================================================================\n\n  /**\n   * Assembles JSON from a sequence of path-value pairs.\n   *\n   * {{{\n   * Json.fromKV(Seq(\n   *   p\"a.b\" -> Json.number(1),\n   *   p\"a.c\" -> Json.String(\"x\"),\n   *   p\"d[0]\" -> Json.Boolean(true)\n   * ))\n   * // {\"a\": {\"b\": 1, \"c\": \"x\"}, \"d\": [true]}\n   * }}}\n   *\n   * @param kvs The path-value pairs\n   * @return Either an error (for conflicting paths) or the assembled JSON\n   */\n  def fromKV(kvs: Seq[(DynamicOptic, Json)]): Either[JsonError, Json] = ???\n\n  /**\n   * Assembles JSON from path-value pairs, throwing on conflict.\n   */\n  def fromKVUnsafe(kvs: Seq[(DynamicOptic, Json)]): Json = fromKV(kvs).fold(throw _, identity)\n\n  // ===========================================================================\n  // Patch Interop\n  // ===========================================================================\n\n  /**\n   * Serializes a [[JsonPatch]] to its JSON representation.\n   *\n   * The format follows RFC 6902 (JSON Patch) for standard operations,\n   * with extensions for LCS-based sequence diffs.\n   *\n   * @param patch The patch to serialize\n   * @return The JSON representation of the patch\n   */\n  def fromJsonPatch(patch: JsonPatch): Json = ???\n\n  /**\n   * Deserializes a JSON representation into a [[JsonPatch]].\n   *\n   * @param json The JSON patch representation\n   * @return Either an error or the parsed patch\n   */\n  def toJsonPatch(json: Json): Either[JsonError, JsonPatch] = ???\n\n  // ===========================================================================\n  // Ordering\n  // ===========================================================================\n\n  /**\n   * Ordering for JSON values.\n   *\n   * Order: Null < Boolean < Number < String < Array < Object\n   */\n  implicit val ordering: Ordering[Json] = (x: Json, y: Json) => x.compare(y)\n}\n\n// =============================================================================\n// MERGE STRATEGY\n// =============================================================================\n\n/**\n * Strategy for merging JSON values.\n */\nsealed trait MergeStrategy\n\nobject MergeStrategy {\n\n  /**\n   * Automatically determines merge behavior based on value types:\n   *  - Objects: deep merge (recurse into matching keys)\n   *  - Arrays: concatenate\n   *  - Primitives: right wins\n   */\n  case object Auto extends MergeStrategy\n\n  /**\n   * Deep merge for objects; concatenate arrays.\n   */\n  case object Deep extends MergeStrategy\n\n  /**\n   * Shallow merge: right value wins for any key conflict.\n   */\n  case object Shallow extends MergeStrategy\n\n  /**\n   * Concatenate arrays; for objects and primitives, right wins.\n   */\n  case object Concat extends MergeStrategy\n\n  /**\n   * Right value always wins (replacement).\n   */\n  case object Replace extends MergeStrategy\n\n  /**\n   * Custom merge function.\n   *\n   * @param f A function receiving path and both values, returning merged result\n   */\n  final case class Custom(f: (DynamicOptic, Json, Json) => Json) extends MergeStrategy\n}\n\n// =============================================================================\n// STRING INTERPOLATORS\n// =============================================================================\n\n/**\n * Provides string interpolators for JSON paths and literals.\n *\n * Import with:\n * {{{\n * import zio.blocks.schema.json.interpolators._\n * }}}\n *\n * ==Path Syntax==\n *\n * The `p` interpolator creates [[DynamicOptic]] paths using a JSONPath-compatible dialect:\n *\n * {{{\n * p\"foo.bar\"           // fields \"foo\" then \"bar\"\n * p\"users[0]\"          // field \"users\", then index 0\n * p\"users[0].name\"     // field \"users\", index 0, field \"name\"\n * p\"items[*]\"          // field \"items\", then all array elements\n * p\"config{*}\"         // field \"config\", then all object values\n * p\"config{*:}\"        // field \"config\", then all object keys\n * p\"[0,2,5]\"           // indices 0, 2, and 5\n * p\"[0:5]\"             // slice: indices 0 through 4\n * p\"[::2]\"             // slice: every other element\n * p\"`field.name`\"      // field with dots in name (backtick escaping)\n * p\"\"\"[\"field\"]\"\"\"     // alternate field syntax (bracket notation)\n * }}}\n *\n * ===JSONPath Compatibility===\n *\n * This syntax is a dialect of JSONPath (RFC 9535). Most JSONPath expressions work:\n *  - `$.foo.bar` - root prefix is optional and ignored\n *  - `.field`, `[\"field\"]` - field access\n *  - `[n]`, `[*]`, `[m,n]`, `[m:n]` - array access\n *\n * '''Not supported:'''\n *  - `..` (recursive descent)\n *  - `[?()]` (filter expressions)\n *\n * ===Extensions beyond JSONPath:===\n *  - `{*}` - all object values (explicit, vs `[*]` which is array-focused in JSONPath)\n *  - `{*:}` - all object keys (not expressible in standard JSONPath)\n *  - Backtick escaping for field names\n */\nobject interpolators {\n\n  implicit class JsonPathInterpolator(val sc: StringContext) extends AnyVal {\n\n    /**\n     * Creates a [[DynamicOptic]] from a path string at compile time.\n     *\n     * @return The parsed [[DynamicOptic]]\n     */\n    def p(args: Any*): DynamicOptic = macro PathMacros.pathInterpolator\n  }\n\n  implicit class JsonLiteralInterpolator(val sc: StringContext) extends AnyVal {\n\n    /**\n     * Creates a [[Json]] value from a JSON literal at compile time.\n     *\n     * {{{\n     * j\"\"\"{\"name\": \"Alice\", \"age\": 30}\"\"\"\n     * j\"[1, 2, 3]\"\n     * j\"null\"\n     * }}}\n     *\n     * Interpolated values are converted to JSON:\n     * {{{\n     * val name = \"Bob\"\n     * val age = 25\n     * j\"\"\"{\"name\": $name, \"age\": $age}\"\"\"\n     * }}}\n     *\n     * @return The parsed [[Json]] value\n     */\n    def j(args: Any*): Json = macro PathMacros.jsonInterpolator\n  }\n}\n\n/**\n * Macro implementations for string interpolators.\n * \n * Separate implementations would be needed for Scala 2 and Scala 3.\n */\nobject PathMacros {\n  import scala.reflect.macros.blackbox\n\n  def pathInterpolator(c: blackbox.Context)(args: c.Expr[Any]*): c.Expr[DynamicOptic] = ???\n\n  def jsonInterpolator(c: blackbox.Context)(args: c.Expr[Any]*): c.Expr[Json] = ???\n}\n\n// =============================================================================\n// PLACEHOLDER TYPES (assumed to exist)\n// =============================================================================\n\n/**\n * Represents a JSON Schema for validation.\n *\n * Placeholder - actual implementation TBD.\n */\nsealed trait JsonSchema\n\nobject JsonSchema {\n  // Placeholder\n}\n\n/**\n * Represents a patch that can be applied to JSON values.\n *\n * Supports RFC 6902 operations (add, remove, replace, move, copy, test)\n * plus extensions for LCS-based sequence diffs and string diffs.\n *\n * Placeholder - actual implementation TBD.\n */\nsealed trait JsonPatch {\n\n  /**\n   * Converts this JSON patch to a [[DynamicPatch]].\n   */\n  def toDynamicPatch: DynamicPatch\n}\n\nobject JsonPatch {\n\n  /**\n   * Creates an empty patch (no operations).\n   */\n  val empty: JsonPatch = ???\n\n  /**\n   * Creates a patch from a [[DynamicPatch]].\n   *\n   * May fail if the DynamicPatch contains operations not representable in JSON.\n   */\n  def fromDynamicPatch(patch: DynamicPatch): Either[JsonError, JsonPatch] = ???\n}\n\n/**\n * Represents a patch that can be applied to [[DynamicValue]].\n *\n * Placeholder - actual implementation TBD.\n */\nsealed trait DynamicPatch\n\nobject DynamicPatch {\n\n  /**\n   * Creates an empty patch (no operations).\n   */\n  val empty: DynamicPatch = ???\n}\n```",
              "url": "https://github.com/zio/zio-blocks/issues/679",
              "tech": [],
              "repo_name": "zio-blocks",
              "repo_owner": "zio",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "ZIO#519",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "ZIO",
              "id": "generated-ZIO",
              "name": "ZIO",
              "description": "",
              "members": [],
              "display_name": "ZIO",
              "created_at": "2026-01-19T14:48:00.122Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/ZIO?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "zio",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-19T14:48:00.122Z",
            "created_at": "2026-01-19T14:48:00.122Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-ZIO#519",
              "status": "open",
              "type": "issue",
              "number": 519,
              "title": "Schema Migration System for ZIO Schema 2",
              "source": {
                "data": {
                  "id": "source-ZIO#519",
                  "user": {
                    "login": "jdegoes",
                    "id": 156745,
                    "node_id": "MDQ6VXNlcjE1Njc0NQ==",
                    "avatar_url": "https://avatars.githubusercontent.com/u/156745?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/jdegoes",
                    "html_url": "https://github.com/jdegoes",
                    "followers_url": "https://api.github.com/users/jdegoes/followers",
                    "following_url": "https://api.github.com/users/jdegoes/following{/other_user}",
                    "gists_url": "https://api.github.com/users/jdegoes/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/jdegoes/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/jdegoes/subscriptions",
                    "organizations_url": "https://api.github.com/users/jdegoes/orgs",
                    "repos_url": "https://api.github.com/users/jdegoes/repos",
                    "events_url": "https://api.github.com/users/jdegoes/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/jdegoes/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Schema Migration System for ZIO Schema 2",
                  "body": "## Overview\n\nImplement a **pure, algebraic migration system** for ZIO Schema 2 that represents **structural transformations between schema versions** as first-class, serializable data.\n\nA migration describes how to transform data from one schema version to another, enabling:\n\n* schema evolution\n* backward / forward compatibility\n* data versioning\n* offline migrations (JSON, SQL, data lakes, registries, etc.)\n\nThe system provides a **typed, macro-validated user API** (`Migration[A, B]`) built on a **pure, serializable core** (`DynamicMigration`) that operates on `DynamicValue`. \n\nThe ADT is fully introspectable and can be used to generate DDL, etc.\n\n## Motivation & Big Picture\n\n### Why structural types?\n\nWhen evolving schemas over time, **older versions of data types should not require runtime representations**.\n\nIn this design:\n\n* **Current versions** are represented by real case classes / enums\n* **Past versions** are represented using:\n\n  * **structural types** for records\n  * **abstract types + intersection types** for sum types\n\nThese types:\n\n* exist **only at compile time**\n* have **no runtime representation**\n* introduce **zero runtime overhead**\n* do **not require optics or instances to be kept around**\n\nThis allows you to describe arbitrarily old versions of data *without polluting your runtime or codebase*.\n\n#### Typical Workflow\n\nA typical workflow looks like:\n\n1. You have a current type:\n\n   ```scala\n   @schema\n   case class Person(name: String, age: Int)\n   ```\n\n2. You derive and copy its structural shape:\n\n   ```scala\n   type PersonV1 = { def name: String; def age: Int }\n   ```\n\n3. You evolve the real type:\n\n   ```scala\n   @schema\n   case class Person(fullName: String, age: Int, country: String)\n   ```\n\n4. You keep only:\n\n   * the **current** runtime type\n   * the **structural type** for the old version\n   * a **pure migration** between them\n\nNo old case classes. No old optics. No runtime baggage.\n\nNote there is no requirement that the \"current\" type actually be a real case class, enum, etc.--so you can work purely with structural types, allowing you to define migrations for data types that are never materialized as runtime structures.\n\n---\n\n### Why pure data migrations?\n\nMigrations are represented entirely as **pure data**:\n\n* no user functions\n* no closures\n* no reflection\n* no runtime code generation\n\nAs a result:\n\n* migrations can be **serialized**\n* stored in **registries**\n* applied **dynamically**\n* inspected and transformed\n* used to generate:\n\n  * upgraders\n  * downgraders\n  * SQL DDL / DML\n  * offline data transforms\n\nWhile code generation is **out of scope for this ticket**, this explains many design decisions (invertibility, path-based actions, no functions).\n\n---\n\n## Core Architecture\n\n### Type Hierarchy\n\n```scala\n// Typed migration (user-facing API)\ncase class Migration[A, B](\n  dynamicMigration: DynamicMigration,\n  sourceSchema: Schema[A], // These are structural schemas!!!\n  targetSchema: Schema[B] // These are structural schemas!!!\n) {\n  /** Apply migration to transform A to B */\n  def apply(value: A): Either[MigrationError, B]\n\n  /** Compose migrations sequentially */\n  def ++[C](that: Migration[B, C]): Migration[A, C]\n\n  /** Alias for ++ */\n  def andThen[C](that: Migration[B, C]): Migration[A, C] = this ++ that\n\n  /** Reverse migration (structural inverse; runtime is best-effort) */\n  def reverse: Migration[B, A]\n}\n```\n\n```scala\n// Untyped migration (pure data, fully serializable)\ncase class DynamicMigration(\n  actions: Vector[MigrationAction]\n) {\n  def apply(value: DynamicValue): Either[MigrationError, DynamicValue]\n  def ++(that: DynamicMigration): DynamicMigration\n  def reverse: DynamicMigration\n}\n```\n\n* `Migration[A, B]` is introspectable, but not pure data due to bindings inside schemas\n* `DynamicMigration` is **fully serializable**\n\n---\n\n## User-Facing API: Selector Expressions\n\n### Selectors, not optics\n\nThe user-facing API **does not expose optics**.\n\nInstead, all locations are specified using **selector expressions**:\n\n```scala\nS => A\n```\n\nExamples:\n\n```scala\n_.name\n_.address.street\n_.addresses.each.streetNumber\n_.country.when[UK]\n```\n\nTo see the syntax, one can look at the `optic` macro, which utilizes the same selector syntax for optic creation (e.g. `optic(_.address.street)`, etc.).\n\n### Macro extraction\n\nAll builder methods that accept selectors are **implemented via macros** (or via a macro-generated type class such as `ToDynamicOptic`).\n\nThe macro:\n\n1. Inspects the selector expression\n2. Validates it is a supported projection\n3. Converts it into a `DynamicOptic`\n4. Stores that optic in the migration action\n\nSupported projections include:\n\n* field access (`_.foo.bar`)\n* case selection (`_.country.when[UK]`)\n* collection traversal (`_.items.each`)\n* (future) key access, wrappers, etc.\n\n`DynamicOptic` is **never exposed publicly**.\n\n---\n\n## Migration Builder\n\nAll selector-accepting methods are implemented via macros. For simplicity, these are shown as functions (e.g. `A => Any`), but this is NOT the way to implement them. Either all these functions need to be macros, or a macro needs to be used to generate an implicit / given at each call site. Macros may do additional validation to constrain the validity of these different types of transformations.\n\n```scala\nclass MigrationBuilder[A, B](\n  sourceSchema: Schema[A],\n  targetSchema: Schema[B],\n  actions: Vector[MigrationAction]\n) {\n\n  // ----- Record operations -----\n\n  def addField(\n    target: B => Any,\n    default: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  def dropField(\n    source: A => Any,\n    defaultForReverse: SchemaExpr[B, ?] = SchemaExpr.DefaultValue\n  ): MigrationBuilder[A, B]\n\n  def renameField(\n    from: A => Any,\n    to: B => Any\n  ): MigrationBuilder[A, B]\n\n  def transformField(\n    from: A => Any,\n    to: B => Any,\n    transform: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  def mandateField(\n    source: A => Option[?],\n    target: B => Any,\n    default: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  def optionalizeField(\n    source: A => Any,\n    target: B => Option[?]\n  ): MigrationBuilder[A, B]\n\n  def changeFieldType(\n    source: A => Any,\n    target: B => Any,\n    converter: SchemaExpr[A, ?]  // primitive-to-primitive only\n  ): MigrationBuilder[A, B]\n\n  // ----- Enum operations (limited) -----\n\n  def renameCase[SumA, SumB](\n    from: String,\n    to: String\n  ): MigrationBuilder[A, B]\n\n  def transformCase[SumA, CaseA, SumB, CaseB](\n    caseMigration: MigrationBuilder[CaseA, CaseB] => MigrationBuilder[CaseA, CaseB]\n  ): MigrationBuilder[A, B]\n\n  // ----- Collections -----\n\n  def transformElements(\n    at: A => Vector[?],\n    transform: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  // ----- Maps -----\n\n  def transformKeys(\n    at: A => Map[?, ?],\n    transform: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  def transformValues(\n    at: A => Map[?, ?],\n    transform: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  /** Build migration with full macro validation */\n  def build: Migration[A, B]\n\n  /** Build migration without full validation */\n  def buildPartial: Migration[A, B]\n}\n```\n\n---\n\n## Migration Actions (Untyped Core)\n\nAll actions operate at a **path**, represented by `DynamicOptic`.\n\n```scala\nsealed trait MigrationAction {\n  def at: DynamicOptic\n  def reverse: MigrationAction\n}\n```\n\n### Record Actions\n\n```scala\ncase class AddField(\n  at: DynamicOptic,\n  default: SchemaExpr[?]\n) extends MigrationAction\n\ncase class DropField(\n  at: DynamicOptic,\n  defaultForReverse: SchemaExpr[?]\n) extends MigrationAction\n\ncase class Rename(\n  at: DynamicOptic,\n  to: String\n) extends MigrationAction\n\ncase class TransformValue(\n  at: DynamicOptic,\n  transform: SchemaExpr[?]\n) extends MigrationAction\n\ncase class Mandate(\n  at: DynamicOptic,\n  default: SchemaExpr[?]\n) extends MigrationAction\n\ncase class Optionalize(\n  at: DynamicOptic\n) extends MigrationAction\n\ncase class Join(\n  at: DynamicOptic,\n  sourcePaths: Vector[DynamicOptic],\n  combiner: SchemaExpr[?]\n) extends MigrationAction\n\ncase class Split(\n  at: DynamicOptic,\n  targetPaths: Vector[DynamicOptic],\n  splitter: SchemaExpr[?]\n) extends MigrationAction\n\ncase class ChangeType(\n  at: DynamicOptic,\n  converter: SchemaExpr[?]\n) extends MigrationAction\n```\n\n---\n\n### Enum Actions (Supported)\n\n```scala\ncase class RenameCase(\n  at: DynamicOptic,\n  from: String,\n  to: String\n) extends MigrationAction\n\ncase class TransformCase(\n  at: DynamicOptic,\n  actions: Vector[MigrationAction]\n) extends MigrationAction\n```\n\n> Enum case addition / removal is **out of scope** for this ticket\n> (requires composite value construction).\n\n---\n\n### Collection / Map Actions\n\n```scala\ncase class TransformElements(\n  at: DynamicOptic,\n  transform: SchemaExpr[?]\n) extends MigrationAction\n\ncase class TransformKeys(\n  at: DynamicOptic,\n  transform: SchemaExpr[?]\n) extends MigrationAction\n\ncase class TransformValues(\n  at: DynamicOptic,\n  transform: SchemaExpr[?]\n) extends MigrationAction\n```\n\n---\n\n## SchemaExpr Integration\n\n* Used for all value-level transformations\n* **Constraints for this ticket**:\n\n  * primitive â†’ primitive only\n  * joins / splits must produce primitives\n  * no record / enum construction\n\n### `SchemaExpr.DefaultValue`\n\nA special expression that:\n\n1. uses the macro-captured field schema\n2. calls `schema.defaultValue`\n3. converts the value to `DynamicValue`\n4. is stored for reverse migrations\n\n---\n\n## Type Modeling\n\n### Records (Structural Types)\n\n```scala\ntype PersonV0 = { val firstName: String; val lastName: String }\ntype PersonV1 = { val fullName: String; val age: Int }\n\nimplicit val v0Schema: Schema[PersonV0] = Schema.structural[PersonV0]\nimplicit val v1Schema: Schema[PersonV1] = Schema.structural[PersonV1]\n```\n\n---\n\n### Enums (Union of Structural Types with Tags)\n\nEnums are encoded into structural types by using union types, together with singleton types (string literals, which represent the name of the case of the enum).\n\nIn structural types, the names of the type aliases shown below are not relevant, nor are they used.\n\n```scala\ntype OldCreditCard =\n  { type Tag = \"CreditCard\"; def number: String; def exp: String }\ntype OldWireTransfer =\n  { type Tag = \"WireTransfer\"; def account: String; def routing: String }\ntype OldPaymentMethod = OldCreditCard | OldWireTransfer\n```\n\nMacros extract:\n\n* refinement type â†’ structure of the case\n* type `Tag` with singleton type â†’ case tag\n\n---\n\n## Laws\n\n### Identity\n\n```scala\nMigration.identity[A].apply(a) == Right(a)\n```\n\n### Associativity\n\n```scala\n(m1 ++ m2) ++ m3 == m1 ++ (m2 ++ m3)\n```\n\n### Structural Reverse\n\n```scala\nm.reverse.reverse == m\n```\n\n### Best-Effort Semantic Inverse\n\n```scala\nm.apply(a) == Right(b) â‡’ m.reverse.apply(b) == Right(a)\n```\n\n(when sufficient information exists)\n\n---\n\n## Error Handling\n\n* All runtime errors return `MigrationError`\n* Errors must capture **path information** (`DynamicOptic`)\n* Enables diagnostics such as:\n\n> â€œFailed to apply TransformValue at `.addresses.each.streetNumber`â€\n\n---\n\n## Example\n\n```scala\ntype PersonV0 = { val firstName: String; val lastName: String }\n\n@schema\ncase class Person(fullName: String, age: Int)\n\nval migration =\n  Migration.newBuilder[PersonV0, Person]\n    .addField(_.age, 0)\n    .build\n\nval old =\n  new { val firstName = \"John\"; val lastName = \"Doe\" }\n\nmigration(old)\n// Right(Person(\"John Doe\", 0))\n```\n\n---\n\n## Success Criteria\n\n* [ ] `DynamicMigration` fully serializable\n* [ ] `Migration[A, B]` wraps schemas and actions\n* [ ] All actions path-based via `DynamicOptic`\n* [ ] User API uses selector functions (`S => A`) for \"optics\" on old and new types\n* [ ] Macro validation in `.build` to confirm \"old\" has been migrated to \"new\"\n* [ ] `.buildPartial` supported\n* [ ] Structural reverse implemented\n* [ ] Identity & associativity laws hold\n* [ ] Enum rename / transform supported\n* [ ] Errors include path information\n* [ ] Comprehensive tests\n* [ ] Scala 2.13 and Scala 3.5+ supported\n",
                  "html_url": "https://github.com/zio/zio-blocks/issues/519"
                },
                "type": "github"
              },
              "hash": "zio/zio-blocks#519",
              "body": "## Overview\n\nImplement a **pure, algebraic migration system** for ZIO Schema 2 that represents **structural transformations between schema versions** as first-class, serializable data.\n\nA migration describes how to transform data from one schema version to another, enabling:\n\n* schema evolution\n* backward / forward compatibility\n* data versioning\n* offline migrations (JSON, SQL, data lakes, registries, etc.)\n\nThe system provides a **typed, macro-validated user API** (`Migration[A, B]`) built on a **pure, serializable core** (`DynamicMigration`) that operates on `DynamicValue`. \n\nThe ADT is fully introspectable and can be used to generate DDL, etc.\n\n## Motivation & Big Picture\n\n### Why structural types?\n\nWhen evolving schemas over time, **older versions of data types should not require runtime representations**.\n\nIn this design:\n\n* **Current versions** are represented by real case classes / enums\n* **Past versions** are represented using:\n\n  * **structural types** for records\n  * **abstract types + intersection types** for sum types\n\nThese types:\n\n* exist **only at compile time**\n* have **no runtime representation**\n* introduce **zero runtime overhead**\n* do **not require optics or instances to be kept around**\n\nThis allows you to describe arbitrarily old versions of data *without polluting your runtime or codebase*.\n\n#### Typical Workflow\n\nA typical workflow looks like:\n\n1. You have a current type:\n\n   ```scala\n   @schema\n   case class Person(name: String, age: Int)\n   ```\n\n2. You derive and copy its structural shape:\n\n   ```scala\n   type PersonV1 = { def name: String; def age: Int }\n   ```\n\n3. You evolve the real type:\n\n   ```scala\n   @schema\n   case class Person(fullName: String, age: Int, country: String)\n   ```\n\n4. You keep only:\n\n   * the **current** runtime type\n   * the **structural type** for the old version\n   * a **pure migration** between them\n\nNo old case classes. No old optics. No runtime baggage.\n\nNote there is no requirement that the \"current\" type actually be a real case class, enum, etc.--so you can work purely with structural types, allowing you to define migrations for data types that are never materialized as runtime structures.\n\n---\n\n### Why pure data migrations?\n\nMigrations are represented entirely as **pure data**:\n\n* no user functions\n* no closures\n* no reflection\n* no runtime code generation\n\nAs a result:\n\n* migrations can be **serialized**\n* stored in **registries**\n* applied **dynamically**\n* inspected and transformed\n* used to generate:\n\n  * upgraders\n  * downgraders\n  * SQL DDL / DML\n  * offline data transforms\n\nWhile code generation is **out of scope for this ticket**, this explains many design decisions (invertibility, path-based actions, no functions).\n\n---\n\n## Core Architecture\n\n### Type Hierarchy\n\n```scala\n// Typed migration (user-facing API)\ncase class Migration[A, B](\n  dynamicMigration: DynamicMigration,\n  sourceSchema: Schema[A], // These are structural schemas!!!\n  targetSchema: Schema[B] // These are structural schemas!!!\n) {\n  /** Apply migration to transform A to B */\n  def apply(value: A): Either[MigrationError, B]\n\n  /** Compose migrations sequentially */\n  def ++[C](that: Migration[B, C]): Migration[A, C]\n\n  /** Alias for ++ */\n  def andThen[C](that: Migration[B, C]): Migration[A, C] = this ++ that\n\n  /** Reverse migration (structural inverse; runtime is best-effort) */\n  def reverse: Migration[B, A]\n}\n```\n\n```scala\n// Untyped migration (pure data, fully serializable)\ncase class DynamicMigration(\n  actions: Vector[MigrationAction]\n) {\n  def apply(value: DynamicValue): Either[MigrationError, DynamicValue]\n  def ++(that: DynamicMigration): DynamicMigration\n  def reverse: DynamicMigration\n}\n```\n\n* `Migration[A, B]` is introspectable, but not pure data due to bindings inside schemas\n* `DynamicMigration` is **fully serializable**\n\n---\n\n## User-Facing API: Selector Expressions\n\n### Selectors, not optics\n\nThe user-facing API **does not expose optics**.\n\nInstead, all locations are specified using **selector expressions**:\n\n```scala\nS => A\n```\n\nExamples:\n\n```scala\n_.name\n_.address.street\n_.addresses.each.streetNumber\n_.country.when[UK]\n```\n\nTo see the syntax, one can look at the `optic` macro, which utilizes the same selector syntax for optic creation (e.g. `optic(_.address.street)`, etc.).\n\n### Macro extraction\n\nAll builder methods that accept selectors are **implemented via macros** (or via a macro-generated type class such as `ToDynamicOptic`).\n\nThe macro:\n\n1. Inspects the selector expression\n2. Validates it is a supported projection\n3. Converts it into a `DynamicOptic`\n4. Stores that optic in the migration action\n\nSupported projections include:\n\n* field access (`_.foo.bar`)\n* case selection (`_.country.when[UK]`)\n* collection traversal (`_.items.each`)\n* (future) key access, wrappers, etc.\n\n`DynamicOptic` is **never exposed publicly**.\n\n---\n\n## Migration Builder\n\nAll selector-accepting methods are implemented via macros. For simplicity, these are shown as functions (e.g. `A => Any`), but this is NOT the way to implement them. Either all these functions need to be macros, or a macro needs to be used to generate an implicit / given at each call site. Macros may do additional validation to constrain the validity of these different types of transformations.\n\n```scala\nclass MigrationBuilder[A, B](\n  sourceSchema: Schema[A],\n  targetSchema: Schema[B],\n  actions: Vector[MigrationAction]\n) {\n\n  // ----- Record operations -----\n\n  def addField(\n    target: B => Any,\n    default: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  def dropField(\n    source: A => Any,\n    defaultForReverse: SchemaExpr[B, ?] = SchemaExpr.DefaultValue\n  ): MigrationBuilder[A, B]\n\n  def renameField(\n    from: A => Any,\n    to: B => Any\n  ): MigrationBuilder[A, B]\n\n  def transformField(\n    from: A => Any,\n    to: B => Any,\n    transform: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  def mandateField(\n    source: A => Option[?],\n    target: B => Any,\n    default: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  def optionalizeField(\n    source: A => Any,\n    target: B => Option[?]\n  ): MigrationBuilder[A, B]\n\n  def changeFieldType(\n    source: A => Any,\n    target: B => Any,\n    converter: SchemaExpr[A, ?]  // primitive-to-primitive only\n  ): MigrationBuilder[A, B]\n\n  // ----- Enum operations (limited) -----\n\n  def renameCase[SumA, SumB](\n    from: String,\n    to: String\n  ): MigrationBuilder[A, B]\n\n  def transformCase[SumA, CaseA, SumB, CaseB](\n    caseMigration: MigrationBuilder[CaseA, CaseB] => MigrationBuilder[CaseA, CaseB]\n  ): MigrationBuilder[A, B]\n\n  // ----- Collections -----\n\n  def transformElements(\n    at: A => Vector[?],\n    transform: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  // ----- Maps -----\n\n  def transformKeys(\n    at: A => Map[?, ?],\n    transform: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  def transformValues(\n    at: A => Map[?, ?],\n    transform: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  /** Build migration with full macro validation */\n  def build: Migration[A, B]\n\n  /** Build migration without full validation */\n  def buildPartial: Migration[A, B]\n}\n```\n\n---\n\n## Migration Actions (Untyped Core)\n\nAll actions operate at a **path**, represented by `DynamicOptic`.\n\n```scala\nsealed trait MigrationAction {\n  def at: DynamicOptic\n  def reverse: MigrationAction\n}\n```\n\n### Record Actions\n\n```scala\ncase class AddField(\n  at: DynamicOptic,\n  default: SchemaExpr[?]\n) extends MigrationAction\n\ncase class DropField(\n  at: DynamicOptic,\n  defaultForReverse: SchemaExpr[?]\n) extends MigrationAction\n\ncase class Rename(\n  at: DynamicOptic,\n  to: String\n) extends MigrationAction\n\ncase class TransformValue(\n  at: DynamicOptic,\n  transform: SchemaExpr[?]\n) extends MigrationAction\n\ncase class Mandate(\n  at: DynamicOptic,\n  default: SchemaExpr[?]\n) extends MigrationAction\n\ncase class Optionalize(\n  at: DynamicOptic\n) extends MigrationAction\n\ncase class Join(\n  at: DynamicOptic,\n  sourcePaths: Vector[DynamicOptic],\n  combiner: SchemaExpr[?]\n) extends MigrationAction\n\ncase class Split(\n  at: DynamicOptic,\n  targetPaths: Vector[DynamicOptic],\n  splitter: SchemaExpr[?]\n) extends MigrationAction\n\ncase class ChangeType(\n  at: DynamicOptic,\n  converter: SchemaExpr[?]\n) extends MigrationAction\n```\n\n---\n\n### Enum Actions (Supported)\n\n```scala\ncase class RenameCase(\n  at: DynamicOptic,\n  from: String,\n  to: String\n) extends MigrationAction\n\ncase class TransformCase(\n  at: DynamicOptic,\n  actions: Vector[MigrationAction]\n) extends MigrationAction\n```\n\n> Enum case addition / removal is **out of scope** for this ticket\n> (requires composite value construction).\n\n---\n\n### Collection / Map Actions\n\n```scala\ncase class TransformElements(\n  at: DynamicOptic,\n  transform: SchemaExpr[?]\n) extends MigrationAction\n\ncase class TransformKeys(\n  at: DynamicOptic,\n  transform: SchemaExpr[?]\n) extends MigrationAction\n\ncase class TransformValues(\n  at: DynamicOptic,\n  transform: SchemaExpr[?]\n) extends MigrationAction\n```\n\n---\n\n## SchemaExpr Integration\n\n* Used for all value-level transformations\n* **Constraints for this ticket**:\n\n  * primitive â†’ primitive only\n  * joins / splits must produce primitives\n  * no record / enum construction\n\n### `SchemaExpr.DefaultValue`\n\nA special expression that:\n\n1. uses the macro-captured field schema\n2. calls `schema.defaultValue`\n3. converts the value to `DynamicValue`\n4. is stored for reverse migrations\n\n---\n\n## Type Modeling\n\n### Records (Structural Types)\n\n```scala\ntype PersonV0 = { val firstName: String; val lastName: String }\ntype PersonV1 = { val fullName: String; val age: Int }\n\nimplicit val v0Schema: Schema[PersonV0] = Schema.structural[PersonV0]\nimplicit val v1Schema: Schema[PersonV1] = Schema.structural[PersonV1]\n```\n\n---\n\n### Enums (Union of Structural Types with Tags)\n\nEnums are encoded into structural types by using union types, together with singleton types (string literals, which represent the name of the case of the enum).\n\nIn structural types, the names of the type aliases shown below are not relevant, nor are they used.\n\n```scala\ntype OldCreditCard =\n  { type Tag = \"CreditCard\"; def number: String; def exp: String }\ntype OldWireTransfer =\n  { type Tag = \"WireTransfer\"; def account: String; def routing: String }\ntype OldPaymentMethod = OldCreditCard | OldWireTransfer\n```\n\nMacros extract:\n\n* refinement type â†’ structure of the case\n* type `Tag` with singleton type â†’ case tag\n\n---\n\n## Laws\n\n### Identity\n\n```scala\nMigration.identity[A].apply(a) == Right(a)\n```\n\n### Associativity\n\n```scala\n(m1 ++ m2) ++ m3 == m1 ++ (m2 ++ m3)\n```\n\n### Structural Reverse\n\n```scala\nm.reverse.reverse == m\n```\n\n### Best-Effort Semantic Inverse\n\n```scala\nm.apply(a) == Right(b) â‡’ m.reverse.apply(b) == Right(a)\n```\n\n(when sufficient information exists)\n\n---\n\n## Error Handling\n\n* All runtime errors return `MigrationError`\n* Errors must capture **path information** (`DynamicOptic`)\n* Enables diagnostics such as:\n\n> â€œFailed to apply TransformValue at `.addresses.each.streetNumber`â€\n\n---\n\n## Example\n\n```scala\ntype PersonV0 = { val firstName: String; val lastName: String }\n\n@schema\ncase class Person(fullName: String, age: Int)\n\nval migration =\n  Migration.newBuilder[PersonV0, Person]\n    .addField(_.age, 0)\n    .build\n\nval old =\n  new { val firstName = \"John\"; val lastName = \"Doe\" }\n\nmigration(old)\n// Right(Person(\"John Doe\", 0))\n```\n\n---\n\n## Success Criteria\n\n* [ ] `DynamicMigration` fully serializable\n* [ ] `Migration[A, B]` wraps schemas and actions\n* [ ] All actions path-based via `DynamicOptic`\n* [ ] User API uses selector functions (`S => A`) for \"optics\" on old and new types\n* [ ] Macro validation in `.build` to confirm \"old\" has been migrated to \"new\"\n* [ ] `.buildPartial` supported\n* [ ] Structural reverse implemented\n* [ ] Identity & associativity laws hold\n* [ ] Enum rename / transform supported\n* [ ] Errors include path information\n* [ ] Comprehensive tests\n* [ ] Scala 2.13 and Scala 3.5+ supported\n",
              "url": "https://github.com/zio/zio-blocks/issues/519",
              "tech": [],
              "repo_name": "zio-blocks",
              "repo_owner": "zio",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "projectdiscovery#1693",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "projectdiscovery",
              "id": "generated-projectdiscovery",
              "name": "Projectdiscovery",
              "description": "",
              "members": [],
              "display_name": "Projectdiscovery",
              "created_at": "2026-01-19T14:47:39.934Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/projectdiscovery?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "projectdiscovery",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-19T14:47:39.934Z",
            "created_at": "2026-01-19T14:47:39.934Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-projectdiscovery#1693",
              "status": "open",
              "type": "issue",
              "number": 1693,
              "title": "test - pls ignore",
              "source": {
                "data": {
                  "id": "source-projectdiscovery#1693",
                  "user": {
                    "login": "dogancanbakir",
                    "id": 65292895,
                    "node_id": "MDQ6VXNlcjY1MjkyODk1",
                    "avatar_url": "https://avatars.githubusercontent.com/u/65292895?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/dogancanbakir",
                    "html_url": "https://github.com/dogancanbakir",
                    "followers_url": "https://api.github.com/users/dogancanbakir/followers",
                    "following_url": "https://api.github.com/users/dogancanbakir/following{/other_user}",
                    "gists_url": "https://api.github.com/users/dogancanbakir/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/dogancanbakir/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/dogancanbakir/subscriptions",
                    "organizations_url": "https://api.github.com/users/dogancanbakir/orgs",
                    "repos_url": "https://api.github.com/users/dogancanbakir/repos",
                    "events_url": "https://api.github.com/users/dogancanbakir/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/dogancanbakir/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "test - pls ignore",
                  "body": "test",
                  "html_url": "https://github.com/projectdiscovery/subfinder/issues/1693"
                },
                "type": "github"
              },
              "hash": "projectdiscovery/subfinder#1693",
              "body": "test",
              "url": "https://github.com/projectdiscovery/subfinder/issues/1693",
              "tech": [],
              "repo_name": "subfinder",
              "repo_owner": "projectdiscovery",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "projectdiscovery#14576",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "projectdiscovery",
              "id": "generated-projectdiscovery",
              "name": "Projectdiscovery",
              "description": "",
              "members": [],
              "display_name": "Projectdiscovery",
              "created_at": "2026-01-19T14:47:40.266Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/projectdiscovery?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "projectdiscovery",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-19T14:47:40.266Z",
            "created_at": "2026-01-19T14:47:40.266Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-projectdiscovery#14576",
              "status": "open",
              "type": "issue",
              "number": 14576,
              "title": "CVE-2018-8581 - Microsoft Exchange Server - Elevation of Privilege ðŸ’°",
              "source": {
                "data": {
                  "id": "source-projectdiscovery#14576",
                  "user": {
                    "login": "princechaddha",
                    "id": 16654365,
                    "node_id": "MDQ6VXNlcjE2NjU0MzY1",
                    "avatar_url": "https://avatars.githubusercontent.com/u/16654365?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/princechaddha",
                    "html_url": "https://github.com/princechaddha",
                    "followers_url": "https://api.github.com/users/princechaddha/followers",
                    "following_url": "https://api.github.com/users/princechaddha/following{/other_user}",
                    "gists_url": "https://api.github.com/users/princechaddha/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/princechaddha/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/princechaddha/subscriptions",
                    "organizations_url": "https://api.github.com/users/princechaddha/orgs",
                    "repos_url": "https://api.github.com/users/princechaddha/repos",
                    "events_url": "https://api.github.com/users/princechaddha/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/princechaddha/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "CVE-2018-8581 - Microsoft Exchange Server - Elevation of Privilege ðŸ’°",
                  "body": "\n### Description: \n> Microsoft Exchange Server contains an elevation of privilege caused by a vulnerability in the system, letting attackers escalate their privileges, exploit requires specific conditions not specified.\n\n#### Severity: `High`\n\n#### POC: \n- https://vulncheck.com/xdb/276c34c7f74f\n- https///gitee.com:mirrors_WyAtu/CVE-2018-8581.git\n- https://vulncheck.com/xdb/7730cd30a582\n- https://github.com/Ridter/Exchange2domain\n- https///github.com:Ridter/Exchange2domain.git\n- https://vulncheck.com/xdb/d7f23b749ff9\n- https://github.com/qiantu88/CVE-2018-8581\n- https///github.com:qiantu88/CVE-2018-8581.git\n- https://vulncheck.com/xdb/dba145cf3cba\n- https://github.com/WyAtu/CVE-2018-8581\n- https///github.com:WyAtu/CVE-2018-8581.git\n- https://vulncheck.com/xdb/3d3434d62f82\n- https///github.com:thezdi/PoC.git\n\n### KEV: True\n\n### Shodan Query: `cpe:\"cpe:2.3:a:microsoft:exchange_server\"`\n\n> Acceptance Criteria: The template must include a complete POC and should not rely solely on version-based detection. Contributors are required to provide debug data(`-debug`) along with the template to help the triage team with validation or can also share a vulnerable environment like docker file. \n\n> Rewards will only be given once the template is fully validated by the team. Templates that are incomplete or invalid will not be accepted. Avoid adding code templates for CVEs that can be achieved using HTTP, TCP, or JavaScript. Such templates are blocked by default and wonâ€™t produce results, so we prioritize creating templates with other protocols unless exceptions are made.\n\nYou can check the FAQ for the Nuclei Templates Community Rewards Program [here](https://github.com/projectdiscovery/nuclei-templates/blob/main/Community-Rewards-FAQ.md).\n",
                  "html_url": "https://github.com/projectdiscovery/nuclei-templates/issues/14576"
                },
                "type": "github"
              },
              "hash": "projectdiscovery/nuclei-templates#14576",
              "body": "\n### Description: \n> Microsoft Exchange Server contains an elevation of privilege caused by a vulnerability in the system, letting attackers escalate their privileges, exploit requires specific conditions not specified.\n\n#### Severity: `High`\n\n#### POC: \n- https://vulncheck.com/xdb/276c34c7f74f\n- https///gitee.com:mirrors_WyAtu/CVE-2018-8581.git\n- https://vulncheck.com/xdb/7730cd30a582\n- https://github.com/Ridter/Exchange2domain\n- https///github.com:Ridter/Exchange2domain.git\n- https://vulncheck.com/xdb/d7f23b749ff9\n- https://github.com/qiantu88/CVE-2018-8581\n- https///github.com:qiantu88/CVE-2018-8581.git\n- https://vulncheck.com/xdb/dba145cf3cba\n- https://github.com/WyAtu/CVE-2018-8581\n- https///github.com:WyAtu/CVE-2018-8581.git\n- https://vulncheck.com/xdb/3d3434d62f82\n- https///github.com:thezdi/PoC.git\n\n### KEV: True\n\n### Shodan Query: `cpe:\"cpe:2.3:a:microsoft:exchange_server\"`\n\n> Acceptance Criteria: The template must include a complete POC and should not rely solely on version-based detection. Contributors are required to provide debug data(`-debug`) along with the template to help the triage team with validation or can also share a vulnerable environment like docker file. \n\n> Rewards will only be given once the template is fully validated by the team. Templates that are incomplete or invalid will not be accepted. Avoid adding code templates for CVEs that can be achieved using HTTP, TCP, or JavaScript. Such templates are blocked by default and wonâ€™t produce results, so we prioritize creating templates with other protocols unless exceptions are made.\n\nYou can check the FAQ for the Nuclei Templates Community Rewards Program [here](https://github.com/projectdiscovery/nuclei-templates/blob/main/Community-Rewards-FAQ.md).\n",
              "url": "https://github.com/projectdiscovery/nuclei-templates/issues/14576",
              "tech": [],
              "repo_name": "nuclei-templates",
              "repo_owner": "projectdiscovery",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "projectdiscovery#14535",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "projectdiscovery",
              "id": "generated-projectdiscovery",
              "name": "Projectdiscovery",
              "description": "",
              "members": [],
              "display_name": "Projectdiscovery",
              "created_at": "2026-01-19T14:47:40.821Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/projectdiscovery?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "projectdiscovery",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-19T14:47:40.821Z",
            "created_at": "2026-01-19T14:47:40.821Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-projectdiscovery#14535",
              "status": "open",
              "type": "issue",
              "number": 14535,
              "title": "CVE-2018-20753 - Kaseya VSA - Command Injection ðŸ’°",
              "source": {
                "data": {
                  "id": "source-projectdiscovery#14535",
                  "user": {
                    "login": "princechaddha",
                    "id": 16654365,
                    "node_id": "MDQ6VXNlcjE2NjU0MzY1",
                    "avatar_url": "https://avatars.githubusercontent.com/u/16654365?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/princechaddha",
                    "html_url": "https://github.com/princechaddha",
                    "followers_url": "https://api.github.com/users/princechaddha/followers",
                    "following_url": "https://api.github.com/users/princechaddha/following{/other_user}",
                    "gists_url": "https://api.github.com/users/princechaddha/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/princechaddha/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/princechaddha/subscriptions",
                    "organizations_url": "https://api.github.com/users/princechaddha/orgs",
                    "repos_url": "https://api.github.com/users/princechaddha/repos",
                    "events_url": "https://api.github.com/users/princechaddha/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/princechaddha/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "CVE-2018-20753 - Kaseya VSA - Command Injection ðŸ’°",
                  "body": "\n### Description: \n> Kaseya VSA RMM before R9.3 9.3.0.35, R9.4 before 9.4.0.36, and R9.5 before 9.5.0.5 contain a command injection caused by insufficient input validation in PowerShell execution, letting unprivileged remote attackers execute arbitrary PowerShell payloads on all managed devices, exploit requires network access to the system.\n\n#### Severity: `Critical`\n\n#### POC: \n- https://blog.huntresslabs.com/deep-dive-kaseya-vsa-mining-payload-c0ac839a0e88\n\n### KEV: True\n\n### Shodan Query: `http.favicon.hash:-1445519482`\n\n> Acceptance Criteria: The template must include a complete POC and should not rely solely on version-based detection. Contributors are required to provide debug data(`-debug`) along with the template to help the triage team with validation or can also share a vulnerable environment like docker file. \n\n> Rewards will only be given once the template is fully validated by the team. Templates that are incomplete or invalid will not be accepted. Avoid adding code templates for CVEs that can be achieved using HTTP, TCP, or JavaScript. Such templates are blocked by default and wonâ€™t produce results, so we prioritize creating templates with other protocols unless exceptions are made.\n\nYou can check the FAQ for the Nuclei Templates Community Rewards Program [here](https://github.com/projectdiscovery/nuclei-templates/blob/main/Community-Rewards-FAQ.md).\n",
                  "html_url": "https://github.com/projectdiscovery/nuclei-templates/issues/14535"
                },
                "type": "github"
              },
              "hash": "projectdiscovery/nuclei-templates#14535",
              "body": "\n### Description: \n> Kaseya VSA RMM before R9.3 9.3.0.35, R9.4 before 9.4.0.36, and R9.5 before 9.5.0.5 contain a command injection caused by insufficient input validation in PowerShell execution, letting unprivileged remote attackers execute arbitrary PowerShell payloads on all managed devices, exploit requires network access to the system.\n\n#### Severity: `Critical`\n\n#### POC: \n- https://blog.huntresslabs.com/deep-dive-kaseya-vsa-mining-payload-c0ac839a0e88\n\n### KEV: True\n\n### Shodan Query: `http.favicon.hash:-1445519482`\n\n> Acceptance Criteria: The template must include a complete POC and should not rely solely on version-based detection. Contributors are required to provide debug data(`-debug`) along with the template to help the triage team with validation or can also share a vulnerable environment like docker file. \n\n> Rewards will only be given once the template is fully validated by the team. Templates that are incomplete or invalid will not be accepted. Avoid adding code templates for CVEs that can be achieved using HTTP, TCP, or JavaScript. Such templates are blocked by default and wonâ€™t produce results, so we prioritize creating templates with other protocols unless exceptions are made.\n\nYou can check the FAQ for the Nuclei Templates Community Rewards Program [here](https://github.com/projectdiscovery/nuclei-templates/blob/main/Community-Rewards-FAQ.md).\n",
              "url": "https://github.com/projectdiscovery/nuclei-templates/issues/14535",
              "tech": [],
              "repo_name": "nuclei-templates",
              "repo_owner": "projectdiscovery",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "projectdiscovery#14488",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "projectdiscovery",
              "id": "generated-projectdiscovery",
              "name": "Projectdiscovery",
              "description": "",
              "members": [],
              "display_name": "Projectdiscovery",
              "created_at": "2026-01-19T14:47:41.643Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/projectdiscovery?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "projectdiscovery",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-19T14:47:41.643Z",
            "created_at": "2026-01-19T14:47:41.643Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-projectdiscovery#14488",
              "status": "open",
              "type": "issue",
              "number": 14488,
              "title": "CVE-2024-3408 - man-group/dtale - Authentication Bypass & Remote Code Execution ðŸ’°",
              "source": {
                "data": {
                  "id": "source-projectdiscovery#14488",
                  "user": {
                    "login": "princechaddha",
                    "id": 16654365,
                    "node_id": "MDQ6VXNlcjE2NjU0MzY1",
                    "avatar_url": "https://avatars.githubusercontent.com/u/16654365?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/princechaddha",
                    "html_url": "https://github.com/princechaddha",
                    "followers_url": "https://api.github.com/users/princechaddha/followers",
                    "following_url": "https://api.github.com/users/princechaddha/following{/other_user}",
                    "gists_url": "https://api.github.com/users/princechaddha/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/princechaddha/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/princechaddha/subscriptions",
                    "organizations_url": "https://api.github.com/users/princechaddha/orgs",
                    "repos_url": "https://api.github.com/users/princechaddha/repos",
                    "events_url": "https://api.github.com/users/princechaddha/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/princechaddha/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "CVE-2024-3408 - man-group/dtale - Authentication Bypass & Remote Code Execution ðŸ’°",
                  "body": "\n### Description: \n> man-group/dtale 3.10.0 contains an authentication bypass and remote code execution caused by improper input validation and a hardcoded SECRET_KEY in Flask configuration, letting attackers forge session cookies and execute arbitrary code, exploit requires attacker to access the application.\n\n#### Severity: `Critical`\n\n#### POC: \n- https://huntr.com/bounties/57a06666-ff85-4577-af19-f3dfb7b02f91\n- https://github.com/rapid7/metasploit-framework/blob/master/modules/exploits/linux/http/dtale_rce_cve_2025_0655.rb\n\n### KEV: True\n\n### Shodan Query: `NA`\n\n> Acceptance Criteria: The template must include a complete POC and should not rely solely on version-based detection. Contributors are required to provide debug data(`-debug`) along with the template to help the triage team with validation or can also share a vulnerable environment like docker file. \n\n> Rewards will only be given once the template is fully validated by the team. Templates that are incomplete or invalid will not be accepted. Avoid adding code templates for CVEs that can be achieved using HTTP, TCP, or JavaScript. Such templates are blocked by default and wonâ€™t produce results, so we prioritize creating templates with other protocols unless exceptions are made.\n\nYou can check the FAQ for the Nuclei Templates Community Rewards Program [here](https://github.com/projectdiscovery/nuclei-templates/blob/main/Community-Rewards-FAQ.md).\n",
                  "html_url": "https://github.com/projectdiscovery/nuclei-templates/issues/14488"
                },
                "type": "github"
              },
              "hash": "projectdiscovery/nuclei-templates#14488",
              "body": "\n### Description: \n> man-group/dtale 3.10.0 contains an authentication bypass and remote code execution caused by improper input validation and a hardcoded SECRET_KEY in Flask configuration, letting attackers forge session cookies and execute arbitrary code, exploit requires attacker to access the application.\n\n#### Severity: `Critical`\n\n#### POC: \n- https://huntr.com/bounties/57a06666-ff85-4577-af19-f3dfb7b02f91\n- https://github.com/rapid7/metasploit-framework/blob/master/modules/exploits/linux/http/dtale_rce_cve_2025_0655.rb\n\n### KEV: True\n\n### Shodan Query: `NA`\n\n> Acceptance Criteria: The template must include a complete POC and should not rely solely on version-based detection. Contributors are required to provide debug data(`-debug`) along with the template to help the triage team with validation or can also share a vulnerable environment like docker file. \n\n> Rewards will only be given once the template is fully validated by the team. Templates that are incomplete or invalid will not be accepted. Avoid adding code templates for CVEs that can be achieved using HTTP, TCP, or JavaScript. Such templates are blocked by default and wonâ€™t produce results, so we prioritize creating templates with other protocols unless exceptions are made.\n\nYou can check the FAQ for the Nuclei Templates Community Rewards Program [here](https://github.com/projectdiscovery/nuclei-templates/blob/main/Community-Rewards-FAQ.md).\n",
              "url": "https://github.com/projectdiscovery/nuclei-templates/issues/14488",
              "tech": [],
              "repo_name": "nuclei-templates",
              "repo_owner": "projectdiscovery",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "projectdiscovery#14488",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "projectdiscovery",
              "id": "generated-projectdiscovery",
              "name": "Projectdiscovery",
              "description": "",
              "members": [],
              "display_name": "Projectdiscovery",
              "created_at": "2026-01-19T14:47:43.429Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/projectdiscovery?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "projectdiscovery",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-19T14:47:43.429Z",
            "created_at": "2026-01-19T14:47:43.429Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-projectdiscovery#14488",
              "status": "open",
              "type": "issue",
              "number": 14488,
              "title": "CVE-2024-3408 - man-group/dtale - Authentication Bypass & Remote Code Execution ðŸ’°",
              "source": {
                "data": {
                  "id": "source-projectdiscovery#14488",
                  "user": {
                    "login": "princechaddha",
                    "id": 16654365,
                    "node_id": "MDQ6VXNlcjE2NjU0MzY1",
                    "avatar_url": "https://avatars.githubusercontent.com/u/16654365?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/princechaddha",
                    "html_url": "https://github.com/princechaddha",
                    "followers_url": "https://api.github.com/users/princechaddha/followers",
                    "following_url": "https://api.github.com/users/princechaddha/following{/other_user}",
                    "gists_url": "https://api.github.com/users/princechaddha/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/princechaddha/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/princechaddha/subscriptions",
                    "organizations_url": "https://api.github.com/users/princechaddha/orgs",
                    "repos_url": "https://api.github.com/users/princechaddha/repos",
                    "events_url": "https://api.github.com/users/princechaddha/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/princechaddha/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "CVE-2024-3408 - man-group/dtale - Authentication Bypass & Remote Code Execution ðŸ’°",
                  "body": "\n### Description: \n> man-group/dtale 3.10.0 contains an authentication bypass and remote code execution caused by improper input validation and a hardcoded SECRET_KEY in Flask configuration, letting attackers forge session cookies and execute arbitrary code, exploit requires attacker to access the application.\n\n#### Severity: `Critical`\n\n#### POC: \n- https://huntr.com/bounties/57a06666-ff85-4577-af19-f3dfb7b02f91\n- https://github.com/rapid7/metasploit-framework/blob/master/modules/exploits/linux/http/dtale_rce_cve_2025_0655.rb\n\n### KEV: True\n\n### Shodan Query: `NA`\n\n> Acceptance Criteria: The template must include a complete POC and should not rely solely on version-based detection. Contributors are required to provide debug data(`-debug`) along with the template to help the triage team with validation or can also share a vulnerable environment like docker file. \n\n> Rewards will only be given once the template is fully validated by the team. Templates that are incomplete or invalid will not be accepted. Avoid adding code templates for CVEs that can be achieved using HTTP, TCP, or JavaScript. Such templates are blocked by default and wonâ€™t produce results, so we prioritize creating templates with other protocols unless exceptions are made.\n\nYou can check the FAQ for the Nuclei Templates Community Rewards Program [here](https://github.com/projectdiscovery/nuclei-templates/blob/main/Community-Rewards-FAQ.md).\n",
                  "html_url": "https://github.com/projectdiscovery/nuclei-templates/issues/14488"
                },
                "type": "github"
              },
              "hash": "projectdiscovery/nuclei-templates#14488",
              "body": "\n### Description: \n> man-group/dtale 3.10.0 contains an authentication bypass and remote code execution caused by improper input validation and a hardcoded SECRET_KEY in Flask configuration, letting attackers forge session cookies and execute arbitrary code, exploit requires attacker to access the application.\n\n#### Severity: `Critical`\n\n#### POC: \n- https://huntr.com/bounties/57a06666-ff85-4577-af19-f3dfb7b02f91\n- https://github.com/rapid7/metasploit-framework/blob/master/modules/exploits/linux/http/dtale_rce_cve_2025_0655.rb\n\n### KEV: True\n\n### Shodan Query: `NA`\n\n> Acceptance Criteria: The template must include a complete POC and should not rely solely on version-based detection. Contributors are required to provide debug data(`-debug`) along with the template to help the triage team with validation or can also share a vulnerable environment like docker file. \n\n> Rewards will only be given once the template is fully validated by the team. Templates that are incomplete or invalid will not be accepted. Avoid adding code templates for CVEs that can be achieved using HTTP, TCP, or JavaScript. Such templates are blocked by default and wonâ€™t produce results, so we prioritize creating templates with other protocols unless exceptions are made.\n\nYou can check the FAQ for the Nuclei Templates Community Rewards Program [here](https://github.com/projectdiscovery/nuclei-templates/blob/main/Community-Rewards-FAQ.md).\n",
              "url": "https://github.com/projectdiscovery/nuclei-templates/issues/14488",
              "tech": [],
              "repo_name": "nuclei-templates",
              "repo_owner": "projectdiscovery",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "projectdiscovery#14451",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "projectdiscovery",
              "id": "generated-projectdiscovery",
              "name": "Projectdiscovery",
              "description": "",
              "members": [],
              "display_name": "Projectdiscovery",
              "created_at": "2026-01-19T14:47:45.322Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/projectdiscovery?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "projectdiscovery",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-19T14:47:45.322Z",
            "created_at": "2026-01-19T14:47:45.322Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-projectdiscovery#14451",
              "status": "open",
              "type": "issue",
              "number": 14451,
              "title": "CVE-2017-18365 - GitHub Enterprise - Insecure Deserialization ðŸ’°",
              "source": {
                "data": {
                  "id": "source-projectdiscovery#14451",
                  "user": {
                    "login": "princechaddha",
                    "id": 16654365,
                    "node_id": "MDQ6VXNlcjE2NjU0MzY1",
                    "avatar_url": "https://avatars.githubusercontent.com/u/16654365?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/princechaddha",
                    "html_url": "https://github.com/princechaddha",
                    "followers_url": "https://api.github.com/users/princechaddha/followers",
                    "following_url": "https://api.github.com/users/princechaddha/following{/other_user}",
                    "gists_url": "https://api.github.com/users/princechaddha/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/princechaddha/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/princechaddha/subscriptions",
                    "organizations_url": "https://api.github.com/users/princechaddha/orgs",
                    "repos_url": "https://api.github.com/users/princechaddha/repos",
                    "events_url": "https://api.github.com/users/princechaddha/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/princechaddha/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "CVE-2017-18365 - GitHub Enterprise - Insecure Deserialization ðŸ’°",
                  "body": "\n### Description: \n> GitHub Enterprise 2.8.x before 2.8.7 contains a deserialization caused by a static enterprise session secret in the Management Console, letting unauthenticated attackers execute arbitrary code, exploit requires crafting a signed cookie with the secret.\n\n#### Severity: `Critical`\n\n#### POC: \n- https://www.exablue.de/blog/2017-03-15-github-enterprise-remote-code-execution.html\n- https://github.com/rapid7/metasploit-framework/blob/master/modules/exploits/linux/http/github_enterprise_secret.rb\n\n### KEV: True\n\n### Shodan Query: `http.title:\"github debug\"`\n\n> Acceptance Criteria: The template must include a complete POC and should not rely solely on version-based detection. Contributors are required to provide debug data(`-debug`) along with the template to help the triage team with validation or can also share a vulnerable environment like docker file. \n\n> Rewards will only be given once the template is fully validated by the team. Templates that are incomplete or invalid will not be accepted. Avoid adding code templates for CVEs that can be achieved using HTTP, TCP, or JavaScript. Such templates are blocked by default and wonâ€™t produce results, so we prioritize creating templates with other protocols unless exceptions are made.\n\nYou can check the FAQ for the Nuclei Templates Community Rewards Program [here](https://github.com/projectdiscovery/nuclei-templates/blob/main/Community-Rewards-FAQ.md).\n",
                  "html_url": "https://github.com/projectdiscovery/nuclei-templates/issues/14451"
                },
                "type": "github"
              },
              "hash": "projectdiscovery/nuclei-templates#14451",
              "body": "\n### Description: \n> GitHub Enterprise 2.8.x before 2.8.7 contains a deserialization caused by a static enterprise session secret in the Management Console, letting unauthenticated attackers execute arbitrary code, exploit requires crafting a signed cookie with the secret.\n\n#### Severity: `Critical`\n\n#### POC: \n- https://www.exablue.de/blog/2017-03-15-github-enterprise-remote-code-execution.html\n- https://github.com/rapid7/metasploit-framework/blob/master/modules/exploits/linux/http/github_enterprise_secret.rb\n\n### KEV: True\n\n### Shodan Query: `http.title:\"github debug\"`\n\n> Acceptance Criteria: The template must include a complete POC and should not rely solely on version-based detection. Contributors are required to provide debug data(`-debug`) along with the template to help the triage team with validation or can also share a vulnerable environment like docker file. \n\n> Rewards will only be given once the template is fully validated by the team. Templates that are incomplete or invalid will not be accepted. Avoid adding code templates for CVEs that can be achieved using HTTP, TCP, or JavaScript. Such templates are blocked by default and wonâ€™t produce results, so we prioritize creating templates with other protocols unless exceptions are made.\n\nYou can check the FAQ for the Nuclei Templates Community Rewards Program [here](https://github.com/projectdiscovery/nuclei-templates/blob/main/Community-Rewards-FAQ.md).\n",
              "url": "https://github.com/projectdiscovery/nuclei-templates/issues/14451",
              "tech": [],
              "repo_name": "nuclei-templates",
              "repo_owner": "projectdiscovery",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "projectdiscovery#14382",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "projectdiscovery",
              "id": "generated-projectdiscovery",
              "name": "Projectdiscovery",
              "description": "",
              "members": [],
              "display_name": "Projectdiscovery",
              "created_at": "2026-01-19T14:47:48.526Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/projectdiscovery?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "projectdiscovery",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-19T14:47:48.526Z",
            "created_at": "2026-01-19T14:47:48.526Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-projectdiscovery#14382",
              "status": "open",
              "type": "issue",
              "number": 14382,
              "title": "CVE-2018-19629 - Hyland Perceptive Content Server - Denial of Service ðŸ’°",
              "source": {
                "data": {
                  "id": "source-projectdiscovery#14382",
                  "user": {
                    "login": "princechaddha",
                    "id": 16654365,
                    "node_id": "MDQ6VXNlcjE2NjU0MzY1",
                    "avatar_url": "https://avatars.githubusercontent.com/u/16654365?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/princechaddha",
                    "html_url": "https://github.com/princechaddha",
                    "followers_url": "https://api.github.com/users/princechaddha/followers",
                    "following_url": "https://api.github.com/users/princechaddha/following{/other_user}",
                    "gists_url": "https://api.github.com/users/princechaddha/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/princechaddha/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/princechaddha/subscriptions",
                    "organizations_url": "https://api.github.com/users/princechaddha/orgs",
                    "repos_url": "https://api.github.com/users/princechaddha/repos",
                    "events_url": "https://api.github.com/users/princechaddha/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/princechaddha/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "CVE-2018-19629 - Hyland Perceptive Content Server - Denial of Service ðŸ’°",
                  "body": "\n### Description: \n> Hyland Perceptive Content Server before 7.1.5 contains a denial of service caused by crashing the ImageNow Server service via a TCP connection, letting attackers disrupt service, exploit requires sending crafted TCP packets.\n\n#### Severity: `High`\n\n#### POC: \n- https://www.oppositionsecurity.com/imagenow-7-1-4-dos/\n\n### KEV: True\n\n### Shodan Query: `NA`\n\n> Acceptance Criteria: The template must include a complete POC and should not rely solely on version-based detection. Contributors are required to provide debug data(`-debug`) along with the template to help the triage team with validation or can also share a vulnerable environment like docker file. \n\n> Rewards will only be given once the template is fully validated by the team. Templates that are incomplete or invalid will not be accepted. Avoid adding code templates for CVEs that can be achieved using HTTP, TCP, or JavaScript. Such templates are blocked by default and wonâ€™t produce results, so we prioritize creating templates with other protocols unless exceptions are made.\n\nYou can check the FAQ for the Nuclei Templates Community Rewards Program [here](https://github.com/projectdiscovery/nuclei-templates/blob/main/Community-Rewards-FAQ.md).\n",
                  "html_url": "https://github.com/projectdiscovery/nuclei-templates/issues/14382"
                },
                "type": "github"
              },
              "hash": "projectdiscovery/nuclei-templates#14382",
              "body": "\n### Description: \n> Hyland Perceptive Content Server before 7.1.5 contains a denial of service caused by crashing the ImageNow Server service via a TCP connection, letting attackers disrupt service, exploit requires sending crafted TCP packets.\n\n#### Severity: `High`\n\n#### POC: \n- https://www.oppositionsecurity.com/imagenow-7-1-4-dos/\n\n### KEV: True\n\n### Shodan Query: `NA`\n\n> Acceptance Criteria: The template must include a complete POC and should not rely solely on version-based detection. Contributors are required to provide debug data(`-debug`) along with the template to help the triage team with validation or can also share a vulnerable environment like docker file. \n\n> Rewards will only be given once the template is fully validated by the team. Templates that are incomplete or invalid will not be accepted. Avoid adding code templates for CVEs that can be achieved using HTTP, TCP, or JavaScript. Such templates are blocked by default and wonâ€™t produce results, so we prioritize creating templates with other protocols unless exceptions are made.\n\nYou can check the FAQ for the Nuclei Templates Community Rewards Program [here](https://github.com/projectdiscovery/nuclei-templates/blob/main/Community-Rewards-FAQ.md).\n",
              "url": "https://github.com/projectdiscovery/nuclei-templates/issues/14382",
              "tech": [],
              "repo_name": "nuclei-templates",
              "repo_owner": "projectdiscovery",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "projectdiscovery#14297",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "projectdiscovery",
              "id": "generated-projectdiscovery",
              "name": "Projectdiscovery",
              "description": "",
              "members": [],
              "display_name": "Projectdiscovery",
              "created_at": "2026-01-19T14:47:51.104Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/projectdiscovery?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "projectdiscovery",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-19T14:47:51.104Z",
            "created_at": "2026-01-19T14:47:51.104Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-projectdiscovery#14297",
              "status": "open",
              "type": "issue",
              "number": 14297,
              "title": "CVE-2019-3980 - Solarwinds Dameware Mini Remote Client - Remote Code Execution ðŸ’°",
              "source": {
                "data": {
                  "id": "source-projectdiscovery#14297",
                  "user": {
                    "login": "princechaddha",
                    "id": 16654365,
                    "node_id": "MDQ6VXNlcjE2NjU0MzY1",
                    "avatar_url": "https://avatars.githubusercontent.com/u/16654365?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/princechaddha",
                    "html_url": "https://github.com/princechaddha",
                    "followers_url": "https://api.github.com/users/princechaddha/followers",
                    "following_url": "https://api.github.com/users/princechaddha/following{/other_user}",
                    "gists_url": "https://api.github.com/users/princechaddha/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/princechaddha/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/princechaddha/subscriptions",
                    "organizations_url": "https://api.github.com/users/princechaddha/orgs",
                    "repos_url": "https://api.github.com/users/princechaddha/repos",
                    "events_url": "https://api.github.com/users/princechaddha/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/princechaddha/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "CVE-2019-3980 - Solarwinds Dameware Mini Remote Client - Remote Code Execution ðŸ’°",
                  "body": "\n### Description: \n> Solarwinds Dameware Mini Remote Client agent v12.1.0.89 contains a remote code execution caused by support for smart card authentication allowing upload and execution of arbitrary executables on the host, letting unauthenticated attackers execute code under the Local System account, exploit requires requesting smart card login.\n\n#### Severity: `Critical`\n\n#### POC: \n- https://www.tenable.com/security/research/tra-227-43\n- https://github.com/CyberQuestor-infosec/CVE-2019-3980-Open_Net_Admin_v18.1.1_RCE\n- https///github.com:CyberQuestor-infosec/CVE-2019-3980-Open_Net_Admin_v18.1.1_RCE.git\n- https://github.com/Barbarisch/CVE-2019-3980\n- https://vulncheck.com/xdb/b2d525559d87\n- https///github.com:Barbarisch/CVE-2019-3980.git\n- https://github.com/warferik/CVE-2019-3980\n\n### KEV: True\n\n### Shodan Query: `NA`\n\n> Acceptance Criteria: The template must include a complete POC and should not rely solely on version-based detection. Contributors are required to provide debug data(`-debug`) along with the template to help the triage team with validation or can also share a vulnerable environment like docker file. \n\n> Rewards will only be given once the template is fully validated by the team. Templates that are incomplete or invalid will not be accepted. Avoid adding code templates for CVEs that can be achieved using HTTP, TCP, or JavaScript. Such templates are blocked by default and wonâ€™t produce results, so we prioritize creating templates with other protocols unless exceptions are made.\n\nYou can check the FAQ for the Nuclei Templates Community Rewards Program [here](https://github.com/projectdiscovery/nuclei-templates/blob/main/Community-Rewards-FAQ.md).\n",
                  "html_url": "https://github.com/projectdiscovery/nuclei-templates/issues/14297"
                },
                "type": "github"
              },
              "hash": "projectdiscovery/nuclei-templates#14297",
              "body": "\n### Description: \n> Solarwinds Dameware Mini Remote Client agent v12.1.0.89 contains a remote code execution caused by support for smart card authentication allowing upload and execution of arbitrary executables on the host, letting unauthenticated attackers execute code under the Local System account, exploit requires requesting smart card login.\n\n#### Severity: `Critical`\n\n#### POC: \n- https://www.tenable.com/security/research/tra-227-43\n- https://github.com/CyberQuestor-infosec/CVE-2019-3980-Open_Net_Admin_v18.1.1_RCE\n- https///github.com:CyberQuestor-infosec/CVE-2019-3980-Open_Net_Admin_v18.1.1_RCE.git\n- https://github.com/Barbarisch/CVE-2019-3980\n- https://vulncheck.com/xdb/b2d525559d87\n- https///github.com:Barbarisch/CVE-2019-3980.git\n- https://github.com/warferik/CVE-2019-3980\n\n### KEV: True\n\n### Shodan Query: `NA`\n\n> Acceptance Criteria: The template must include a complete POC and should not rely solely on version-based detection. Contributors are required to provide debug data(`-debug`) along with the template to help the triage team with validation or can also share a vulnerable environment like docker file. \n\n> Rewards will only be given once the template is fully validated by the team. Templates that are incomplete or invalid will not be accepted. Avoid adding code templates for CVEs that can be achieved using HTTP, TCP, or JavaScript. Such templates are blocked by default and wonâ€™t produce results, so we prioritize creating templates with other protocols unless exceptions are made.\n\nYou can check the FAQ for the Nuclei Templates Community Rewards Program [here](https://github.com/projectdiscovery/nuclei-templates/blob/main/Community-Rewards-FAQ.md).\n",
              "url": "https://github.com/projectdiscovery/nuclei-templates/issues/14297",
              "tech": [],
              "repo_name": "nuclei-templates",
              "repo_owner": "projectdiscovery",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "projectdiscovery#14278",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "projectdiscovery",
              "id": "generated-projectdiscovery",
              "name": "Projectdiscovery",
              "description": "",
              "members": [],
              "display_name": "Projectdiscovery",
              "created_at": "2026-01-19T14:47:55.805Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/projectdiscovery?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "projectdiscovery",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-19T14:47:55.805Z",
            "created_at": "2026-01-19T14:47:55.805Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-projectdiscovery#14278",
              "status": "open",
              "type": "issue",
              "number": 14278,
              "title": "CVE-2019-18935 - Progress Telerik UI for ASP.NET AJAX - Insecure Deserialization ðŸ’°",
              "source": {
                "data": {
                  "id": "source-projectdiscovery#14278",
                  "user": {
                    "login": "princechaddha",
                    "id": 16654365,
                    "node_id": "MDQ6VXNlcjE2NjU0MzY1",
                    "avatar_url": "https://avatars.githubusercontent.com/u/16654365?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/princechaddha",
                    "html_url": "https://github.com/princechaddha",
                    "followers_url": "https://api.github.com/users/princechaddha/followers",
                    "following_url": "https://api.github.com/users/princechaddha/following{/other_user}",
                    "gists_url": "https://api.github.com/users/princechaddha/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/princechaddha/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/princechaddha/subscriptions",
                    "organizations_url": "https://api.github.com/users/princechaddha/orgs",
                    "repos_url": "https://api.github.com/users/princechaddha/repos",
                    "events_url": "https://api.github.com/users/princechaddha/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/princechaddha/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "CVE-2019-18935 - Progress Telerik UI for ASP.NET AJAX - Insecure Deserialization ðŸ’°",
                  "body": "\n### Description: \n> Progress Telerik UI for ASP.NET AJAX <= 2019.3.1023 contains a .NET deserialization caused by insecure RadAsyncUpload function, letting attackers with known encryption keys execute remote code, exploit requires known encryption keys or specific settings.\n\n#### Severity: `Critical`\n\n#### POC: \n- http://packetstormsecurity.com/files/159653/Telerik-UI-ASP.NET-AJAX-RadAsyncUpload-Deserialization.html\n- https://github.com/bao7uo/RAU_crypto\n- https://github.com/noperator/CVE-2019-18935\n- https://know.bishopfox.com/research/cve-2019-18935-remote-code-execution-in-telerik-ui\n- https://github.com/rapid7/metasploit-framework/blob/master/modules/exploits/windows/http/telerik_rau_deserialization.rb\n- https://github.com/menashe12346/CVE-2019-18935\n- https///github.com:menashe12346/CVE-2019-18935.git\n- https://github.com/quyt0/CVE-2019-18935-exploit-study\n- https///github.com:quyt0/CVE-2019-18935-exploit-study.git\n- https///github.com:hnytgl/TelerikUI-RCE.git\n- https://github.com/0xsharz/telerik-scanner-CVE-2019-18935\n- https://github.com/ekkoo-z/CVE-2019-18935-bypasswaf\n- https///github.com:ekkoo-z/CVE-2019-18935-bypasswaf.git\n- https://vulncheck.com/xdb/c621c71a9bf3\n- https://github.com/clarkvoss/telerik\n- https///github.com:clarkvoss/telerik.git\n- https://github.com/dust-life/CVE-2019-18935-memShell\n- https://github.com/KasunPriyashan/Telerik-UI-ASP.NET-AJAX-Exploitation\n- https://vulncheck.com/xdb/dffdf06b5f8a\n- https://github.com/0xAgun/CVE-2019-18935-checker\n- https///github.com:0xAgun/CVE-2019-18935-checker.git\n- https://github.com/random-robbie/CVE-2019-18935\n- https://vulncheck.com/xdb/dd4d5145d7fd\n- https://github.com/appliedi/Telerik_CVE-2019-18935\n- https///github.com:appliedi/Telerik_CVE-2019-18935.git\n- https://vulncheck.com/xdb/8dc793fec147\n- https://github.com/murataydemir/CVE-2019-18935\n- https///github.com:murataydemir/CVE-2019-18935.git\n- https://vulncheck.com/xdb/569e3fec38c8\n- https://github.com/ThanHuuTuan/CVE_2019_18935\n- https///github.com:ThanHuuTuan/CVE_2019_18935.git\n- https://vulncheck.com/xdb/48d2eb3dee46\n- https://github.com/ThanHuuTuan/Telerik_CVE-2019-18935\n- https///github.com:ThanHuuTuan/Telerik_CVE-2019-18935.git\n- https://vulncheck.com/xdb/6733f1b67fb2\n- https://github.com/becrevex/Telerik_CVE-2019-18935\n- https///github.com:becrevex/Telerik_CVE-2019-18935.git\n- https://vulncheck.com/xdb/de3ebe4e8ea8\n- https///github.com:noperator/CVE-2019-18935.git\n\n### KEV: True\n\n### Shodan Query: `NA`\n\n> Acceptance Criteria: The template must include a complete POC and should not rely solely on version-based detection. Contributors are required to provide debug data(`-debug`) along with the template to help the triage team with validation or can also share a vulnerable environment like docker file. \n\n> Rewards will only be given once the template is fully validated by the team. Templates that are incomplete or invalid will not be accepted. Avoid adding code templates for CVEs that can be achieved using HTTP, TCP, or JavaScript. Such templates are blocked by default and wonâ€™t produce results, so we prioritize creating templates with other protocols unless exceptions are made.\n\nYou can check the FAQ for the Nuclei Templates Community Rewards Program [here](https://github.com/projectdiscovery/nuclei-templates/blob/main/Community-Rewards-FAQ.md).\n",
                  "html_url": "https://github.com/projectdiscovery/nuclei-templates/issues/14278"
                },
                "type": "github"
              },
              "hash": "projectdiscovery/nuclei-templates#14278",
              "body": "\n### Description: \n> Progress Telerik UI for ASP.NET AJAX <= 2019.3.1023 contains a .NET deserialization caused by insecure RadAsyncUpload function, letting attackers with known encryption keys execute remote code, exploit requires known encryption keys or specific settings.\n\n#### Severity: `Critical`\n\n#### POC: \n- http://packetstormsecurity.com/files/159653/Telerik-UI-ASP.NET-AJAX-RadAsyncUpload-Deserialization.html\n- https://github.com/bao7uo/RAU_crypto\n- https://github.com/noperator/CVE-2019-18935\n- https://know.bishopfox.com/research/cve-2019-18935-remote-code-execution-in-telerik-ui\n- https://github.com/rapid7/metasploit-framework/blob/master/modules/exploits/windows/http/telerik_rau_deserialization.rb\n- https://github.com/menashe12346/CVE-2019-18935\n- https///github.com:menashe12346/CVE-2019-18935.git\n- https://github.com/quyt0/CVE-2019-18935-exploit-study\n- https///github.com:quyt0/CVE-2019-18935-exploit-study.git\n- https///github.com:hnytgl/TelerikUI-RCE.git\n- https://github.com/0xsharz/telerik-scanner-CVE-2019-18935\n- https://github.com/ekkoo-z/CVE-2019-18935-bypasswaf\n- https///github.com:ekkoo-z/CVE-2019-18935-bypasswaf.git\n- https://vulncheck.com/xdb/c621c71a9bf3\n- https://github.com/clarkvoss/telerik\n- https///github.com:clarkvoss/telerik.git\n- https://github.com/dust-life/CVE-2019-18935-memShell\n- https://github.com/KasunPriyashan/Telerik-UI-ASP.NET-AJAX-Exploitation\n- https://vulncheck.com/xdb/dffdf06b5f8a\n- https://github.com/0xAgun/CVE-2019-18935-checker\n- https///github.com:0xAgun/CVE-2019-18935-checker.git\n- https://github.com/random-robbie/CVE-2019-18935\n- https://vulncheck.com/xdb/dd4d5145d7fd\n- https://github.com/appliedi/Telerik_CVE-2019-18935\n- https///github.com:appliedi/Telerik_CVE-2019-18935.git\n- https://vulncheck.com/xdb/8dc793fec147\n- https://github.com/murataydemir/CVE-2019-18935\n- https///github.com:murataydemir/CVE-2019-18935.git\n- https://vulncheck.com/xdb/569e3fec38c8\n- https://github.com/ThanHuuTuan/CVE_2019_18935\n- https///github.com:ThanHuuTuan/CVE_2019_18935.git\n- https://vulncheck.com/xdb/48d2eb3dee46\n- https://github.com/ThanHuuTuan/Telerik_CVE-2019-18935\n- https///github.com:ThanHuuTuan/Telerik_CVE-2019-18935.git\n- https://vulncheck.com/xdb/6733f1b67fb2\n- https://github.com/becrevex/Telerik_CVE-2019-18935\n- https///github.com:becrevex/Telerik_CVE-2019-18935.git\n- https://vulncheck.com/xdb/de3ebe4e8ea8\n- https///github.com:noperator/CVE-2019-18935.git\n\n### KEV: True\n\n### Shodan Query: `NA`\n\n> Acceptance Criteria: The template must include a complete POC and should not rely solely on version-based detection. Contributors are required to provide debug data(`-debug`) along with the template to help the triage team with validation or can also share a vulnerable environment like docker file. \n\n> Rewards will only be given once the template is fully validated by the team. Templates that are incomplete or invalid will not be accepted. Avoid adding code templates for CVEs that can be achieved using HTTP, TCP, or JavaScript. Such templates are blocked by default and wonâ€™t produce results, so we prioritize creating templates with other protocols unless exceptions are made.\n\nYou can check the FAQ for the Nuclei Templates Community Rewards Program [here](https://github.com/projectdiscovery/nuclei-templates/blob/main/Community-Rewards-FAQ.md).\n",
              "url": "https://github.com/projectdiscovery/nuclei-templates/issues/14278",
              "tech": [],
              "repo_name": "nuclei-templates",
              "repo_owner": "projectdiscovery",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "projectdiscovery#1471",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "projectdiscovery",
              "id": "generated-projectdiscovery",
              "name": "Projectdiscovery",
              "description": "",
              "members": [],
              "display_name": "Projectdiscovery",
              "created_at": "2026-01-19T14:48:00.138Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/projectdiscovery?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "projectdiscovery",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-19T14:48:00.138Z",
            "created_at": "2026-01-19T14:48:00.138Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-projectdiscovery#1471",
              "status": "open",
              "type": "issue",
              "number": 1471,
              "title": "release katana v1.3.0",
              "source": {
                "data": {
                  "id": "source-projectdiscovery#1471",
                  "user": {
                    "login": "dogancanbakir",
                    "id": 65292895,
                    "node_id": "MDQ6VXNlcjY1MjkyODk1",
                    "avatar_url": "https://avatars.githubusercontent.com/u/65292895?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/dogancanbakir",
                    "html_url": "https://github.com/dogancanbakir",
                    "followers_url": "https://api.github.com/users/dogancanbakir/followers",
                    "following_url": "https://api.github.com/users/dogancanbakir/following{/other_user}",
                    "gists_url": "https://api.github.com/users/dogancanbakir/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/dogancanbakir/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/dogancanbakir/subscriptions",
                    "organizations_url": "https://api.github.com/users/dogancanbakir/orgs",
                    "repos_url": "https://api.github.com/users/dogancanbakir/repos",
                    "events_url": "https://api.github.com/users/dogancanbakir/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/dogancanbakir/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "release katana v1.3.0",
                  "body": "https://github.com/projectdiscovery/nuclei-templates/issues/14278 https://github.com/projectdiscovery/nuclei-templates/pull/14290 https://github.com/projectdiscovery/nuclei-templates/pull/14554 https:",
                  "html_url": "https://github.com/projectdiscovery/katana/issues/1471"
                },
                "type": "github"
              },
              "hash": "projectdiscovery/katana#1471",
              "body": "https://github.com/projectdiscovery/nuclei-templates/issues/14278 https://github.com/projectdiscovery/nuclei-templates/pull/14290 https://github.com/projectdiscovery/nuclei-templates/pull/14554 https:",
              "url": "https://github.com/projectdiscovery/katana/issues/1471",
              "tech": [],
              "repo_name": "katana",
              "repo_owner": "projectdiscovery",
              "forge": "github"
            },
            "timeouts_disabled": false
          }
        ],
        "next_cursor": null
      }
    }
  }
}