{
  "result": {
    "data": {
      "json": {
        "items": [
          {
            "id": "permitio#716",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "permitio",
              "id": "generated-permitio",
              "name": "Permitio",
              "description": "",
              "members": [],
              "display_name": "Permitio",
              "created_at": "2026-01-30T03:41:22.094Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/permitio?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "permitio",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-30T03:41:22.095Z",
            "created_at": "2026-01-30T03:41:22.095Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-permitio#716",
              "status": "open",
              "type": "issue",
              "number": 716,
              "title": "Error resolving broadcast hostname being swallowed",
              "source": {
                "data": {
                  "id": "source-permitio#716",
                  "user": {
                    "login": "keyz182",
                    "id": 693408,
                    "node_id": "MDQ6VXNlcjY5MzQwOA==",
                    "avatar_url": "https://avatars.githubusercontent.com/u/693408?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/keyz182",
                    "html_url": "https://github.com/keyz182",
                    "followers_url": "https://api.github.com/users/keyz182/followers",
                    "following_url": "https://api.github.com/users/keyz182/following{/other_user}",
                    "gists_url": "https://api.github.com/users/keyz182/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/keyz182/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/keyz182/subscriptions",
                    "organizations_url": "https://api.github.com/users/keyz182/orgs",
                    "repos_url": "https://api.github.com/users/keyz182/repos",
                    "events_url": "https://api.github.com/users/keyz182/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/keyz182/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Error resolving broadcast hostname being swallowed",
                  "body": "**Describe the bug**\r\n\r\nWe had a deployment of opal-server that we'd typoed the broadcast URI. We were seeing websockets disconnect errors in the clients, but no errors server side, so no clues it was the broadcast URI. \r\n\r\nAfter turning debug logging on for the server, I spotted the following output:\r\n\r\n```\r\n2024-12-04T15:27:01.018085+0000| fastapi_websocket_rpc.websocket_rpc_e...| INFO  | Client connected\r\n2024-12-04T15:27:01.018500+0000| websockets.legacy.server                | INFO  | connection open\r\n2024-12-04T15:27:01.022749+0000| fastapi_websocket_rpc.rpc_channel       |DEBUG  | Handling RPC request - {'request': RpcRequest(method='_ping_', arguments={}, call_id='5d8d421e3dc94751a035b202644c8e8a'), 'channel': '72c2a547ffc64741bd095079bc778d7d'}\r\n2024-12-04T15:27:01.023420+0000| fastapi_websocket_pubsub.pub_sub_server |DEBUG  | task is done: {<Task finished name='Task-3053' coro=<EventBroadcaster.__read_notifications__() done, defined at /usr/local/lib/python3.10/site-packages/fastapi_websocket_pubsub/event_broadcaster.py:245> exception=gaierror(-2, 'Name or service not known')>}\r\n2024-12-04T15:27:01.023565+0000| fastapi_websocket_pubsub.event_broadc...| INFO  | Cancelling broadcast listen task\r\n2024-12-04T15:27:01.023677+0000| fastapi_websocket_pubsub.event_broadc...|DEBUG  | Unsubscribing from ALL TOPICS\r\n2024-12-04T15:27:01.023790+0000| fastapi_websocket_pubsub.event_notifier |DEBUG  | Removing Subscription of topic='__EventNotifier_ALL_TOPICS__' for subscriber=cc43be7c3ebb41e1b4869ace10d213db\r\n2024-12-04T15:27:01.023948+0000| fastapi_websocket_rpc.websocket_rpc_e...| INFO  | Client connection failed - 42723 :: 72c2a547ffc64741bd095079bc778d7d\r\n2024-12-04T15:27:01.024165+0000| fastapi_websocket_pubsub.pub_sub_server |DEBUG  | Leaving endpoint's main loop\r\n2024-12-04T15:27:01.026785+0000| websockets.legacy.server                | INFO  | connection closed\r\n```\r\n\r\nBased on the 4th line, I went to look at `fastapi_websocket_pubsub/event_broadcaster.py:245` and saw it was referencing the broadcast URI, at which point I double checked ours and saw the typo. \r\n\r\nWhat I believe to be a bug is that the error is being swallowed, and should probably be elevated to an `ERROR` level log for visibility.\r\n\r\n**To Reproduce**\r\nSet the broadcast URI to an invalid value - in our case, a postgres URI with a hostname that didn't resolve.\r\n\r\nLogs: [se616-opal-opal-server-545c454db-hx2nc.log](https://github.com/user-attachments/files/18010731/se616-opal-opal-server-545c454db-hx2nc.log)\r\n\r\n**Expected behavior**\r\nA clear error level log to indicate that the broadcast URI could not be resolved\r\n\r\n**OPAL version**\r\n - Version: Client - 0.7.15, Server - 0.7.8\r\n",
                  "html_url": "https://github.com/permitio/opal/issues/716"
                },
                "type": "github"
              },
              "hash": "permitio/opal#716",
              "body": "**Describe the bug**\r\n\r\nWe had a deployment of opal-server that we'd typoed the broadcast URI. We were seeing websockets disconnect errors in the clients, but no errors server side, so no clues it was the broadcast URI. \r\n\r\nAfter turning debug logging on for the server, I spotted the following output:\r\n\r\n```\r\n2024-12-04T15:27:01.018085+0000| fastapi_websocket_rpc.websocket_rpc_e...| INFO  | Client connected\r\n2024-12-04T15:27:01.018500+0000| websockets.legacy.server                | INFO  | connection open\r\n2024-12-04T15:27:01.022749+0000| fastapi_websocket_rpc.rpc_channel       |DEBUG  | Handling RPC request - {'request': RpcRequest(method='_ping_', arguments={}, call_id='5d8d421e3dc94751a035b202644c8e8a'), 'channel': '72c2a547ffc64741bd095079bc778d7d'}\r\n2024-12-04T15:27:01.023420+0000| fastapi_websocket_pubsub.pub_sub_server |DEBUG  | task is done: {<Task finished name='Task-3053' coro=<EventBroadcaster.__read_notifications__() done, defined at /usr/local/lib/python3.10/site-packages/fastapi_websocket_pubsub/event_broadcaster.py:245> exception=gaierror(-2, 'Name or service not known')>}\r\n2024-12-04T15:27:01.023565+0000| fastapi_websocket_pubsub.event_broadc...| INFO  | Cancelling broadcast listen task\r\n2024-12-04T15:27:01.023677+0000| fastapi_websocket_pubsub.event_broadc...|DEBUG  | Unsubscribing from ALL TOPICS\r\n2024-12-04T15:27:01.023790+0000| fastapi_websocket_pubsub.event_notifier |DEBUG  | Removing Subscription of topic='__EventNotifier_ALL_TOPICS__' for subscriber=cc43be7c3ebb41e1b4869ace10d213db\r\n2024-12-04T15:27:01.023948+0000| fastapi_websocket_rpc.websocket_rpc_e...| INFO  | Client connection failed - 42723 :: 72c2a547ffc64741bd095079bc778d7d\r\n2024-12-04T15:27:01.024165+0000| fastapi_websocket_pubsub.pub_sub_server |DEBUG  | Leaving endpoint's main loop\r\n2024-12-04T15:27:01.026785+0000| websockets.legacy.server                | INFO  | connection closed\r\n```\r\n\r\nBased on the 4th line, I went to look at `fastapi_websocket_pubsub/event_broadcaster.py:245` and saw it was referencing the broadcast URI, at which point I double checked ours and saw the typo. \r\n\r\nWhat I believe to be a bug is that the error is being swallowed, and should probably be elevated to an `ERROR` level log for visibility.\r\n\r\n**To Reproduce**\r\nSet the broadcast URI to an invalid value - in our case, a postgres URI with a hostname that didn't resolve.\r\n\r\nLogs: [se616-opal-opal-server-545c454db-hx2nc.log](https://github.com/user-attachments/files/18010731/se616-opal-opal-server-545c454db-hx2nc.log)\r\n\r\n**Expected behavior**\r\nA clear error level log to indicate that the broadcast URI could not be resolved\r\n\r\n**OPAL version**\r\n - Version: Client - 0.7.15, Server - 0.7.8\r\n",
              "url": "https://github.com/permitio/opal/issues/716",
              "tech": [],
              "repo_name": "opal",
              "repo_owner": "permitio",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "permitio#677",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "permitio",
              "id": "generated-permitio",
              "name": "Permitio",
              "description": "",
              "members": [],
              "display_name": "Permitio",
              "created_at": "2026-01-30T03:41:22.353Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/permitio?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "permitio",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-30T03:41:22.353Z",
            "created_at": "2026-01-30T03:41:22.353Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-permitio#677",
              "status": "open",
              "type": "issue",
              "number": 677,
              "title": "Create E2E tests framework using PyTest",
              "source": {
                "data": {
                  "id": "source-permitio#677",
                  "user": {
                    "login": "danyi1212",
                    "id": 12188774,
                    "node_id": "MDQ6VXNlcjEyMTg4Nzc0",
                    "avatar_url": "https://avatars.githubusercontent.com/u/12188774?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/danyi1212",
                    "html_url": "https://github.com/danyi1212",
                    "followers_url": "https://api.github.com/users/danyi1212/followers",
                    "following_url": "https://api.github.com/users/danyi1212/following{/other_user}",
                    "gists_url": "https://api.github.com/users/danyi1212/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/danyi1212/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/danyi1212/subscriptions",
                    "organizations_url": "https://api.github.com/users/danyi1212/orgs",
                    "repos_url": "https://api.github.com/users/danyi1212/repos",
                    "events_url": "https://api.github.com/users/danyi1212/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/danyi1212/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Create E2E tests framework using PyTest",
                  "body": "We want to create a new baseline framework for writing E2E tests for OPAL Client and Server using PyTest\r\n\r\nThe test framework should do the following tasks on its baseline/initial run:\r\n* Run an OPAL Server and Client inside Docker\r\n* Initially test for health check responsivity\r\n* Check logs for errors and critical alerts\r\n* Check the client and server are connected using the [Statistics API](https://opal-v2.permit.io/redoc#tag/Server-Statistics/operation/get_statistics_statistics_get)\r\n\r\nThe acceptance criteria for this issue is the ability to run a single test command that will be based on the framework specified above and run a very basic assertion test on OPAL",
                  "html_url": "https://github.com/permitio/opal/issues/677"
                },
                "type": "github"
              },
              "hash": "permitio/opal#677",
              "body": "We want to create a new baseline framework for writing E2E tests for OPAL Client and Server using PyTest\r\n\r\nThe test framework should do the following tasks on its baseline/initial run:\r\n* Run an OPAL Server and Client inside Docker\r\n* Initially test for health check responsivity\r\n* Check logs for errors and critical alerts\r\n* Check the client and server are connected using the [Statistics API](https://opal-v2.permit.io/redoc#tag/Server-Statistics/operation/get_statistics_statistics_get)\r\n\r\nThe acceptance criteria for this issue is the ability to run a single test command that will be based on the framework specified above and run a very basic assertion test on OPAL",
              "url": "https://github.com/permitio/opal/issues/677",
              "tech": [],
              "repo_name": "opal",
              "repo_owner": "permitio",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "permitio#634",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "permitio",
              "id": "generated-permitio",
              "name": "Permitio",
              "description": "",
              "members": [],
              "display_name": "Permitio",
              "created_at": "2026-01-30T03:41:22.649Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/permitio?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "permitio",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-30T03:41:22.649Z",
            "created_at": "2026-01-30T03:41:22.649Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-permitio#634",
              "status": "open",
              "type": "issue",
              "number": 634,
              "title": "OPAL Server doesn't clean up symbolic links when github is down",
              "source": {
                "data": {
                  "id": "source-permitio#634",
                  "user": {
                    "login": "kreyyser",
                    "id": 8156669,
                    "node_id": "MDQ6VXNlcjgxNTY2Njk=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/8156669?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/kreyyser",
                    "html_url": "https://github.com/kreyyser",
                    "followers_url": "https://api.github.com/users/kreyyser/followers",
                    "following_url": "https://api.github.com/users/kreyyser/following{/other_user}",
                    "gists_url": "https://api.github.com/users/kreyyser/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/kreyyser/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/kreyyser/subscriptions",
                    "organizations_url": "https://api.github.com/users/kreyyser/orgs",
                    "repos_url": "https://api.github.com/users/kreyyser/repos",
                    "events_url": "https://api.github.com/users/kreyyser/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/kreyyser/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "OPAL Server doesn't clean up symbolic links when github is down",
                  "body": "When opal server has github policies setup and github is down for some time opal server seems like spawn zombie processes but apparently looks like it is just a list of symbolic links that are not cleaned up.\r\n\r\n**To Reproduce**\r\nrun OPAL with github policies source as a container\r\nmake somehow github return 500\r\nlist processes in opal server container\r\n\r\n**Expected behavior**\r\nNo zombie processes or broken links proc directory\r\n\r\n**Screenshots**\r\n<img width=\"1329\" alt=\"opal-server-proc\" src=\"https://github.com/user-attachments/assets/9f4fa8a5-9867-45d2-a21d-2a7c133ac9c1\">\r\n\r\n**OPAL version**\r\n - Version: 0.7.6\r\n",
                  "html_url": "https://github.com/permitio/opal/issues/634"
                },
                "type": "github"
              },
              "hash": "permitio/opal#634",
              "body": "When opal server has github policies setup and github is down for some time opal server seems like spawn zombie processes but apparently looks like it is just a list of symbolic links that are not cleaned up.\r\n\r\n**To Reproduce**\r\nrun OPAL with github policies source as a container\r\nmake somehow github return 500\r\nlist processes in opal server container\r\n\r\n**Expected behavior**\r\nNo zombie processes or broken links proc directory\r\n\r\n**Screenshots**\r\n<img width=\"1329\" alt=\"opal-server-proc\" src=\"https://github.com/user-attachments/assets/9f4fa8a5-9867-45d2-a21d-2a7c133ac9c1\">\r\n\r\n**OPAL version**\r\n - Version: 0.7.6\r\n",
              "url": "https://github.com/permitio/opal/issues/634",
              "tech": [],
              "repo_name": "opal",
              "repo_owner": "permitio",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "cal#18947",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "cal",
              "id": "generated-cal",
              "name": "Cal",
              "description": "",
              "members": [],
              "display_name": "Cal",
              "created_at": "2026-01-30T03:42:09.779Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/cal?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "calcom",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-30T03:42:09.779Z",
            "created_at": "2026-01-30T03:42:09.779Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-cal#18947",
              "status": "open",
              "type": "issue",
              "number": 18947,
              "title": "[CAL-5091] additional settings: \"add team member as optional guest",
              "source": {
                "data": {
                  "id": "source-cal#18947",
                  "user": {
                    "login": "PeerRich",
                    "id": 8019099,
                    "node_id": "MDQ6VXNlcjgwMTkwOTk=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/8019099?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/PeerRich",
                    "html_url": "https://github.com/PeerRich",
                    "followers_url": "https://api.github.com/users/PeerRich/followers",
                    "following_url": "https://api.github.com/users/PeerRich/following{/other_user}",
                    "gists_url": "https://api.github.com/users/PeerRich/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/PeerRich/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/PeerRich/subscriptions",
                    "organizations_url": "https://api.github.com/users/PeerRich/orgs",
                    "repos_url": "https://api.github.com/users/PeerRich/repos",
                    "events_url": "https://api.github.com/users/PeerRich/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/PeerRich/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "[CAL-5091] additional settings: \"add team member as optional guest",
                  "body": "![Image](https://github.com/user-attachments/assets/305d292b-a984-44c0-b89f-f8ed979d4c71)\n\n1. team members only (to protect spam) and show `<UpgradeTeamsBadge />`\n2.  don't check the team members calendar for conflict checking, only invite them\n3. if possible mark them as \"optional\":\n\n![Image](https://github.com/user-attachments/assets/7d2a1ec0-6c68-4334-a5ea-a1137279b98f)\n\n<sub>[CAL-5091](https://linear.app/calcom/issue/CAL-5091/additional-settings-add-team-member-as-optional-guest)</sub>",
                  "html_url": "https://github.com/calcom/cal.com/issues/18947"
                },
                "type": "github"
              },
              "hash": "calcom/cal.com#18947",
              "body": "![Image](https://github.com/user-attachments/assets/305d292b-a984-44c0-b89f-f8ed979d4c71)\n\n1. team members only (to protect spam) and show `<UpgradeTeamsBadge />`\n2.  don't check the team members calendar for conflict checking, only invite them\n3. if possible mark them as \"optional\":\n\n![Image](https://github.com/user-attachments/assets/7d2a1ec0-6c68-4334-a5ea-a1137279b98f)\n\n<sub>[CAL-5091](https://linear.app/calcom/issue/CAL-5091/additional-settings-add-team-member-as-optional-guest)</sub>",
              "url": "https://github.com/calcom/cal.com/issues/18947",
              "tech": [],
              "repo_name": "cal.com",
              "repo_owner": "calcom",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "cal#18992",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "cal",
              "id": "generated-cal",
              "name": "Cal",
              "description": "",
              "members": [],
              "display_name": "Cal",
              "created_at": "2026-01-30T03:42:09.967Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/cal?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "calcom",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-30T03:42:09.967Z",
            "created_at": "2026-01-30T03:42:09.967Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-cal#18992",
              "status": "open",
              "type": "issue",
              "number": 18992,
              "title": "[CAL-5107] add no-show to zapier (its a webhook only right now)",
              "source": {
                "data": {
                  "id": "source-cal#18992",
                  "user": {
                    "login": "PeerRich",
                    "id": 8019099,
                    "node_id": "MDQ6VXNlcjgwMTkwOTk=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/8019099?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/PeerRich",
                    "html_url": "https://github.com/PeerRich",
                    "followers_url": "https://api.github.com/users/PeerRich/followers",
                    "following_url": "https://api.github.com/users/PeerRich/following{/other_user}",
                    "gists_url": "https://api.github.com/users/PeerRich/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/PeerRich/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/PeerRich/subscriptions",
                    "organizations_url": "https://api.github.com/users/PeerRich/orgs",
                    "repos_url": "https://api.github.com/users/PeerRich/repos",
                    "events_url": "https://api.github.com/users/PeerRich/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/PeerRich/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "[CAL-5107] add no-show to zapier (its a webhook only right now)",
                  "body": "![Image](https://github.com/user-attachments/assets/d1992193-e964-4382-aff1-ba90d29c0562)\n\n<sub>[CAL-5107](https://linear.app/calcom/issue/CAL-5107/add-no-show-to-zapier-its-a-webhook-only-right-now)</sub>",
                  "html_url": "https://github.com/calcom/cal.com/issues/18992"
                },
                "type": "github"
              },
              "hash": "calcom/cal.com#18992",
              "body": "![Image](https://github.com/user-attachments/assets/d1992193-e964-4382-aff1-ba90d29c0562)\n\n<sub>[CAL-5107](https://linear.app/calcom/issue/CAL-5107/add-no-show-to-zapier-its-a-webhook-only-right-now)</sub>",
              "url": "https://github.com/calcom/cal.com/issues/18992",
              "tech": [],
              "repo_name": "cal.com",
              "repo_owner": "calcom",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "cal#18987",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "cal",
              "id": "generated-cal",
              "name": "Cal",
              "description": "",
              "members": [],
              "display_name": "Cal",
              "created_at": "2026-01-30T03:42:10.174Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/cal?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "calcom",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-30T03:42:10.174Z",
            "created_at": "2026-01-30T03:42:10.174Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-cal#18987",
              "status": "open",
              "type": "issue",
              "number": 18987,
              "title": "[CAL-5097] add the same \"booking questions\" to routing forms",
              "source": {
                "data": {
                  "id": "source-cal#18987",
                  "user": {
                    "login": "PeerRich",
                    "id": 8019099,
                    "node_id": "MDQ6VXNlcjgwMTkwOTk=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/8019099?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/PeerRich",
                    "html_url": "https://github.com/PeerRich",
                    "followers_url": "https://api.github.com/users/PeerRich/followers",
                    "following_url": "https://api.github.com/users/PeerRich/following{/other_user}",
                    "gists_url": "https://api.github.com/users/PeerRich/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/PeerRich/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/PeerRich/subscriptions",
                    "organizations_url": "https://api.github.com/users/PeerRich/orgs",
                    "repos_url": "https://api.github.com/users/PeerRich/repos",
                    "events_url": "https://api.github.com/users/PeerRich/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/PeerRich/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "[CAL-5097] add the same \"booking questions\" to routing forms",
                  "body": "right now \"booking forms\" for event-types have more (and different) inputs that routing forms:\n\n\nevent-types:\n\nhttps://github.com/user-attachments/assets/29c921ea-8677-4238-a198-55be00ce8188\n\nrouting forms:\n\nhttps://github.com/user-attachments/assets/cdaf70e0-7c5b-416b-a984-a57ded4c8525\n\n\nwe should reuse the entire event-type booking question UI inside routing forms.\n\n\nwe should also ask for the identifier **first** and not prefill it. (see event-types)\n\n<sub>[CAL-5097](https://linear.app/calcom/issue/CAL-5097/add-the-same-booking-questions-to-routing-forms)</sub>",
                  "html_url": "https://github.com/calcom/cal.com/issues/18987"
                },
                "type": "github"
              },
              "hash": "calcom/cal.com#18987",
              "body": "right now \"booking forms\" for event-types have more (and different) inputs that routing forms:\n\n\nevent-types:\n\nhttps://github.com/user-attachments/assets/29c921ea-8677-4238-a198-55be00ce8188\n\nrouting forms:\n\nhttps://github.com/user-attachments/assets/cdaf70e0-7c5b-416b-a984-a57ded4c8525\n\n\nwe should reuse the entire event-type booking question UI inside routing forms.\n\n\nwe should also ask for the identifier **first** and not prefill it. (see event-types)\n\n<sub>[CAL-5097](https://linear.app/calcom/issue/CAL-5097/add-the-same-booking-questions-to-routing-forms)</sub>",
              "url": "https://github.com/calcom/cal.com/issues/18987",
              "tech": [],
              "repo_name": "cal.com",
              "repo_owner": "calcom",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "cal#8123",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "cal",
              "id": "generated-cal",
              "name": "Cal",
              "description": "",
              "members": [],
              "display_name": "Cal",
              "created_at": "2026-01-30T03:42:10.422Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/cal?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "calcom",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-30T03:42:10.422Z",
            "created_at": "2026-01-30T03:42:10.422Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-cal#8123",
              "status": "open",
              "type": "issue",
              "number": 8123,
              "title": "[CAL-1425] Exchange on Premise 2016",
              "source": {
                "data": {
                  "id": "source-cal#8123",
                  "user": {
                    "login": "PeerRich",
                    "id": 8019099,
                    "node_id": "MDQ6VXNlcjgwMTkwOTk=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/8019099?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/PeerRich",
                    "html_url": "https://github.com/PeerRich",
                    "followers_url": "https://api.github.com/users/PeerRich/followers",
                    "following_url": "https://api.github.com/users/PeerRich/following{/other_user}",
                    "gists_url": "https://api.github.com/users/PeerRich/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/PeerRich/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/PeerRich/subscriptions",
                    "organizations_url": "https://api.github.com/users/PeerRich/orgs",
                    "repos_url": "https://api.github.com/users/PeerRich/repos",
                    "events_url": "https://api.github.com/users/PeerRich/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/PeerRich/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "[CAL-1425] Exchange on Premise 2016",
                  "body": " > If I use Exchange 2016 i get the message \"cannot added\". and if i use standard Exchange as Option I get \"unauthorized\". but i checked that the EWS login works fine via URL\r\n\r\n\n\n<sub>[CAL-1425](https://linear.app/calcom/issue/CAL-1425/exchange-on-premise-2016)</sub>",
                  "html_url": "https://github.com/calcom/cal.com/issues/8123"
                },
                "type": "github"
              },
              "hash": "calcom/cal.com#8123",
              "body": " > If I use Exchange 2016 i get the message \"cannot added\". and if i use standard Exchange as Option I get \"unauthorized\". but i checked that the EWS login works fine via URL\r\n\r\n\n\n<sub>[CAL-1425](https://linear.app/calcom/issue/CAL-1425/exchange-on-premise-2016)</sub>",
              "url": "https://github.com/calcom/cal.com/issues/8123",
              "tech": [],
              "repo_name": "cal.com",
              "repo_owner": "calcom",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "cal#16378",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "cal",
              "id": "generated-cal",
              "name": "Cal",
              "description": "",
              "members": [],
              "display_name": "Cal",
              "created_at": "2026-01-30T03:42:10.714Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/cal?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "calcom",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-30T03:42:10.714Z",
            "created_at": "2026-01-30T03:42:10.714Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-cal#16378",
              "status": "open",
              "type": "issue",
              "number": 16378,
              "title": "[CAL-4531] Take into account guest's availability when rescheduling",
              "source": {
                "data": {
                  "id": "source-cal#16378",
                  "user": {
                    "login": "pumfleet",
                    "id": 25907159,
                    "node_id": "MDQ6VXNlcjI1OTA3MTU5",
                    "avatar_url": "https://avatars.githubusercontent.com/u/25907159?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/pumfleet",
                    "html_url": "https://github.com/pumfleet",
                    "followers_url": "https://api.github.com/users/pumfleet/followers",
                    "following_url": "https://api.github.com/users/pumfleet/following{/other_user}",
                    "gists_url": "https://api.github.com/users/pumfleet/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/pumfleet/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/pumfleet/subscriptions",
                    "organizations_url": "https://api.github.com/users/pumfleet/orgs",
                    "repos_url": "https://api.github.com/users/pumfleet/repos",
                    "events_url": "https://api.github.com/users/pumfleet/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/pumfleet/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "[CAL-4531] Take into account guest's availability when rescheduling",
                  "body": "If I (a Cal.com user) book another Cal.com user and they want to reschedule it on their end (instead of requesting me to reschedule), it doesn't take into account my availability and just lets them freely choose a time.\r\n\r\nThis is because the person who booked the meeting may or may not be a Cal.com user, hence we don't bother checking for their availability. But we do have the user's email, so we should look up the user and see if they're a Cal.com user, and then if so, retrieve the available times for them, and only display those when the host tries to reschedule\n\n<sub>[CAL-4531](https://linear.app/calcom/issue/CAL-4531/take-into-account-guests-availability-when-rescheduling)</sub>",
                  "html_url": "https://github.com/calcom/cal.com/issues/16378"
                },
                "type": "github"
              },
              "hash": "calcom/cal.com#16378",
              "body": "If I (a Cal.com user) book another Cal.com user and they want to reschedule it on their end (instead of requesting me to reschedule), it doesn't take into account my availability and just lets them freely choose a time.\r\n\r\nThis is because the person who booked the meeting may or may not be a Cal.com user, hence we don't bother checking for their availability. But we do have the user's email, so we should look up the user and see if they're a Cal.com user, and then if so, retrieve the available times for them, and only display those when the host tries to reschedule\n\n<sub>[CAL-4531](https://linear.app/calcom/issue/CAL-4531/take-into-account-guests-availability-when-rescheduling)</sub>",
              "url": "https://github.com/calcom/cal.com/issues/16378",
              "tech": [],
              "repo_name": "cal.com",
              "repo_owner": "calcom",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "cal#13532",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "cal",
              "id": "generated-cal",
              "name": "Cal",
              "description": "",
              "members": [],
              "display_name": "Cal",
              "created_at": "2026-01-30T03:42:10.938Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/cal?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "calcom",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-30T03:42:10.938Z",
            "created_at": "2026-01-30T03:42:10.938Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-cal#13532",
              "status": "open",
              "type": "issue",
              "number": 13532,
              "title": "[CAL-3076] allow emails and invite people to a team event-type directly from \"assignment\" if not in team yet",
              "source": {
                "data": {
                  "id": "source-cal#13532",
                  "user": {
                    "login": "PeerRich",
                    "id": 8019099,
                    "node_id": "MDQ6VXNlcjgwMTkwOTk=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/8019099?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/PeerRich",
                    "html_url": "https://github.com/PeerRich",
                    "followers_url": "https://api.github.com/users/PeerRich/followers",
                    "following_url": "https://api.github.com/users/PeerRich/following{/other_user}",
                    "gists_url": "https://api.github.com/users/PeerRich/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/PeerRich/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/PeerRich/subscriptions",
                    "organizations_url": "https://api.github.com/users/PeerRich/orgs",
                    "repos_url": "https://api.github.com/users/PeerRich/repos",
                    "events_url": "https://api.github.com/users/PeerRich/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/PeerRich/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "[CAL-3076] allow emails and invite people to a team event-type directly from \"assignment\" if not in team yet",
                  "body": "- [ ] allow emails in assignment\n- [ ] invite person if its not in the team yet (as Member)\n- [ ] allow multiple emails comma separated: [user1@example.com](mailto:user1@example.com), [user2@example.com](mailto:user2@example.com)\n\n![CleanShot 2024-02-05 at 10 17 08@2x](https://uploads.linear.app/e86bf957-d82f-465e-b205-135559f4b623/598b18ab-0aed-491d-90f4-cd2afa2f1bbb/24eba054-180f-45cf-b858-4764d896572f?signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJwYXRoIjoiL2U4NmJmOTU3LWQ4MmYtNDY1ZS1iMjA1LTEzNTU1OWY0YjYyMy81OThiMThhYi0wYWVkLTQ5MWQtOTBmNC1jZDJhZmEyZjFiYmIvMjRlYmEwNTQtMTgwZi00NWNmLWI4NTgtNDc2NGQ4OTY1NzJmIiwiaWF0IjoxNzA3MTI4MjY3LCJleHAiOjE3MDcyMTQ2Njd9.DQDBQ-o7r2wBUIvnU0ZH2MoSkKZMbzDB9cIHtLUvV4Q)\n\n<sub>From [SyncLinear.com](https://synclinear.com) | [CAL-3076](https://linear.app/calcom/issue/CAL-3076/allow-emails-and-invite-people-to-a-team-event-type-directly-from)</sub>",
                  "html_url": "https://github.com/calcom/cal.com/issues/13532"
                },
                "type": "github"
              },
              "hash": "calcom/cal.com#13532",
              "body": "- [ ] allow emails in assignment\n- [ ] invite person if its not in the team yet (as Member)\n- [ ] allow multiple emails comma separated: [user1@example.com](mailto:user1@example.com), [user2@example.com](mailto:user2@example.com)\n\n![CleanShot 2024-02-05 at 10 17 08@2x](https://uploads.linear.app/e86bf957-d82f-465e-b205-135559f4b623/598b18ab-0aed-491d-90f4-cd2afa2f1bbb/24eba054-180f-45cf-b858-4764d896572f?signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJwYXRoIjoiL2U4NmJmOTU3LWQ4MmYtNDY1ZS1iMjA1LTEzNTU1OWY0YjYyMy81OThiMThhYi0wYWVkLTQ5MWQtOTBmNC1jZDJhZmEyZjFiYmIvMjRlYmEwNTQtMTgwZi00NWNmLWI4NTgtNDc2NGQ4OTY1NzJmIiwiaWF0IjoxNzA3MTI4MjY3LCJleHAiOjE3MDcyMTQ2Njd9.DQDBQ-o7r2wBUIvnU0ZH2MoSkKZMbzDB9cIHtLUvV4Q)\n\n<sub>From [SyncLinear.com](https://synclinear.com) | [CAL-3076](https://linear.app/calcom/issue/CAL-3076/allow-emails-and-invite-people-to-a-team-event-type-directly-from)</sub>",
              "url": "https://github.com/calcom/cal.com/issues/13532",
              "tech": [],
              "repo_name": "cal.com",
              "repo_owner": "calcom",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "cal#11340",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "cal",
              "id": "generated-cal",
              "name": "Cal",
              "description": "",
              "members": [],
              "display_name": "Cal",
              "created_at": "2026-01-30T03:42:11.147Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/cal?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "calcom",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-30T03:42:11.147Z",
            "created_at": "2026-01-30T03:42:11.147Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-cal#11340",
              "status": "open",
              "type": "issue",
              "number": 11340,
              "title": "Add Lawpay as a payment option",
              "source": {
                "data": {
                  "id": "source-cal#11340",
                  "user": {
                    "login": "Kfelts",
                    "id": 51497445,
                    "node_id": "MDQ6VXNlcjUxNDk3NDQ1",
                    "avatar_url": "https://avatars.githubusercontent.com/u/51497445?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/Kfelts",
                    "html_url": "https://github.com/Kfelts",
                    "followers_url": "https://api.github.com/users/Kfelts/followers",
                    "following_url": "https://api.github.com/users/Kfelts/following{/other_user}",
                    "gists_url": "https://api.github.com/users/Kfelts/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/Kfelts/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/Kfelts/subscriptions",
                    "organizations_url": "https://api.github.com/users/Kfelts/orgs",
                    "repos_url": "https://api.github.com/users/Kfelts/repos",
                    "events_url": "https://api.github.com/users/Kfelts/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/Kfelts/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Add Lawpay as a payment option",
                  "body": "### Is your proposal related to a problem?\r\n\r\nMany attorneys use Lawpay as their payment processor because it automatically handles trust accounting and avoids comingling funds between operations and trust accounts. Stripe doesn't have that capability. I'd like to see Lawpay (Affinipay) offered as a gateway option since they have an open API and integrate easily with other scheduling programs.\r\n\r\n\r\n### Describe the solution you'd like\r\n\r\nThe ability to connect Cal.com to Lawpay as a payment processor for appointment bookings\r\n\r\n### Requirement/Document\r\n\r\n[Lawpay Integration Partners](https://www.lawpay.com/partners/integrated-partners/)\r\n[API Reference Documents](https://developers.affinipay.com/reference/api.html)\r\n\r\n",
                  "html_url": "https://github.com/calcom/cal.com/issues/11340"
                },
                "type": "github"
              },
              "hash": "calcom/cal.com#11340",
              "body": "### Is your proposal related to a problem?\r\n\r\nMany attorneys use Lawpay as their payment processor because it automatically handles trust accounting and avoids comingling funds between operations and trust accounts. Stripe doesn't have that capability. I'd like to see Lawpay (Affinipay) offered as a gateway option since they have an open API and integrate easily with other scheduling programs.\r\n\r\n\r\n### Describe the solution you'd like\r\n\r\nThe ability to connect Cal.com to Lawpay as a payment processor for appointment bookings\r\n\r\n### Requirement/Document\r\n\r\n[Lawpay Integration Partners](https://www.lawpay.com/partners/integrated-partners/)\r\n[API Reference Documents](https://developers.affinipay.com/reference/api.html)\r\n\r\n",
              "url": "https://github.com/calcom/cal.com/issues/11340",
              "tech": [],
              "repo_name": "cal.com",
              "repo_owner": "calcom",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "cal#2",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "cal",
              "id": "generated-cal",
              "name": "Cal",
              "description": "",
              "members": [],
              "display_name": "Cal",
              "created_at": "2026-01-30T03:42:11.438Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/cal?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "calcom",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-30T03:42:11.438Z",
            "created_at": "2026-01-30T03:42:11.438Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-cal#2",
              "status": "open",
              "type": "issue",
              "number": 2,
              "title": "Plans on weights?",
              "source": {
                "data": {
                  "id": "source-cal#2",
                  "user": {
                    "login": "TaigaYamada",
                    "id": 77144664,
                    "node_id": "MDQ6VXNlcjc3MTQ0NjY0",
                    "avatar_url": "https://avatars.githubusercontent.com/u/77144664?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/TaigaYamada",
                    "html_url": "https://github.com/TaigaYamada",
                    "followers_url": "https://api.github.com/users/TaigaYamada/followers",
                    "following_url": "https://api.github.com/users/TaigaYamada/following{/other_user}",
                    "gists_url": "https://api.github.com/users/TaigaYamada/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/TaigaYamada/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/TaigaYamada/subscriptions",
                    "organizations_url": "https://api.github.com/users/TaigaYamada/orgs",
                    "repos_url": "https://api.github.com/users/TaigaYamada/repos",
                    "events_url": "https://api.github.com/users/TaigaYamada/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/TaigaYamada/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Plans on weights?",
                  "body": "I absolutely love the font! Thank you for the amazing work.\n\nAre there any plans to introduce more weights to the font in the future?",
                  "html_url": "https://github.com/calcom/sans/issues/2"
                },
                "type": "github"
              },
              "hash": "calcom/font#2",
              "body": "I absolutely love the font! Thank you for the amazing work.\n\nAre there any plans to introduce more weights to the font in the future?",
              "url": "https://github.com/calcom/sans/issues/2",
              "tech": [],
              "repo_name": "font",
              "repo_owner": "calcom",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "cal#1985",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "cal",
              "id": "generated-cal",
              "name": "Cal",
              "description": "",
              "members": [],
              "display_name": "Cal",
              "created_at": "2026-01-30T03:42:11.739Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/cal?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "calcom",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-30T03:42:11.739Z",
            "created_at": "2026-01-30T03:42:11.739Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-cal#1985",
              "status": "open",
              "type": "issue",
              "number": 1985,
              "title": "[CAL-3105] BigBlueButton Integration",
              "source": {
                "data": {
                  "id": "source-cal#1985",
                  "user": {
                    "login": "philippdormann",
                    "id": 17651032,
                    "node_id": "MDQ6VXNlcjE3NjUxMDMy",
                    "avatar_url": "https://avatars.githubusercontent.com/u/17651032?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/philippdormann",
                    "html_url": "https://github.com/philippdormann",
                    "followers_url": "https://api.github.com/users/philippdormann/followers",
                    "following_url": "https://api.github.com/users/philippdormann/following{/other_user}",
                    "gists_url": "https://api.github.com/users/philippdormann/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/philippdormann/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/philippdormann/subscriptions",
                    "organizations_url": "https://api.github.com/users/philippdormann/orgs",
                    "repos_url": "https://api.github.com/users/philippdormann/repos",
                    "events_url": "https://api.github.com/users/philippdormann/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/philippdormann/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "[CAL-3105] BigBlueButton Integration",
                  "body": "### Is your proposal related to a problem?\r\n\r\nNo, this is a new feature request\r\n\r\n### Describe the solution you'd like\r\n\r\nApp Integration for [BigBlueButton](https://bigbluebutton.org/) using the [BigBlueButton API](https://docs.bigbluebutton.org/dev/api.html#create)\n\n<sub>[CAL-3105](https://linear.app/calcom/issue/CAL-3105/bigbluebutton-integration)</sub>",
                  "html_url": "https://github.com/calcom/cal.com/issues/1985"
                },
                "type": "github"
              },
              "hash": "calcom/cal.com#1985",
              "body": "### Is your proposal related to a problem?\r\n\r\nNo, this is a new feature request\r\n\r\n### Describe the solution you'd like\r\n\r\nApp Integration for [BigBlueButton](https://bigbluebutton.org/) using the [BigBlueButton API](https://docs.bigbluebutton.org/dev/api.html#create)\n\n<sub>[CAL-3105](https://linear.app/calcom/issue/CAL-3105/bigbluebutton-integration)</sub>",
              "url": "https://github.com/calcom/cal.com/issues/1985",
              "tech": [],
              "repo_name": "cal.com",
              "repo_owner": "calcom",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "cal#3717",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "cal",
              "id": "generated-cal",
              "name": "Cal",
              "description": "",
              "members": [],
              "display_name": "Cal",
              "created_at": "2026-01-30T03:42:11.971Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/cal?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "calcom",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-30T03:42:11.971Z",
            "created_at": "2026-01-30T03:42:11.971Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-cal#3717",
              "status": "open",
              "type": "issue",
              "number": 3717,
              "title": "[CAL-3414] App: Lever.co",
              "source": {
                "data": {
                  "id": "source-cal#3717",
                  "user": {
                    "login": "PeerRich",
                    "id": 8019099,
                    "node_id": "MDQ6VXNlcjgwMTkwOTk=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/8019099?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/PeerRich",
                    "html_url": "https://github.com/PeerRich",
                    "followers_url": "https://api.github.com/users/PeerRich/followers",
                    "following_url": "https://api.github.com/users/PeerRich/following{/other_user}",
                    "gists_url": "https://api.github.com/users/PeerRich/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/PeerRich/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/PeerRich/subscriptions",
                    "organizations_url": "https://api.github.com/users/PeerRich/orgs",
                    "repos_url": "https://api.github.com/users/PeerRich/repos",
                    "events_url": "https://api.github.com/users/PeerRich/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/PeerRich/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "[CAL-3414] App: Lever.co",
                  "body": "similar to Greenhouse\n\n<sub>[CAL-3414](https://linear.app/calcom/issue/CAL-3414/app-leverco)</sub>",
                  "html_url": "https://github.com/calcom/cal.com/issues/3717"
                },
                "type": "github"
              },
              "hash": "calcom/cal.com#3717",
              "body": "similar to Greenhouse\n\n<sub>[CAL-3414](https://linear.app/calcom/issue/CAL-3414/app-leverco)</sub>",
              "url": "https://github.com/calcom/cal.com/issues/3717",
              "tech": [],
              "repo_name": "cal.com",
              "repo_owner": "calcom",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "projectdiscovery#1693",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "projectdiscovery",
              "id": "generated-projectdiscovery",
              "name": "Projectdiscovery",
              "description": "",
              "members": [],
              "display_name": "Projectdiscovery",
              "created_at": "2026-01-30T03:42:13.013Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/projectdiscovery?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "projectdiscovery",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-30T03:42:13.013Z",
            "created_at": "2026-01-30T03:42:13.013Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-projectdiscovery#1693",
              "status": "open",
              "type": "issue",
              "number": 1693,
              "title": "test - pls ignore",
              "source": {
                "data": {
                  "id": "source-projectdiscovery#1693",
                  "user": {
                    "login": "dogancanbakir",
                    "id": 65292895,
                    "node_id": "MDQ6VXNlcjY1MjkyODk1",
                    "avatar_url": "https://avatars.githubusercontent.com/u/65292895?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/dogancanbakir",
                    "html_url": "https://github.com/dogancanbakir",
                    "followers_url": "https://api.github.com/users/dogancanbakir/followers",
                    "following_url": "https://api.github.com/users/dogancanbakir/following{/other_user}",
                    "gists_url": "https://api.github.com/users/dogancanbakir/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/dogancanbakir/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/dogancanbakir/subscriptions",
                    "organizations_url": "https://api.github.com/users/dogancanbakir/orgs",
                    "repos_url": "https://api.github.com/users/dogancanbakir/repos",
                    "events_url": "https://api.github.com/users/dogancanbakir/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/dogancanbakir/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "test - pls ignore",
                  "body": "test",
                  "html_url": "https://github.com/projectdiscovery/subfinder/issues/1693"
                },
                "type": "github"
              },
              "hash": "projectdiscovery/subfinder#1693",
              "body": "test",
              "url": "https://github.com/projectdiscovery/subfinder/issues/1693",
              "tech": [],
              "repo_name": "subfinder",
              "repo_owner": "projectdiscovery",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "projectdiscovery#14576",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "projectdiscovery",
              "id": "generated-projectdiscovery",
              "name": "Projectdiscovery",
              "description": "",
              "members": [],
              "display_name": "Projectdiscovery",
              "created_at": "2026-01-30T03:42:13.211Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/projectdiscovery?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "projectdiscovery",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-30T03:42:13.211Z",
            "created_at": "2026-01-30T03:42:13.211Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-projectdiscovery#14576",
              "status": "open",
              "type": "issue",
              "number": 14576,
              "title": "CVE-2018-8581 - Microsoft Exchange Server - Elevation of Privilege ",
              "source": {
                "data": {
                  "id": "source-projectdiscovery#14576",
                  "user": {
                    "login": "princechaddha",
                    "id": 16654365,
                    "node_id": "MDQ6VXNlcjE2NjU0MzY1",
                    "avatar_url": "https://avatars.githubusercontent.com/u/16654365?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/princechaddha",
                    "html_url": "https://github.com/princechaddha",
                    "followers_url": "https://api.github.com/users/princechaddha/followers",
                    "following_url": "https://api.github.com/users/princechaddha/following{/other_user}",
                    "gists_url": "https://api.github.com/users/princechaddha/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/princechaddha/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/princechaddha/subscriptions",
                    "organizations_url": "https://api.github.com/users/princechaddha/orgs",
                    "repos_url": "https://api.github.com/users/princechaddha/repos",
                    "events_url": "https://api.github.com/users/princechaddha/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/princechaddha/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "CVE-2018-8581 - Microsoft Exchange Server - Elevation of Privilege ",
                  "body": "\n### Description: \n> Microsoft Exchange Server contains an elevation of privilege caused by a vulnerability in the system, letting attackers escalate their privileges, exploit requires specific conditions not specified.\n\n#### Severity: `High`\n\n#### POC: \n- https://vulncheck.com/xdb/276c34c7f74f\n- https///gitee.com:mirrors_WyAtu/CVE-2018-8581.git\n- https://vulncheck.com/xdb/7730cd30a582\n- https://github.com/Ridter/Exchange2domain\n- https///github.com:Ridter/Exchange2domain.git\n- https://vulncheck.com/xdb/d7f23b749ff9\n- https://github.com/qiantu88/CVE-2018-8581\n- https///github.com:qiantu88/CVE-2018-8581.git\n- https://vulncheck.com/xdb/dba145cf3cba\n- https://github.com/WyAtu/CVE-2018-8581\n- https///github.com:WyAtu/CVE-2018-8581.git\n- https://vulncheck.com/xdb/3d3434d62f82\n- https///github.com:thezdi/PoC.git\n\n### KEV: True\n\n### Shodan Query: `cpe:\"cpe:2.3:a:microsoft:exchange_server\"`\n\n> Acceptance Criteria: The template must include a complete POC and should not rely solely on version-based detection. Contributors are required to provide debug data(`-debug`) along with the template to help the triage team with validation or can also share a vulnerable environment like docker file. \n\n> Rewards will only be given once the template is fully validated by the team. Templates that are incomplete or invalid will not be accepted. Avoid adding code templates for CVEs that can be achieved using HTTP, TCP, or JavaScript. Such templates are blocked by default and wont produce results, so we prioritize creating templates with other protocols unless exceptions are made.\n\nYou can check the FAQ for the Nuclei Templates Community Rewards Program [here](https://github.com/projectdiscovery/nuclei-templates/blob/main/Community-Rewards-FAQ.md).\n",
                  "html_url": "https://github.com/projectdiscovery/nuclei-templates/issues/14576"
                },
                "type": "github"
              },
              "hash": "projectdiscovery/nuclei-templates#14576",
              "body": "\n### Description: \n> Microsoft Exchange Server contains an elevation of privilege caused by a vulnerability in the system, letting attackers escalate their privileges, exploit requires specific conditions not specified.\n\n#### Severity: `High`\n\n#### POC: \n- https://vulncheck.com/xdb/276c34c7f74f\n- https///gitee.com:mirrors_WyAtu/CVE-2018-8581.git\n- https://vulncheck.com/xdb/7730cd30a582\n- https://github.com/Ridter/Exchange2domain\n- https///github.com:Ridter/Exchange2domain.git\n- https://vulncheck.com/xdb/d7f23b749ff9\n- https://github.com/qiantu88/CVE-2018-8581\n- https///github.com:qiantu88/CVE-2018-8581.git\n- https://vulncheck.com/xdb/dba145cf3cba\n- https://github.com/WyAtu/CVE-2018-8581\n- https///github.com:WyAtu/CVE-2018-8581.git\n- https://vulncheck.com/xdb/3d3434d62f82\n- https///github.com:thezdi/PoC.git\n\n### KEV: True\n\n### Shodan Query: `cpe:\"cpe:2.3:a:microsoft:exchange_server\"`\n\n> Acceptance Criteria: The template must include a complete POC and should not rely solely on version-based detection. Contributors are required to provide debug data(`-debug`) along with the template to help the triage team with validation or can also share a vulnerable environment like docker file. \n\n> Rewards will only be given once the template is fully validated by the team. Templates that are incomplete or invalid will not be accepted. Avoid adding code templates for CVEs that can be achieved using HTTP, TCP, or JavaScript. Such templates are blocked by default and wont produce results, so we prioritize creating templates with other protocols unless exceptions are made.\n\nYou can check the FAQ for the Nuclei Templates Community Rewards Program [here](https://github.com/projectdiscovery/nuclei-templates/blob/main/Community-Rewards-FAQ.md).\n",
              "url": "https://github.com/projectdiscovery/nuclei-templates/issues/14576",
              "tech": [],
              "repo_name": "nuclei-templates",
              "repo_owner": "projectdiscovery",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "projectdiscovery#14535",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "projectdiscovery",
              "id": "generated-projectdiscovery",
              "name": "Projectdiscovery",
              "description": "",
              "members": [],
              "display_name": "Projectdiscovery",
              "created_at": "2026-01-30T03:42:13.398Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/projectdiscovery?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "projectdiscovery",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-30T03:42:13.398Z",
            "created_at": "2026-01-30T03:42:13.398Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-projectdiscovery#14535",
              "status": "open",
              "type": "issue",
              "number": 14535,
              "title": "CVE-2018-20753 - Kaseya VSA - Command Injection ",
              "source": {
                "data": {
                  "id": "source-projectdiscovery#14535",
                  "user": {
                    "login": "princechaddha",
                    "id": 16654365,
                    "node_id": "MDQ6VXNlcjE2NjU0MzY1",
                    "avatar_url": "https://avatars.githubusercontent.com/u/16654365?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/princechaddha",
                    "html_url": "https://github.com/princechaddha",
                    "followers_url": "https://api.github.com/users/princechaddha/followers",
                    "following_url": "https://api.github.com/users/princechaddha/following{/other_user}",
                    "gists_url": "https://api.github.com/users/princechaddha/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/princechaddha/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/princechaddha/subscriptions",
                    "organizations_url": "https://api.github.com/users/princechaddha/orgs",
                    "repos_url": "https://api.github.com/users/princechaddha/repos",
                    "events_url": "https://api.github.com/users/princechaddha/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/princechaddha/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "CVE-2018-20753 - Kaseya VSA - Command Injection ",
                  "body": "\n### Description: \n> Kaseya VSA RMM before R9.3 9.3.0.35, R9.4 before 9.4.0.36, and R9.5 before 9.5.0.5 contain a command injection caused by insufficient input validation in PowerShell execution, letting unprivileged remote attackers execute arbitrary PowerShell payloads on all managed devices, exploit requires network access to the system.\n\n#### Severity: `Critical`\n\n#### POC: \n- https://blog.huntresslabs.com/deep-dive-kaseya-vsa-mining-payload-c0ac839a0e88\n\n### KEV: True\n\n### Shodan Query: `http.favicon.hash:-1445519482`\n\n> Acceptance Criteria: The template must include a complete POC and should not rely solely on version-based detection. Contributors are required to provide debug data(`-debug`) along with the template to help the triage team with validation or can also share a vulnerable environment like docker file. \n\n> Rewards will only be given once the template is fully validated by the team. Templates that are incomplete or invalid will not be accepted. Avoid adding code templates for CVEs that can be achieved using HTTP, TCP, or JavaScript. Such templates are blocked by default and wont produce results, so we prioritize creating templates with other protocols unless exceptions are made.\n\nYou can check the FAQ for the Nuclei Templates Community Rewards Program [here](https://github.com/projectdiscovery/nuclei-templates/blob/main/Community-Rewards-FAQ.md).\n",
                  "html_url": "https://github.com/projectdiscovery/nuclei-templates/issues/14535"
                },
                "type": "github"
              },
              "hash": "projectdiscovery/nuclei-templates#14535",
              "body": "\n### Description: \n> Kaseya VSA RMM before R9.3 9.3.0.35, R9.4 before 9.4.0.36, and R9.5 before 9.5.0.5 contain a command injection caused by insufficient input validation in PowerShell execution, letting unprivileged remote attackers execute arbitrary PowerShell payloads on all managed devices, exploit requires network access to the system.\n\n#### Severity: `Critical`\n\n#### POC: \n- https://blog.huntresslabs.com/deep-dive-kaseya-vsa-mining-payload-c0ac839a0e88\n\n### KEV: True\n\n### Shodan Query: `http.favicon.hash:-1445519482`\n\n> Acceptance Criteria: The template must include a complete POC and should not rely solely on version-based detection. Contributors are required to provide debug data(`-debug`) along with the template to help the triage team with validation or can also share a vulnerable environment like docker file. \n\n> Rewards will only be given once the template is fully validated by the team. Templates that are incomplete or invalid will not be accepted. Avoid adding code templates for CVEs that can be achieved using HTTP, TCP, or JavaScript. Such templates are blocked by default and wont produce results, so we prioritize creating templates with other protocols unless exceptions are made.\n\nYou can check the FAQ for the Nuclei Templates Community Rewards Program [here](https://github.com/projectdiscovery/nuclei-templates/blob/main/Community-Rewards-FAQ.md).\n",
              "url": "https://github.com/projectdiscovery/nuclei-templates/issues/14535",
              "tech": [],
              "repo_name": "nuclei-templates",
              "repo_owner": "projectdiscovery",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "projectdiscovery#14488",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "projectdiscovery",
              "id": "generated-projectdiscovery",
              "name": "Projectdiscovery",
              "description": "",
              "members": [],
              "display_name": "Projectdiscovery",
              "created_at": "2026-01-30T03:42:13.582Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/projectdiscovery?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "projectdiscovery",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-30T03:42:13.582Z",
            "created_at": "2026-01-30T03:42:13.582Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-projectdiscovery#14488",
              "status": "open",
              "type": "issue",
              "number": 14488,
              "title": "CVE-2024-3408 - man-group/dtale - Authentication Bypass & Remote Code Execution ",
              "source": {
                "data": {
                  "id": "source-projectdiscovery#14488",
                  "user": {
                    "login": "princechaddha",
                    "id": 16654365,
                    "node_id": "MDQ6VXNlcjE2NjU0MzY1",
                    "avatar_url": "https://avatars.githubusercontent.com/u/16654365?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/princechaddha",
                    "html_url": "https://github.com/princechaddha",
                    "followers_url": "https://api.github.com/users/princechaddha/followers",
                    "following_url": "https://api.github.com/users/princechaddha/following{/other_user}",
                    "gists_url": "https://api.github.com/users/princechaddha/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/princechaddha/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/princechaddha/subscriptions",
                    "organizations_url": "https://api.github.com/users/princechaddha/orgs",
                    "repos_url": "https://api.github.com/users/princechaddha/repos",
                    "events_url": "https://api.github.com/users/princechaddha/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/princechaddha/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "CVE-2024-3408 - man-group/dtale - Authentication Bypass & Remote Code Execution ",
                  "body": "\n### Description: \n> man-group/dtale 3.10.0 contains an authentication bypass and remote code execution caused by improper input validation and a hardcoded SECRET_KEY in Flask configuration, letting attackers forge session cookies and execute arbitrary code, exploit requires attacker to access the application.\n\n#### Severity: `Critical`\n\n#### POC: \n- https://huntr.com/bounties/57a06666-ff85-4577-af19-f3dfb7b02f91\n- https://github.com/rapid7/metasploit-framework/blob/master/modules/exploits/linux/http/dtale_rce_cve_2025_0655.rb\n\n### KEV: True\n\n### Shodan Query: `NA`\n\n> Acceptance Criteria: The template must include a complete POC and should not rely solely on version-based detection. Contributors are required to provide debug data(`-debug`) along with the template to help the triage team with validation or can also share a vulnerable environment like docker file. \n\n> Rewards will only be given once the template is fully validated by the team. Templates that are incomplete or invalid will not be accepted. Avoid adding code templates for CVEs that can be achieved using HTTP, TCP, or JavaScript. Such templates are blocked by default and wont produce results, so we prioritize creating templates with other protocols unless exceptions are made.\n\nYou can check the FAQ for the Nuclei Templates Community Rewards Program [here](https://github.com/projectdiscovery/nuclei-templates/blob/main/Community-Rewards-FAQ.md).\n",
                  "html_url": "https://github.com/projectdiscovery/nuclei-templates/issues/14488"
                },
                "type": "github"
              },
              "hash": "projectdiscovery/nuclei-templates#14488",
              "body": "\n### Description: \n> man-group/dtale 3.10.0 contains an authentication bypass and remote code execution caused by improper input validation and a hardcoded SECRET_KEY in Flask configuration, letting attackers forge session cookies and execute arbitrary code, exploit requires attacker to access the application.\n\n#### Severity: `Critical`\n\n#### POC: \n- https://huntr.com/bounties/57a06666-ff85-4577-af19-f3dfb7b02f91\n- https://github.com/rapid7/metasploit-framework/blob/master/modules/exploits/linux/http/dtale_rce_cve_2025_0655.rb\n\n### KEV: True\n\n### Shodan Query: `NA`\n\n> Acceptance Criteria: The template must include a complete POC and should not rely solely on version-based detection. Contributors are required to provide debug data(`-debug`) along with the template to help the triage team with validation or can also share a vulnerable environment like docker file. \n\n> Rewards will only be given once the template is fully validated by the team. Templates that are incomplete or invalid will not be accepted. Avoid adding code templates for CVEs that can be achieved using HTTP, TCP, or JavaScript. Such templates are blocked by default and wont produce results, so we prioritize creating templates with other protocols unless exceptions are made.\n\nYou can check the FAQ for the Nuclei Templates Community Rewards Program [here](https://github.com/projectdiscovery/nuclei-templates/blob/main/Community-Rewards-FAQ.md).\n",
              "url": "https://github.com/projectdiscovery/nuclei-templates/issues/14488",
              "tech": [],
              "repo_name": "nuclei-templates",
              "repo_owner": "projectdiscovery",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "projectdiscovery#14488",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "projectdiscovery",
              "id": "generated-projectdiscovery",
              "name": "Projectdiscovery",
              "description": "",
              "members": [],
              "display_name": "Projectdiscovery",
              "created_at": "2026-01-30T03:42:13.602Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/projectdiscovery?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "projectdiscovery",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-30T03:42:13.602Z",
            "created_at": "2026-01-30T03:42:13.602Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-projectdiscovery#14488",
              "status": "open",
              "type": "issue",
              "number": 14488,
              "title": "CVE-2024-3408 - man-group/dtale - Authentication Bypass & Remote Code Execution ",
              "source": {
                "data": {
                  "id": "source-projectdiscovery#14488",
                  "user": {
                    "login": "princechaddha",
                    "id": 16654365,
                    "node_id": "MDQ6VXNlcjE2NjU0MzY1",
                    "avatar_url": "https://avatars.githubusercontent.com/u/16654365?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/princechaddha",
                    "html_url": "https://github.com/princechaddha",
                    "followers_url": "https://api.github.com/users/princechaddha/followers",
                    "following_url": "https://api.github.com/users/princechaddha/following{/other_user}",
                    "gists_url": "https://api.github.com/users/princechaddha/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/princechaddha/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/princechaddha/subscriptions",
                    "organizations_url": "https://api.github.com/users/princechaddha/orgs",
                    "repos_url": "https://api.github.com/users/princechaddha/repos",
                    "events_url": "https://api.github.com/users/princechaddha/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/princechaddha/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "CVE-2024-3408 - man-group/dtale - Authentication Bypass & Remote Code Execution ",
                  "body": "\n### Description: \n> man-group/dtale 3.10.0 contains an authentication bypass and remote code execution caused by improper input validation and a hardcoded SECRET_KEY in Flask configuration, letting attackers forge session cookies and execute arbitrary code, exploit requires attacker to access the application.\n\n#### Severity: `Critical`\n\n#### POC: \n- https://huntr.com/bounties/57a06666-ff85-4577-af19-f3dfb7b02f91\n- https://github.com/rapid7/metasploit-framework/blob/master/modules/exploits/linux/http/dtale_rce_cve_2025_0655.rb\n\n### KEV: True\n\n### Shodan Query: `NA`\n\n> Acceptance Criteria: The template must include a complete POC and should not rely solely on version-based detection. Contributors are required to provide debug data(`-debug`) along with the template to help the triage team with validation or can also share a vulnerable environment like docker file. \n\n> Rewards will only be given once the template is fully validated by the team. Templates that are incomplete or invalid will not be accepted. Avoid adding code templates for CVEs that can be achieved using HTTP, TCP, or JavaScript. Such templates are blocked by default and wont produce results, so we prioritize creating templates with other protocols unless exceptions are made.\n\nYou can check the FAQ for the Nuclei Templates Community Rewards Program [here](https://github.com/projectdiscovery/nuclei-templates/blob/main/Community-Rewards-FAQ.md).\n",
                  "html_url": "https://github.com/projectdiscovery/nuclei-templates/issues/14488"
                },
                "type": "github"
              },
              "hash": "projectdiscovery/nuclei-templates#14488",
              "body": "\n### Description: \n> man-group/dtale 3.10.0 contains an authentication bypass and remote code execution caused by improper input validation and a hardcoded SECRET_KEY in Flask configuration, letting attackers forge session cookies and execute arbitrary code, exploit requires attacker to access the application.\n\n#### Severity: `Critical`\n\n#### POC: \n- https://huntr.com/bounties/57a06666-ff85-4577-af19-f3dfb7b02f91\n- https://github.com/rapid7/metasploit-framework/blob/master/modules/exploits/linux/http/dtale_rce_cve_2025_0655.rb\n\n### KEV: True\n\n### Shodan Query: `NA`\n\n> Acceptance Criteria: The template must include a complete POC and should not rely solely on version-based detection. Contributors are required to provide debug data(`-debug`) along with the template to help the triage team with validation or can also share a vulnerable environment like docker file. \n\n> Rewards will only be given once the template is fully validated by the team. Templates that are incomplete or invalid will not be accepted. Avoid adding code templates for CVEs that can be achieved using HTTP, TCP, or JavaScript. Such templates are blocked by default and wont produce results, so we prioritize creating templates with other protocols unless exceptions are made.\n\nYou can check the FAQ for the Nuclei Templates Community Rewards Program [here](https://github.com/projectdiscovery/nuclei-templates/blob/main/Community-Rewards-FAQ.md).\n",
              "url": "https://github.com/projectdiscovery/nuclei-templates/issues/14488",
              "tech": [],
              "repo_name": "nuclei-templates",
              "repo_owner": "projectdiscovery",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "projectdiscovery#14451",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "projectdiscovery",
              "id": "generated-projectdiscovery",
              "name": "Projectdiscovery",
              "description": "",
              "members": [],
              "display_name": "Projectdiscovery",
              "created_at": "2026-01-30T03:42:13.780Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/projectdiscovery?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "projectdiscovery",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-30T03:42:13.780Z",
            "created_at": "2026-01-30T03:42:13.780Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-projectdiscovery#14451",
              "status": "open",
              "type": "issue",
              "number": 14451,
              "title": "CVE-2017-18365 - GitHub Enterprise - Insecure Deserialization ",
              "source": {
                "data": {
                  "id": "source-projectdiscovery#14451",
                  "user": {
                    "login": "princechaddha",
                    "id": 16654365,
                    "node_id": "MDQ6VXNlcjE2NjU0MzY1",
                    "avatar_url": "https://avatars.githubusercontent.com/u/16654365?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/princechaddha",
                    "html_url": "https://github.com/princechaddha",
                    "followers_url": "https://api.github.com/users/princechaddha/followers",
                    "following_url": "https://api.github.com/users/princechaddha/following{/other_user}",
                    "gists_url": "https://api.github.com/users/princechaddha/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/princechaddha/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/princechaddha/subscriptions",
                    "organizations_url": "https://api.github.com/users/princechaddha/orgs",
                    "repos_url": "https://api.github.com/users/princechaddha/repos",
                    "events_url": "https://api.github.com/users/princechaddha/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/princechaddha/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "CVE-2017-18365 - GitHub Enterprise - Insecure Deserialization ",
                  "body": "\n### Description: \n> GitHub Enterprise 2.8.x before 2.8.7 contains a deserialization caused by a static enterprise session secret in the Management Console, letting unauthenticated attackers execute arbitrary code, exploit requires crafting a signed cookie with the secret.\n\n#### Severity: `Critical`\n\n#### POC: \n- https://www.exablue.de/blog/2017-03-15-github-enterprise-remote-code-execution.html\n- https://github.com/rapid7/metasploit-framework/blob/master/modules/exploits/linux/http/github_enterprise_secret.rb\n\n### KEV: True\n\n### Shodan Query: `http.title:\"github debug\"`\n\n> Acceptance Criteria: The template must include a complete POC and should not rely solely on version-based detection. Contributors are required to provide debug data(`-debug`) along with the template to help the triage team with validation or can also share a vulnerable environment like docker file. \n\n> Rewards will only be given once the template is fully validated by the team. Templates that are incomplete or invalid will not be accepted. Avoid adding code templates for CVEs that can be achieved using HTTP, TCP, or JavaScript. Such templates are blocked by default and wont produce results, so we prioritize creating templates with other protocols unless exceptions are made.\n\nYou can check the FAQ for the Nuclei Templates Community Rewards Program [here](https://github.com/projectdiscovery/nuclei-templates/blob/main/Community-Rewards-FAQ.md).\n",
                  "html_url": "https://github.com/projectdiscovery/nuclei-templates/issues/14451"
                },
                "type": "github"
              },
              "hash": "projectdiscovery/nuclei-templates#14451",
              "body": "\n### Description: \n> GitHub Enterprise 2.8.x before 2.8.7 contains a deserialization caused by a static enterprise session secret in the Management Console, letting unauthenticated attackers execute arbitrary code, exploit requires crafting a signed cookie with the secret.\n\n#### Severity: `Critical`\n\n#### POC: \n- https://www.exablue.de/blog/2017-03-15-github-enterprise-remote-code-execution.html\n- https://github.com/rapid7/metasploit-framework/blob/master/modules/exploits/linux/http/github_enterprise_secret.rb\n\n### KEV: True\n\n### Shodan Query: `http.title:\"github debug\"`\n\n> Acceptance Criteria: The template must include a complete POC and should not rely solely on version-based detection. Contributors are required to provide debug data(`-debug`) along with the template to help the triage team with validation or can also share a vulnerable environment like docker file. \n\n> Rewards will only be given once the template is fully validated by the team. Templates that are incomplete or invalid will not be accepted. Avoid adding code templates for CVEs that can be achieved using HTTP, TCP, or JavaScript. Such templates are blocked by default and wont produce results, so we prioritize creating templates with other protocols unless exceptions are made.\n\nYou can check the FAQ for the Nuclei Templates Community Rewards Program [here](https://github.com/projectdiscovery/nuclei-templates/blob/main/Community-Rewards-FAQ.md).\n",
              "url": "https://github.com/projectdiscovery/nuclei-templates/issues/14451",
              "tech": [],
              "repo_name": "nuclei-templates",
              "repo_owner": "projectdiscovery",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "projectdiscovery#1471",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "projectdiscovery",
              "id": "generated-projectdiscovery",
              "name": "Projectdiscovery",
              "description": "",
              "members": [],
              "display_name": "Projectdiscovery",
              "created_at": "2026-01-30T03:42:13.986Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/projectdiscovery?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "projectdiscovery",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-30T03:42:13.986Z",
            "created_at": "2026-01-30T03:42:13.986Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-projectdiscovery#1471",
              "status": "open",
              "type": "issue",
              "number": 1471,
              "title": "release katana v1.3.0",
              "source": {
                "data": {
                  "id": "source-projectdiscovery#1471",
                  "user": {
                    "login": "dogancanbakir",
                    "id": 65292895,
                    "node_id": "MDQ6VXNlcjY1MjkyODk1",
                    "avatar_url": "https://avatars.githubusercontent.com/u/65292895?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/dogancanbakir",
                    "html_url": "https://github.com/dogancanbakir",
                    "followers_url": "https://api.github.com/users/dogancanbakir/followers",
                    "following_url": "https://api.github.com/users/dogancanbakir/following{/other_user}",
                    "gists_url": "https://api.github.com/users/dogancanbakir/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/dogancanbakir/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/dogancanbakir/subscriptions",
                    "organizations_url": "https://api.github.com/users/dogancanbakir/orgs",
                    "repos_url": "https://api.github.com/users/dogancanbakir/repos",
                    "events_url": "https://api.github.com/users/dogancanbakir/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/dogancanbakir/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "release katana v1.3.0",
                  "body": "https://github.com/projectdiscovery/nuclei-templates/pull/14666 https://github.com/projectdiscovery/nuclei-templates/pull/14667 https://github.com/projectdiscovery/nuclei-templates/pull/14452 https://",
                  "html_url": "https://github.com/projectdiscovery/katana/issues/1471"
                },
                "type": "github"
              },
              "hash": "projectdiscovery/katana#1471",
              "body": "https://github.com/projectdiscovery/nuclei-templates/pull/14666 https://github.com/projectdiscovery/nuclei-templates/pull/14667 https://github.com/projectdiscovery/nuclei-templates/pull/14452 https://",
              "url": "https://github.com/projectdiscovery/katana/issues/1471",
              "tech": [],
              "repo_name": "katana",
              "repo_owner": "projectdiscovery",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "zio#685",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "zio",
              "id": "generated-zio",
              "name": "Zio",
              "description": "",
              "members": [],
              "display_name": "Zio",
              "created_at": "2026-01-30T03:42:13.114Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/zio?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "zio",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-30T03:42:13.114Z",
            "created_at": "2026-01-30T03:42:13.114Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-zio#685",
              "status": "open",
              "type": "issue",
              "number": 685,
              "title": "Add JsonPatch - Depends on #679",
              "source": {
                "data": {
                  "id": "source-zio#685",
                  "user": {
                    "login": "jdegoes",
                    "id": 156745,
                    "node_id": "MDQ6VXNlcjE1Njc0NQ==",
                    "avatar_url": "https://avatars.githubusercontent.com/u/156745?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/jdegoes",
                    "html_url": "https://github.com/jdegoes",
                    "followers_url": "https://api.github.com/users/jdegoes/followers",
                    "following_url": "https://api.github.com/users/jdegoes/following{/other_user}",
                    "gists_url": "https://api.github.com/users/jdegoes/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/jdegoes/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/jdegoes/subscriptions",
                    "organizations_url": "https://api.github.com/users/jdegoes/orgs",
                    "repos_url": "https://api.github.com/users/jdegoes/repos",
                    "events_url": "https://api.github.com/users/jdegoes/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/jdegoes/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Add JsonPatch - Depends on #679",
                  "body": "<html><head></head><body><h1>Add <code>JsonPatch</code> type for diffing and patching JSON values</h1>\n<h2>Summary</h2>\n<p>Implement a <code>JsonPatch</code> type that enables computing diffs between JSON values and applying patches to transform one JSON value into another. This type should mirror the existing <code>DynamicPatch</code> implementation, adapted for JSON's simpler data model.</p>\n<h2>Motivation</h2>\n<p><code>DynamicValue</code> has a well-designed <code>DynamicPatch</code> system with:</p>\n<ul>\n<li>Monoid composition (<code>++</code> with <code>empty</code> identity)</li>\n<li>LCS-based sequence diffing</li>\n<li>Primitive delta operations (numeric deltas, string edits)</li>\n<li>Comprehensive algebraic laws verified by property tests</li>\n</ul>\n<p>The proposed <code>Json</code> type (see #TBD) needs equivalent patching capabilities. Rather than converting <code>Json  DynamicValue</code> for every patch operation, a native <code>JsonPatch</code> provides:</p>\n<ul>\n<li>Type safety (no conversion errors for JSON-incompatible DynamicPatch operations)</li>\n<li>API consistency with the <code>Json</code> type</li>\n<li>Potential for JSON-specific optimizations</li>\n</ul>\n<h2>Design Sketch</h2>\n<p>A design sketch is available at <a href=\"https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/json/JsonPatch.scala\"><code>schema/shared/src/main/scala/zio/blocks/schema/json/JsonPatch.scala</code></a>. This sketch is <strong>a guide, not a specification</strong>  implementers should use judgment and deviate where appropriate.</p>\n<h3>Core Types</h3>\n<p>The design mirrors <code>DynamicPatch</code> with JSON-specific adaptations:</p>\n\nDynamicPatch | JsonPatch | Notes\n-- | -- | --\nDynamicPatch(Vector[DynamicPatchOp]) | JsonPatch(Vector[JsonPatchOp]) | Same structure\nOperation.Set | Op.Set | Same\nOperation.PrimitiveDelta | Op.PrimitiveDelta | Simplified for JSON types\nOperation.SequenceEdit | Op.ArrayEdit | Renamed\nOperation.MapEdit | Op.ObjectEdit | String keys only\nOperation.Patch | Op.Nested | Same\nSeqOp | ArrayOp | Same operations\nMapOp | ObjectOp | String keys only\nPrimitiveOp (14 variants) | PrimitiveOp (2 variants) | See below\n\n\n<h3>StringOp</h3>\n<p>Mirror <code>DynamicPatch.StringOp</code> exactly:</p>\n<ul>\n<li><code>Insert(index: Int, text: String)</code></li>\n<li><code>Delete(index: Int, length: Int)</code></li>\n<li><code>Append(text: String)</code></li>\n<li><code>Modify(index: Int, length: Int, text: String)</code></li>\n</ul>\n<h3>ArrayOp</h3>\n<p>Mirror <code>DynamicPatch.SeqOp</code>:</p>\n<ul>\n<li><code>Insert(index: Int, values: Vector[Json])</code></li>\n<li><code>Append(values: Vector[Json])</code></li>\n<li><code>Delete(index: Int, count: Int)</code></li>\n<li><code>Modify(index: Int, op: Op)</code></li>\n</ul>\n<h3>ObjectOp</h3>\n<p>Mirror <code>DynamicPatch.MapOp</code> with string keys:</p>\n<ul>\n<li><code>Add(key: String, value: Json)</code></li>\n<li><code>Remove(key: String)</code></li>\n<li><code>Modify(key: String, patch: JsonPatch)</code></li>\n</ul>\n<h2>Requirements</h2>\n<h3>Functional Requirements</h3>\n<ul>\n<li>[ ] <strong>F1</strong>: <code>JsonPatch.diff(source, target)</code> computes a patch transforming source to target</li>\n<li>[ ] <strong>F2</strong>: <code>patch.apply(json, mode)</code> applies a patch with configurable failure handling</li>\n<li>[ ] <strong>F3</strong>: <code>patch1 ++ patch2</code> composes patches (apply first, then second)</li>\n<li>[ ] <strong>F4</strong>: <code>JsonPatch.empty</code> is the identity element for composition</li>\n<li>[ ] <strong>F5</strong>: Support <code>JsonPatchMode.Strict</code>, <code>Lenient</code>, and <code>Clobber</code> modes</li>\n<li>[ ] <strong>F6</strong>: Bidirectional conversion: <code>toDynamicPatch</code> / <code>fromDynamicPatch</code></li>\n</ul>\n<h3>Algebraic Laws</h3>\n<p>All laws must be verified with property-based tests (see <code>PatchLawsSpec</code> for reference):</p>\n<ul>\n<li>[ ] <strong>L1</strong>: Left identity  <code>(empty ++ p)(j) == p(j)</code></li>\n<li>[ ] <strong>L2</strong>: Right identity  <code>(p ++ empty)(j) == p(j)</code></li>\n<li>[ ] <strong>L3</strong>: Associativity  <code>((p1 ++ p2) ++ p3)(j) == (p1 ++ (p2 ++ p3))(j)</code></li>\n<li>[ ] <strong>L4</strong>: Roundtrip  <code>diff(a, b)(a) == Right(b)</code></li>\n<li>[ ] <strong>L5</strong>: Identity diff  <code>diff(j, j).isEmpty</code></li>\n<li>[ ] <strong>L6</strong>: Diff composition  <code>(diff(a, b) ++ diff(b, c))(a) == Right(c)</code></li>\n<li>[ ] <strong>L7</strong>: Lenient subsumes Strict  if <code>p(j, Strict) == Right(r)</code> then <code>p(j, Lenient) == Right(r)</code></li>\n</ul>\n<h3>Testing Requirements</h3>\n<ul>\n<li>[ ] <strong>T1</strong>: Property-based tests for all algebraic laws (see <code>PatchLawsSpec</code>)</li>\n<li>[ ] <strong>T2</strong>: Test each operation type (<code>Set</code>, <code>PrimitiveDelta</code>, <code>ArrayEdit</code>, <code>ObjectEdit</code>, <code>Nested</code>)</li>\n<li>[ ] <strong>T3</strong>: Test each <code>ArrayOp</code> variant (<code>Insert</code>, <code>Append</code>, <code>Delete</code>, <code>Modify</code>)</li>\n<li>[ ] <strong>T4</strong>: Test each <code>ObjectOp</code> variant (<code>Add</code>, <code>Remove</code>, <code>Modify</code>)</li>\n<li>[ ] <strong>T5</strong>: Test each <code>StringOp</code> variant (<code>Insert</code>, <code>Delete</code>, <code>Append</code>, <code>Modify</code>)</li>\n<li>[ ] <strong>T6</strong>: Test <code>NumberDelta</code> with positive, negative, zero, and decimal deltas</li>\n<li>[ ] <strong>T7</strong>: Test all three <code>JsonPatchMode</code> behaviors</li>\n<li>[ ] <strong>T8</strong>: Test <code>toDynamicPatch</code> / <code>fromDynamicPatch</code> roundtrip</li>\n<li>[ ] <strong>T9</strong>: Test edge cases: empty arrays, empty objects, empty strings, nested structures</li>\n<li>[ ] <strong>T10</strong>: Test error cases: invalid paths, type mismatches, out-of-bounds indices</li>\n</ul>\n<h3>Documentation Requirements</h3>\n<ul>\n<li>[ ] <strong>D1</strong>: ScalaDoc for all public types and methods</li>\n<li>[ ] <strong>D2</strong>: Usage examples in ScalaDoc (see sketch for examples)</li>\n<li>[ ] <strong>D3</strong>: Document algebraic laws in type-level comments</li>\n<li>[ ] <strong>D4</strong>: Document relationship to <code>DynamicPatch</code></li>\n</ul>\n<h3>Implementation Notes</h3>\n<ol>\n<li>\n<p><strong>Follow <code>DynamicPatch</code> patterns</strong>: The implementation in <code>DynamicPatch.scala</code> is the reference. Study <code>Differ.scala</code> for diff algorithms (especially LCS for sequences and strings).</p>\n</li>\n<li>\n<p><strong>Reuse algorithms where possible</strong>: Consider whether <code>JsonPatch</code> can delegate to <code>DynamicPatch</code> internally, or share algorithm implementations.</p>\n</li>\n<li>\n<p><strong>Keep it minimal</strong>: Resist adding operations not present in <code>DynamicPatch</code>. The design is intentionally minimal and principled.</p>\n</li>\n<li>\n<p><strong>Performance considerations</strong>: The register-based design of ZIO Blocks prioritizes performance. Avoid unnecessary allocations in hot paths.</p>\n</li>\n</ol>\n<h2>Out of Scope</h2>\n<p>The following are explicitly <strong>not</strong> part of this issue:</p>\n<ul>\n<li>RFC 6902 JSON Patch serialization format (separate issue)</li>\n<li>Patch inversion / undo support (separate issue)</li>\n<li>Patch optimization / compaction (separate issue)</li>\n<li>Integration with <code>Json</code> type methods like <code>json.diff(other)</code> (depends on <code>Json</code> implementation)</li>\n</ul>\n<h2>Related</h2>\n<ul>\n<li><code>DynamicPatch</code>  <a href=\"https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/DynamicPatch.scala\"><code>schema/shared/src/main/scala/zio/blocks/schema/patch/DynamicPatch.scala</code></a></li>\n<li><code>Differ</code>  <a href=\"https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/Differ.scala\"><code>schema/shared/src/main/scala/zio/blocks/schema/patch/Differ.scala</code></a></li>\n<li><code>PatchLawsSpec</code>  <a href=\"https://claude.ai/chat/schema/shared/src/test/scala/zio/blocks/schema/patch/PatchLawsSpec.scala\"><code>schema/shared/src/test/scala/zio/blocks/schema/patch/PatchLawsSpec.scala</code></a></li>\n<li><code>PatchMode</code>  <a href=\"https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/PatchMode.scala\"><code>schema/shared/src/main/scala/zio/blocks/schema/patch/PatchMode.scala</code></a></li>\n</ul>\n<h2>Acceptance Criteria</h2>\n<ul>\n<li>[ ] All functional requirements (F1-F6) implemented</li>\n<li>[ ] All algebraic laws (L1-L7) pass property-based tests</li>\n<li>[ ] All testing requirements (T1-T10) have corresponding test cases</li>\n<li>[ ] All documentation requirements (D1-D4) complete</li>\n<li>[ ] Code reviewed and approved</li>\n<li>[ ] CI passing</li>\n</ul></body></html># Add `JsonPatch` type for diffing and patching JSON values\n\n## Summary\n\nImplement a `JsonPatch` type that enables computing diffs between JSON values and applying patches to transform one JSON value into another. This type should mirror the existing `DynamicPatch` implementation, adapted for JSON's simpler data model.\n\n## Motivation\n\n`DynamicValue` has a well-designed `DynamicPatch` system with:\n- Monoid composition (`++` with `empty` identity)\n- LCS-based sequence diffing\n- Primitive delta operations (numeric deltas, string edits)\n- Comprehensive algebraic laws verified by property tests\n\nThe proposed `Json` type (see #TBD) needs equivalent patching capabilities. Rather than converting `Json  DynamicValue` for every patch operation, a native `JsonPatch` provides:\n- Type safety (no conversion errors for JSON-incompatible DynamicPatch operations)\n- API consistency with the `Json` type\n- Potential for JSON-specific optimizations\n\n## Design Sketch\n\nA design sketch is available at [`[schema/shared/src/main/scala/zio/blocks/schema/json/JsonPatch.scala](https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/json/JsonPatch.scala)`](./schema/shared/src/main/scala/zio/blocks/schema/json/JsonPatch.scala). This sketch is **a guide, not a specification**  implementers should use judgment and deviate where appropriate.\n\n### Core Types\n\nThe design mirrors `DynamicPatch` with JSON-specific adaptations:\n\n| DynamicPatch | JsonPatch | Notes |\n|--------------|-----------|-------|\n| `DynamicPatch(Vector[DynamicPatchOp])` | `JsonPatch(Vector[JsonPatchOp])` | Same structure |\n| `Operation.Set` | `Op.Set` | Same |\n| `Operation.PrimitiveDelta` | `Op.PrimitiveDelta` | Simplified for JSON types |\n| `Operation.SequenceEdit` | `Op.ArrayEdit` | Renamed |\n| `Operation.MapEdit` | `Op.ObjectEdit` | String keys only |\n| `Operation.Patch` | `Op.Nested` | Same |\n| `SeqOp` | `ArrayOp` | Same operations |\n| `MapOp` | `ObjectOp` | String keys only |\n| `PrimitiveOp` (14 variants) | `PrimitiveOp` (2 variants) | See below |\n\n### Primitive Operations\n\nJSON has a simpler type system than `DynamicValue`:\n\n| JSON Type | Delta Operation | Notes |\n|-----------|-----------------|-------|\n| Number | `NumberDelta(BigDecimal)` | Unifies all numeric deltas |\n| String | `StringEdit(Vector[StringOp])` | Same as `DynamicPatch` |\n| Boolean | Use `Op.Set` | No delta (same as `DynamicPatch`) |\n| Null | Use `Op.Set` | No delta |\n\n### StringOp\n\nMirror `DynamicPatch.StringOp` exactly:\n- `Insert(index: Int, text: String)`\n- `Delete(index: Int, length: Int)`\n- `Append(text: String)`\n- `Modify(index: Int, length: Int, text: String)`\n\n### ArrayOp\n\nMirror `DynamicPatch.SeqOp`:\n- `Insert(index: Int, values: Vector[Json])`\n- `Append(values: Vector[Json])`\n- `Delete(index: Int, count: Int)`\n- `Modify(index: Int, op: Op)`\n\n### ObjectOp\n\nMirror `DynamicPatch.MapOp` with string keys:\n- `Add(key: String, value: Json)`\n- `Remove(key: String)`\n- `Modify(key: String, patch: JsonPatch)`\n\n## Requirements\n\n### Functional Requirements\n\n- [ ] **F1**: `JsonPatch.diff(source, target)` computes a patch transforming source to target\n- [ ] **F2**: `patch.apply(json, mode)` applies a patch with configurable failure handling\n- [ ] **F3**: `patch1 ++ patch2` composes patches (apply first, then second)\n- [ ] **F4**: `JsonPatch.empty` is the identity element for composition\n- [ ] **F5**: Support `JsonPatchMode.Strict`, `Lenient`, and `Clobber` modes\n- [ ] **F6**: Bidirectional conversion: `toDynamicPatch` / `fromDynamicPatch`\n\n### Algebraic Laws\n\nAll laws must be verified with property-based tests (see `PatchLawsSpec` for reference):\n\n- [ ] **L1**: Left identity  `(empty ++ p)(j) == p(j)`\n- [ ] **L2**: Right identity  `(p ++ empty)(j) == p(j)`\n- [ ] **L3**: Associativity  `((p1 ++ p2) ++ p3)(j) == (p1 ++ (p2 ++ p3))(j)`\n- [ ] **L4**: Roundtrip  `diff(a, b)(a) == Right(b)`\n- [ ] **L5**: Identity diff  `diff(j, j).isEmpty`\n- [ ] **L6**: Diff composition  `(diff(a, b) ++ diff(b, c))(a) == Right(c)`\n- [ ] **L7**: Lenient subsumes Strict  if `p(j, Strict) == Right(r)` then `p(j, Lenient) == Right(r)`\n\n### Testing Requirements\n\n- [ ] **T1**: Property-based tests for all algebraic laws (see `PatchLawsSpec`)\n- [ ] **T2**: Test each operation type (`Set`, `PrimitiveDelta`, `ArrayEdit`, `ObjectEdit`, `Nested`)\n- [ ] **T3**: Test each `ArrayOp` variant (`Insert`, `Append`, `Delete`, `Modify`)\n- [ ] **T4**: Test each `ObjectOp` variant (`Add`, `Remove`, `Modify`)\n- [ ] **T5**: Test each `StringOp` variant (`Insert`, `Delete`, `Append`, `Modify`)\n- [ ] **T6**: Test `NumberDelta` with positive, negative, zero, and decimal deltas\n- [ ] **T7**: Test all three `JsonPatchMode` behaviors\n- [ ] **T8**: Test `toDynamicPatch` / `fromDynamicPatch` roundtrip\n- [ ] **T9**: Test edge cases: empty arrays, empty objects, empty strings, nested structures\n- [ ] **T10**: Test error cases: invalid paths, type mismatches, out-of-bounds indices\n\n### Documentation Requirements\n\n- [ ] **D1**: ScalaDoc for all public types and methods\n- [ ] **D2**: Usage examples in ScalaDoc (see sketch for examples)\n- [ ] **D3**: Document algebraic laws in type-level comments\n- [ ] **D4**: Document relationship to `DynamicPatch`\n\n## Related\n\n- `DynamicPatch`  [`[schema/shared/src/main/scala/zio/blocks/schema/patch/DynamicPatch.scala](https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/DynamicPatch.scala)`](./schema/shared/src/main/scala/zio/blocks/schema/patch/DynamicPatch.scala)\n- `Differ`  [`[schema/shared/src/main/scala/zio/blocks/schema/patch/Differ.scala](https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/Differ.scala)`](./schema/shared/src/main/scala/zio/blocks/schema/patch/Differ.scala)\n- `PatchLawsSpec`  [`[schema/shared/src/test/scala/zio/blocks/schema/patch/PatchLawsSpec.scala](https://claude.ai/chat/schema/shared/src/test/scala/zio/blocks/schema/patch/PatchLawsSpec.scala)`](./schema/shared/src/test/scala/zio/blocks/schema/patch/PatchLawsSpec.scala)\n- `PatchMode`  [`[schema/shared/src/main/scala/zio/blocks/schema/patch/PatchMode.scala](https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/PatchMode.scala)`](./schema/shared/src/main/scala/zio/blocks/schema/patch/PatchMode.scala)\n\n## Acceptance Criteria\n\n- [ ] All functional requirements (F1-F6) implemented\n- [ ] All algebraic laws (L1-L7) pass property-based tests\n- [ ] All testing requirements (T1-T10) have corresponding test cases\n- [ ] All documentation requirements (D1-D4) complete\n- [ ] Code reviewed and approved\n- [ ] CI passing\n\n# Sketch\n\n```scala\npackage zio.blocks.schema.json\n\nimport zio.blocks.schema.DynamicOptic\nimport zio.blocks.schema.patch.DynamicPatch\n\n// =============================================================================\n// JSON PATCH\n// =============================================================================\n\n/**\n * An untyped patch that operates on [[Json]] values.\n *\n * `JsonPatch` is the JSON-specific counterpart to [[DynamicPatch]]. It represents\n * a sequence of operations that transform one JSON value into another. Patches\n * are serializable and composable.\n *\n * ==Design==\n *\n * This type directly mirrors [[DynamicPatch]] but is specialized for JSON's\n * simpler data model:\n *  - JSON has 4 leaf types (String, Number, Boolean, Null) vs 30 PrimitiveValues\n *  - JSON objects have string keys only (no arbitrary-keyed maps)\n *  - JSON has no native Variant type\n *\n * ==Algebraic Laws==\n *\n * '''Monoid Laws''' (under `++` composition):\n * {{{\n * // 1. LEFT IDENTITY\n *  p: JsonPatch, j: Json.\n *   (JsonPatch.empty ++ p)(j, mode) == p(j, mode)\n *\n * // 2. RIGHT IDENTITY\n *  p: JsonPatch, j: Json.\n *   (p ++ JsonPatch.empty)(j, mode) == p(j, mode)\n *\n * // 3. ASSOCIATIVITY\n *  p1, p2, p3: JsonPatch, j: Json.\n *   ((p1 ++ p2) ++ p3)(j, mode) == (p1 ++ (p2 ++ p3))(j, mode)\n * }}}\n *\n * '''Diff/Apply Laws''':\n * {{{\n * // 4. ROUNDTRIP\n *  source, target: Json.\n *   JsonPatch.diff(source, target)(source, Strict) == Right(target)\n *\n * // 5. IDENTITY DIFF\n *  j: Json.\n *   JsonPatch.diff(j, j).isEmpty == true\n *\n * // 6. DIFF COMPOSITION\n *  a, b, c: Json.\n *   (JsonPatch.diff(a, b) ++ JsonPatch.diff(b, c))(a, Strict) == Right(c)\n * }}}\n *\n * '''PatchMode Laws''':\n * {{{\n * // 7. STRICT FAILS ON ERROR\n * // Strict mode fails on first precondition violation\n *\n * // 8. LENIENT SKIPS ERRORS\n * // Lenient mode skips failing operations, always returns Right\n *\n * // 9. LENIENT SUBSUMES STRICT\n *  p: JsonPatch, j: Json.\n *   p(j, Strict) == Right(r) implies p(j, Lenient) == Right(r)\n *\n * // 10. CLOBBER FORCES SUCCESS\n * // Clobber mode creates missing paths, always returns Right\n * }}}\n *\n * @param ops The sequence of patch operations\n */\nfinal case class JsonPatch(ops: Vector[JsonPatch.JsonPatchOp]) {\n\n  /**\n   * Applies this patch to a JSON value.\n   *\n   * @param json The JSON value to patch\n   * @param mode The patch mode (default: Strict)\n   * @return Either an error or the patched value\n   */\n  def apply(json: Json, mode: JsonPatchMode = JsonPatchMode.Strict): Either[JsonError, Json]\n\n  /**\n   * Composes this patch with another. Applies this patch first, then `that`.\n   *\n   * This is the monoid `combine` operation.\n   */\n  def ++(that: JsonPatch): JsonPatch = JsonPatch(ops ++ that.ops)\n\n  /**\n   * Returns true if this patch contains no operations.\n   */\n  def isEmpty: Boolean = ops.isEmpty\n\n  /**\n   * Converts this JSON patch to a [[DynamicPatch]].\n   */\n  def toDynamicPatch: DynamicPatch\n}\n\nobject JsonPatch {\n\n  /**\n   * Empty patch  the identity element for `++` composition.\n   */\n  val empty: JsonPatch = JsonPatch(Vector.empty)\n\n  /**\n   * Creates a patch with a single operation at the root path.\n   */\n  def root(op: Op): JsonPatch =\n    JsonPatch(Vector(JsonPatchOp(DynamicOptic.root, op)))\n\n  /**\n   * Creates a patch with a single operation at the given path.\n   */\n  def apply(path: DynamicOptic, op: Op): JsonPatch =\n    JsonPatch(Vector(JsonPatchOp(path, op)))\n\n  /**\n   * Computes a patch that transforms `oldJson` into `newJson`.\n   *\n   * Law: `diff(old, new)(old, Strict) == Right(new)`\n   */\n  def diff(oldJson: Json, newJson: Json): JsonPatch\n\n  /**\n   * Creates a JSON patch from a [[DynamicPatch]].\n   *\n   * May fail if the DynamicPatch contains operations not representable in JSON\n   * (e.g., non-string map keys, temporal deltas, variant operations).\n   */\n  def fromDynamicPatch(patch: DynamicPatch): Either[JsonError, JsonPatch]\n\n  // ===========================================================================\n  // JsonPatchOp  a single operation at a path\n  // ===========================================================================\n\n  /**\n   * A single patch operation: a path and what to do there.\n   *\n   * Mirrors [[DynamicPatch.DynamicPatchOp]].\n   */\n  final case class JsonPatchOp(path: DynamicOptic, op: Op)\n\n  // ===========================================================================\n  // Op  the operation to perform at a path\n  // ===========================================================================\n\n  /**\n   * The operation to perform at a target location.\n   *\n   * Mirrors [[DynamicPatch.Operation]] but specialized for JSON.\n   */\n  sealed trait Op\n\n  object Op {\n\n    /**\n     * Set a value directly (replacement).\n     *\n     * Mirrors [[DynamicPatch.Operation.Set]].\n     */\n    final case class Set(value: Json) extends Op\n\n    /**\n     * Apply a primitive delta operation.\n     *\n     * Used for numeric deltas and string edits.\n     * Mirrors [[DynamicPatch.Operation.PrimitiveDelta]].\n     */\n    final case class PrimitiveDelta(op: PrimitiveOp) extends Op\n\n    /**\n     * Apply array edit operations.\n     *\n     * Used for inserting, appending, deleting, or modifying array elements.\n     * Mirrors [[DynamicPatch.Operation.SequenceEdit]].\n     */\n    final case class ArrayEdit(ops: Vector[ArrayOp]) extends Op\n\n    /**\n     * Apply object edit operations.\n     *\n     * Used for adding, removing, or modifying object fields.\n     * Mirrors [[DynamicPatch.Operation.MapEdit]] but with string keys.\n     */\n    final case class ObjectEdit(ops: Vector[ObjectOp]) extends Op\n\n    /**\n     * Apply a nested patch.\n     *\n     * Used to group operations sharing a common path prefix.\n     * Mirrors [[DynamicPatch.Operation.Patch]].\n     */\n    final case class Nested(patch: JsonPatch) extends Op\n  }\n\n  // ===========================================================================\n  // PrimitiveOp  delta operations for JSON primitives\n  // ===========================================================================\n\n  /**\n   * Delta operations for JSON primitive values.\n   *\n   * JSON has only one numeric type, so we use BigDecimal for deltas.\n   * Boolean has no delta (use Set to toggle).\n   * Null has no delta (use Set to change).\n   *\n   * Mirrors [[DynamicPatch.PrimitiveOp]] but simplified for JSON's type system.\n   */\n  sealed trait PrimitiveOp\n\n  object PrimitiveOp {\n\n    /**\n     * Add a delta to a JSON number.\n     *\n     * Applied by: `currentValue + delta`\n     *\n     * Mirrors the numeric delta operations in [[DynamicPatch.PrimitiveOp]]\n     * (IntDelta, LongDelta, DoubleDelta, etc.) unified into one type.\n     */\n    final case class NumberDelta(delta: BigDecimal) extends PrimitiveOp\n\n    /**\n     * Apply string edit operations.\n     *\n     * Mirrors [[DynamicPatch.PrimitiveOp.StringEdit]].\n     */\n    final case class StringEdit(ops: Vector[StringOp]) extends PrimitiveOp\n  }\n\n  // ===========================================================================\n  // StringOp  edit operations for strings\n  // ===========================================================================\n\n  /**\n   * Edit operations for JSON strings.\n   *\n   * Mirrors [[DynamicPatch.StringOp]] exactly.\n   */\n  sealed trait StringOp\n\n  object StringOp {\n\n    /**\n     * Insert text at the given index.\n     */\n    final case class Insert(index: Int, text: String) extends StringOp\n\n    /**\n     * Delete characters starting at the given index.\n     */\n    final case class Delete(index: Int, length: Int) extends StringOp\n\n    /**\n     * Append text to the end of the string.\n     */\n    final case class Append(text: String) extends StringOp\n\n    /**\n     * Replace characters starting at index with new text.\n     */\n    final case class Modify(index: Int, length: Int, text: String) extends StringOp\n  }\n\n  // ===========================================================================\n  // ArrayOp  edit operations for arrays\n  // ===========================================================================\n\n  /**\n   * Edit operations for JSON arrays.\n   *\n   * Mirrors [[DynamicPatch.SeqOp]] but with Json values.\n   */\n  sealed trait ArrayOp\n\n  object ArrayOp {\n\n    /**\n     * Insert values at the given index.\n     */\n    final case class Insert(index: Int, values: Vector[Json]) extends ArrayOp\n\n    /**\n     * Append values to the end of the array.\n     */\n    final case class Append(values: Vector[Json]) extends ArrayOp\n\n    /**\n     * Delete elements starting at the given index.\n     */\n    final case class Delete(index: Int, count: Int) extends ArrayOp\n\n    /**\n     * Modify the element at the given index with a nested operation.\n     */\n    final case class Modify(index: Int, op: Op) extends ArrayOp\n  }\n\n  // ===========================================================================\n  // ObjectOp  edit operations for objects\n  // ===========================================================================\n\n  /**\n   * Edit operations for JSON objects.\n   *\n   * Mirrors [[DynamicPatch.MapOp]] but with string keys (JSON constraint).\n   */\n  sealed trait ObjectOp\n\n  object ObjectOp {\n\n    /**\n     * Add a field to the object.\n     */\n    final case class Add(key: String, value: Json) extends ObjectOp\n\n    /**\n     * Remove a field from the object.\n     */\n    final case class Remove(key: String) extends ObjectOp\n\n    /**\n     * Modify a field's value with a nested patch.\n     */\n    final case class Modify(key: String, patch: JsonPatch) extends ObjectOp\n  }\n}\n\n// =============================================================================\n// PATCH MODE\n// =============================================================================\n\n/**\n * Controls how patch application handles failures.\n *\n * Mirrors [[zio.blocks.schema.patch.PatchMode]].\n */\nsealed trait JsonPatchMode\n\nobject JsonPatchMode {\n\n  /**\n   * Fail on precondition violations.\n   */\n  case object Strict extends JsonPatchMode\n\n  /**\n   * Skip operations that fail preconditions.\n   */\n  case object Lenient extends JsonPatchMode\n\n  /**\n   * Replace/overwrite on conflicts (create missing paths).\n   */\n  case object Clobber extends JsonPatchMode\n}\n\n// =============================================================================\n// USAGE EXAMPLES\n// =============================================================================\n\n/*\n * ==Example 1: Basic Patching==\n *\n * {{{\n * import zio.blocks.schema.json._\n *\n * val json = Json.Object(Vector(\n *   \"name\" -> Json.String(\"Alice\"),\n *   \"age\" -> Json.Number(\"30\")\n * ))\n *\n * // Replace name\n * val patch = JsonPatch.root(JsonPatch.Op.Set(Json.String(\"Bob\")))\n *   // Or at a specific path:\n *   // JsonPatch(DynamicOptic.root.field(\"name\"), JsonPatch.Op.Set(Json.String(\"Bob\")))\n *\n * val result = patch(json, JsonPatchMode.Strict)\n * }}}\n *\n * ==Example 2: Diff and Apply (Roundtrip Law)==\n *\n * {{{\n * val source = Json.Object(Vector(\"x\" -> Json.Number(\"1\")))\n * val target = Json.Object(Vector(\"x\" -> Json.Number(\"5\")))\n *\n * val patch = JsonPatch.diff(source, target)\n *\n * // Roundtrip law\n * assert(patch(source, JsonPatchMode.Strict) == Right(target))\n *\n * // Identity diff law\n * assert(JsonPatch.diff(source, source).isEmpty)\n * }}}\n *\n * ==Example 3: Monoid Laws==\n *\n * {{{\n * val p1 = JsonPatch.diff(a, b)\n * val p2 = JsonPatch.diff(b, c)\n * val p3 = JsonPatch.diff(c, d)\n *\n * // Left identity\n * assert((JsonPatch.empty ++ p1)(a, Strict) == p1(a, Strict))\n *\n * // Right identity\n * assert((p1 ++ JsonPatch.empty)(a, Strict) == p1(a, Strict))\n *\n * // Associativity\n * assert(((p1 ++ p2) ++ p3)(a, Strict) == (p1 ++ (p2 ++ p3))(a, Strict))\n * }}}\n *\n * ==Example 4: Numeric Delta==\n *\n * {{{\n * val json = Json.Number(\"10\")\n *\n * // Add 5 to the number (more efficient than Set for large structures)\n * val patch = JsonPatch.root(\n *   JsonPatch.Op.PrimitiveDelta(JsonPatch.PrimitiveOp.NumberDelta(BigDecimal(5)))\n * )\n *\n * assert(patch(json, Strict) == Right(Json.Number(\"15\")))\n * }}}\n *\n * ==Example 5: String Edit==\n *\n * {{{\n * val json = Json.String(\"hello world\")\n *\n * // Change \"hello\" to \"hi\" using LCS-based edits\n * val patch = JsonPatch.root(\n *   JsonPatch.Op.PrimitiveDelta(\n *     JsonPatch.PrimitiveOp.StringEdit(Vector(\n *       JsonPatch.StringOp.Delete(0, 5),\n *       JsonPatch.StringOp.Insert(0, \"hi\")\n *     ))\n *   )\n * )\n *\n * assert(patch(json, Strict) == Right(Json.String(\"hi world\")))\n * }}}\n *\n * ==Example 6: Array Edit==\n *\n * {{{\n * val json = Json.Array(Vector(Json.Number(\"1\"), Json.Number(\"2\"), Json.Number(\"3\")))\n *\n * // Delete element at index 1, append new element\n * val patch = JsonPatch.root(\n *   JsonPatch.Op.ArrayEdit(Vector(\n *     JsonPatch.ArrayOp.Delete(1, 1),\n *     JsonPatch.ArrayOp.Append(Vector(Json.Number(\"4\")))\n *   ))\n * )\n *\n * // Result: [1, 3, 4]\n * }}}\n *\n * ==Example 7: Object Edit==\n *\n * {{{\n * val json = Json.Object(Vector(\"a\" -> Json.Number(\"1\"), \"b\" -> Json.Number(\"2\")))\n *\n * // Remove field \"a\", add field \"c\"\n * val patch = JsonPatch.root(\n *   JsonPatch.Op.ObjectEdit(Vector(\n *     JsonPatch.ObjectOp.Remove(\"a\"),\n *     JsonPatch.ObjectOp.Add(\"c\", Json.Number(\"3\"))\n *   ))\n * )\n *\n * // Result: {\"b\": 2, \"c\": 3}\n * }}}\n *\n * ==Example 8: Nested Patch==\n *\n * {{{\n * val json = Json.Object(Vector(\n *   \"user\" -> Json.Object(Vector(\n *     \"name\" -> Json.String(\"Alice\"),\n *     \"age\" -> Json.Number(\"30\")\n *   ))\n * ))\n *\n * // Patch nested inside \"user\"\n * val innerPatch = JsonPatch(Vector(\n *   JsonPatch.JsonPatchOp(\n *     DynamicOptic.root.field(\"age\"),\n *     JsonPatch.Op.PrimitiveDelta(JsonPatch.PrimitiveOp.NumberDelta(BigDecimal(1)))\n *   )\n * ))\n *\n * val patch = JsonPatch(\n *   DynamicOptic.root.field(\"user\"),\n *   JsonPatch.Op.Nested(innerPatch)\n * )\n *\n * // Increments user.age by 1\n * }}}\n *\n * ==Example 9: Diff Composition Law==\n *\n * {{{\n * val a = Json.Number(\"1\")\n * val b = Json.Number(\"5\")\n * val c = Json.Number(\"10\")\n *\n * val p1 = JsonPatch.diff(a, b)  // delta +4\n * val p2 = JsonPatch.diff(b, c)  // delta +5\n *\n * // Composition law: applying composed patch equals applying sequentially\n * assert((p1 ++ p2)(a, Strict) == Right(c))\n * }}}\n *\n * ==Example 10: PatchMode Behavior==\n *\n * {{{\n * val json = Json.Object(Vector(\"a\" -> Json.Number(\"1\")))\n *\n * // Try to remove non-existent field\n * val patch = JsonPatch.root(\n *   JsonPatch.Op.ObjectEdit(Vector(JsonPatch.ObjectOp.Remove(\"nonexistent\")))\n * )\n *\n * // Strict: fails\n * assert(patch(json, JsonPatchMode.Strict).isLeft)\n *\n * // Lenient: skips, returns unchanged\n * assert(patch(json, JsonPatchMode.Lenient) == Right(json))\n *\n * // Clobber: skips (nothing to clobber), returns unchanged\n * assert(patch(json, JsonPatchMode.Clobber) == Right(json))\n * }}}\n */\n```",
                  "html_url": "https://github.com/zio/zio-blocks/issues/685"
                },
                "type": "github"
              },
              "hash": "zio/zio-blocks#685",
              "body": "<html><head></head><body><h1>Add <code>JsonPatch</code> type for diffing and patching JSON values</h1>\n<h2>Summary</h2>\n<p>Implement a <code>JsonPatch</code> type that enables computing diffs between JSON values and applying patches to transform one JSON value into another. This type should mirror the existing <code>DynamicPatch</code> implementation, adapted for JSON's simpler data model.</p>\n<h2>Motivation</h2>\n<p><code>DynamicValue</code> has a well-designed <code>DynamicPatch</code> system with:</p>\n<ul>\n<li>Monoid composition (<code>++</code> with <code>empty</code> identity)</li>\n<li>LCS-based sequence diffing</li>\n<li>Primitive delta operations (numeric deltas, string edits)</li>\n<li>Comprehensive algebraic laws verified by property tests</li>\n</ul>\n<p>The proposed <code>Json</code> type (see #TBD) needs equivalent patching capabilities. Rather than converting <code>Json  DynamicValue</code> for every patch operation, a native <code>JsonPatch</code> provides:</p>\n<ul>\n<li>Type safety (no conversion errors for JSON-incompatible DynamicPatch operations)</li>\n<li>API consistency with the <code>Json</code> type</li>\n<li>Potential for JSON-specific optimizations</li>\n</ul>\n<h2>Design Sketch</h2>\n<p>A design sketch is available at <a href=\"https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/json/JsonPatch.scala\"><code>schema/shared/src/main/scala/zio/blocks/schema/json/JsonPatch.scala</code></a>. This sketch is <strong>a guide, not a specification</strong>  implementers should use judgment and deviate where appropriate.</p>\n<h3>Core Types</h3>\n<p>The design mirrors <code>DynamicPatch</code> with JSON-specific adaptations:</p>\n\nDynamicPatch | JsonPatch | Notes\n-- | -- | --\nDynamicPatch(Vector[DynamicPatchOp]) | JsonPatch(Vector[JsonPatchOp]) | Same structure\nOperation.Set | Op.Set | Same\nOperation.PrimitiveDelta | Op.PrimitiveDelta | Simplified for JSON types\nOperation.SequenceEdit | Op.ArrayEdit | Renamed\nOperation.MapEdit | Op.ObjectEdit | String keys only\nOperation.Patch | Op.Nested | Same\nSeqOp | ArrayOp | Same operations\nMapOp | ObjectOp | String keys only\nPrimitiveOp (14 variants) | PrimitiveOp (2 variants) | See below\n\n\n<h3>StringOp</h3>\n<p>Mirror <code>DynamicPatch.StringOp</code> exactly:</p>\n<ul>\n<li><code>Insert(index: Int, text: String)</code></li>\n<li><code>Delete(index: Int, length: Int)</code></li>\n<li><code>Append(text: String)</code></li>\n<li><code>Modify(index: Int, length: Int, text: String)</code></li>\n</ul>\n<h3>ArrayOp</h3>\n<p>Mirror <code>DynamicPatch.SeqOp</code>:</p>\n<ul>\n<li><code>Insert(index: Int, values: Vector[Json])</code></li>\n<li><code>Append(values: Vector[Json])</code></li>\n<li><code>Delete(index: Int, count: Int)</code></li>\n<li><code>Modify(index: Int, op: Op)</code></li>\n</ul>\n<h3>ObjectOp</h3>\n<p>Mirror <code>DynamicPatch.MapOp</code> with string keys:</p>\n<ul>\n<li><code>Add(key: String, value: Json)</code></li>\n<li><code>Remove(key: String)</code></li>\n<li><code>Modify(key: String, patch: JsonPatch)</code></li>\n</ul>\n<h2>Requirements</h2>\n<h3>Functional Requirements</h3>\n<ul>\n<li>[ ] <strong>F1</strong>: <code>JsonPatch.diff(source, target)</code> computes a patch transforming source to target</li>\n<li>[ ] <strong>F2</strong>: <code>patch.apply(json, mode)</code> applies a patch with configurable failure handling</li>\n<li>[ ] <strong>F3</strong>: <code>patch1 ++ patch2</code> composes patches (apply first, then second)</li>\n<li>[ ] <strong>F4</strong>: <code>JsonPatch.empty</code> is the identity element for composition</li>\n<li>[ ] <strong>F5</strong>: Support <code>JsonPatchMode.Strict</code>, <code>Lenient</code>, and <code>Clobber</code> modes</li>\n<li>[ ] <strong>F6</strong>: Bidirectional conversion: <code>toDynamicPatch</code> / <code>fromDynamicPatch</code></li>\n</ul>\n<h3>Algebraic Laws</h3>\n<p>All laws must be verified with property-based tests (see <code>PatchLawsSpec</code> for reference):</p>\n<ul>\n<li>[ ] <strong>L1</strong>: Left identity  <code>(empty ++ p)(j) == p(j)</code></li>\n<li>[ ] <strong>L2</strong>: Right identity  <code>(p ++ empty)(j) == p(j)</code></li>\n<li>[ ] <strong>L3</strong>: Associativity  <code>((p1 ++ p2) ++ p3)(j) == (p1 ++ (p2 ++ p3))(j)</code></li>\n<li>[ ] <strong>L4</strong>: Roundtrip  <code>diff(a, b)(a) == Right(b)</code></li>\n<li>[ ] <strong>L5</strong>: Identity diff  <code>diff(j, j).isEmpty</code></li>\n<li>[ ] <strong>L6</strong>: Diff composition  <code>(diff(a, b) ++ diff(b, c))(a) == Right(c)</code></li>\n<li>[ ] <strong>L7</strong>: Lenient subsumes Strict  if <code>p(j, Strict) == Right(r)</code> then <code>p(j, Lenient) == Right(r)</code></li>\n</ul>\n<h3>Testing Requirements</h3>\n<ul>\n<li>[ ] <strong>T1</strong>: Property-based tests for all algebraic laws (see <code>PatchLawsSpec</code>)</li>\n<li>[ ] <strong>T2</strong>: Test each operation type (<code>Set</code>, <code>PrimitiveDelta</code>, <code>ArrayEdit</code>, <code>ObjectEdit</code>, <code>Nested</code>)</li>\n<li>[ ] <strong>T3</strong>: Test each <code>ArrayOp</code> variant (<code>Insert</code>, <code>Append</code>, <code>Delete</code>, <code>Modify</code>)</li>\n<li>[ ] <strong>T4</strong>: Test each <code>ObjectOp</code> variant (<code>Add</code>, <code>Remove</code>, <code>Modify</code>)</li>\n<li>[ ] <strong>T5</strong>: Test each <code>StringOp</code> variant (<code>Insert</code>, <code>Delete</code>, <code>Append</code>, <code>Modify</code>)</li>\n<li>[ ] <strong>T6</strong>: Test <code>NumberDelta</code> with positive, negative, zero, and decimal deltas</li>\n<li>[ ] <strong>T7</strong>: Test all three <code>JsonPatchMode</code> behaviors</li>\n<li>[ ] <strong>T8</strong>: Test <code>toDynamicPatch</code> / <code>fromDynamicPatch</code> roundtrip</li>\n<li>[ ] <strong>T9</strong>: Test edge cases: empty arrays, empty objects, empty strings, nested structures</li>\n<li>[ ] <strong>T10</strong>: Test error cases: invalid paths, type mismatches, out-of-bounds indices</li>\n</ul>\n<h3>Documentation Requirements</h3>\n<ul>\n<li>[ ] <strong>D1</strong>: ScalaDoc for all public types and methods</li>\n<li>[ ] <strong>D2</strong>: Usage examples in ScalaDoc (see sketch for examples)</li>\n<li>[ ] <strong>D3</strong>: Document algebraic laws in type-level comments</li>\n<li>[ ] <strong>D4</strong>: Document relationship to <code>DynamicPatch</code></li>\n</ul>\n<h3>Implementation Notes</h3>\n<ol>\n<li>\n<p><strong>Follow <code>DynamicPatch</code> patterns</strong>: The implementation in <code>DynamicPatch.scala</code> is the reference. Study <code>Differ.scala</code> for diff algorithms (especially LCS for sequences and strings).</p>\n</li>\n<li>\n<p><strong>Reuse algorithms where possible</strong>: Consider whether <code>JsonPatch</code> can delegate to <code>DynamicPatch</code> internally, or share algorithm implementations.</p>\n</li>\n<li>\n<p><strong>Keep it minimal</strong>: Resist adding operations not present in <code>DynamicPatch</code>. The design is intentionally minimal and principled.</p>\n</li>\n<li>\n<p><strong>Performance considerations</strong>: The register-based design of ZIO Blocks prioritizes performance. Avoid unnecessary allocations in hot paths.</p>\n</li>\n</ol>\n<h2>Out of Scope</h2>\n<p>The following are explicitly <strong>not</strong> part of this issue:</p>\n<ul>\n<li>RFC 6902 JSON Patch serialization format (separate issue)</li>\n<li>Patch inversion / undo support (separate issue)</li>\n<li>Patch optimization / compaction (separate issue)</li>\n<li>Integration with <code>Json</code> type methods like <code>json.diff(other)</code> (depends on <code>Json</code> implementation)</li>\n</ul>\n<h2>Related</h2>\n<ul>\n<li><code>DynamicPatch</code>  <a href=\"https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/DynamicPatch.scala\"><code>schema/shared/src/main/scala/zio/blocks/schema/patch/DynamicPatch.scala</code></a></li>\n<li><code>Differ</code>  <a href=\"https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/Differ.scala\"><code>schema/shared/src/main/scala/zio/blocks/schema/patch/Differ.scala</code></a></li>\n<li><code>PatchLawsSpec</code>  <a href=\"https://claude.ai/chat/schema/shared/src/test/scala/zio/blocks/schema/patch/PatchLawsSpec.scala\"><code>schema/shared/src/test/scala/zio/blocks/schema/patch/PatchLawsSpec.scala</code></a></li>\n<li><code>PatchMode</code>  <a href=\"https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/PatchMode.scala\"><code>schema/shared/src/main/scala/zio/blocks/schema/patch/PatchMode.scala</code></a></li>\n</ul>\n<h2>Acceptance Criteria</h2>\n<ul>\n<li>[ ] All functional requirements (F1-F6) implemented</li>\n<li>[ ] All algebraic laws (L1-L7) pass property-based tests</li>\n<li>[ ] All testing requirements (T1-T10) have corresponding test cases</li>\n<li>[ ] All documentation requirements (D1-D4) complete</li>\n<li>[ ] Code reviewed and approved</li>\n<li>[ ] CI passing</li>\n</ul></body></html># Add `JsonPatch` type for diffing and patching JSON values\n\n## Summary\n\nImplement a `JsonPatch` type that enables computing diffs between JSON values and applying patches to transform one JSON value into another. This type should mirror the existing `DynamicPatch` implementation, adapted for JSON's simpler data model.\n\n## Motivation\n\n`DynamicValue` has a well-designed `DynamicPatch` system with:\n- Monoid composition (`++` with `empty` identity)\n- LCS-based sequence diffing\n- Primitive delta operations (numeric deltas, string edits)\n- Comprehensive algebraic laws verified by property tests\n\nThe proposed `Json` type (see #TBD) needs equivalent patching capabilities. Rather than converting `Json  DynamicValue` for every patch operation, a native `JsonPatch` provides:\n- Type safety (no conversion errors for JSON-incompatible DynamicPatch operations)\n- API consistency with the `Json` type\n- Potential for JSON-specific optimizations\n\n## Design Sketch\n\nA design sketch is available at [`[schema/shared/src/main/scala/zio/blocks/schema/json/JsonPatch.scala](https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/json/JsonPatch.scala)`](./schema/shared/src/main/scala/zio/blocks/schema/json/JsonPatch.scala). This sketch is **a guide, not a specification**  implementers should use judgment and deviate where appropriate.\n\n### Core Types\n\nThe design mirrors `DynamicPatch` with JSON-specific adaptations:\n\n| DynamicPatch | JsonPatch | Notes |\n|--------------|-----------|-------|\n| `DynamicPatch(Vector[DynamicPatchOp])` | `JsonPatch(Vector[JsonPatchOp])` | Same structure |\n| `Operation.Set` | `Op.Set` | Same |\n| `Operation.PrimitiveDelta` | `Op.PrimitiveDelta` | Simplified for JSON types |\n| `Operation.SequenceEdit` | `Op.ArrayEdit` | Renamed |\n| `Operation.MapEdit` | `Op.ObjectEdit` | String keys only |\n| `Operation.Patch` | `Op.Nested` | Same |\n| `SeqOp` | `ArrayOp` | Same operations |\n| `MapOp` | `ObjectOp` | String keys only |\n| `PrimitiveOp` (14 variants) | `PrimitiveOp` (2 variants) | See below |\n\n### Primitive Operations\n\nJSON has a simpler type system than `DynamicValue`:\n\n| JSON Type | Delta Operation | Notes |\n|-----------|-----------------|-------|\n| Number | `NumberDelta(BigDecimal)` | Unifies all numeric deltas |\n| String | `StringEdit(Vector[StringOp])` | Same as `DynamicPatch` |\n| Boolean | Use `Op.Set` | No delta (same as `DynamicPatch`) |\n| Null | Use `Op.Set` | No delta |\n\n### StringOp\n\nMirror `DynamicPatch.StringOp` exactly:\n- `Insert(index: Int, text: String)`\n- `Delete(index: Int, length: Int)`\n- `Append(text: String)`\n- `Modify(index: Int, length: Int, text: String)`\n\n### ArrayOp\n\nMirror `DynamicPatch.SeqOp`:\n- `Insert(index: Int, values: Vector[Json])`\n- `Append(values: Vector[Json])`\n- `Delete(index: Int, count: Int)`\n- `Modify(index: Int, op: Op)`\n\n### ObjectOp\n\nMirror `DynamicPatch.MapOp` with string keys:\n- `Add(key: String, value: Json)`\n- `Remove(key: String)`\n- `Modify(key: String, patch: JsonPatch)`\n\n## Requirements\n\n### Functional Requirements\n\n- [ ] **F1**: `JsonPatch.diff(source, target)` computes a patch transforming source to target\n- [ ] **F2**: `patch.apply(json, mode)` applies a patch with configurable failure handling\n- [ ] **F3**: `patch1 ++ patch2` composes patches (apply first, then second)\n- [ ] **F4**: `JsonPatch.empty` is the identity element for composition\n- [ ] **F5**: Support `JsonPatchMode.Strict`, `Lenient`, and `Clobber` modes\n- [ ] **F6**: Bidirectional conversion: `toDynamicPatch` / `fromDynamicPatch`\n\n### Algebraic Laws\n\nAll laws must be verified with property-based tests (see `PatchLawsSpec` for reference):\n\n- [ ] **L1**: Left identity  `(empty ++ p)(j) == p(j)`\n- [ ] **L2**: Right identity  `(p ++ empty)(j) == p(j)`\n- [ ] **L3**: Associativity  `((p1 ++ p2) ++ p3)(j) == (p1 ++ (p2 ++ p3))(j)`\n- [ ] **L4**: Roundtrip  `diff(a, b)(a) == Right(b)`\n- [ ] **L5**: Identity diff  `diff(j, j).isEmpty`\n- [ ] **L6**: Diff composition  `(diff(a, b) ++ diff(b, c))(a) == Right(c)`\n- [ ] **L7**: Lenient subsumes Strict  if `p(j, Strict) == Right(r)` then `p(j, Lenient) == Right(r)`\n\n### Testing Requirements\n\n- [ ] **T1**: Property-based tests for all algebraic laws (see `PatchLawsSpec`)\n- [ ] **T2**: Test each operation type (`Set`, `PrimitiveDelta`, `ArrayEdit`, `ObjectEdit`, `Nested`)\n- [ ] **T3**: Test each `ArrayOp` variant (`Insert`, `Append`, `Delete`, `Modify`)\n- [ ] **T4**: Test each `ObjectOp` variant (`Add`, `Remove`, `Modify`)\n- [ ] **T5**: Test each `StringOp` variant (`Insert`, `Delete`, `Append`, `Modify`)\n- [ ] **T6**: Test `NumberDelta` with positive, negative, zero, and decimal deltas\n- [ ] **T7**: Test all three `JsonPatchMode` behaviors\n- [ ] **T8**: Test `toDynamicPatch` / `fromDynamicPatch` roundtrip\n- [ ] **T9**: Test edge cases: empty arrays, empty objects, empty strings, nested structures\n- [ ] **T10**: Test error cases: invalid paths, type mismatches, out-of-bounds indices\n\n### Documentation Requirements\n\n- [ ] **D1**: ScalaDoc for all public types and methods\n- [ ] **D2**: Usage examples in ScalaDoc (see sketch for examples)\n- [ ] **D3**: Document algebraic laws in type-level comments\n- [ ] **D4**: Document relationship to `DynamicPatch`\n\n## Related\n\n- `DynamicPatch`  [`[schema/shared/src/main/scala/zio/blocks/schema/patch/DynamicPatch.scala](https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/DynamicPatch.scala)`](./schema/shared/src/main/scala/zio/blocks/schema/patch/DynamicPatch.scala)\n- `Differ`  [`[schema/shared/src/main/scala/zio/blocks/schema/patch/Differ.scala](https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/Differ.scala)`](./schema/shared/src/main/scala/zio/blocks/schema/patch/Differ.scala)\n- `PatchLawsSpec`  [`[schema/shared/src/test/scala/zio/blocks/schema/patch/PatchLawsSpec.scala](https://claude.ai/chat/schema/shared/src/test/scala/zio/blocks/schema/patch/PatchLawsSpec.scala)`](./schema/shared/src/test/scala/zio/blocks/schema/patch/PatchLawsSpec.scala)\n- `PatchMode`  [`[schema/shared/src/main/scala/zio/blocks/schema/patch/PatchMode.scala](https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/PatchMode.scala)`](./schema/shared/src/main/scala/zio/blocks/schema/patch/PatchMode.scala)\n\n## Acceptance Criteria\n\n- [ ] All functional requirements (F1-F6) implemented\n- [ ] All algebraic laws (L1-L7) pass property-based tests\n- [ ] All testing requirements (T1-T10) have corresponding test cases\n- [ ] All documentation requirements (D1-D4) complete\n- [ ] Code reviewed and approved\n- [ ] CI passing\n\n# Sketch\n\n```scala\npackage zio.blocks.schema.json\n\nimport zio.blocks.schema.DynamicOptic\nimport zio.blocks.schema.patch.DynamicPatch\n\n// =============================================================================\n// JSON PATCH\n// =============================================================================\n\n/**\n * An untyped patch that operates on [[Json]] values.\n *\n * `JsonPatch` is the JSON-specific counterpart to [[DynamicPatch]]. It represents\n * a sequence of operations that transform one JSON value into another. Patches\n * are serializable and composable.\n *\n * ==Design==\n *\n * This type directly mirrors [[DynamicPatch]] but is specialized for JSON's\n * simpler data model:\n *  - JSON has 4 leaf types (String, Number, Boolean, Null) vs 30 PrimitiveValues\n *  - JSON objects have string keys only (no arbitrary-keyed maps)\n *  - JSON has no native Variant type\n *\n * ==Algebraic Laws==\n *\n * '''Monoid Laws''' (under `++` composition):\n * {{{\n * // 1. LEFT IDENTITY\n *  p: JsonPatch, j: Json.\n *   (JsonPatch.empty ++ p)(j, mode) == p(j, mode)\n *\n * // 2. RIGHT IDENTITY\n *  p: JsonPatch, j: Json.\n *   (p ++ JsonPatch.empty)(j, mode) == p(j, mode)\n *\n * // 3. ASSOCIATIVITY\n *  p1, p2, p3: JsonPatch, j: Json.\n *   ((p1 ++ p2) ++ p3)(j, mode) == (p1 ++ (p2 ++ p3))(j, mode)\n * }}}\n *\n * '''Diff/Apply Laws''':\n * {{{\n * // 4. ROUNDTRIP\n *  source, target: Json.\n *   JsonPatch.diff(source, target)(source, Strict) == Right(target)\n *\n * // 5. IDENTITY DIFF\n *  j: Json.\n *   JsonPatch.diff(j, j).isEmpty == true\n *\n * // 6. DIFF COMPOSITION\n *  a, b, c: Json.\n *   (JsonPatch.diff(a, b) ++ JsonPatch.diff(b, c))(a, Strict) == Right(c)\n * }}}\n *\n * '''PatchMode Laws''':\n * {{{\n * // 7. STRICT FAILS ON ERROR\n * // Strict mode fails on first precondition violation\n *\n * // 8. LENIENT SKIPS ERRORS\n * // Lenient mode skips failing operations, always returns Right\n *\n * // 9. LENIENT SUBSUMES STRICT\n *  p: JsonPatch, j: Json.\n *   p(j, Strict) == Right(r) implies p(j, Lenient) == Right(r)\n *\n * // 10. CLOBBER FORCES SUCCESS\n * // Clobber mode creates missing paths, always returns Right\n * }}}\n *\n * @param ops The sequence of patch operations\n */\nfinal case class JsonPatch(ops: Vector[JsonPatch.JsonPatchOp]) {\n\n  /**\n   * Applies this patch to a JSON value.\n   *\n   * @param json The JSON value to patch\n   * @param mode The patch mode (default: Strict)\n   * @return Either an error or the patched value\n   */\n  def apply(json: Json, mode: JsonPatchMode = JsonPatchMode.Strict): Either[JsonError, Json]\n\n  /**\n   * Composes this patch with another. Applies this patch first, then `that`.\n   *\n   * This is the monoid `combine` operation.\n   */\n  def ++(that: JsonPatch): JsonPatch = JsonPatch(ops ++ that.ops)\n\n  /**\n   * Returns true if this patch contains no operations.\n   */\n  def isEmpty: Boolean = ops.isEmpty\n\n  /**\n   * Converts this JSON patch to a [[DynamicPatch]].\n   */\n  def toDynamicPatch: DynamicPatch\n}\n\nobject JsonPatch {\n\n  /**\n   * Empty patch  the identity element for `++` composition.\n   */\n  val empty: JsonPatch = JsonPatch(Vector.empty)\n\n  /**\n   * Creates a patch with a single operation at the root path.\n   */\n  def root(op: Op): JsonPatch =\n    JsonPatch(Vector(JsonPatchOp(DynamicOptic.root, op)))\n\n  /**\n   * Creates a patch with a single operation at the given path.\n   */\n  def apply(path: DynamicOptic, op: Op): JsonPatch =\n    JsonPatch(Vector(JsonPatchOp(path, op)))\n\n  /**\n   * Computes a patch that transforms `oldJson` into `newJson`.\n   *\n   * Law: `diff(old, new)(old, Strict) == Right(new)`\n   */\n  def diff(oldJson: Json, newJson: Json): JsonPatch\n\n  /**\n   * Creates a JSON patch from a [[DynamicPatch]].\n   *\n   * May fail if the DynamicPatch contains operations not representable in JSON\n   * (e.g., non-string map keys, temporal deltas, variant operations).\n   */\n  def fromDynamicPatch(patch: DynamicPatch): Either[JsonError, JsonPatch]\n\n  // ===========================================================================\n  // JsonPatchOp  a single operation at a path\n  // ===========================================================================\n\n  /**\n   * A single patch operation: a path and what to do there.\n   *\n   * Mirrors [[DynamicPatch.DynamicPatchOp]].\n   */\n  final case class JsonPatchOp(path: DynamicOptic, op: Op)\n\n  // ===========================================================================\n  // Op  the operation to perform at a path\n  // ===========================================================================\n\n  /**\n   * The operation to perform at a target location.\n   *\n   * Mirrors [[DynamicPatch.Operation]] but specialized for JSON.\n   */\n  sealed trait Op\n\n  object Op {\n\n    /**\n     * Set a value directly (replacement).\n     *\n     * Mirrors [[DynamicPatch.Operation.Set]].\n     */\n    final case class Set(value: Json) extends Op\n\n    /**\n     * Apply a primitive delta operation.\n     *\n     * Used for numeric deltas and string edits.\n     * Mirrors [[DynamicPatch.Operation.PrimitiveDelta]].\n     */\n    final case class PrimitiveDelta(op: PrimitiveOp) extends Op\n\n    /**\n     * Apply array edit operations.\n     *\n     * Used for inserting, appending, deleting, or modifying array elements.\n     * Mirrors [[DynamicPatch.Operation.SequenceEdit]].\n     */\n    final case class ArrayEdit(ops: Vector[ArrayOp]) extends Op\n\n    /**\n     * Apply object edit operations.\n     *\n     * Used for adding, removing, or modifying object fields.\n     * Mirrors [[DynamicPatch.Operation.MapEdit]] but with string keys.\n     */\n    final case class ObjectEdit(ops: Vector[ObjectOp]) extends Op\n\n    /**\n     * Apply a nested patch.\n     *\n     * Used to group operations sharing a common path prefix.\n     * Mirrors [[DynamicPatch.Operation.Patch]].\n     */\n    final case class Nested(patch: JsonPatch) extends Op\n  }\n\n  // ===========================================================================\n  // PrimitiveOp  delta operations for JSON primitives\n  // ===========================================================================\n\n  /**\n   * Delta operations for JSON primitive values.\n   *\n   * JSON has only one numeric type, so we use BigDecimal for deltas.\n   * Boolean has no delta (use Set to toggle).\n   * Null has no delta (use Set to change).\n   *\n   * Mirrors [[DynamicPatch.PrimitiveOp]] but simplified for JSON's type system.\n   */\n  sealed trait PrimitiveOp\n\n  object PrimitiveOp {\n\n    /**\n     * Add a delta to a JSON number.\n     *\n     * Applied by: `currentValue + delta`\n     *\n     * Mirrors the numeric delta operations in [[DynamicPatch.PrimitiveOp]]\n     * (IntDelta, LongDelta, DoubleDelta, etc.) unified into one type.\n     */\n    final case class NumberDelta(delta: BigDecimal) extends PrimitiveOp\n\n    /**\n     * Apply string edit operations.\n     *\n     * Mirrors [[DynamicPatch.PrimitiveOp.StringEdit]].\n     */\n    final case class StringEdit(ops: Vector[StringOp]) extends PrimitiveOp\n  }\n\n  // ===========================================================================\n  // StringOp  edit operations for strings\n  // ===========================================================================\n\n  /**\n   * Edit operations for JSON strings.\n   *\n   * Mirrors [[DynamicPatch.StringOp]] exactly.\n   */\n  sealed trait StringOp\n\n  object StringOp {\n\n    /**\n     * Insert text at the given index.\n     */\n    final case class Insert(index: Int, text: String) extends StringOp\n\n    /**\n     * Delete characters starting at the given index.\n     */\n    final case class Delete(index: Int, length: Int) extends StringOp\n\n    /**\n     * Append text to the end of the string.\n     */\n    final case class Append(text: String) extends StringOp\n\n    /**\n     * Replace characters starting at index with new text.\n     */\n    final case class Modify(index: Int, length: Int, text: String) extends StringOp\n  }\n\n  // ===========================================================================\n  // ArrayOp  edit operations for arrays\n  // ===========================================================================\n\n  /**\n   * Edit operations for JSON arrays.\n   *\n   * Mirrors [[DynamicPatch.SeqOp]] but with Json values.\n   */\n  sealed trait ArrayOp\n\n  object ArrayOp {\n\n    /**\n     * Insert values at the given index.\n     */\n    final case class Insert(index: Int, values: Vector[Json]) extends ArrayOp\n\n    /**\n     * Append values to the end of the array.\n     */\n    final case class Append(values: Vector[Json]) extends ArrayOp\n\n    /**\n     * Delete elements starting at the given index.\n     */\n    final case class Delete(index: Int, count: Int) extends ArrayOp\n\n    /**\n     * Modify the element at the given index with a nested operation.\n     */\n    final case class Modify(index: Int, op: Op) extends ArrayOp\n  }\n\n  // ===========================================================================\n  // ObjectOp  edit operations for objects\n  // ===========================================================================\n\n  /**\n   * Edit operations for JSON objects.\n   *\n   * Mirrors [[DynamicPatch.MapOp]] but with string keys (JSON constraint).\n   */\n  sealed trait ObjectOp\n\n  object ObjectOp {\n\n    /**\n     * Add a field to the object.\n     */\n    final case class Add(key: String, value: Json) extends ObjectOp\n\n    /**\n     * Remove a field from the object.\n     */\n    final case class Remove(key: String) extends ObjectOp\n\n    /**\n     * Modify a field's value with a nested patch.\n     */\n    final case class Modify(key: String, patch: JsonPatch) extends ObjectOp\n  }\n}\n\n// =============================================================================\n// PATCH MODE\n// =============================================================================\n\n/**\n * Controls how patch application handles failures.\n *\n * Mirrors [[zio.blocks.schema.patch.PatchMode]].\n */\nsealed trait JsonPatchMode\n\nobject JsonPatchMode {\n\n  /**\n   * Fail on precondition violations.\n   */\n  case object Strict extends JsonPatchMode\n\n  /**\n   * Skip operations that fail preconditions.\n   */\n  case object Lenient extends JsonPatchMode\n\n  /**\n   * Replace/overwrite on conflicts (create missing paths).\n   */\n  case object Clobber extends JsonPatchMode\n}\n\n// =============================================================================\n// USAGE EXAMPLES\n// =============================================================================\n\n/*\n * ==Example 1: Basic Patching==\n *\n * {{{\n * import zio.blocks.schema.json._\n *\n * val json = Json.Object(Vector(\n *   \"name\" -> Json.String(\"Alice\"),\n *   \"age\" -> Json.Number(\"30\")\n * ))\n *\n * // Replace name\n * val patch = JsonPatch.root(JsonPatch.Op.Set(Json.String(\"Bob\")))\n *   // Or at a specific path:\n *   // JsonPatch(DynamicOptic.root.field(\"name\"), JsonPatch.Op.Set(Json.String(\"Bob\")))\n *\n * val result = patch(json, JsonPatchMode.Strict)\n * }}}\n *\n * ==Example 2: Diff and Apply (Roundtrip Law)==\n *\n * {{{\n * val source = Json.Object(Vector(\"x\" -> Json.Number(\"1\")))\n * val target = Json.Object(Vector(\"x\" -> Json.Number(\"5\")))\n *\n * val patch = JsonPatch.diff(source, target)\n *\n * // Roundtrip law\n * assert(patch(source, JsonPatchMode.Strict) == Right(target))\n *\n * // Identity diff law\n * assert(JsonPatch.diff(source, source).isEmpty)\n * }}}\n *\n * ==Example 3: Monoid Laws==\n *\n * {{{\n * val p1 = JsonPatch.diff(a, b)\n * val p2 = JsonPatch.diff(b, c)\n * val p3 = JsonPatch.diff(c, d)\n *\n * // Left identity\n * assert((JsonPatch.empty ++ p1)(a, Strict) == p1(a, Strict))\n *\n * // Right identity\n * assert((p1 ++ JsonPatch.empty)(a, Strict) == p1(a, Strict))\n *\n * // Associativity\n * assert(((p1 ++ p2) ++ p3)(a, Strict) == (p1 ++ (p2 ++ p3))(a, Strict))\n * }}}\n *\n * ==Example 4: Numeric Delta==\n *\n * {{{\n * val json = Json.Number(\"10\")\n *\n * // Add 5 to the number (more efficient than Set for large structures)\n * val patch = JsonPatch.root(\n *   JsonPatch.Op.PrimitiveDelta(JsonPatch.PrimitiveOp.NumberDelta(BigDecimal(5)))\n * )\n *\n * assert(patch(json, Strict) == Right(Json.Number(\"15\")))\n * }}}\n *\n * ==Example 5: String Edit==\n *\n * {{{\n * val json = Json.String(\"hello world\")\n *\n * // Change \"hello\" to \"hi\" using LCS-based edits\n * val patch = JsonPatch.root(\n *   JsonPatch.Op.PrimitiveDelta(\n *     JsonPatch.PrimitiveOp.StringEdit(Vector(\n *       JsonPatch.StringOp.Delete(0, 5),\n *       JsonPatch.StringOp.Insert(0, \"hi\")\n *     ))\n *   )\n * )\n *\n * assert(patch(json, Strict) == Right(Json.String(\"hi world\")))\n * }}}\n *\n * ==Example 6: Array Edit==\n *\n * {{{\n * val json = Json.Array(Vector(Json.Number(\"1\"), Json.Number(\"2\"), Json.Number(\"3\")))\n *\n * // Delete element at index 1, append new element\n * val patch = JsonPatch.root(\n *   JsonPatch.Op.ArrayEdit(Vector(\n *     JsonPatch.ArrayOp.Delete(1, 1),\n *     JsonPatch.ArrayOp.Append(Vector(Json.Number(\"4\")))\n *   ))\n * )\n *\n * // Result: [1, 3, 4]\n * }}}\n *\n * ==Example 7: Object Edit==\n *\n * {{{\n * val json = Json.Object(Vector(\"a\" -> Json.Number(\"1\"), \"b\" -> Json.Number(\"2\")))\n *\n * // Remove field \"a\", add field \"c\"\n * val patch = JsonPatch.root(\n *   JsonPatch.Op.ObjectEdit(Vector(\n *     JsonPatch.ObjectOp.Remove(\"a\"),\n *     JsonPatch.ObjectOp.Add(\"c\", Json.Number(\"3\"))\n *   ))\n * )\n *\n * // Result: {\"b\": 2, \"c\": 3}\n * }}}\n *\n * ==Example 8: Nested Patch==\n *\n * {{{\n * val json = Json.Object(Vector(\n *   \"user\" -> Json.Object(Vector(\n *     \"name\" -> Json.String(\"Alice\"),\n *     \"age\" -> Json.Number(\"30\")\n *   ))\n * ))\n *\n * // Patch nested inside \"user\"\n * val innerPatch = JsonPatch(Vector(\n *   JsonPatch.JsonPatchOp(\n *     DynamicOptic.root.field(\"age\"),\n *     JsonPatch.Op.PrimitiveDelta(JsonPatch.PrimitiveOp.NumberDelta(BigDecimal(1)))\n *   )\n * ))\n *\n * val patch = JsonPatch(\n *   DynamicOptic.root.field(\"user\"),\n *   JsonPatch.Op.Nested(innerPatch)\n * )\n *\n * // Increments user.age by 1\n * }}}\n *\n * ==Example 9: Diff Composition Law==\n *\n * {{{\n * val a = Json.Number(\"1\")\n * val b = Json.Number(\"5\")\n * val c = Json.Number(\"10\")\n *\n * val p1 = JsonPatch.diff(a, b)  // delta +4\n * val p2 = JsonPatch.diff(b, c)  // delta +5\n *\n * // Composition law: applying composed patch equals applying sequentially\n * assert((p1 ++ p2)(a, Strict) == Right(c))\n * }}}\n *\n * ==Example 10: PatchMode Behavior==\n *\n * {{{\n * val json = Json.Object(Vector(\"a\" -> Json.Number(\"1\")))\n *\n * // Try to remove non-existent field\n * val patch = JsonPatch.root(\n *   JsonPatch.Op.ObjectEdit(Vector(JsonPatch.ObjectOp.Remove(\"nonexistent\")))\n * )\n *\n * // Strict: fails\n * assert(patch(json, JsonPatchMode.Strict).isLeft)\n *\n * // Lenient: skips, returns unchanged\n * assert(patch(json, JsonPatchMode.Lenient) == Right(json))\n *\n * // Clobber: skips (nothing to clobber), returns unchanged\n * assert(patch(json, JsonPatchMode.Clobber) == Right(json))\n * }}}\n */\n```",
              "url": "https://github.com/zio/zio-blocks/issues/685",
              "tech": [],
              "repo_name": "zio-blocks",
              "repo_owner": "zio",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "zio#519",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "zio",
              "id": "generated-zio",
              "name": "Zio",
              "description": "",
              "members": [],
              "display_name": "Zio",
              "created_at": "2026-01-30T03:42:13.351Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/zio?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "zio",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-30T03:42:13.351Z",
            "created_at": "2026-01-30T03:42:13.351Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-zio#519",
              "status": "open",
              "type": "issue",
              "number": 519,
              "title": "Schema Migration System for ZIO Schema 2",
              "source": {
                "data": {
                  "id": "source-zio#519",
                  "user": {
                    "login": "jdegoes",
                    "id": 156745,
                    "node_id": "MDQ6VXNlcjE1Njc0NQ==",
                    "avatar_url": "https://avatars.githubusercontent.com/u/156745?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/jdegoes",
                    "html_url": "https://github.com/jdegoes",
                    "followers_url": "https://api.github.com/users/jdegoes/followers",
                    "following_url": "https://api.github.com/users/jdegoes/following{/other_user}",
                    "gists_url": "https://api.github.com/users/jdegoes/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/jdegoes/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/jdegoes/subscriptions",
                    "organizations_url": "https://api.github.com/users/jdegoes/orgs",
                    "repos_url": "https://api.github.com/users/jdegoes/repos",
                    "events_url": "https://api.github.com/users/jdegoes/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/jdegoes/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Schema Migration System for ZIO Schema 2",
                  "body": "## Overview\n\nImplement a **pure, algebraic migration system** for ZIO Schema 2 that represents **structural transformations between schema versions** as first-class, serializable data.\n\nA migration describes how to transform data from one schema version to another, enabling:\n\n* schema evolution\n* backward / forward compatibility\n* data versioning\n* offline migrations (JSON, SQL, data lakes, registries, etc.)\n\nThe system provides a **typed, macro-validated user API** (`Migration[A, B]`) built on a **pure, serializable core** (`DynamicMigration`) that operates on `DynamicValue`. \n\nThe ADT is fully introspectable and can be used to generate DDL, etc.\n\n## Motivation & Big Picture\n\n### Why structural types?\n\nWhen evolving schemas over time, **older versions of data types should not require runtime representations**.\n\nIn this design:\n\n* **Current versions** are represented by real case classes / enums\n* **Past versions** are represented using:\n\n  * **structural types** for records\n  * **abstract types + intersection types** for sum types\n\nThese types:\n\n* exist **only at compile time**\n* have **no runtime representation**\n* introduce **zero runtime overhead**\n* do **not require optics or instances to be kept around**\n\nThis allows you to describe arbitrarily old versions of data *without polluting your runtime or codebase*.\n\n#### Typical Workflow\n\nA typical workflow looks like:\n\n1. You have a current type:\n\n   ```scala\n   @schema\n   case class Person(name: String, age: Int)\n   ```\n\n2. You derive and copy its structural shape:\n\n   ```scala\n   type PersonV1 = { def name: String; def age: Int }\n   ```\n\n3. You evolve the real type:\n\n   ```scala\n   @schema\n   case class Person(fullName: String, age: Int, country: String)\n   ```\n\n4. You keep only:\n\n   * the **current** runtime type\n   * the **structural type** for the old version\n   * a **pure migration** between them\n\nNo old case classes. No old optics. No runtime baggage.\n\nNote there is no requirement that the \"current\" type actually be a real case class, enum, etc.--so you can work purely with structural types, allowing you to define migrations for data types that are never materialized as runtime structures.\n\n---\n\n### Why pure data migrations?\n\nMigrations are represented entirely as **pure data**:\n\n* no user functions\n* no closures\n* no reflection\n* no runtime code generation\n\nAs a result:\n\n* migrations can be **serialized**\n* stored in **registries**\n* applied **dynamically**\n* inspected and transformed\n* used to generate:\n\n  * upgraders\n  * downgraders\n  * SQL DDL / DML\n  * offline data transforms\n\nWhile code generation is **out of scope for this ticket**, this explains many design decisions (invertibility, path-based actions, no functions).\n\n---\n\n## Core Architecture\n\n### Type Hierarchy\n\n```scala\n// Typed migration (user-facing API)\ncase class Migration[A, B](\n  dynamicMigration: DynamicMigration,\n  sourceSchema: Schema[A], // These are structural schemas!!!\n  targetSchema: Schema[B] // These are structural schemas!!!\n) {\n  /** Apply migration to transform A to B */\n  def apply(value: A): Either[MigrationError, B]\n\n  /** Compose migrations sequentially */\n  def ++[C](that: Migration[B, C]): Migration[A, C]\n\n  /** Alias for ++ */\n  def andThen[C](that: Migration[B, C]): Migration[A, C] = this ++ that\n\n  /** Reverse migration (structural inverse; runtime is best-effort) */\n  def reverse: Migration[B, A]\n}\n```\n\n```scala\n// Untyped migration (pure data, fully serializable)\ncase class DynamicMigration(\n  actions: Vector[MigrationAction]\n) {\n  def apply(value: DynamicValue): Either[MigrationError, DynamicValue]\n  def ++(that: DynamicMigration): DynamicMigration\n  def reverse: DynamicMigration\n}\n```\n\n* `Migration[A, B]` is introspectable, but not pure data due to bindings inside schemas\n* `DynamicMigration` is **fully serializable**\n\n---\n\n## User-Facing API: Selector Expressions\n\n### Selectors, not optics\n\nThe user-facing API **does not expose optics**.\n\nInstead, all locations are specified using **selector expressions**:\n\n```scala\nS => A\n```\n\nExamples:\n\n```scala\n_.name\n_.address.street\n_.addresses.each.streetNumber\n_.country.when[UK]\n```\n\nTo see the syntax, one can look at the `optic` macro, which utilizes the same selector syntax for optic creation (e.g. `optic(_.address.street)`, etc.).\n\n### Macro extraction\n\nAll builder methods that accept selectors are **implemented via macros** (or via a macro-generated type class such as `ToDynamicOptic`).\n\nThe macro:\n\n1. Inspects the selector expression\n2. Validates it is a supported projection\n3. Converts it into a `DynamicOptic`\n4. Stores that optic in the migration action\n\nSupported projections include:\n\n* field access (`_.foo.bar`)\n* case selection (`_.country.when[UK]`)\n* collection traversal (`_.items.each`)\n* (future) key access, wrappers, etc.\n\n`DynamicOptic` is **never exposed publicly**.\n\n---\n\n## Migration Builder\n\nAll selector-accepting methods are implemented via macros. For simplicity, these are shown as functions (e.g. `A => Any`), but this is NOT the way to implement them. Either all these functions need to be macros, or a macro needs to be used to generate an implicit / given at each call site. Macros may do additional validation to constrain the validity of these different types of transformations.\n\n```scala\nclass MigrationBuilder[A, B](\n  sourceSchema: Schema[A],\n  targetSchema: Schema[B],\n  actions: Vector[MigrationAction]\n) {\n\n  // ----- Record operations -----\n\n  def addField(\n    target: B => Any,\n    default: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  def dropField(\n    source: A => Any,\n    defaultForReverse: SchemaExpr[B, ?] = SchemaExpr.DefaultValue\n  ): MigrationBuilder[A, B]\n\n  def renameField(\n    from: A => Any,\n    to: B => Any\n  ): MigrationBuilder[A, B]\n\n  def transformField(\n    from: A => Any,\n    to: B => Any,\n    transform: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  def mandateField(\n    source: A => Option[?],\n    target: B => Any,\n    default: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  def optionalizeField(\n    source: A => Any,\n    target: B => Option[?]\n  ): MigrationBuilder[A, B]\n\n  def changeFieldType(\n    source: A => Any,\n    target: B => Any,\n    converter: SchemaExpr[A, ?]  // primitive-to-primitive only\n  ): MigrationBuilder[A, B]\n\n  // ----- Enum operations (limited) -----\n\n  def renameCase[SumA, SumB](\n    from: String,\n    to: String\n  ): MigrationBuilder[A, B]\n\n  def transformCase[SumA, CaseA, SumB, CaseB](\n    caseMigration: MigrationBuilder[CaseA, CaseB] => MigrationBuilder[CaseA, CaseB]\n  ): MigrationBuilder[A, B]\n\n  // ----- Collections -----\n\n  def transformElements(\n    at: A => Vector[?],\n    transform: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  // ----- Maps -----\n\n  def transformKeys(\n    at: A => Map[?, ?],\n    transform: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  def transformValues(\n    at: A => Map[?, ?],\n    transform: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  /** Build migration with full macro validation */\n  def build: Migration[A, B]\n\n  /** Build migration without full validation */\n  def buildPartial: Migration[A, B]\n}\n```\n\n---\n\n## Migration Actions (Untyped Core)\n\nAll actions operate at a **path**, represented by `DynamicOptic`.\n\n```scala\nsealed trait MigrationAction {\n  def at: DynamicOptic\n  def reverse: MigrationAction\n}\n```\n\n### Record Actions\n\n```scala\ncase class AddField(\n  at: DynamicOptic,\n  default: SchemaExpr[?]\n) extends MigrationAction\n\ncase class DropField(\n  at: DynamicOptic,\n  defaultForReverse: SchemaExpr[?]\n) extends MigrationAction\n\ncase class Rename(\n  at: DynamicOptic,\n  to: String\n) extends MigrationAction\n\ncase class TransformValue(\n  at: DynamicOptic,\n  transform: SchemaExpr[?]\n) extends MigrationAction\n\ncase class Mandate(\n  at: DynamicOptic,\n  default: SchemaExpr[?]\n) extends MigrationAction\n\ncase class Optionalize(\n  at: DynamicOptic\n) extends MigrationAction\n\ncase class Join(\n  at: DynamicOptic,\n  sourcePaths: Vector[DynamicOptic],\n  combiner: SchemaExpr[?]\n) extends MigrationAction\n\ncase class Split(\n  at: DynamicOptic,\n  targetPaths: Vector[DynamicOptic],\n  splitter: SchemaExpr[?]\n) extends MigrationAction\n\ncase class ChangeType(\n  at: DynamicOptic,\n  converter: SchemaExpr[?]\n) extends MigrationAction\n```\n\n---\n\n### Enum Actions (Supported)\n\n```scala\ncase class RenameCase(\n  at: DynamicOptic,\n  from: String,\n  to: String\n) extends MigrationAction\n\ncase class TransformCase(\n  at: DynamicOptic,\n  actions: Vector[MigrationAction]\n) extends MigrationAction\n```\n\n> Enum case addition / removal is **out of scope** for this ticket\n> (requires composite value construction).\n\n---\n\n### Collection / Map Actions\n\n```scala\ncase class TransformElements(\n  at: DynamicOptic,\n  transform: SchemaExpr[?]\n) extends MigrationAction\n\ncase class TransformKeys(\n  at: DynamicOptic,\n  transform: SchemaExpr[?]\n) extends MigrationAction\n\ncase class TransformValues(\n  at: DynamicOptic,\n  transform: SchemaExpr[?]\n) extends MigrationAction\n```\n\n---\n\n## SchemaExpr Integration\n\n* Used for all value-level transformations\n* **Constraints for this ticket**:\n\n  * primitive  primitive only\n  * joins / splits must produce primitives\n  * no record / enum construction\n\n### `SchemaExpr.DefaultValue`\n\nA special expression that:\n\n1. uses the macro-captured field schema\n2. calls `schema.defaultValue`\n3. converts the value to `DynamicValue`\n4. is stored for reverse migrations\n\n---\n\n## Type Modeling\n\n### Records (Structural Types)\n\n```scala\ntype PersonV0 = { val firstName: String; val lastName: String }\ntype PersonV1 = { val fullName: String; val age: Int }\n\nimplicit val v0Schema: Schema[PersonV0] = Schema.structural[PersonV0]\nimplicit val v1Schema: Schema[PersonV1] = Schema.structural[PersonV1]\n```\n\n---\n\n### Enums (Union of Structural Types with Tags)\n\nEnums are encoded into structural types by using union types, together with singleton types (string literals, which represent the name of the case of the enum).\n\nIn structural types, the names of the type aliases shown below are not relevant, nor are they used.\n\n```scala\ntype OldCreditCard =\n  { type Tag = \"CreditCard\"; def number: String; def exp: String }\ntype OldWireTransfer =\n  { type Tag = \"WireTransfer\"; def account: String; def routing: String }\ntype OldPaymentMethod = OldCreditCard | OldWireTransfer\n```\n\nMacros extract:\n\n* refinement type  structure of the case\n* type `Tag` with singleton type  case tag\n\n---\n\n## Laws\n\n### Identity\n\n```scala\nMigration.identity[A].apply(a) == Right(a)\n```\n\n### Associativity\n\n```scala\n(m1 ++ m2) ++ m3 == m1 ++ (m2 ++ m3)\n```\n\n### Structural Reverse\n\n```scala\nm.reverse.reverse == m\n```\n\n### Best-Effort Semantic Inverse\n\n```scala\nm.apply(a) == Right(b)  m.reverse.apply(b) == Right(a)\n```\n\n(when sufficient information exists)\n\n---\n\n## Error Handling\n\n* All runtime errors return `MigrationError`\n* Errors must capture **path information** (`DynamicOptic`)\n* Enables diagnostics such as:\n\n> Failed to apply TransformValue at `.addresses.each.streetNumber`\n\n---\n\n## Example\n\n```scala\ntype PersonV0 = { val firstName: String; val lastName: String }\n\n@schema\ncase class Person(fullName: String, age: Int)\n\nval migration =\n  Migration.newBuilder[PersonV0, Person]\n    .addField(_.age, 0)\n    .build\n\nval old =\n  new { val firstName = \"John\"; val lastName = \"Doe\" }\n\nmigration(old)\n// Right(Person(\"John Doe\", 0))\n```\n\n---\n\n## Success Criteria\n\n* [ ] `DynamicMigration` fully serializable\n* [ ] `Migration[A, B]` wraps schemas and actions\n* [ ] All actions path-based via `DynamicOptic`\n* [ ] User API uses selector functions (`S => A`) for \"optics\" on old and new types\n* [ ] Macro validation in `.build` to confirm \"old\" has been migrated to \"new\"\n* [ ] `.buildPartial` supported\n* [ ] Structural reverse implemented\n* [ ] Identity & associativity laws hold\n* [ ] Enum rename / transform supported\n* [ ] Errors include path information\n* [ ] Comprehensive tests\n* [ ] Scala 2.13 and Scala 3.5+ supported\n",
                  "html_url": "https://github.com/zio/zio-blocks/issues/519"
                },
                "type": "github"
              },
              "hash": "zio/zio-blocks#519",
              "body": "## Overview\n\nImplement a **pure, algebraic migration system** for ZIO Schema 2 that represents **structural transformations between schema versions** as first-class, serializable data.\n\nA migration describes how to transform data from one schema version to another, enabling:\n\n* schema evolution\n* backward / forward compatibility\n* data versioning\n* offline migrations (JSON, SQL, data lakes, registries, etc.)\n\nThe system provides a **typed, macro-validated user API** (`Migration[A, B]`) built on a **pure, serializable core** (`DynamicMigration`) that operates on `DynamicValue`. \n\nThe ADT is fully introspectable and can be used to generate DDL, etc.\n\n## Motivation & Big Picture\n\n### Why structural types?\n\nWhen evolving schemas over time, **older versions of data types should not require runtime representations**.\n\nIn this design:\n\n* **Current versions** are represented by real case classes / enums\n* **Past versions** are represented using:\n\n  * **structural types** for records\n  * **abstract types + intersection types** for sum types\n\nThese types:\n\n* exist **only at compile time**\n* have **no runtime representation**\n* introduce **zero runtime overhead**\n* do **not require optics or instances to be kept around**\n\nThis allows you to describe arbitrarily old versions of data *without polluting your runtime or codebase*.\n\n#### Typical Workflow\n\nA typical workflow looks like:\n\n1. You have a current type:\n\n   ```scala\n   @schema\n   case class Person(name: String, age: Int)\n   ```\n\n2. You derive and copy its structural shape:\n\n   ```scala\n   type PersonV1 = { def name: String; def age: Int }\n   ```\n\n3. You evolve the real type:\n\n   ```scala\n   @schema\n   case class Person(fullName: String, age: Int, country: String)\n   ```\n\n4. You keep only:\n\n   * the **current** runtime type\n   * the **structural type** for the old version\n   * a **pure migration** between them\n\nNo old case classes. No old optics. No runtime baggage.\n\nNote there is no requirement that the \"current\" type actually be a real case class, enum, etc.--so you can work purely with structural types, allowing you to define migrations for data types that are never materialized as runtime structures.\n\n---\n\n### Why pure data migrations?\n\nMigrations are represented entirely as **pure data**:\n\n* no user functions\n* no closures\n* no reflection\n* no runtime code generation\n\nAs a result:\n\n* migrations can be **serialized**\n* stored in **registries**\n* applied **dynamically**\n* inspected and transformed\n* used to generate:\n\n  * upgraders\n  * downgraders\n  * SQL DDL / DML\n  * offline data transforms\n\nWhile code generation is **out of scope for this ticket**, this explains many design decisions (invertibility, path-based actions, no functions).\n\n---\n\n## Core Architecture\n\n### Type Hierarchy\n\n```scala\n// Typed migration (user-facing API)\ncase class Migration[A, B](\n  dynamicMigration: DynamicMigration,\n  sourceSchema: Schema[A], // These are structural schemas!!!\n  targetSchema: Schema[B] // These are structural schemas!!!\n) {\n  /** Apply migration to transform A to B */\n  def apply(value: A): Either[MigrationError, B]\n\n  /** Compose migrations sequentially */\n  def ++[C](that: Migration[B, C]): Migration[A, C]\n\n  /** Alias for ++ */\n  def andThen[C](that: Migration[B, C]): Migration[A, C] = this ++ that\n\n  /** Reverse migration (structural inverse; runtime is best-effort) */\n  def reverse: Migration[B, A]\n}\n```\n\n```scala\n// Untyped migration (pure data, fully serializable)\ncase class DynamicMigration(\n  actions: Vector[MigrationAction]\n) {\n  def apply(value: DynamicValue): Either[MigrationError, DynamicValue]\n  def ++(that: DynamicMigration): DynamicMigration\n  def reverse: DynamicMigration\n}\n```\n\n* `Migration[A, B]` is introspectable, but not pure data due to bindings inside schemas\n* `DynamicMigration` is **fully serializable**\n\n---\n\n## User-Facing API: Selector Expressions\n\n### Selectors, not optics\n\nThe user-facing API **does not expose optics**.\n\nInstead, all locations are specified using **selector expressions**:\n\n```scala\nS => A\n```\n\nExamples:\n\n```scala\n_.name\n_.address.street\n_.addresses.each.streetNumber\n_.country.when[UK]\n```\n\nTo see the syntax, one can look at the `optic` macro, which utilizes the same selector syntax for optic creation (e.g. `optic(_.address.street)`, etc.).\n\n### Macro extraction\n\nAll builder methods that accept selectors are **implemented via macros** (or via a macro-generated type class such as `ToDynamicOptic`).\n\nThe macro:\n\n1. Inspects the selector expression\n2. Validates it is a supported projection\n3. Converts it into a `DynamicOptic`\n4. Stores that optic in the migration action\n\nSupported projections include:\n\n* field access (`_.foo.bar`)\n* case selection (`_.country.when[UK]`)\n* collection traversal (`_.items.each`)\n* (future) key access, wrappers, etc.\n\n`DynamicOptic` is **never exposed publicly**.\n\n---\n\n## Migration Builder\n\nAll selector-accepting methods are implemented via macros. For simplicity, these are shown as functions (e.g. `A => Any`), but this is NOT the way to implement them. Either all these functions need to be macros, or a macro needs to be used to generate an implicit / given at each call site. Macros may do additional validation to constrain the validity of these different types of transformations.\n\n```scala\nclass MigrationBuilder[A, B](\n  sourceSchema: Schema[A],\n  targetSchema: Schema[B],\n  actions: Vector[MigrationAction]\n) {\n\n  // ----- Record operations -----\n\n  def addField(\n    target: B => Any,\n    default: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  def dropField(\n    source: A => Any,\n    defaultForReverse: SchemaExpr[B, ?] = SchemaExpr.DefaultValue\n  ): MigrationBuilder[A, B]\n\n  def renameField(\n    from: A => Any,\n    to: B => Any\n  ): MigrationBuilder[A, B]\n\n  def transformField(\n    from: A => Any,\n    to: B => Any,\n    transform: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  def mandateField(\n    source: A => Option[?],\n    target: B => Any,\n    default: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  def optionalizeField(\n    source: A => Any,\n    target: B => Option[?]\n  ): MigrationBuilder[A, B]\n\n  def changeFieldType(\n    source: A => Any,\n    target: B => Any,\n    converter: SchemaExpr[A, ?]  // primitive-to-primitive only\n  ): MigrationBuilder[A, B]\n\n  // ----- Enum operations (limited) -----\n\n  def renameCase[SumA, SumB](\n    from: String,\n    to: String\n  ): MigrationBuilder[A, B]\n\n  def transformCase[SumA, CaseA, SumB, CaseB](\n    caseMigration: MigrationBuilder[CaseA, CaseB] => MigrationBuilder[CaseA, CaseB]\n  ): MigrationBuilder[A, B]\n\n  // ----- Collections -----\n\n  def transformElements(\n    at: A => Vector[?],\n    transform: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  // ----- Maps -----\n\n  def transformKeys(\n    at: A => Map[?, ?],\n    transform: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  def transformValues(\n    at: A => Map[?, ?],\n    transform: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  /** Build migration with full macro validation */\n  def build: Migration[A, B]\n\n  /** Build migration without full validation */\n  def buildPartial: Migration[A, B]\n}\n```\n\n---\n\n## Migration Actions (Untyped Core)\n\nAll actions operate at a **path**, represented by `DynamicOptic`.\n\n```scala\nsealed trait MigrationAction {\n  def at: DynamicOptic\n  def reverse: MigrationAction\n}\n```\n\n### Record Actions\n\n```scala\ncase class AddField(\n  at: DynamicOptic,\n  default: SchemaExpr[?]\n) extends MigrationAction\n\ncase class DropField(\n  at: DynamicOptic,\n  defaultForReverse: SchemaExpr[?]\n) extends MigrationAction\n\ncase class Rename(\n  at: DynamicOptic,\n  to: String\n) extends MigrationAction\n\ncase class TransformValue(\n  at: DynamicOptic,\n  transform: SchemaExpr[?]\n) extends MigrationAction\n\ncase class Mandate(\n  at: DynamicOptic,\n  default: SchemaExpr[?]\n) extends MigrationAction\n\ncase class Optionalize(\n  at: DynamicOptic\n) extends MigrationAction\n\ncase class Join(\n  at: DynamicOptic,\n  sourcePaths: Vector[DynamicOptic],\n  combiner: SchemaExpr[?]\n) extends MigrationAction\n\ncase class Split(\n  at: DynamicOptic,\n  targetPaths: Vector[DynamicOptic],\n  splitter: SchemaExpr[?]\n) extends MigrationAction\n\ncase class ChangeType(\n  at: DynamicOptic,\n  converter: SchemaExpr[?]\n) extends MigrationAction\n```\n\n---\n\n### Enum Actions (Supported)\n\n```scala\ncase class RenameCase(\n  at: DynamicOptic,\n  from: String,\n  to: String\n) extends MigrationAction\n\ncase class TransformCase(\n  at: DynamicOptic,\n  actions: Vector[MigrationAction]\n) extends MigrationAction\n```\n\n> Enum case addition / removal is **out of scope** for this ticket\n> (requires composite value construction).\n\n---\n\n### Collection / Map Actions\n\n```scala\ncase class TransformElements(\n  at: DynamicOptic,\n  transform: SchemaExpr[?]\n) extends MigrationAction\n\ncase class TransformKeys(\n  at: DynamicOptic,\n  transform: SchemaExpr[?]\n) extends MigrationAction\n\ncase class TransformValues(\n  at: DynamicOptic,\n  transform: SchemaExpr[?]\n) extends MigrationAction\n```\n\n---\n\n## SchemaExpr Integration\n\n* Used for all value-level transformations\n* **Constraints for this ticket**:\n\n  * primitive  primitive only\n  * joins / splits must produce primitives\n  * no record / enum construction\n\n### `SchemaExpr.DefaultValue`\n\nA special expression that:\n\n1. uses the macro-captured field schema\n2. calls `schema.defaultValue`\n3. converts the value to `DynamicValue`\n4. is stored for reverse migrations\n\n---\n\n## Type Modeling\n\n### Records (Structural Types)\n\n```scala\ntype PersonV0 = { val firstName: String; val lastName: String }\ntype PersonV1 = { val fullName: String; val age: Int }\n\nimplicit val v0Schema: Schema[PersonV0] = Schema.structural[PersonV0]\nimplicit val v1Schema: Schema[PersonV1] = Schema.structural[PersonV1]\n```\n\n---\n\n### Enums (Union of Structural Types with Tags)\n\nEnums are encoded into structural types by using union types, together with singleton types (string literals, which represent the name of the case of the enum).\n\nIn structural types, the names of the type aliases shown below are not relevant, nor are they used.\n\n```scala\ntype OldCreditCard =\n  { type Tag = \"CreditCard\"; def number: String; def exp: String }\ntype OldWireTransfer =\n  { type Tag = \"WireTransfer\"; def account: String; def routing: String }\ntype OldPaymentMethod = OldCreditCard | OldWireTransfer\n```\n\nMacros extract:\n\n* refinement type  structure of the case\n* type `Tag` with singleton type  case tag\n\n---\n\n## Laws\n\n### Identity\n\n```scala\nMigration.identity[A].apply(a) == Right(a)\n```\n\n### Associativity\n\n```scala\n(m1 ++ m2) ++ m3 == m1 ++ (m2 ++ m3)\n```\n\n### Structural Reverse\n\n```scala\nm.reverse.reverse == m\n```\n\n### Best-Effort Semantic Inverse\n\n```scala\nm.apply(a) == Right(b)  m.reverse.apply(b) == Right(a)\n```\n\n(when sufficient information exists)\n\n---\n\n## Error Handling\n\n* All runtime errors return `MigrationError`\n* Errors must capture **path information** (`DynamicOptic`)\n* Enables diagnostics such as:\n\n> Failed to apply TransformValue at `.addresses.each.streetNumber`\n\n---\n\n## Example\n\n```scala\ntype PersonV0 = { val firstName: String; val lastName: String }\n\n@schema\ncase class Person(fullName: String, age: Int)\n\nval migration =\n  Migration.newBuilder[PersonV0, Person]\n    .addField(_.age, 0)\n    .build\n\nval old =\n  new { val firstName = \"John\"; val lastName = \"Doe\" }\n\nmigration(old)\n// Right(Person(\"John Doe\", 0))\n```\n\n---\n\n## Success Criteria\n\n* [ ] `DynamicMigration` fully serializable\n* [ ] `Migration[A, B]` wraps schemas and actions\n* [ ] All actions path-based via `DynamicOptic`\n* [ ] User API uses selector functions (`S => A`) for \"optics\" on old and new types\n* [ ] Macro validation in `.build` to confirm \"old\" has been migrated to \"new\"\n* [ ] `.buildPartial` supported\n* [ ] Structural reverse implemented\n* [ ] Identity & associativity laws hold\n* [ ] Enum rename / transform supported\n* [ ] Errors include path information\n* [ ] Comprehensive tests\n* [ ] Scala 2.13 and Scala 3.5+ supported\n",
              "url": "https://github.com/zio/zio-blocks/issues/519",
              "tech": [],
              "repo_name": "zio-blocks",
              "repo_owner": "zio",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "zio#471",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "zio",
              "id": "generated-zio",
              "name": "Zio",
              "description": "",
              "members": [],
              "display_name": "Zio",
              "created_at": "2026-01-30T03:42:13.539Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/zio?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "zio",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-30T03:42:13.539Z",
            "created_at": "2026-01-30T03:42:13.539Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-zio#471",
              "status": "open",
              "type": "issue",
              "number": 471,
              "title": "Replace TypeName by TypeId & Macro Derivation",
              "source": {
                "data": {
                  "id": "source-zio#471",
                  "user": {
                    "login": "jdegoes",
                    "id": 156745,
                    "node_id": "MDQ6VXNlcjE1Njc0NQ==",
                    "avatar_url": "https://avatars.githubusercontent.com/u/156745?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/jdegoes",
                    "html_url": "https://github.com/jdegoes",
                    "followers_url": "https://api.github.com/users/jdegoes/followers",
                    "following_url": "https://api.github.com/users/jdegoes/following{/other_user}",
                    "gists_url": "https://api.github.com/users/jdegoes/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/jdegoes/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/jdegoes/subscriptions",
                    "organizations_url": "https://api.github.com/users/jdegoes/orgs",
                    "repos_url": "https://api.github.com/users/jdegoes/repos",
                    "events_url": "https://api.github.com/users/jdegoes/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/jdegoes/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Replace TypeName by TypeId & Macro Derivation",
                  "body": "# Design and Implement `TypeId` for Type Registry\n\n## Goal\n\nDesign and implement a `TypeId[A]` data structure that can faithfully represent any Scala type or type constructor, capturing sufficient metadata to support:\n\n- **Type identity**: Uniquely identifying types across serialization boundaries\n- **Subtype checking**: Implementing `isSubtypeOf` directly on `TypeId` without runtime reflection\n- **Type equality**: Determining structural and nominal type equivalence\n- **Map/Set keys**: Using `TypeId` as keys in type registries (requires correct `equals`/`hashCode`)\n- **Macro derivation**: Derivation of `TypeId` for any type or type constructor, source-compatible across Scala 2/3\n\nThe data type must be used to wholly replace `TypeName` in the source code of ZIO Blocks.\n\n## Requirements\n\n### API Surface\n```scala\n// Explicit derivation\nval stringId: TypeId[String] = TypeId.of[String]\nval listId: TypeId[List] = TypeId.of[List]  // Type constructors supported\n\n// Implicit derivation for generic code\ndef process[A](value: A)(implicit typeId: TypeId[A]): Unit = ???\n\n// Or using Scala 3 context bounds\ndef process[A: TypeId](value: A): Unit = ???\n\n// Use as map keys in type registries\nval registry: Map[TypeId[_], Binding[_]] = Map(\n  TypeId.of[String] -> stringBinding,\n  TypeId.of[List[Int]] -> listIntBinding\n)\n```\n\n### Cross-Version Support\n\n- **Scala 2.13**: Use `scala.reflect.macros` for compile-time derivation\n- **Scala 3.x (3.03.7+)**: Use `scala.quoted` macros\n\nThe runtime data model (`TypeId`, `TypeRepr`, etc.) should be shared across versions. Only the macro implementations differ.\n\n### Equals and HashCode Contract\n\n`TypeId` instances will be used as keys in `Map` and `Set` collections within type registries. The `equals` and `hashCode` implementations must satisfy the following requirements:\n\n#### Equality Semantics\n\n1. **Nominal identity for non-aliases**: Two `TypeId` instances referring to the same nominal type (same `fullName`) are equal, regardless of when/where the macro derived them.\n\n2. **Type alias transparency**: Type aliases should be equal to their underlying types after normalization.\n```scala\n   type Age = Int\n   TypeId.of[Age] == TypeId.of[Int]  // true (after normalization)\n```\n\n3. **Opaque type nominality**: Opaque types are *not* equal to their representation or to other opaque types.\n```scala\n   opaque type Email = String\n   opaque type UserId = String\n   TypeId.of[Email] == TypeId.of[String]  // false\n   TypeId.of[Email] == TypeId.of[UserId]  // false\n```\n\n4. **Applied types**: Two applied types are equal iff their type constructors are equal and all type arguments are equal.\n```scala\n   TypeId.of[List[Int]] == TypeId.of[List[Int]]      // true\n   TypeId.of[List[Int]] == TypeId.of[List[String]]  // false\n```\n\n5. **Structural types**: Two structural types are equal iff they have the same members (by name and type).\n\n6. **Compound types**: Order matters for intersections and unions (or they must be normalized to a canonical order).\n```scala\n   // Option A: Order-sensitive\n   TypeId.of[A & B] != TypeId.of[B & A]\n   \n   // Option B: Canonicalized (preferred)\n   TypeId.of[A & B] == TypeId.of[B & A]  // after sorting components\n```\n\n#### HashCode Requirements\n\n1. **Consistency**: `hashCode` must be consistent with `equals`equal objects must have equal hash codes.\n\n2. **Stability**: The same `TypeId` derived in different compilation units or at different times must produce the same `hashCode`.\n\n3. **Distribution**: Hash codes should be well-distributed to avoid collisions in hash maps.\n\n4. **Determinism**: `hashCode` must not depend on object identity, memory addresses, or other non-deterministic factors.\n\n#### Implementation Approach\n```scala\nsealed trait TypeId[A <: AnyKind] {\n  // ... other members ...\n\n  /** \n   * Equality based on normalized type structure.\n   * Type aliases are expanded before comparison.\n   */\n  override def equals(other: Any): Boolean = other match {\n    case that: TypeId[_] => TypeId.structurallyEqual(this, that)\n    case _ => false\n  }\n\n  /**\n   * Hash code based on normalized type structure.\n   * Must be consistent with equals.\n   */\n  override def hashCode(): Int = TypeId.structuralHash(this)\n}\n\nobject TypeId {\n  /**\n   * Compare two TypeIds for structural equality after normalization.\n   */\n  def structurallyEqual(a: TypeId[_], b: TypeId[_]): Boolean = {\n    // 1. Normalize both (expand aliases)\n    // 2. Compare structure recursively\n    // 3. For opaque types, compare by fullName only (nominal)\n    ???\n  }\n\n  /**\n   * Compute a stable hash code for a TypeId.\n   */\n  def structuralHash(id: TypeId[_]): Int = {\n    // 1. Normalize (expand aliases)\n    // 2. Compute hash from structural components\n    // 3. Must use stable values (fullName, not object identity)\n    ???\n  }\n}\n```\n\n#### Edge Cases\n\n- **Recursive types**: Must handle cycles without infinite loops in both `equals` and `hashCode`.\n- **Type parameters**: `TypeId.of[List]` (unapplied) must have different hash than `TypeId.of[List[Int]]` (applied).\n- **Path-dependent types**: `a.T` and `b.T` are equal only if `a` and `b` are the same stable path.\n- **Local types**: Types defined in local scopes need unique identification (e.g., include source location or synthetic index).\n\n### Key Operations\n```scala\ntrait TypeId[A <: AnyKind] {\n  def name: String\n  def fullName: String\n  def owner: Owner\n  def typeParams: List[TypeParam]\n  def parents: List[TypeRepr]\n  \n  // Core operations\n  def isSubtypeOf(other: TypeId[_]): Boolean\n  def isSupertypeOf(other: TypeId[_]): Boolean\n  def isEquivalentTo(other: TypeId[_]): Boolean\n  \n  // Equality (for use as map keys)\n  override def equals(other: Any): Boolean\n  override def hashCode(): Int\n}\n```\n\n## Attached Design Document\n\nSee the attached `TypeId-DataModel.md` for a comprehensive sketch of:\n\n- Core data structures (`TypeId`, `TypeRepr`, `TypeParam`, `Owner`, etc.)\n- Type expression representation (applied types, intersections, unions, match types, etc.)\n- Variance and bounds modeling\n- Substitution and normalization algorithms\n- Standard library type definitions\n\n> [!WARNING]\n> **The attached document is a design sketch, not production code.** Some details may be incorrect, incomplete, or require adjustment during implementation. It should be treated as a starting point for discussion and iteration, not a specification to implement verbatim.\n\n## Test Strategy\n\nComprehensive testing should validate four layers: **macro derivation correctness**, **data model completeness**, **type operation correctness**, and **equals/hashCode correctness**.\n\n### 1. Equals and HashCode Tests\n\nThese tests are critical since `TypeId` will be used as map keys.\n\n#### Basic Contract Tests\n```scala\ntest(\"equals is reflexive\") {\n  val id = TypeId.of[String]\n  assertTrue(id == id)\n  assertTrue(id.equals(id))\n}\n\ntest(\"equals is symmetric\") {\n  val id1 = TypeId.of[String]\n  val id2 = TypeId.of[String]\n  assertTrue(id1 == id2)\n  assertTrue(id2 == id1)\n}\n\ntest(\"equals is transitive\") {\n  val id1 = TypeId.of[String]\n  val id2 = TypeId.of[String]\n  val id3 = TypeId.of[String]\n  assertTrue(id1 == id2)\n  assertTrue(id2 == id3)\n  assertTrue(id1 == id3)\n}\n\ntest(\"hashCode is consistent with equals\") {\n  val id1 = TypeId.of[String]\n  val id2 = TypeId.of[String]\n  assertTrue(id1 == id2)\n  assertTrue(id1.hashCode == id2.hashCode)\n}\n\ntest(\"hashCode is stable across invocations\") {\n  val id = TypeId.of[List[Int]]\n  val hash1 = id.hashCode\n  val hash2 = id.hashCode\n  assertTrue(hash1 == hash2)\n}\n```\n\n#### Nominal Type Equality\n```scala\ntest(\"same nominal types are equal\") {\n  assertTrue(TypeId.of[String] == TypeId.of[String])\n  assertTrue(TypeId.of[Int] == TypeId.of[Int])\n  assertTrue(TypeId.of[List[Int]] == TypeId.of[List[Int]])\n}\n\ntest(\"different nominal types are not equal\") {\n  assertTrue(TypeId.of[String] != TypeId.of[Int])\n  assertTrue(TypeId.of[List[Int]] != TypeId.of[List[String]])\n  assertTrue(TypeId.of[List[Int]] != TypeId.of[Vector[Int]])\n}\n```\n\n#### Type Alias Equality\n```scala\ntest(\"type aliases equal their underlying types\") {\n  type Age = Int\n  type Name = String\n  \n  assertTrue(TypeId.of[Age] == TypeId.of[Int])\n  assertTrue(TypeId.of[Name] == TypeId.of[String])\n  assertTrue(TypeId.of[Age].hashCode == TypeId.of[Int].hashCode)\n}\n\ntest(\"chained type aliases resolve correctly\") {\n  type A = Int\n  type B = A\n  type C = B\n  \n  assertTrue(TypeId.of[C] == TypeId.of[Int])\n  assertTrue(TypeId.of[C] == TypeId.of[A])\n  assertTrue(TypeId.of[C] == TypeId.of[B])\n}\n\ntest(\"generic type aliases equal their expansion\") {\n  type MyList[A] = List[A]\n  \n  assertTrue(TypeId.of[MyList[Int]] == TypeId.of[List[Int]])\n  assertTrue(TypeId.of[MyList[String]] == TypeId.of[List[String]])\n}\n```\n\n#### Opaque Type Equality\n```scala\ntest(\"opaque types are not equal to their representation\") {\n  opaque type Email = String\n  \n  assertTrue(TypeId.of[Email] != TypeId.of[String])\n  assertTrue(TypeId.of[Email].hashCode != TypeId.of[String].hashCode) // likely but not guaranteed\n}\n\ntest(\"different opaque types are not equal even with same representation\") {\n  opaque type Email = String\n  opaque type UserId = String\n  \n  assertTrue(TypeId.of[Email] != TypeId.of[UserId])\n}\n\ntest(\"same opaque type is equal to itself\") {\n  opaque type Email = String\n  \n  assertTrue(TypeId.of[Email] == TypeId.of[Email])\n}\n```\n\n#### Applied Type Equality\n```scala\ntest(\"applied types with same constructor and args are equal\") {\n  assertTrue(TypeId.of[List[Int]] == TypeId.of[List[Int]])\n  assertTrue(TypeId.of[Map[String, Int]] == TypeId.of[Map[String, Int]])\n  assertTrue(TypeId.of[Either[String, Int]] == TypeId.of[Either[String, Int]])\n}\n\ntest(\"applied types with different args are not equal\") {\n  assertTrue(TypeId.of[List[Int]] != TypeId.of[List[String]])\n  assertTrue(TypeId.of[Map[String, Int]] != TypeId.of[Map[Int, String]])\n}\n\ntest(\"unapplied type constructor not equal to applied type\") {\n  assertTrue(TypeId.of[List] != TypeId.of[List[Int]])\n  assertTrue(TypeId.of[Map] != TypeId.of[Map[String, Int]])\n}\n```\n\n#### Compound Type Equality\n```scala\ntest(\"intersection types equality\") {\n  // Assuming canonicalized ordering\n  assertTrue(TypeId.of[Serializable & Comparable[String]] == TypeId.of[Serializable & Comparable[String]])\n}\n\ntest(\"union types equality\") {\n  assertTrue(TypeId.of[Int | String] == TypeId.of[Int | String])\n}\n```\n\n#### Map/Set Usage Tests\n```scala\ntest(\"TypeId works as Map key\") {\n  val map = Map[TypeId[_], String](\n    TypeId.of[String] -> \"string\",\n    TypeId.of[Int] -> \"int\",\n    TypeId.of[List[Int]] -> \"list-int\"\n  )\n  \n  assertTrue(map(TypeId.of[String]) == \"string\")\n  assertTrue(map(TypeId.of[Int]) == \"int\")\n  assertTrue(map(TypeId.of[List[Int]]) == \"list-int\")\n  assertTrue(map.get(TypeId.of[Double]).isEmpty)\n}\n\ntest(\"TypeId works as Map key with type aliases\") {\n  type Age = Int\n  \n  val map = Map[TypeId[_], String](\n    TypeId.of[Int] -> \"int\"\n  )\n  \n  // Should find the entry via alias\n  assertTrue(map(TypeId.of[Age]) == \"int\")\n}\n\ntest(\"TypeId works in Set\") {\n  val set = Set(\n    TypeId.of[String],\n    TypeId.of[Int],\n    TypeId.of[List[Int]]\n  )\n  \n  assertTrue(set.contains(TypeId.of[String]))\n  assertTrue(set.contains(TypeId.of[Int]))\n  assertTrue(!set.contains(TypeId.of[Double]))\n}\n\ntest(\"TypeId deduplication in Set\") {\n  type Age = Int\n  \n  val set = Set(\n    TypeId.of[Int],\n    TypeId.of[Age]  // Should deduplicate\n  )\n  \n  assertTrue(set.size == 1)\n}\n\ntest(\"mutable HashMap works with TypeId\") {\n  val map = scala.collection.mutable.HashMap[TypeId[_], String]()\n  \n  map(TypeId.of[String]) = \"string\"\n  map(TypeId.of[Int]) = \"int\"\n  \n  assertTrue(map(TypeId.of[String]) == \"string\")\n  \n  // Update via equal key\n  type Name = String\n  map(TypeId.of[Name]) = \"updated\"\n  assertTrue(map(TypeId.of[String]) == \"updated\")\n}\n```\n\n#### Cross-Compilation Equality\n```scala\ntest(\"TypeId equality is stable across compilation units\") {\n  // id1 derived in CompilationUnitA\n  val id1 = CompilationUnitA.stringTypeId\n  // id2 derived in CompilationUnitB  \n  val id2 = CompilationUnitB.stringTypeId\n  \n  assertTrue(id1 == id2)\n  assertTrue(id1.hashCode == id2.hashCode)\n}\n```\n\n### 2. Macro Derivation Tests\n\nVerify that the macro correctly captures type information for all supported type forms.\n\n#### Primitive and Basic Types\n```scala\ntest(\"derives primitives correctly\") {\n  assertTrue(TypeId.of[Int].name == \"Int\")\n  assertTrue(TypeId.of[String].fullName == \"java.lang.String\")\n  assertTrue(TypeId.of[Unit].isValueClass)\n}\n```\n\n#### Generic Types and Type Constructors\n```scala\ntest(\"derives type constructors\") {\n  val listId = TypeId.of[List]\n  assertTrue(listId.arity == 1)\n  assertTrue(listId.typeParams.head.variance == Variance.Covariant)\n}\n\ntest(\"derives applied types\") {\n  val listIntId = TypeId.of[List[Int]]\n  // Should capture that this is List applied to Int\n}\n\ntest(\"derives higher-kinded types\") {\n  val functorId = TypeId.of[Functor]  // Functor[F[_]]\n  assertTrue(functorId.typeParams.head.kind == Kind.`* -> *`)\n}\n```\n\n#### Type Aliases and Opaque Types\n```scala\ntype Age = Int\nopaque type Email = String\n\ntest(\"derives type aliases\") {\n  val ageId = TypeId.of[Age]\n  assertTrue(ageId.isAlias)\n  assertTrue(ageId.aliasedTo == Some(TypeRepr.Ref(TypeId.of[Int])))\n}\n\ntest(\"derives opaque types\") {\n  val emailId = TypeId.of[Email]\n  assertTrue(emailId.isOpaque)\n  // Representation should be captured\n}\n```\n\n#### Classes, Traits, Objects, Enums\n```scala\nsealed trait Animal\ncase class Dog(name: String) extends Animal\ncase object Cat extends Animal\n\nenum Color { case Red, Green, Blue, RGB(r: Int, g: Int, b: Int) }\n\ntest(\"derives sealed hierarchy\") {\n  val animalId = TypeId.of[Animal]\n  assertTrue(animalId.isSealed)\n  assertTrue(animalId.defKind match {\n    case TypeDefKind.Trait(true, subtypes) => subtypes.nonEmpty\n    case _ => false\n  })\n}\n\ntest(\"derives enums with cases\") {\n  val colorId = TypeId.of[Color]\n  assertTrue(colorId.enumCases.map(_.name) == List(\"Red\", \"Green\", \"Blue\", \"RGB\"))\n  assertTrue(colorId.enumCases.find(_.name == \"RGB\").exists(_.params.nonEmpty))\n}\n```\n\n#### Structural and Refinement Types\n```scala\ntest(\"derives structural types\") {\n  type Sized = { def size: Int }\n  val sizedId = TypeId.of[Sized]\n  // Should capture the structural member\n}\n```\n\n#### Compound Types\n```scala\ntest(\"derives intersection types\") {\n  val id = TypeId.of[String & Serializable]\n  // Should capture both components\n}\n\ntest(\"derives union types\") {\n  val id = TypeId.of[String | Int]\n  // Should capture both components\n}\n```\n\n#### Tuple Types (Including Named Tuples for Scala 3.5+)\n```scala\ntest(\"derives positional tuples\") {\n  val id = TypeId.of[(Int, String, Boolean)]\n  // Should capture element types\n}\n\ntest(\"derives named tuples\") {  // Scala 3.5+\n  val id = TypeId.of[(name: String, age: Int)]\n  // Should capture labels and types\n}\n```\n\n#### Function Types\n```scala\ntest(\"derives function types\") {\n  val id = TypeId.of[(Int, String) => Boolean]\n  // Should capture param types and result type\n}\n\ntest(\"derives context function types\") {  // Scala 3\n  val id = TypeId.of[(Int, String) ?=> Boolean]\n}\n\ntest(\"derives polymorphic function types\") {  // Scala 3\n  val id = TypeId.of[[A] => A => A]\n}\n```\n\n#### Path-Dependent and Singleton Types\n```scala\nobject Outer {\n  object Inner {\n    type T = Int\n  }\n  val inner: Inner.type = Inner\n}\n\ntest(\"derives path-dependent types\") {\n  val id = TypeId.of[Outer.Inner.T]\n  // Should capture the path\n}\n\ntest(\"derives singleton types\") {\n  val id = TypeId.of[Outer.Inner.type]\n}\n```\n\n#### Match Types (Scala 3)\n```scala\ntype Elem[X] = X match {\n  case String => Char\n  case Array[t] => t\n}\n\ntest(\"derives match types\") {\n  val id = TypeId.of[Elem]\n  // Should capture scrutinee, cases, and binders\n}\n```\n\n### 3. Data Model Completeness Tests\n\nVerify that round-tripping through the model preserves type information.\n```scala\ntest(\"TypeRepr substitution is correct\") {\n  val A = TypeParam(\"A\", 0)\n  val listOfA = TypeRepr.Applied(TypeRepr.Ref(listId), List(TypeRepr.ParamRef(A)))\n  val substituted = listOfA.substitute(Map(A -> TypeRepr.Ref(intId)))\n  assertTrue(substituted == TypeRepr.Applied(TypeRepr.Ref(listId), List(TypeRepr.Ref(intId))))\n}\n\ntest(\"normalization expands aliases\") {\n  type MyInt = Int\n  val myIntRepr = TypeRepr.Ref(TypeId.of[MyInt])\n  val normalized = TypeNormalization.normalize(myIntRepr)\n  assertTrue(normalized == TypeRepr.Ref(TypeId.of[Int]))\n}\n```\n\n### 4. Subtyping Tests\n\nVerify that `isSubtypeOf` correctly implements Scala's subtyping rules.\n\n#### Basic Subtyping\n```scala\ntest(\"Nothing is subtype of everything\") {\n  assertTrue(TypeId.of[Nothing].isSubtypeOf(TypeId.of[Int]))\n  assertTrue(TypeId.of[Nothing].isSubtypeOf(TypeId.of[String]))\n  assertTrue(TypeId.of[Nothing].isSubtypeOf(TypeId.of[Any]))\n}\n\ntest(\"everything is subtype of Any\") {\n  assertTrue(TypeId.of[Int].isSubtypeOf(TypeId.of[Any]))\n  assertTrue(TypeId.of[String].isSubtypeOf(TypeId.of[Any]))\n  assertTrue(TypeId.of[List[Int]].isSubtypeOf(TypeId.of[Any]))\n}\n\ntest(\"reflexivity\") {\n  assertTrue(TypeId.of[String].isSubtypeOf(TypeId.of[String]))\n  assertTrue(TypeId.of[List[Int]].isSubtypeOf(TypeId.of[List[Int]]))\n}\n```\n\n#### Variance-Aware Subtyping\n```scala\ntest(\"covariant type parameter subtyping\") {\n  // List is covariant: List[Dog] <: List[Animal]\n  assertTrue(TypeId.of[List[Dog]].isSubtypeOf(TypeId.of[List[Animal]]))\n  assertTrue(!TypeId.of[List[Animal]].isSubtypeOf(TypeId.of[List[Dog]]))\n}\n\ntest(\"contravariant type parameter subtyping\") {\n  // Function1 is contravariant in input: (Animal => Int) <: (Dog => Int)\n  assertTrue(TypeId.of[Animal => Int].isSubtypeOf(TypeId.of[Dog => Int]))\n  assertTrue(!TypeId.of[Dog => Int].isSubtypeOf(TypeId.of[Animal => Int]))\n}\n\ntest(\"invariant type parameter subtyping\") {\n  // Array is invariant\n  assertTrue(!TypeId.of[Array[Dog]].isSubtypeOf(TypeId.of[Array[Animal]]))\n  assertTrue(!TypeId.of[Array[Animal]].isSubtypeOf(TypeId.of[Array[Dog]]))\n}\n```\n\n#### Union and Intersection Types\n```scala\ntest(\"union type subtyping\") {\n  // A <: A | B and B <: A | B\n  assertTrue(TypeId.of[Int].isSubtypeOf(TypeId.of[Int | String]))\n  assertTrue(TypeId.of[String].isSubtypeOf(TypeId.of[Int | String]))\n  \n  // A | B <: C requires both A <: C and B <: C\n  assertTrue(!TypeId.of[Int | String].isSubtypeOf(TypeId.of[Int]))\n}\n\ntest(\"intersection type subtyping\") {\n  // A & B <: A and A & B <: B\n  assertTrue(TypeId.of[Serializable & Comparable[String]].isSubtypeOf(TypeId.of[Serializable]))\n  \n  // A <: B & C requires A <: B and A <: C\n}\n```\n\n#### Nominal Hierarchy Subtyping\n```scala\ntest(\"class hierarchy subtyping\") {\n  assertTrue(TypeId.of[Dog].isSubtypeOf(TypeId.of[Animal]))\n  assertTrue(TypeId.of[String].isSubtypeOf(TypeId.of[CharSequence]))\n}\n```\n\n#### Type Alias Transparency\n```scala\ntest(\"type aliases are transparent for subtyping\") {\n  type Age = Int\n  assertTrue(TypeId.of[Age].isSubtypeOf(TypeId.of[Int]))\n  assertTrue(TypeId.of[Int].isSubtypeOf(TypeId.of[Age]))\n  assertTrue(TypeId.of[Age].isEquivalentTo(TypeId.of[Int]))\n}\n```\n\n#### Opaque Type Nominality\n```scala\ntest(\"opaque types are nominally distinct\") {\n  opaque type Email = String\n  opaque type UserId = String\n  \n  assertTrue(!TypeId.of[Email].isSubtypeOf(TypeId.of[String]))  // Outside defining scope\n  assertTrue(!TypeId.of[Email].isSubtypeOf(TypeId.of[UserId]))\n}\n```\n\n### 5. Edge Cases and Regression Tests\n```scala\ntest(\"handles recursive types\") {\n  enum Tree[+A] {\n    case Leaf(value: A)\n    case Branch(left: Tree[A], right: Tree[A])\n  }\n  val treeId = TypeId.of[Tree]\n  // Should not stack overflow on equals/hashCode\n  val hash = treeId.hashCode  // Must terminate\n  assertTrue(treeId == treeId)    // Must terminate\n}\n\ntest(\"handles deeply nested generics\") {\n  val id = TypeId.of[List[Map[String, Option[Either[Int, List[String]]]]]]\n  // Should capture full structure\n  val hash = id.hashCode\n  assertTrue(id == TypeId.of[List[Map[String, Option[Either[Int, List[String]]]]]])\n}\n\ntest(\"handles local and anonymous types\") {\n  def foo() = {\n    class Local\n    TypeId.of[Local]\n  }\n  // Should handle gracefully\n}\n\ntest(\"handles Java types\") {\n  val id = TypeId.of[java.util.ArrayList[String]]\n  // Should interop correctly\n}\n```\n\n### 6. Cross-Compilation Tests\n\nRun the same test suite on both Scala 2.13 and Scala 3.x to ensure consistent behavior:\n```scala\n// In shared test sources\nclass TypeIdSpec extends AnyFunSuite {\n  // All tests above should pass on both Scala versions\n}\n```\n\nSpecific attention should be paid to:\n- Features that exist only in Scala 3 (union/intersection types, enums, match types, named tuples)\n- Features with different representations (Scala 2 existentials vs Scala 3 wildcards)\n- Macro API differences (should be invisible to users but implementation must handle both)\n- **Equality of TypeIds derived in Scala 2 vs Scala 3 for the same type** (if cross-published)\n\n## Acceptance Criteria\n\n- [ ] `TypeId.of[A]` works for all documented type forms on Scala 2.13\n- [ ] `TypeId.of[A]` works for all documented type forms on Scala 3.03.7\n- [ ] `implicit TypeId[A]` derivation works in generic contexts\n- [ ] `isSubtypeOf` correctly handles variance, unions, intersections, and nominal hierarchies\n- [ ] Type aliases are normalized correctly\n- [ ] Opaque types maintain nominal distinction\n- [ ] **`equals` and `hashCode` satisfy the Java contract**\n- [ ] **`TypeId` works correctly as `Map` and `Set` keys**\n- [ ] **Type aliases resolve to equal `TypeId` as their underlying types**\n- [ ] **Opaque types have distinct `TypeId` from their representation**\n- [ ] **`hashCode` is stable and deterministic across compilations**\n- [ ] All tests pass on both Scala versions\n- [ ] No runtime reflection is required (all information captured at compile time)\n\n# Sketch of TypeId\n\n# TypeId Data Model for Scala 3.x Type Registry\n\nA comprehensive data model for representing Scala 3 types and type constructors, designed to support:\n- Lossless type representation for serialization/deserialization frameworks\n- Subtype checking (`isSubtypeOf`)\n- Type equality checking\n- Type normalization (alias expansion)\n\n## Design Principles\n\n1. **Polykinded phantom types**: `TypeId[A <: AnyKind]` preserves Scala type information at compile time\n2. **Separation of identity and representation**: `TypeId` identifies types; `TypeRepr` represents type expressions\n3. **Complete metadata**: Capture everything a macro can know at compile time\n4. **Stability tracking**: Path-dependent types require knowing path stability\n\n---\n\n## Core Data Model\n\n### Variance\n```scala\nenum Variance {\n  case Invariant\n  case Covariant\n  case Contravariant\n\n  def symbol: String = this match {\n    case Invariant     => \"\"\n    case Covariant     => \"+\"\n    case Contravariant => \"-\"\n  }\n\n  /** Flip variance for contravariant positions */\n  def flip: Variance = this match {\n    case Invariant     => Invariant\n    case Covariant     => Contravariant\n    case Contravariant => Covariant\n  }\n}\n```\n\n### TypeBounds\n```scala\nfinal case class TypeBounds(\n  lower: Option[TypeRepr],  // >: bound\n  upper: Option[TypeRepr]   // <: bound\n) {\n  def isUnbounded: Boolean = lower.isEmpty && upper.isEmpty\n  \n  def hasLower: Boolean = lower.isDefined\n  def hasUpper: Boolean = upper.isDefined\n  \n  /** Combine bounds (intersection of constraints) */\n  def &(other: TypeBounds): TypeBounds = TypeBounds(\n    lower = (lower, other.lower) match {\n      case (Some(l1), Some(l2)) => Some(TypeRepr.Union(l1, l2))\n      case (Some(l), None) => Some(l)\n      case (None, Some(l)) => Some(l)\n      case (None, None) => None\n    },\n    upper = (upper, other.upper) match {\n      case (Some(u1), Some(u2)) => Some(TypeRepr.Intersection(u1, u2))\n      case (Some(u), None) => Some(u)\n      case (None, Some(u)) => Some(u)\n      case (None, None) => None\n    }\n  )\n}\n\nobject TypeBounds {\n  val empty: TypeBounds = TypeBounds(None, None)\n  \n  def upper(tpe: TypeRepr): TypeBounds = TypeBounds(None, Some(tpe))\n  def lower(tpe: TypeRepr): TypeBounds = TypeBounds(Some(tpe), None)\n  def exact(tpe: TypeRepr): TypeBounds = TypeBounds(Some(tpe), Some(tpe))\n}\n```\n\n### Kind\n\nRepresents the \"type of a type\" - distinguishing proper types from type constructors.\n```scala\nsealed trait Kind {\n  def arity: Int\n  def isProperType: Boolean = this == Kind.Type\n  def isHigherKinded: Boolean = !isProperType\n}\n\nobject Kind {\n  /** Proper type: Int, String, List[Int] */\n  case object Type extends Kind { \n    def arity: Int = 0 \n  }\n\n  /** Type constructor: List, Option, Map */\n  final case class Arrow(params: List[Kind], result: Kind) extends Kind {\n    def arity: Int = params.size\n  }\n\n  // Convenience constructors\n  val `* -> *`: Kind = Arrow(List(Type), Type)\n  val `* -> * -> *`: Kind = Arrow(List(Type, Type), Type)\n  val `(* -> *) -> *`: Kind = Arrow(List(`* -> *`), Type)\n  \n  def arity(n: Int): Kind = \n    if (n == 0) Type \n    else Arrow(List.fill(n)(Type), Type)\n}\n```\n\n### TypeParam\n\nComplete type parameter specification with all information needed for subtyping.\n```scala\nfinal case class TypeParam(\n  name: String,\n  index: Int,\n  variance: Variance = Variance.Invariant,\n  bounds: TypeBounds = TypeBounds.empty,\n  kind: Kind = Kind.Type\n) {\n  def isHigherKinded: Boolean = kind.isHigherKinded\n  def isCovariant: Boolean = variance == Variance.Covariant\n  def isContravariant: Boolean = variance == Variance.Contravariant\n  def isInvariant: Boolean = variance == Variance.Invariant\n}\n\nobject TypeParam {\n  def invariant(name: String, index: Int): TypeParam = \n    TypeParam(name, index, Variance.Invariant)\n    \n  def covariant(name: String, index: Int): TypeParam = \n    TypeParam(name, index, Variance.Covariant)\n    \n  def contravariant(name: String, index: Int): TypeParam = \n    TypeParam(name, index, Variance.Contravariant)\n}\n```\n\n---\n\n## Type Definition Classification\n\n### TypeDefKind\n\nClassifies what kind of type definition a `TypeId` represents.\n```scala\nsealed trait TypeDefKind\n\nobject TypeDefKind {\n  final case class Class(\n    isFinal: Boolean = false,\n    isAbstract: Boolean = false,\n    isCase: Boolean = false,\n    isValue: Boolean = false  // extends AnyVal\n  ) extends TypeDefKind\n\n  final case class Trait(\n    isSealed: Boolean = false,\n    knownSubtypes: List[TypeRepr] = Nil\n  ) extends TypeDefKind\n\n  /** Singleton object */\n  case object Object extends TypeDefKind\n\n  /** Scala 3 enum */\n  final case class Enum(\n    cases: List[EnumCaseInfo]\n  ) extends TypeDefKind\n\n  /** Individual enum case (when represented as its own type) */\n  final case class EnumCase(\n    parentEnum: TypeRepr,\n    ordinal: Int,\n    isObjectCase: Boolean  // case Red vs case RGB(...)\n  ) extends TypeDefKind\n\n  /** Type alias: type Foo = Bar */\n  case object TypeAlias extends TypeDefKind\n\n  /** Opaque type: opaque type Foo = Bar */\n  final case class OpaqueType(\n    publicBounds: TypeBounds  // Bounds visible outside defining scope\n  ) extends TypeDefKind\n\n  /** Abstract type member */\n  case object AbstractType extends TypeDefKind\n}\n\n/** Information about an enum case for serialization */\nfinal case class EnumCaseInfo(\n  name: String,\n  ordinal: Int,\n  params: List[EnumCaseParam],  // Empty for object cases\n  isObjectCase: Boolean\n) {\n  def arity: Int = params.size\n}\n\nfinal case class EnumCaseParam(\n  name: String,\n  tpe: TypeRepr\n)\n```\n\n---\n\n## Parameters and Clauses\n\n### ParamClause\n```scala\nsealed trait ParamClause {\n  def params: List[Param]\n  def isEmpty: Boolean = params.isEmpty\n  def size: Int = params.size\n}\n\nobject ParamClause {\n  final case class Regular(params: List[Param]) extends ParamClause\n  final case class Using(params: List[Param]) extends ParamClause\n  final case class Implicit(params: List[Param]) extends ParamClause\n  \n  val empty: ParamClause = Regular(Nil)\n}\n```\n\n### Param\n```scala\nfinal case class Param(\n  name: String,\n  tpe: TypeRepr,\n  hasDefault: Boolean = false,\n  isRepeated: Boolean = false  // varargs: A*\n)\n```\n\n---\n\n## Ownership and Paths\n\n### Owner\n\nRepresents the lexical owner of a type definition.\n```scala\nfinal case class Owner(segments: List[Owner.Segment]) {\n  def /(segment: Owner.Segment): Owner = Owner(segments :+ segment)\n  \n  def parent: Option[Owner] = \n    if (segments.isEmpty) None \n    else Some(Owner(segments.init))\n  \n  def isRoot: Boolean = segments.isEmpty\n  \n  def asString: String = segments.map(_.show).mkString(\".\")\n  \n  /** Check if this owner is a prefix of another */\n  def isPrefixOf(other: Owner): Boolean =\n    other.segments.startsWith(segments)\n}\n\nobject Owner {\n  sealed trait Segment {\n    def name: String\n    def show: String = name\n  }\n\n  final case class Package(name: String) extends Segment\n  final case class Term(name: String) extends Segment\n  final case class Type(name: String) extends Segment\n  final case class Local(index: Int) extends Segment {\n    def name: String = s\"<local$index>\"\n  }\n\n  val Root: Owner = Owner(Nil)\n  \n  def pkg(name: String): Owner = Owner(List(Package(name)))\n  def pkgs(names: String*): Owner = Owner(names.map(Package(_)).toList)\n}\n```\n\n### TermPath\n\nRepresents paths to terms, used for singleton and path-dependent types.\n```scala\nfinal case class TermPath(segments: List[TermPath.Segment]) {\n  def /(segment: TermPath.Segment): TermPath = \n    TermPath(segments :+ segment)\n  \n  def isStable: Boolean = segments.forall(_.isStable)\n  \n  def asString: String = segments.map(_.name).mkString(\".\")\n}\n\nobject TermPath {\n  sealed trait Segment {\n    def name: String\n    def isStable: Boolean\n  }\n\n  /** Package reference - always stable */\n  final case class Package(name: String) extends Segment {\n    def isStable: Boolean = true\n  }\n\n  /** Object/module reference - always stable */\n  final case class Module(name: String) extends Segment {\n    def isStable: Boolean = true\n  }\n\n  /** Val reference - stable */\n  final case class Val(name: String) extends Segment {\n    def isStable: Boolean = true\n  }\n\n  /** Lazy val reference - stable */\n  final case class LazyVal(name: String) extends Segment {\n    def isStable: Boolean = true\n  }\n\n  /** Var reference - NOT stable */\n  final case class Var(name: String) extends Segment {\n    def isStable: Boolean = false\n  }\n\n  /** Def/method reference - NOT stable */\n  final case class Def(name: String) extends Segment {\n    def isStable: Boolean = false\n  }\n\n  /** This reference */\n  final case class This(ownerName: String) extends Segment {\n    def name: String = s\"$ownerName.this\"\n    def isStable: Boolean = true\n  }\n\n  /** Super reference */\n  final case class Super(ownerName: String, mixinName: Option[String]) extends Segment {\n    def name: String = mixinName.fold(s\"$ownerName.super\")(m => s\"$ownerName.super[$m]\")\n    def isStable: Boolean = true\n  }\n\n  val empty: TermPath = TermPath(Nil)\n}\n```\n\n---\n\n## TypeId: Type Identity\n\nThe primary type for identifying types and type constructors.\n```scala\nsealed trait TypeId[A <: AnyKind] {\n  def name: String\n  def owner: Owner\n  def typeParams: List[TypeParam]\n  def defKind: TypeDefKind\n  def parents: List[TypeRepr]\n  def selfType: Option[TypeRepr]\n  def aliasedTo: Option[TypeRepr]      // For type aliases\n  def representation: Option[TypeRepr] // For opaque types\n  def annotations: List[Annotation]\n\n  // Derived properties\n  final def arity: Int = typeParams.size\n  \n  final def fullName: String =\n    if (owner.isRoot) name\n    else s\"${owner.asString}.$name\"\n\n  final def isProperType: Boolean = arity == 0\n  final def isTypeConstructor: Boolean = arity > 0\n\n  final def isClass: Boolean = defKind.isInstanceOf[TypeDefKind.Class]\n  final def isTrait: Boolean = defKind.isInstanceOf[TypeDefKind.Trait]\n  final def isObject: Boolean = defKind == TypeDefKind.Object\n  final def isEnum: Boolean = defKind.isInstanceOf[TypeDefKind.Enum]\n  final def isAlias: Boolean = defKind == TypeDefKind.TypeAlias\n  final def isOpaque: Boolean = defKind.isInstanceOf[TypeDefKind.OpaqueType]\n  final def isAbstract: Boolean = defKind == TypeDefKind.AbstractType\n\n  final def isSealed: Boolean = defKind match {\n    case TypeDefKind.Trait(isSealed, _) => isSealed\n    case _ => false\n  }\n\n  final def isCaseClass: Boolean = defKind match {\n    case TypeDefKind.Class(_, _, isCase, _) => isCase\n    case _ => false\n  }\n\n  final def isValueClass: Boolean = defKind match {\n    case TypeDefKind.Class(_, _, _, isValue) => isValue\n    case _ => false\n  }\n  \n  /** Get enum cases if this is an enum */\n  final def enumCases: List[EnumCaseInfo] = defKind match {\n    case TypeDefKind.Enum(cases) => cases\n    case _ => Nil\n  }\n}\n\nobject TypeId {\n  private final case class Impl[A <: AnyKind](\n    name: String,\n    owner: Owner,\n    typeParams: List[TypeParam],\n    defKind: TypeDefKind,\n    parents: List[TypeRepr],\n    selfType: Option[TypeRepr],\n    aliasedTo: Option[TypeRepr],\n    representation: Option[TypeRepr],\n    annotations: List[Annotation]\n  ) extends TypeId[A]\n\n  // ========== Smart Constructors ==========\n\n  def nominal[A <: AnyKind](\n    name: String,\n    owner: Owner,\n    typeParams: List[TypeParam] = Nil,\n    defKind: TypeDefKind,\n    parents: List[TypeRepr] = Nil,\n    selfType: Option[TypeRepr] = None,\n    annotations: List[Annotation] = Nil\n  ): TypeId[A] = Impl[A](\n    name, owner, typeParams, defKind,\n    parents, selfType, None, None, annotations\n  )\n\n  def alias[A <: AnyKind](\n    name: String,\n    owner: Owner,\n    typeParams: List[TypeParam] = Nil,\n    aliased: TypeRepr,\n    annotations: List[Annotation] = Nil\n  ): TypeId[A] = Impl[A](\n    name, owner, typeParams, TypeDefKind.TypeAlias,\n    Nil, None, Some(aliased), None, annotations\n  )\n\n  def opaque[A <: AnyKind](\n    name: String,\n    owner: Owner,\n    typeParams: List[TypeParam] = Nil,\n    representation: TypeRepr,\n    publicBounds: TypeBounds = TypeBounds.empty,\n    annotations: List[Annotation] = Nil\n  ): TypeId[A] = Impl[A](\n    name, owner, typeParams, TypeDefKind.OpaqueType(publicBounds),\n    Nil, None, None, Some(representation), annotations\n  )\n\n  // ========== Extractors ==========\n\n  object Nominal {\n    def unapply(id: TypeId[?]): Option[(String, Owner, List[TypeParam], TypeDefKind, List[TypeRepr])] =\n      if (id.aliasedTo.isEmpty && id.representation.isEmpty)\n        Some((id.name, id.owner, id.typeParams, id.defKind, id.parents))\n      else None\n  }\n\n  object Alias {\n    def unapply(id: TypeId[?]): Option[(String, Owner, List[TypeParam], TypeRepr)] =\n      id.aliasedTo.map(a => (id.name, id.owner, id.typeParams, a))\n  }\n\n  object Opaque {\n    def unapply(id: TypeId[?]): Option[(String, Owner, List[TypeParam], TypeRepr, TypeBounds)] =\n      (id.defKind, id.representation) match {\n        case (TypeDefKind.OpaqueType(bounds), Some(repr)) =>\n          Some((id.name, id.owner, id.typeParams, repr, bounds))\n        case _ => None\n      }\n  }\n\n  object Sealed {\n    def unapply(id: TypeId[?]): Option[(String, List[TypeRepr])] =\n      id.defKind match {\n        case TypeDefKind.Trait(true, subtypes) => Some((id.name, subtypes))\n        case _ => None\n      }\n  }\n  \n  object Enum {\n    def unapply(id: TypeId[?]): Option[(String, Owner, List[EnumCaseInfo])] =\n      id.defKind match {\n        case TypeDefKind.Enum(cases) => Some((id.name, id.owner, cases))\n        case _ => None\n      }\n  }\n}\n```\n\n---\n\n## TypeRepr: Type Expressions\n\nThe expression language for representing type structures.\n```scala\nsealed trait TypeRepr {\n  /** Substitute type parameters with concrete types */\n  def substitute(substitutions: Map[TypeParam, TypeRepr]): TypeRepr =\n    TypeRepr.substitute(this, substitutions)\n}\n\nobject TypeRepr {\n\n  // ==================== Type References ====================\n\n  /** Reference to a type by its TypeId */\n  final case class Ref(id: TypeId[? <: AnyKind]) extends TypeRepr\n\n  /** Reference to a type parameter */\n  final case class ParamRef(\n    param: TypeParam,\n    binderDepth: Int = 0  // De Bruijn index: 0 = innermost binder\n  ) extends TypeRepr\n\n  /** Path-dependent type: qualifier.Member */\n  final case class TypeSelect(\n    qualifier: TermPath,\n    memberName: String\n  ) extends TypeRepr {\n    def isStable: Boolean = qualifier.isStable\n  }\n\n  /** Type projection (deprecated but exists): Outer#Inner */\n  final case class TypeProjection(\n    prefix: TypeRepr,\n    memberName: String\n  ) extends TypeRepr\n\n  // ==================== Type Application ====================\n\n  /** Type constructor application: F[A, B] */\n  final case class Applied(\n    tycon: TypeRepr,\n    args: List[TypeRepr]\n  ) extends TypeRepr {\n    def arity: Int = args.size\n  }\n\n  // ==================== Type Constructors ====================\n\n  /** Type lambda: [X, Y] =>> F[X, Y] */\n  final case class TypeLambda(\n    params: List[TypeParam],\n    body: TypeRepr\n  ) extends TypeRepr {\n    def arity: Int = params.size\n  }\n\n  // ==================== Compound Types ====================\n\n  /** Intersection: A & B & C */\n  final case class Intersection(components: List[TypeRepr]) extends TypeRepr {\n    require(components.sizeIs >= 2, \"Intersection requires at least 2 types\")\n  }\n  \n  object Intersection {\n    def apply(left: TypeRepr, right: TypeRepr): Intersection =\n      (left, right) match {\n        case (Intersection(l), Intersection(r)) => Intersection(l ++ r)\n        case (Intersection(l), r) => Intersection(l :+ r)\n        case (l, Intersection(r)) => Intersection(l :: r)\n        case (l, r) => Intersection(List(l, r))\n      }\n  }\n\n  /** Union: A | B | C */\n  final case class Union(components: List[TypeRepr]) extends TypeRepr {\n    require(components.sizeIs >= 2, \"Union requires at least 2 types\")\n  }\n  \n  object Union {\n    def apply(left: TypeRepr, right: TypeRepr): Union =\n      (left, right) match {\n        case (Union(l), Union(r)) => Union(l ++ r)\n        case (Union(l), r) => Union(l :+ r)\n        case (l, Union(r)) => Union(l :: r)\n        case (l, r) => Union(List(l, r))\n      }\n  }\n\n  /** Structural/refinement type: { def foo: Int; type T } */\n  final case class Structural(\n    parents: List[TypeRepr],\n    members: List[Member]\n  ) extends TypeRepr\n\n  // ==================== Function Types ====================\n\n  /** Regular function: (A, B) => C */\n  final case class Function(\n    params: List[TypeRepr],\n    result: TypeRepr\n  ) extends TypeRepr {\n    def arity: Int = params.size\n  }\n\n  /** Context function: (A, B) ?=> C */\n  final case class ContextFunction(\n    params: List[TypeRepr],\n    result: TypeRepr\n  ) extends TypeRepr\n\n  /** Polymorphic function: [A] => A => A */\n  final case class PolyFunction(\n    typeParams: List[TypeParam],\n    result: TypeRepr\n  ) extends TypeRepr\n\n  /** Dependent function: (x: A) => x.T */\n  final case class DependentFunction(\n    params: List[Param],\n    result: TypeRepr  // May contain references to param names\n  ) extends TypeRepr\n\n  // ==================== Special Parameter Types ====================\n\n  /** By-name type: => A */\n  final case class ByName(underlying: TypeRepr) extends TypeRepr\n\n  /** Repeated/vararg type: A* */\n  final case class Repeated(underlying: TypeRepr) extends TypeRepr\n\n  // ==================== Tuple Types ====================\n\n  /** Tuple type with optional labels: (A, B) or (name: String, age: Int) */\n  final case class Tuple(elements: List[TupleElement]) extends TypeRepr {\n    def arity: Int = elements.size\n    def isNamed: Boolean = elements.exists(_.label.isDefined)\n    def isPositional: Boolean = elements.forall(_.label.isEmpty)\n    \n    def labels: List[Option[String]] = elements.map(_.label)\n    def types: List[TypeRepr] = elements.map(_.tpe)\n  }\n\n  final case class TupleElement(\n    label: Option[String],\n    tpe: TypeRepr\n  )\n  \n  object Tuple {\n    def positional(types: TypeRepr*): Tuple = \n      Tuple(types.map(t => TupleElement(None, t)).toList)\n      \n    def named(fields: (String, TypeRepr)*): Tuple =\n      Tuple(fields.map { case (n, t) => TupleElement(Some(n), t) }.toList)\n  }\n\n  // ==================== Singleton & Literal Types ====================\n\n  /** Singleton type: x.type */\n  final case class Singleton(path: TermPath) extends TypeRepr {\n    def isStable: Boolean = path.isStable\n  }\n\n  /** This type: this.type within a class */\n  final case class ThisType(owner: TypeId[? <: AnyKind]) extends TypeRepr\n\n  /** Super type reference */\n  final case class SuperType(\n    thisType: TypeRepr,\n    mixinTrait: Option[TypeRepr]\n  ) extends TypeRepr\n\n  /** Literal/constant type: 42, \"foo\", true */\n  final case class ConstantType(value: Constant) extends TypeRepr\n\n  // ==================== Match Types ====================\n\n  /** Match type: T match { case P => R; ... } */\n  final case class MatchType(\n    bound: TypeRepr,\n    scrutinee: TypeRepr,\n    cases: List[MatchTypeCase]\n  ) extends TypeRepr\n\n  final case class MatchTypeCase(\n    bindings: List[TypeParam],  // Captured type vars, e.g., `t` in `case Array[t] => t`\n    pattern: TypeRepr,\n    result: TypeRepr            // Can reference bindings via ParamRef\n  )\n\n  // ==================== Bounded/Wildcard Types ====================\n\n  /** Wildcard with bounds: ? <: Upper, ? >: Lower */\n  final case class Wildcard(bounds: TypeBounds) extends TypeRepr\n  \n  object Wildcard {\n    val unbounded: Wildcard = Wildcard(TypeBounds.empty)\n    def <:(upper: TypeRepr): Wildcard = Wildcard(TypeBounds.upper(upper))\n    def >:(lower: TypeRepr): Wildcard = Wildcard(TypeBounds.lower(lower))\n  }\n\n  // ==================== Recursive Types ====================\n\n  /** Recursive type: used for recursive type aliases */\n  final case class RecType(body: TypeRepr) extends TypeRepr\n\n  /** Reference to enclosing RecType */\n  case object RecThis extends TypeRepr\n\n  // ==================== Annotated Types ====================\n\n  /** Type with annotations: A @ann */\n  final case class Annotated(\n    underlying: TypeRepr,\n    annotations: List[Annotation]\n  ) extends TypeRepr\n\n  // ==================== Top, Bottom, and Special Types ====================\n\n  case object AnyType extends TypeRepr\n  case object AnyKindType extends TypeRepr\n  case object NothingType extends TypeRepr\n  case object NullType extends TypeRepr\n  case object UnitType extends TypeRepr\n\n  // ==================== Substitution ====================\n\n  def substitute(repr: TypeRepr, subs: Map[TypeParam, TypeRepr]): TypeRepr = {\n    def go(r: TypeRepr): TypeRepr = r match {\n      case ParamRef(param, 0) => subs.getOrElse(param, r)\n      case ParamRef(_, _) => r  // Different binder depth\n      case Ref(_) => r\n      case Applied(tycon, args) => Applied(go(tycon), args.map(go))\n      case TypeLambda(params, body) =>\n        // Shift substitutions to account for new binders\n        val shifted = subs.map { case (p, t) => p -> shiftBinderDepth(t, 1) }\n        TypeLambda(params, substitute(body, shifted))\n      case Intersection(comps) => Intersection(comps.map(go))\n      case Union(comps) => Union(comps.map(go))\n      case Structural(parents, members) =>\n        Structural(parents.map(go), members.map(substituteMember(_, subs)))\n      case Function(params, result) => Function(params.map(go), go(result))\n      case ContextFunction(params, result) => ContextFunction(params.map(go), go(result))\n      case PolyFunction(tps, result) => PolyFunction(tps, go(result))\n      case DependentFunction(params, result) =>\n        DependentFunction(params.map(p => p.copy(tpe = go(p.tpe))), go(result))\n      case ByName(u) => ByName(go(u))\n      case Repeated(u) => Repeated(go(u))\n      case Tuple(elems) => Tuple(elems.map(e => e.copy(tpe = go(e.tpe))))\n      case MatchType(bound, scrutinee, cases) =>\n        MatchType(go(bound), go(scrutinee), cases.map(substituteMatchCase(_, subs)))\n      case Wildcard(bounds) => Wildcard(substituteBounds(bounds, subs))\n      case RecType(body) => RecType(go(body))\n      case Annotated(underlying, anns) => Annotated(go(underlying), anns)\n      case TypeSelect(_, _) | TypeProjection(_, _) | Singleton(_) |\n           ThisType(_) | SuperType(_, _) | ConstantType(_) | RecThis |\n           AnyType | AnyKindType | NothingType | NullType | UnitType => r\n    }\n    go(repr)\n  }\n\n  private def shiftBinderDepth(repr: TypeRepr, delta: Int): TypeRepr = repr match {\n    case ParamRef(param, depth) => ParamRef(param, depth + delta)\n    case Applied(tycon, args) => Applied(shiftBinderDepth(tycon, delta), args.map(shiftBinderDepth(_, delta)))\n    // ... other cases follow same pattern\n    case other => other  // Simplified; full impl would recurse\n  }\n\n  private def substituteBounds(bounds: TypeBounds, subs: Map[TypeParam, TypeRepr]): TypeBounds =\n    TypeBounds(bounds.lower.map(substitute(_, subs)), bounds.upper.map(substitute(_, subs)))\n\n  private def substituteMatchCase(c: MatchTypeCase, subs: Map[TypeParam, TypeRepr]): MatchTypeCase = {\n    // Remove bindings from substitution map (they shadow outer params)\n    val shadowedSubs = subs -- c.bindings\n    MatchTypeCase(c.bindings, substitute(c.pattern, shadowedSubs), substitute(c.result, shadowedSubs))\n  }\n\n  private def substituteMember(m: Member, subs: Map[TypeParam, TypeRepr]): Member = m match {\n    case Member.Val(name, tpe, isMutable, targetName, annotations) =>\n      Member.Val(name, substitute(tpe, subs), isMutable, targetName, annotations)\n    case Member.Def(name, typeParams, paramClauses, result, targetName, annotations) =>\n      Member.Def(\n        name, typeParams,\n        paramClauses.map(substituteParamClause(_, subs)),\n        substitute(result, subs),\n        targetName, annotations\n      )\n    case Member.TypeMember(name, typeParams, bounds, alias, annotations) =>\n      Member.TypeMember(\n        name, typeParams,\n        substituteBounds(bounds, subs),\n        alias.map(substitute(_, subs)),\n        annotations\n      )\n  }\n\n  private def substituteParamClause(clause: ParamClause, subs: Map[TypeParam, TypeRepr]): ParamClause = {\n    def subParam(p: Param): Param = p.copy(tpe = substitute(p.tpe, subs))\n    clause match {\n      case ParamClause.Regular(params) => ParamClause.Regular(params.map(subParam))\n      case ParamClause.Using(params) => ParamClause.Using(params.map(subParam))\n      case ParamClause.Implicit(params) => ParamClause.Implicit(params.map(subParam))\n    }\n  }\n}\n```\n\n---\n\n## Members: For Structural Types\n```scala\nsealed trait Member\n\nobject Member {\n  final case class Val(\n    name: String,\n    tpe: TypeRepr,\n    isMutable: Boolean = false,\n    targetName: Option[String] = None,  // @targetName annotation\n    annotations: List[Annotation] = Nil\n  ) extends Member\n\n  final case class Def(\n    name: String,\n    typeParams: List[TypeParam] = Nil,\n    paramClauses: List[ParamClause] = Nil,\n    result: TypeRepr,\n    targetName: Option[String] = None,\n    annotations: List[Annotation] = Nil\n  ) extends Member {\n    def arity: Int = paramClauses.map(_.size).sum\n  }\n\n  final case class TypeMember(\n    name: String,\n    typeParams: List[TypeParam] = Nil,\n    bounds: TypeBounds = TypeBounds.empty,\n    alias: Option[TypeRepr] = None,  // Some = type alias, None = abstract\n    annotations: List[Annotation] = Nil\n  ) extends Member {\n    def isAbstract: Boolean = alias.isEmpty && bounds != TypeBounds.empty\n    def isAlias: Boolean = alias.isDefined\n  }\n}\n```\n\n---\n\n## Constants and Annotations\n\n### Constant\n```scala\nsealed trait Constant {\n  type Value\n  def value: Value\n}\n\nobject Constant {\n  final case class IntConst(value: Int) extends Constant { type Value = Int }\n  final case class LongConst(value: Long) extends Constant { type Value = Long }\n  final case class FloatConst(value: Float) extends Constant { type Value = Float }\n  final case class DoubleConst(value: Double) extends Constant { type Value = Double }\n  final case class BooleanConst(value: Boolean) extends Constant { type Value = Boolean }\n  final case class CharConst(value: Char) extends Constant { type Value = Char }\n  final case class StringConst(value: String) extends Constant { type Value = String }\n  final case class NullConst() extends Constant { type Value = Null; def value: Null = null }\n  final case class UnitConst() extends Constant { type Value = Unit; def value: Unit = () }\n  final case class ClassOfConst(tpe: TypeRepr) extends Constant { type Value = TypeRepr; def value: TypeRepr = tpe }\n}\n```\n\n### Annotation\n```scala\nfinal case class Annotation(\n  tpe: TypeRepr,\n  args: List[AnnotationArg]\n)\n\nsealed trait AnnotationArg\n\nobject AnnotationArg {\n  final case class ConstArg(value: Constant) extends AnnotationArg\n  final case class ArrayArg(elements: List[AnnotationArg]) extends AnnotationArg\n  final case class NestedArg(annotation: Annotation) extends AnnotationArg\n  final case class TypeArg(tpe: TypeRepr) extends AnnotationArg\n  final case class NamedArg(name: String, value: AnnotationArg) extends AnnotationArg\n}\n```\n\n---\n\n## Type Operations\n\n### Normalization\n\nExpands type aliases to their underlying types.\n```scala\nobject TypeNormalization {\n  \n  /**\n   * Normalize a type by expanding type aliases.\n   * Does NOT expand opaque types (they are nominally distinct).\n   */\n  def normalize(tpe: TypeRepr): TypeRepr = tpe match {\n    // Direct alias reference with no args\n    case TypeRepr.Ref(TypeId.Alias(_, _, Nil, aliased)) =>\n      normalize(aliased)\n    \n    // Applied alias: expand and substitute\n    case TypeRepr.Applied(TypeRepr.Ref(TypeId.Alias(_, _, params, aliased)), args) \n        if params.size == args.size =>\n      val subs = params.zip(args.map(normalize)).toMap\n      normalize(TypeRepr.substitute(aliased, subs))\n    \n    // Recurse into compound types\n    case TypeRepr.Applied(tycon, args) =>\n      TypeRepr.Applied(normalize(tycon), args.map(normalize))\n    \n    case TypeRepr.Intersection(comps) =>\n      TypeRepr.Intersection(comps.map(normalize))\n    \n    case TypeRepr.Union(comps) =>\n      TypeRepr.Union(comps.map(normalize))\n    \n    case TypeRepr.Function(params, result) =>\n      TypeRepr.Function(params.map(normalize), normalize(result))\n    \n    case TypeRepr.ContextFunction(params, result) =>\n      TypeRepr.ContextFunction(params.map(normalize), normalize(result))\n    \n    case TypeRepr.Tuple(elems) =>\n      TypeRepr.Tuple(elems.map(e => e.copy(tpe = normalize(e.tpe))))\n    \n    case TypeRepr.ByName(u) => TypeRepr.ByName(normalize(u))\n    case TypeRepr.Repeated(u) => TypeRepr.Repeated(normalize(u))\n    case TypeRepr.Annotated(u, anns) => TypeRepr.Annotated(normalize(u), anns)\n    case TypeRepr.Wildcard(bounds) => \n      TypeRepr.Wildcard(TypeBounds(bounds.lower.map(normalize), bounds.upper.map(normalize)))\n    \n    // Atoms don't change\n    case _ => tpe\n  }\n  \n  /**\n   * Get the underlying representation of an opaque type.\n   * Only valid within the opaque type's defining scope.\n   */\n  def unwrapOpaque(tpe: TypeRepr): Option[TypeRepr] = tpe match {\n    case TypeRepr.Ref(TypeId.Opaque(_, _, Nil, repr, _)) =>\n      Some(repr)\n    case TypeRepr.Applied(TypeRepr.Ref(TypeId.Opaque(_, _, params, repr, _)), args)\n        if params.size == args.size =>\n      val subs = params.zip(args).toMap\n      Some(TypeRepr.substitute(repr, subs))\n    case _ => None\n  }\n}\n```\n\n### Type Equality\n```scala\nobject TypeEquality {\n  \n  /**\n   * Check if two types are equal (after normalization).\n   * This is structural equality, not reference equality.\n   */\n  def areEqual(a: TypeRepr, b: TypeRepr): Boolean = {\n    val aNorm = TypeNormalization.normalize(a)\n    val bNorm = TypeNormalization.normalize(b)\n    structurallyEqual(aNorm, bNorm)\n  }\n  \n  private def structurallyEqual(a: TypeRepr, b: TypeRepr): Boolean = (a, b) match {\n    case (TypeRepr.Ref(idA), TypeRepr.Ref(idB)) =>\n      idA.fullName == idB.fullName\n    \n    case (TypeRepr.ParamRef(pA, dA), TypeRepr.ParamRef(pB, dB)) =>\n      pA.index == pB.index && dA == dB\n    \n    case (TypeRepr.Applied(tcA, argsA), TypeRepr.Applied(tcB, argsB)) =>\n      structurallyEqual(tcA, tcB) && \n        argsA.size == argsB.size &&\n        argsA.zip(argsB).forall { case (x, y) => structurallyEqual(x, y) }\n    \n    case (TypeRepr.Intersection(cA), TypeRepr.Intersection(cB)) =>\n      cA.size == cB.size && cA.zip(cB).forall { case (x, y) => structurallyEqual(x, y) }\n    \n    case (TypeRepr.Union(cA), TypeRepr.Union(cB)) =>\n      cA.size == cB.size && cA.zip(cB).forall { case (x, y) => structurallyEqual(x, y) }\n    \n    case (TypeRepr.Function(pA, rA), TypeRepr.Function(pB, rB)) =>\n      pA.size == pB.size &&\n        pA.zip(pB).forall { case (x, y) => structurallyEqual(x, y) } &&\n        structurallyEqual(rA, rB)\n    \n    case (TypeRepr.Tuple(eA), TypeRepr.Tuple(eB)) =>\n      eA.size == eB.size && eA.zip(eB).forall { case (x, y) => \n        x.label == y.label && structurallyEqual(x.tpe, y.tpe)\n      }\n    \n    case (TypeRepr.ConstantType(cA), TypeRepr.ConstantType(cB)) =>\n      cA == cB\n    \n    case (TypeRepr.AnyType, TypeRepr.AnyType) => true\n    case (TypeRepr.NothingType, TypeRepr.NothingType) => true\n    case (TypeRepr.NullType, TypeRepr.NullType) => true\n    case (TypeRepr.UnitType, TypeRepr.UnitType) => true\n    \n    // More cases for full coverage...\n    case _ => false\n  }\n}\n```\n\n### Subtyping\n```scala\nobject Subtyping {\n  \n  /**\n   * Context for subtyping calculations.\n   * Tracks assumptions to handle recursive types and avoid infinite loops.\n   */\n  final case class Context(\n    assumptions: Set[(TypeRepr, TypeRepr)] = Set.empty,\n    depth: Int = 0,\n    maxDepth: Int = 100\n  ) {\n    def assume(sub: TypeRepr, sup: TypeRepr): Context =\n      copy(assumptions = assumptions + ((sub, sup)))\n    \n    def isAssumed(sub: TypeRepr, sup: TypeRepr): Boolean =\n      assumptions.contains((sub, sup))\n    \n    def deeper: Context = copy(depth = depth + 1)\n    def tooDeep: Boolean = depth >= maxDepth\n  }\n  \n  /**\n   * Check if `sub` is a subtype of `sup`.\n   * \n   * Implements the Scala 3 subtyping rules including:\n   * - Reflexivity: A <: A\n   * - Top: A <: Any for all A\n   * - Bottom: Nothing <: A for all A  \n   * - Variance-aware generic subtyping\n   * - Union/intersection type rules\n   * - Structural subtyping\n   */\n  def isSubtype(sub: TypeRepr, sup: TypeRepr)(using ctx: Context = Context()): Boolean = ???\n  \n  /**\n   * Check if two types are equivalent (mutual subtypes).\n   */\n  def isEquivalent(a: TypeRepr, b: TypeRepr)(using ctx: Context = Context()): Boolean =\n    isSubtype(a, b) && isSubtype(b, a)\n  \n  /**\n   * Find the least upper bound (LUB) of two types.\n   * Returns the most specific type that is a supertype of both.\n   */\n  def lub(a: TypeRepr, b: TypeRepr): TypeRepr = ???\n  \n  /**\n   * Find the greatest lower bound (GLB) of two types.\n   * Returns the most general type that is a subtype of both.\n   */\n  def glb(a: TypeRepr, b: TypeRepr): TypeRepr = ???\n  \n  /**\n   * Check if a type conforms to given bounds.\n   */\n  def conformsToBounds(tpe: TypeRepr, bounds: TypeBounds)(using ctx: Context = Context()): Boolean = {\n    val lowerOk = bounds.lower.forall(lo => isSubtype(lo, tpe))\n    val upperOk = bounds.upper.forall(hi => isSubtype(tpe, hi))\n    lowerOk && upperOk\n  }\n  \n  /**\n   * Reduce a match type to its result, if possible.\n   * Returns None if the match type cannot be reduced (e.g., abstract scrutinee).\n   */\n  def reduceMatchType(mt: TypeRepr.MatchType)(using ctx: Context = Context()): Option[TypeRepr] = ???\n}\n```\n\n---\n\n## Standard Library Type Definitions\n\nPredefined `TypeId` instances for common types.\n```scala\nobject StandardTypes {\n  import TypeDefKind.*\n  \n  private val scalaOwner = Owner.pkg(\"scala\")\n  private val scalaCollectionImmutable = Owner.pkgs(\"scala\", \"collection\", \"immutable\")\n  private val javaLang = Owner.pkgs(\"java\", \"lang\")\n  \n  // ========== Primitives ==========\n  \n  val IntId: TypeId[Int] = TypeId.nominal[Int](\n    \"Int\", scalaOwner, Nil, Class(isFinal = true, isValue = true)\n  )\n  \n  val LongId: TypeId[Long] = TypeId.nominal[Long](\n    \"Long\", scalaOwner, Nil, Class(isFinal = true, isValue = true)\n  )\n  \n  val DoubleId: TypeId[Double] = TypeId.nominal[Double](\n    \"Double\", scalaOwner, Nil, Class(isFinal = true, isValue = true)\n  )\n  \n  val FloatId: TypeId[Float] = TypeId.nominal[Float](\n    \"Float\", scalaOwner, Nil, Class(isFinal = true, isValue = true)\n  )\n  \n  val BooleanId: TypeId[Boolean] = TypeId.nominal[Boolean](\n    \"Boolean\", scalaOwner, Nil, Class(isFinal = true, isValue = true)\n  )\n  \n  val CharId: TypeId[Char] = TypeId.nominal[Char](\n    \"Char\", scalaOwner, Nil, Class(isFinal = true, isValue = true)\n  )\n  \n  val ByteId: TypeId[Byte] = TypeId.nominal[Byte](\n    \"Byte\", scalaOwner, Nil, Class(isFinal = true, isValue = true)\n  )\n  \n  val ShortId: TypeId[Short] = TypeId.nominal[Short](\n    \"Short\", scalaOwner, Nil, Class(isFinal = true, isValue = true)\n  )\n  \n  val UnitId: TypeId[Unit] = TypeId.nominal[Unit](\n    \"Unit\", scalaOwner, Nil, Class(isFinal = true, isValue = true)\n  )\n  \n  // ========== Reference Types ==========\n  \n  val StringId: TypeId[String] = TypeId.nominal[String](\n    \"String\", javaLang, Nil, Class(isFinal = true)\n  )\n  \n  val AnyId: TypeId[Any] = TypeId.nominal[Any](\n    \"Any\", scalaOwner, Nil, Class(isAbstract = true)\n  )\n  \n  val AnyRefId: TypeId[AnyRef] = TypeId.nominal[AnyRef](\n    \"AnyRef\", scalaOwner, Nil, Class(isAbstract = true),\n    parents = List(TypeRepr.Ref(AnyId))\n  )\n  \n  val AnyValId: TypeId[AnyVal] = TypeId.nominal[AnyVal](\n    \"AnyVal\", scalaOwner, Nil, Class(isAbstract = true),\n    parents = List(TypeRepr.Ref(AnyId))\n  )\n  \n  val NothingId: TypeId[Nothing] = TypeId.nominal[Nothing](\n    \"Nothing\", scalaOwner, Nil, Class(isFinal = true, isAbstract = true)\n  )\n  \n  val NullId: TypeId[Null] = TypeId.nominal[Null](\n    \"Null\", scalaOwner, Nil, Class(isFinal = true)\n  )\n  \n  // ========== Collection Type Constructors ==========\n  \n  private val A = TypeParam.covariant(\"A\", 0)\n  private val K = TypeParam.invariant(\"K\", 0)\n  private val V = TypeParam.covariant(\"V\", 1)\n  \n  val ListId: TypeId[List] = TypeId.nominal[List](\n    \"List\", scalaCollectionImmutable, List(A), Trait(isSealed = true)\n  )\n  \n  val VectorId: TypeId[Vector] = TypeId.nominal[Vector](\n    \"Vector\", scalaCollectionImmutable, List(A), Class(isFinal = true)\n  )\n  \n  val SetId: TypeId[Set] = TypeId.nominal[Set](\n    \"Set\", scalaCollectionImmutable, List(A), Trait()\n  )\n  \n  val MapId: TypeId[Map] = TypeId.nominal[Map](\n    \"Map\", scalaCollectionImmutable, List(K, V), Trait()\n  )\n  \n  val OptionId: TypeId[Option] = TypeId.nominal[Option](\n    \"Option\", scalaOwner, List(A), Trait(isSealed = true)\n  )\n  \n  val EitherA = TypeParam.covariant(\"A\", 0)\n  val EitherB = TypeParam.covariant(\"B\", 1)\n  val EitherId: TypeId[Either] = TypeId.nominal[Either](\n    \"Either\", scalaOwner, List(EitherA, EitherB), Trait(isSealed = true)\n  )\n  \n  // ========== Tuple Type Constructors ==========\n  \n  val EmptyTupleId: TypeId[EmptyTuple] = TypeId.nominal[EmptyTuple](\n    \"EmptyTuple\", scalaOwner, Nil, Object\n  )\n  \n  val TupleConsH = TypeParam.covariant(\"H\", 0)\n  val TupleConsT = TypeParam.covariant(\"T\", 1, bounds = TypeBounds.upper(TypeRepr.Ref(???))) // <: Tuple\n  val TupleConsId: TypeId[*:] = TypeId.nominal[*:](\n    \"*:\", scalaOwner, List(TupleConsH, TupleConsT), Class(isFinal = true, isCase = true)\n  )\n  \n  // ========== Convenience TypeRepr Builders ==========\n  \n  def int: TypeRepr = TypeRepr.Ref(IntId)\n  def long: TypeRepr = TypeRepr.Ref(LongId)\n  def double: TypeRepr = TypeRepr.Ref(DoubleId)\n  def float: TypeRepr = TypeRepr.Ref(FloatId)\n  def boolean: TypeRepr = TypeRepr.Ref(BooleanId)\n  def string: TypeRepr = TypeRepr.Ref(StringId)\n  def unit: TypeRepr = TypeRepr.UnitType\n  def any: TypeRepr = TypeRepr.AnyType\n  def nothing: TypeRepr = TypeRepr.NothingType\n  \n  def list(elem: TypeRepr): TypeRepr = TypeRepr.Applied(TypeRepr.Ref(ListId), List(elem))\n  def option(elem: TypeRepr): TypeRepr = TypeRepr.Applied(TypeRepr.Ref(OptionId), List(elem))\n  def map(key: TypeRepr, value: TypeRepr): TypeRepr = TypeRepr.Applied(TypeRepr.Ref(MapId), List(key, value))\n  def either(left: TypeRepr, right: TypeRepr): TypeRepr = TypeRepr.Applied(TypeRepr.Ref(EitherId), List(left, right))\n}\n```\n\n---\n\n## Example Usage\n```scala\nobject Examples {\n  import TypeRepr.*\n  import StandardTypes.*\n  \n  // ========== Simple Types ==========\n  \n  val intType: TypeRepr = int\n  val stringType: TypeRepr = string\n  val listOfInt: TypeRepr = list(int)\n  val mapStringToInt: TypeRepr = map(string, int)\n  \n  // ========== Named Tuple ==========\n  \n  // (name: String, age: Int)\n  val personTuple: TypeRepr = Tuple.named(\n    \"name\" -> string,\n    \"age\" -> int\n  )\n  \n  // ========== Type Alias ==========\n  \n  // type Age = Int\n  val AgeId: TypeId[Int] = TypeId.alias[Int](\n    \"Age\",\n    Owner.pkg(\"myapp\"),\n    Nil,\n    int\n  )\n  \n  // type StringMap[V] = Map[String, V]\n  val V = TypeParam.covariant(\"V\", 0)\n  val StringMapId: TypeId[Map[String, *]] = TypeId.alias[Map[String, *]](\n    \"StringMap\",\n    Owner.pkg(\"myapp\"),\n    List(V),\n    Applied(Ref(MapId), List(string, ParamRef(V)))\n  )\n  \n  // ========== Opaque Type ==========\n  \n  // opaque type Email = String\n  val EmailId: TypeId[String] = TypeId.opaque[String](\n    \"Email\",\n    Owner.pkg(\"myapp\"),\n    Nil,\n    string\n  )\n  \n  // ========== Enum ==========\n  \n  val ColorId: TypeId[?] = TypeId.nominal(\n    \"Color\",\n    Owner.pkg(\"myapp\"),\n    Nil,\n    TypeDefKind.Enum(List(\n      EnumCaseInfo(\"Red\", 0, Nil, isObjectCase = true),\n      EnumCaseInfo(\"Green\", 1, Nil, isObjectCase = true),\n      EnumCaseInfo(\"Blue\", 2, Nil, isObjectCase = true),\n      EnumCaseInfo(\"RGB\", 3, List(\n        EnumCaseParam(\"r\", int),\n        EnumCaseParam(\"g\", int),\n        EnumCaseParam(\"b\", int)\n      ), isObjectCase = false)\n    ))\n  )\n  \n  // ========== Match Type ==========\n  \n  // type Elem[X] = X match { case String => Char; case Array[t] => t }\n  val X = TypeParam.invariant(\"X\", 0)\n  val t = TypeParam.invariant(\"t\", 0)\n  \n  val ElemId: TypeId[?] = TypeId.alias(\n    \"Elem\",\n    Owner.pkg(\"myapp\"),\n    List(X),\n    MatchType(\n      bound = any,\n      scrutinee = ParamRef(X),\n      cases = List(\n        MatchTypeCase(Nil, string, Ref(CharId)),\n        MatchTypeCase(\n          List(t),\n          Applied(Ref(???), List(ParamRef(t))), // Array[t]\n          ParamRef(t)\n        )\n      )\n    )\n  )\n  \n  // ========== Structural Type ==========\n  \n  // { def size: Int; val name: String }\n  val sizedNamed: TypeRepr = Structural(\n    parents = Nil,\n    members = List(\n      Member.Def(\"size\", Nil, Nil, int),\n      Member.Val(\"name\", string)\n    )\n  )\n  \n  // ========== Path-Dependent Type ==========\n  \n  // myModule.Inner.T\n  val pathDependent: TypeRepr = TypeSelect(\n    TermPath(List(\n      TermPath.Package(\"myapp\"),\n      TermPath.Module(\"myModule\"),\n      TermPath.Module(\"Inner\")\n    )),\n    \"T\"\n  )\n  \n  // ========== Intersection & Union ==========\n  \n  // String & { def foo: Int }\n  val stringWithFoo: TypeRepr = Intersection(\n    string,\n    Structural(Nil, List(Member.Def(\"foo\", Nil, Nil, int)))\n  )\n  \n  // String | Int\n  val stringOrInt: TypeRepr = Union(string, int)\n  \n  // ========== Function Types ==========\n  \n  // (Int, String) => Boolean\n  val func: TypeRepr = Function(List(int, string), boolean)\n  \n  // (Int, String) ?=> Boolean (context function)\n  val ctxFunc: TypeRepr = ContextFunction(List(int, string), boolean)\n  \n  // [A] => A => A (polymorphic function)\n  val polyFunc: TypeRepr = PolyFunction(\n    List(TypeParam.invariant(\"A\", 0)),\n    Function(List(ParamRef(TypeParam.invariant(\"A\", 0))), ParamRef(TypeParam.invariant(\"A\", 0)))\n  )\n}\n```\n\n---\n\n## Macro Derivation (Sketch)\n```scala\nimport scala.quoted.*\n\nobject TypeIdMacros {\n  \n  /**\n   * Derive a TypeId for any type or type constructor at compile time.\n   * Captures all type information available to the compiler.\n   */\n  inline def derive[A <: AnyKind]: TypeId[A] = ${ deriveMacro[A] }\n  \n  def deriveMacro[A <: AnyKind: Type](using Quotes): Expr[TypeId[A]] = {\n    import quotes.reflect.*\n    \n    val tpe = TypeRepr.of[A]\n    \n    // Extract type information from compiler\n    // ... implementation details ...\n    \n    ???\n  }\n  \n  /**\n   * Derive a TypeRepr for a concrete type at compile time.\n   */\n  inline def typeRepr[A]: TypeRepr = ${ typeReprMacro[A] }\n  \n  def typeReprMacro[A: Type](using Quotes): Expr[TypeRepr] = ???\n}\n```\n\n---\n\n## Open Questions / Future Work\n\n1. **Recursive type handling**: The `RecType`/`RecThis` encoding may need refinement for complex recursive types.\n\n2. **Match type reduction**: Full implementation requires tracking what patterns are \"provably disjoint.\"\n\n3. **Structural subtyping**: Member-by-member comparison with proper handling of overloaded methods.\n\n4. **Scala 2 compatibility**: Some constructs (existentials, compound types) may need additional representation.\n\n5. **Serialization format**: The data model is designed for runtime use; a compact serialization format (e.g., protobuf schema) would be a natural next step.",
                  "html_url": "https://github.com/zio/zio-blocks/issues/471"
                },
                "type": "github"
              },
              "hash": "zio/zio-blocks#471",
              "body": "# Design and Implement `TypeId` for Type Registry\n\n## Goal\n\nDesign and implement a `TypeId[A]` data structure that can faithfully represent any Scala type or type constructor, capturing sufficient metadata to support:\n\n- **Type identity**: Uniquely identifying types across serialization boundaries\n- **Subtype checking**: Implementing `isSubtypeOf` directly on `TypeId` without runtime reflection\n- **Type equality**: Determining structural and nominal type equivalence\n- **Map/Set keys**: Using `TypeId` as keys in type registries (requires correct `equals`/`hashCode`)\n- **Macro derivation**: Derivation of `TypeId` for any type or type constructor, source-compatible across Scala 2/3\n\nThe data type must be used to wholly replace `TypeName` in the source code of ZIO Blocks.\n\n## Requirements\n\n### API Surface\n```scala\n// Explicit derivation\nval stringId: TypeId[String] = TypeId.of[String]\nval listId: TypeId[List] = TypeId.of[List]  // Type constructors supported\n\n// Implicit derivation for generic code\ndef process[A](value: A)(implicit typeId: TypeId[A]): Unit = ???\n\n// Or using Scala 3 context bounds\ndef process[A: TypeId](value: A): Unit = ???\n\n// Use as map keys in type registries\nval registry: Map[TypeId[_], Binding[_]] = Map(\n  TypeId.of[String] -> stringBinding,\n  TypeId.of[List[Int]] -> listIntBinding\n)\n```\n\n### Cross-Version Support\n\n- **Scala 2.13**: Use `scala.reflect.macros` for compile-time derivation\n- **Scala 3.x (3.03.7+)**: Use `scala.quoted` macros\n\nThe runtime data model (`TypeId`, `TypeRepr`, etc.) should be shared across versions. Only the macro implementations differ.\n\n### Equals and HashCode Contract\n\n`TypeId` instances will be used as keys in `Map` and `Set` collections within type registries. The `equals` and `hashCode` implementations must satisfy the following requirements:\n\n#### Equality Semantics\n\n1. **Nominal identity for non-aliases**: Two `TypeId` instances referring to the same nominal type (same `fullName`) are equal, regardless of when/where the macro derived them.\n\n2. **Type alias transparency**: Type aliases should be equal to their underlying types after normalization.\n```scala\n   type Age = Int\n   TypeId.of[Age] == TypeId.of[Int]  // true (after normalization)\n```\n\n3. **Opaque type nominality**: Opaque types are *not* equal to their representation or to other opaque types.\n```scala\n   opaque type Email = String\n   opaque type UserId = String\n   TypeId.of[Email] == TypeId.of[String]  // false\n   TypeId.of[Email] == TypeId.of[UserId]  // false\n```\n\n4. **Applied types**: Two applied types are equal iff their type constructors are equal and all type arguments are equal.\n```scala\n   TypeId.of[List[Int]] == TypeId.of[List[Int]]      // true\n   TypeId.of[List[Int]] == TypeId.of[List[String]]  // false\n```\n\n5. **Structural types**: Two structural types are equal iff they have the same members (by name and type).\n\n6. **Compound types**: Order matters for intersections and unions (or they must be normalized to a canonical order).\n```scala\n   // Option A: Order-sensitive\n   TypeId.of[A & B] != TypeId.of[B & A]\n   \n   // Option B: Canonicalized (preferred)\n   TypeId.of[A & B] == TypeId.of[B & A]  // after sorting components\n```\n\n#### HashCode Requirements\n\n1. **Consistency**: `hashCode` must be consistent with `equals`equal objects must have equal hash codes.\n\n2. **Stability**: The same `TypeId` derived in different compilation units or at different times must produce the same `hashCode`.\n\n3. **Distribution**: Hash codes should be well-distributed to avoid collisions in hash maps.\n\n4. **Determinism**: `hashCode` must not depend on object identity, memory addresses, or other non-deterministic factors.\n\n#### Implementation Approach\n```scala\nsealed trait TypeId[A <: AnyKind] {\n  // ... other members ...\n\n  /** \n   * Equality based on normalized type structure.\n   * Type aliases are expanded before comparison.\n   */\n  override def equals(other: Any): Boolean = other match {\n    case that: TypeId[_] => TypeId.structurallyEqual(this, that)\n    case _ => false\n  }\n\n  /**\n   * Hash code based on normalized type structure.\n   * Must be consistent with equals.\n   */\n  override def hashCode(): Int = TypeId.structuralHash(this)\n}\n\nobject TypeId {\n  /**\n   * Compare two TypeIds for structural equality after normalization.\n   */\n  def structurallyEqual(a: TypeId[_], b: TypeId[_]): Boolean = {\n    // 1. Normalize both (expand aliases)\n    // 2. Compare structure recursively\n    // 3. For opaque types, compare by fullName only (nominal)\n    ???\n  }\n\n  /**\n   * Compute a stable hash code for a TypeId.\n   */\n  def structuralHash(id: TypeId[_]): Int = {\n    // 1. Normalize (expand aliases)\n    // 2. Compute hash from structural components\n    // 3. Must use stable values (fullName, not object identity)\n    ???\n  }\n}\n```\n\n#### Edge Cases\n\n- **Recursive types**: Must handle cycles without infinite loops in both `equals` and `hashCode`.\n- **Type parameters**: `TypeId.of[List]` (unapplied) must have different hash than `TypeId.of[List[Int]]` (applied).\n- **Path-dependent types**: `a.T` and `b.T` are equal only if `a` and `b` are the same stable path.\n- **Local types**: Types defined in local scopes need unique identification (e.g., include source location or synthetic index).\n\n### Key Operations\n```scala\ntrait TypeId[A <: AnyKind] {\n  def name: String\n  def fullName: String\n  def owner: Owner\n  def typeParams: List[TypeParam]\n  def parents: List[TypeRepr]\n  \n  // Core operations\n  def isSubtypeOf(other: TypeId[_]): Boolean\n  def isSupertypeOf(other: TypeId[_]): Boolean\n  def isEquivalentTo(other: TypeId[_]): Boolean\n  \n  // Equality (for use as map keys)\n  override def equals(other: Any): Boolean\n  override def hashCode(): Int\n}\n```\n\n## Attached Design Document\n\nSee the attached `TypeId-DataModel.md` for a comprehensive sketch of:\n\n- Core data structures (`TypeId`, `TypeRepr`, `TypeParam`, `Owner`, etc.)\n- Type expression representation (applied types, intersections, unions, match types, etc.)\n- Variance and bounds modeling\n- Substitution and normalization algorithms\n- Standard library type definitions\n\n> [!WARNING]\n> **The attached document is a design sketch, not production code.** Some details may be incorrect, incomplete, or require adjustment during implementation. It should be treated as a starting point for discussion and iteration, not a specification to implement verbatim.\n\n## Test Strategy\n\nComprehensive testing should validate four layers: **macro derivation correctness**, **data model completeness**, **type operation correctness**, and **equals/hashCode correctness**.\n\n### 1. Equals and HashCode Tests\n\nThese tests are critical since `TypeId` will be used as map keys.\n\n#### Basic Contract Tests\n```scala\ntest(\"equals is reflexive\") {\n  val id = TypeId.of[String]\n  assertTrue(id == id)\n  assertTrue(id.equals(id))\n}\n\ntest(\"equals is symmetric\") {\n  val id1 = TypeId.of[String]\n  val id2 = TypeId.of[String]\n  assertTrue(id1 == id2)\n  assertTrue(id2 == id1)\n}\n\ntest(\"equals is transitive\") {\n  val id1 = TypeId.of[String]\n  val id2 = TypeId.of[String]\n  val id3 = TypeId.of[String]\n  assertTrue(id1 == id2)\n  assertTrue(id2 == id3)\n  assertTrue(id1 == id3)\n}\n\ntest(\"hashCode is consistent with equals\") {\n  val id1 = TypeId.of[String]\n  val id2 = TypeId.of[String]\n  assertTrue(id1 == id2)\n  assertTrue(id1.hashCode == id2.hashCode)\n}\n\ntest(\"hashCode is stable across invocations\") {\n  val id = TypeId.of[List[Int]]\n  val hash1 = id.hashCode\n  val hash2 = id.hashCode\n  assertTrue(hash1 == hash2)\n}\n```\n\n#### Nominal Type Equality\n```scala\ntest(\"same nominal types are equal\") {\n  assertTrue(TypeId.of[String] == TypeId.of[String])\n  assertTrue(TypeId.of[Int] == TypeId.of[Int])\n  assertTrue(TypeId.of[List[Int]] == TypeId.of[List[Int]])\n}\n\ntest(\"different nominal types are not equal\") {\n  assertTrue(TypeId.of[String] != TypeId.of[Int])\n  assertTrue(TypeId.of[List[Int]] != TypeId.of[List[String]])\n  assertTrue(TypeId.of[List[Int]] != TypeId.of[Vector[Int]])\n}\n```\n\n#### Type Alias Equality\n```scala\ntest(\"type aliases equal their underlying types\") {\n  type Age = Int\n  type Name = String\n  \n  assertTrue(TypeId.of[Age] == TypeId.of[Int])\n  assertTrue(TypeId.of[Name] == TypeId.of[String])\n  assertTrue(TypeId.of[Age].hashCode == TypeId.of[Int].hashCode)\n}\n\ntest(\"chained type aliases resolve correctly\") {\n  type A = Int\n  type B = A\n  type C = B\n  \n  assertTrue(TypeId.of[C] == TypeId.of[Int])\n  assertTrue(TypeId.of[C] == TypeId.of[A])\n  assertTrue(TypeId.of[C] == TypeId.of[B])\n}\n\ntest(\"generic type aliases equal their expansion\") {\n  type MyList[A] = List[A]\n  \n  assertTrue(TypeId.of[MyList[Int]] == TypeId.of[List[Int]])\n  assertTrue(TypeId.of[MyList[String]] == TypeId.of[List[String]])\n}\n```\n\n#### Opaque Type Equality\n```scala\ntest(\"opaque types are not equal to their representation\") {\n  opaque type Email = String\n  \n  assertTrue(TypeId.of[Email] != TypeId.of[String])\n  assertTrue(TypeId.of[Email].hashCode != TypeId.of[String].hashCode) // likely but not guaranteed\n}\n\ntest(\"different opaque types are not equal even with same representation\") {\n  opaque type Email = String\n  opaque type UserId = String\n  \n  assertTrue(TypeId.of[Email] != TypeId.of[UserId])\n}\n\ntest(\"same opaque type is equal to itself\") {\n  opaque type Email = String\n  \n  assertTrue(TypeId.of[Email] == TypeId.of[Email])\n}\n```\n\n#### Applied Type Equality\n```scala\ntest(\"applied types with same constructor and args are equal\") {\n  assertTrue(TypeId.of[List[Int]] == TypeId.of[List[Int]])\n  assertTrue(TypeId.of[Map[String, Int]] == TypeId.of[Map[String, Int]])\n  assertTrue(TypeId.of[Either[String, Int]] == TypeId.of[Either[String, Int]])\n}\n\ntest(\"applied types with different args are not equal\") {\n  assertTrue(TypeId.of[List[Int]] != TypeId.of[List[String]])\n  assertTrue(TypeId.of[Map[String, Int]] != TypeId.of[Map[Int, String]])\n}\n\ntest(\"unapplied type constructor not equal to applied type\") {\n  assertTrue(TypeId.of[List] != TypeId.of[List[Int]])\n  assertTrue(TypeId.of[Map] != TypeId.of[Map[String, Int]])\n}\n```\n\n#### Compound Type Equality\n```scala\ntest(\"intersection types equality\") {\n  // Assuming canonicalized ordering\n  assertTrue(TypeId.of[Serializable & Comparable[String]] == TypeId.of[Serializable & Comparable[String]])\n}\n\ntest(\"union types equality\") {\n  assertTrue(TypeId.of[Int | String] == TypeId.of[Int | String])\n}\n```\n\n#### Map/Set Usage Tests\n```scala\ntest(\"TypeId works as Map key\") {\n  val map = Map[TypeId[_], String](\n    TypeId.of[String] -> \"string\",\n    TypeId.of[Int] -> \"int\",\n    TypeId.of[List[Int]] -> \"list-int\"\n  )\n  \n  assertTrue(map(TypeId.of[String]) == \"string\")\n  assertTrue(map(TypeId.of[Int]) == \"int\")\n  assertTrue(map(TypeId.of[List[Int]]) == \"list-int\")\n  assertTrue(map.get(TypeId.of[Double]).isEmpty)\n}\n\ntest(\"TypeId works as Map key with type aliases\") {\n  type Age = Int\n  \n  val map = Map[TypeId[_], String](\n    TypeId.of[Int] -> \"int\"\n  )\n  \n  // Should find the entry via alias\n  assertTrue(map(TypeId.of[Age]) == \"int\")\n}\n\ntest(\"TypeId works in Set\") {\n  val set = Set(\n    TypeId.of[String],\n    TypeId.of[Int],\n    TypeId.of[List[Int]]\n  )\n  \n  assertTrue(set.contains(TypeId.of[String]))\n  assertTrue(set.contains(TypeId.of[Int]))\n  assertTrue(!set.contains(TypeId.of[Double]))\n}\n\ntest(\"TypeId deduplication in Set\") {\n  type Age = Int\n  \n  val set = Set(\n    TypeId.of[Int],\n    TypeId.of[Age]  // Should deduplicate\n  )\n  \n  assertTrue(set.size == 1)\n}\n\ntest(\"mutable HashMap works with TypeId\") {\n  val map = scala.collection.mutable.HashMap[TypeId[_], String]()\n  \n  map(TypeId.of[String]) = \"string\"\n  map(TypeId.of[Int]) = \"int\"\n  \n  assertTrue(map(TypeId.of[String]) == \"string\")\n  \n  // Update via equal key\n  type Name = String\n  map(TypeId.of[Name]) = \"updated\"\n  assertTrue(map(TypeId.of[String]) == \"updated\")\n}\n```\n\n#### Cross-Compilation Equality\n```scala\ntest(\"TypeId equality is stable across compilation units\") {\n  // id1 derived in CompilationUnitA\n  val id1 = CompilationUnitA.stringTypeId\n  // id2 derived in CompilationUnitB  \n  val id2 = CompilationUnitB.stringTypeId\n  \n  assertTrue(id1 == id2)\n  assertTrue(id1.hashCode == id2.hashCode)\n}\n```\n\n### 2. Macro Derivation Tests\n\nVerify that the macro correctly captures type information for all supported type forms.\n\n#### Primitive and Basic Types\n```scala\ntest(\"derives primitives correctly\") {\n  assertTrue(TypeId.of[Int].name == \"Int\")\n  assertTrue(TypeId.of[String].fullName == \"java.lang.String\")\n  assertTrue(TypeId.of[Unit].isValueClass)\n}\n```\n\n#### Generic Types and Type Constructors\n```scala\ntest(\"derives type constructors\") {\n  val listId = TypeId.of[List]\n  assertTrue(listId.arity == 1)\n  assertTrue(listId.typeParams.head.variance == Variance.Covariant)\n}\n\ntest(\"derives applied types\") {\n  val listIntId = TypeId.of[List[Int]]\n  // Should capture that this is List applied to Int\n}\n\ntest(\"derives higher-kinded types\") {\n  val functorId = TypeId.of[Functor]  // Functor[F[_]]\n  assertTrue(functorId.typeParams.head.kind == Kind.`* -> *`)\n}\n```\n\n#### Type Aliases and Opaque Types\n```scala\ntype Age = Int\nopaque type Email = String\n\ntest(\"derives type aliases\") {\n  val ageId = TypeId.of[Age]\n  assertTrue(ageId.isAlias)\n  assertTrue(ageId.aliasedTo == Some(TypeRepr.Ref(TypeId.of[Int])))\n}\n\ntest(\"derives opaque types\") {\n  val emailId = TypeId.of[Email]\n  assertTrue(emailId.isOpaque)\n  // Representation should be captured\n}\n```\n\n#### Classes, Traits, Objects, Enums\n```scala\nsealed trait Animal\ncase class Dog(name: String) extends Animal\ncase object Cat extends Animal\n\nenum Color { case Red, Green, Blue, RGB(r: Int, g: Int, b: Int) }\n\ntest(\"derives sealed hierarchy\") {\n  val animalId = TypeId.of[Animal]\n  assertTrue(animalId.isSealed)\n  assertTrue(animalId.defKind match {\n    case TypeDefKind.Trait(true, subtypes) => subtypes.nonEmpty\n    case _ => false\n  })\n}\n\ntest(\"derives enums with cases\") {\n  val colorId = TypeId.of[Color]\n  assertTrue(colorId.enumCases.map(_.name) == List(\"Red\", \"Green\", \"Blue\", \"RGB\"))\n  assertTrue(colorId.enumCases.find(_.name == \"RGB\").exists(_.params.nonEmpty))\n}\n```\n\n#### Structural and Refinement Types\n```scala\ntest(\"derives structural types\") {\n  type Sized = { def size: Int }\n  val sizedId = TypeId.of[Sized]\n  // Should capture the structural member\n}\n```\n\n#### Compound Types\n```scala\ntest(\"derives intersection types\") {\n  val id = TypeId.of[String & Serializable]\n  // Should capture both components\n}\n\ntest(\"derives union types\") {\n  val id = TypeId.of[String | Int]\n  // Should capture both components\n}\n```\n\n#### Tuple Types (Including Named Tuples for Scala 3.5+)\n```scala\ntest(\"derives positional tuples\") {\n  val id = TypeId.of[(Int, String, Boolean)]\n  // Should capture element types\n}\n\ntest(\"derives named tuples\") {  // Scala 3.5+\n  val id = TypeId.of[(name: String, age: Int)]\n  // Should capture labels and types\n}\n```\n\n#### Function Types\n```scala\ntest(\"derives function types\") {\n  val id = TypeId.of[(Int, String) => Boolean]\n  // Should capture param types and result type\n}\n\ntest(\"derives context function types\") {  // Scala 3\n  val id = TypeId.of[(Int, String) ?=> Boolean]\n}\n\ntest(\"derives polymorphic function types\") {  // Scala 3\n  val id = TypeId.of[[A] => A => A]\n}\n```\n\n#### Path-Dependent and Singleton Types\n```scala\nobject Outer {\n  object Inner {\n    type T = Int\n  }\n  val inner: Inner.type = Inner\n}\n\ntest(\"derives path-dependent types\") {\n  val id = TypeId.of[Outer.Inner.T]\n  // Should capture the path\n}\n\ntest(\"derives singleton types\") {\n  val id = TypeId.of[Outer.Inner.type]\n}\n```\n\n#### Match Types (Scala 3)\n```scala\ntype Elem[X] = X match {\n  case String => Char\n  case Array[t] => t\n}\n\ntest(\"derives match types\") {\n  val id = TypeId.of[Elem]\n  // Should capture scrutinee, cases, and binders\n}\n```\n\n### 3. Data Model Completeness Tests\n\nVerify that round-tripping through the model preserves type information.\n```scala\ntest(\"TypeRepr substitution is correct\") {\n  val A = TypeParam(\"A\", 0)\n  val listOfA = TypeRepr.Applied(TypeRepr.Ref(listId), List(TypeRepr.ParamRef(A)))\n  val substituted = listOfA.substitute(Map(A -> TypeRepr.Ref(intId)))\n  assertTrue(substituted == TypeRepr.Applied(TypeRepr.Ref(listId), List(TypeRepr.Ref(intId))))\n}\n\ntest(\"normalization expands aliases\") {\n  type MyInt = Int\n  val myIntRepr = TypeRepr.Ref(TypeId.of[MyInt])\n  val normalized = TypeNormalization.normalize(myIntRepr)\n  assertTrue(normalized == TypeRepr.Ref(TypeId.of[Int]))\n}\n```\n\n### 4. Subtyping Tests\n\nVerify that `isSubtypeOf` correctly implements Scala's subtyping rules.\n\n#### Basic Subtyping\n```scala\ntest(\"Nothing is subtype of everything\") {\n  assertTrue(TypeId.of[Nothing].isSubtypeOf(TypeId.of[Int]))\n  assertTrue(TypeId.of[Nothing].isSubtypeOf(TypeId.of[String]))\n  assertTrue(TypeId.of[Nothing].isSubtypeOf(TypeId.of[Any]))\n}\n\ntest(\"everything is subtype of Any\") {\n  assertTrue(TypeId.of[Int].isSubtypeOf(TypeId.of[Any]))\n  assertTrue(TypeId.of[String].isSubtypeOf(TypeId.of[Any]))\n  assertTrue(TypeId.of[List[Int]].isSubtypeOf(TypeId.of[Any]))\n}\n\ntest(\"reflexivity\") {\n  assertTrue(TypeId.of[String].isSubtypeOf(TypeId.of[String]))\n  assertTrue(TypeId.of[List[Int]].isSubtypeOf(TypeId.of[List[Int]]))\n}\n```\n\n#### Variance-Aware Subtyping\n```scala\ntest(\"covariant type parameter subtyping\") {\n  // List is covariant: List[Dog] <: List[Animal]\n  assertTrue(TypeId.of[List[Dog]].isSubtypeOf(TypeId.of[List[Animal]]))\n  assertTrue(!TypeId.of[List[Animal]].isSubtypeOf(TypeId.of[List[Dog]]))\n}\n\ntest(\"contravariant type parameter subtyping\") {\n  // Function1 is contravariant in input: (Animal => Int) <: (Dog => Int)\n  assertTrue(TypeId.of[Animal => Int].isSubtypeOf(TypeId.of[Dog => Int]))\n  assertTrue(!TypeId.of[Dog => Int].isSubtypeOf(TypeId.of[Animal => Int]))\n}\n\ntest(\"invariant type parameter subtyping\") {\n  // Array is invariant\n  assertTrue(!TypeId.of[Array[Dog]].isSubtypeOf(TypeId.of[Array[Animal]]))\n  assertTrue(!TypeId.of[Array[Animal]].isSubtypeOf(TypeId.of[Array[Dog]]))\n}\n```\n\n#### Union and Intersection Types\n```scala\ntest(\"union type subtyping\") {\n  // A <: A | B and B <: A | B\n  assertTrue(TypeId.of[Int].isSubtypeOf(TypeId.of[Int | String]))\n  assertTrue(TypeId.of[String].isSubtypeOf(TypeId.of[Int | String]))\n  \n  // A | B <: C requires both A <: C and B <: C\n  assertTrue(!TypeId.of[Int | String].isSubtypeOf(TypeId.of[Int]))\n}\n\ntest(\"intersection type subtyping\") {\n  // A & B <: A and A & B <: B\n  assertTrue(TypeId.of[Serializable & Comparable[String]].isSubtypeOf(TypeId.of[Serializable]))\n  \n  // A <: B & C requires A <: B and A <: C\n}\n```\n\n#### Nominal Hierarchy Subtyping\n```scala\ntest(\"class hierarchy subtyping\") {\n  assertTrue(TypeId.of[Dog].isSubtypeOf(TypeId.of[Animal]))\n  assertTrue(TypeId.of[String].isSubtypeOf(TypeId.of[CharSequence]))\n}\n```\n\n#### Type Alias Transparency\n```scala\ntest(\"type aliases are transparent for subtyping\") {\n  type Age = Int\n  assertTrue(TypeId.of[Age].isSubtypeOf(TypeId.of[Int]))\n  assertTrue(TypeId.of[Int].isSubtypeOf(TypeId.of[Age]))\n  assertTrue(TypeId.of[Age].isEquivalentTo(TypeId.of[Int]))\n}\n```\n\n#### Opaque Type Nominality\n```scala\ntest(\"opaque types are nominally distinct\") {\n  opaque type Email = String\n  opaque type UserId = String\n  \n  assertTrue(!TypeId.of[Email].isSubtypeOf(TypeId.of[String]))  // Outside defining scope\n  assertTrue(!TypeId.of[Email].isSubtypeOf(TypeId.of[UserId]))\n}\n```\n\n### 5. Edge Cases and Regression Tests\n```scala\ntest(\"handles recursive types\") {\n  enum Tree[+A] {\n    case Leaf(value: A)\n    case Branch(left: Tree[A], right: Tree[A])\n  }\n  val treeId = TypeId.of[Tree]\n  // Should not stack overflow on equals/hashCode\n  val hash = treeId.hashCode  // Must terminate\n  assertTrue(treeId == treeId)    // Must terminate\n}\n\ntest(\"handles deeply nested generics\") {\n  val id = TypeId.of[List[Map[String, Option[Either[Int, List[String]]]]]]\n  // Should capture full structure\n  val hash = id.hashCode\n  assertTrue(id == TypeId.of[List[Map[String, Option[Either[Int, List[String]]]]]])\n}\n\ntest(\"handles local and anonymous types\") {\n  def foo() = {\n    class Local\n    TypeId.of[Local]\n  }\n  // Should handle gracefully\n}\n\ntest(\"handles Java types\") {\n  val id = TypeId.of[java.util.ArrayList[String]]\n  // Should interop correctly\n}\n```\n\n### 6. Cross-Compilation Tests\n\nRun the same test suite on both Scala 2.13 and Scala 3.x to ensure consistent behavior:\n```scala\n// In shared test sources\nclass TypeIdSpec extends AnyFunSuite {\n  // All tests above should pass on both Scala versions\n}\n```\n\nSpecific attention should be paid to:\n- Features that exist only in Scala 3 (union/intersection types, enums, match types, named tuples)\n- Features with different representations (Scala 2 existentials vs Scala 3 wildcards)\n- Macro API differences (should be invisible to users but implementation must handle both)\n- **Equality of TypeIds derived in Scala 2 vs Scala 3 for the same type** (if cross-published)\n\n## Acceptance Criteria\n\n- [ ] `TypeId.of[A]` works for all documented type forms on Scala 2.13\n- [ ] `TypeId.of[A]` works for all documented type forms on Scala 3.03.7\n- [ ] `implicit TypeId[A]` derivation works in generic contexts\n- [ ] `isSubtypeOf` correctly handles variance, unions, intersections, and nominal hierarchies\n- [ ] Type aliases are normalized correctly\n- [ ] Opaque types maintain nominal distinction\n- [ ] **`equals` and `hashCode` satisfy the Java contract**\n- [ ] **`TypeId` works correctly as `Map` and `Set` keys**\n- [ ] **Type aliases resolve to equal `TypeId` as their underlying types**\n- [ ] **Opaque types have distinct `TypeId` from their representation**\n- [ ] **`hashCode` is stable and deterministic across compilations**\n- [ ] All tests pass on both Scala versions\n- [ ] No runtime reflection is required (all information captured at compile time)\n\n# Sketch of TypeId\n\n# TypeId Data Model for Scala 3.x Type Registry\n\nA comprehensive data model for representing Scala 3 types and type constructors, designed to support:\n- Lossless type representation for serialization/deserialization frameworks\n- Subtype checking (`isSubtypeOf`)\n- Type equality checking\n- Type normalization (alias expansion)\n\n## Design Principles\n\n1. **Polykinded phantom types**: `TypeId[A <: AnyKind]` preserves Scala type information at compile time\n2. **Separation of identity and representation**: `TypeId` identifies types; `TypeRepr` represents type expressions\n3. **Complete metadata**: Capture everything a macro can know at compile time\n4. **Stability tracking**: Path-dependent types require knowing path stability\n\n---\n\n## Core Data Model\n\n### Variance\n```scala\nenum Variance {\n  case Invariant\n  case Covariant\n  case Contravariant\n\n  def symbol: String = this match {\n    case Invariant     => \"\"\n    case Covariant     => \"+\"\n    case Contravariant => \"-\"\n  }\n\n  /** Flip variance for contravariant positions */\n  def flip: Variance = this match {\n    case Invariant     => Invariant\n    case Covariant     => Contravariant\n    case Contravariant => Covariant\n  }\n}\n```\n\n### TypeBounds\n```scala\nfinal case class TypeBounds(\n  lower: Option[TypeRepr],  // >: bound\n  upper: Option[TypeRepr]   // <: bound\n) {\n  def isUnbounded: Boolean = lower.isEmpty && upper.isEmpty\n  \n  def hasLower: Boolean = lower.isDefined\n  def hasUpper: Boolean = upper.isDefined\n  \n  /** Combine bounds (intersection of constraints) */\n  def &(other: TypeBounds): TypeBounds = TypeBounds(\n    lower = (lower, other.lower) match {\n      case (Some(l1), Some(l2)) => Some(TypeRepr.Union(l1, l2))\n      case (Some(l), None) => Some(l)\n      case (None, Some(l)) => Some(l)\n      case (None, None) => None\n    },\n    upper = (upper, other.upper) match {\n      case (Some(u1), Some(u2)) => Some(TypeRepr.Intersection(u1, u2))\n      case (Some(u), None) => Some(u)\n      case (None, Some(u)) => Some(u)\n      case (None, None) => None\n    }\n  )\n}\n\nobject TypeBounds {\n  val empty: TypeBounds = TypeBounds(None, None)\n  \n  def upper(tpe: TypeRepr): TypeBounds = TypeBounds(None, Some(tpe))\n  def lower(tpe: TypeRepr): TypeBounds = TypeBounds(Some(tpe), None)\n  def exact(tpe: TypeRepr): TypeBounds = TypeBounds(Some(tpe), Some(tpe))\n}\n```\n\n### Kind\n\nRepresents the \"type of a type\" - distinguishing proper types from type constructors.\n```scala\nsealed trait Kind {\n  def arity: Int\n  def isProperType: Boolean = this == Kind.Type\n  def isHigherKinded: Boolean = !isProperType\n}\n\nobject Kind {\n  /** Proper type: Int, String, List[Int] */\n  case object Type extends Kind { \n    def arity: Int = 0 \n  }\n\n  /** Type constructor: List, Option, Map */\n  final case class Arrow(params: List[Kind], result: Kind) extends Kind {\n    def arity: Int = params.size\n  }\n\n  // Convenience constructors\n  val `* -> *`: Kind = Arrow(List(Type), Type)\n  val `* -> * -> *`: Kind = Arrow(List(Type, Type), Type)\n  val `(* -> *) -> *`: Kind = Arrow(List(`* -> *`), Type)\n  \n  def arity(n: Int): Kind = \n    if (n == 0) Type \n    else Arrow(List.fill(n)(Type), Type)\n}\n```\n\n### TypeParam\n\nComplete type parameter specification with all information needed for subtyping.\n```scala\nfinal case class TypeParam(\n  name: String,\n  index: Int,\n  variance: Variance = Variance.Invariant,\n  bounds: TypeBounds = TypeBounds.empty,\n  kind: Kind = Kind.Type\n) {\n  def isHigherKinded: Boolean = kind.isHigherKinded\n  def isCovariant: Boolean = variance == Variance.Covariant\n  def isContravariant: Boolean = variance == Variance.Contravariant\n  def isInvariant: Boolean = variance == Variance.Invariant\n}\n\nobject TypeParam {\n  def invariant(name: String, index: Int): TypeParam = \n    TypeParam(name, index, Variance.Invariant)\n    \n  def covariant(name: String, index: Int): TypeParam = \n    TypeParam(name, index, Variance.Covariant)\n    \n  def contravariant(name: String, index: Int): TypeParam = \n    TypeParam(name, index, Variance.Contravariant)\n}\n```\n\n---\n\n## Type Definition Classification\n\n### TypeDefKind\n\nClassifies what kind of type definition a `TypeId` represents.\n```scala\nsealed trait TypeDefKind\n\nobject TypeDefKind {\n  final case class Class(\n    isFinal: Boolean = false,\n    isAbstract: Boolean = false,\n    isCase: Boolean = false,\n    isValue: Boolean = false  // extends AnyVal\n  ) extends TypeDefKind\n\n  final case class Trait(\n    isSealed: Boolean = false,\n    knownSubtypes: List[TypeRepr] = Nil\n  ) extends TypeDefKind\n\n  /** Singleton object */\n  case object Object extends TypeDefKind\n\n  /** Scala 3 enum */\n  final case class Enum(\n    cases: List[EnumCaseInfo]\n  ) extends TypeDefKind\n\n  /** Individual enum case (when represented as its own type) */\n  final case class EnumCase(\n    parentEnum: TypeRepr,\n    ordinal: Int,\n    isObjectCase: Boolean  // case Red vs case RGB(...)\n  ) extends TypeDefKind\n\n  /** Type alias: type Foo = Bar */\n  case object TypeAlias extends TypeDefKind\n\n  /** Opaque type: opaque type Foo = Bar */\n  final case class OpaqueType(\n    publicBounds: TypeBounds  // Bounds visible outside defining scope\n  ) extends TypeDefKind\n\n  /** Abstract type member */\n  case object AbstractType extends TypeDefKind\n}\n\n/** Information about an enum case for serialization */\nfinal case class EnumCaseInfo(\n  name: String,\n  ordinal: Int,\n  params: List[EnumCaseParam],  // Empty for object cases\n  isObjectCase: Boolean\n) {\n  def arity: Int = params.size\n}\n\nfinal case class EnumCaseParam(\n  name: String,\n  tpe: TypeRepr\n)\n```\n\n---\n\n## Parameters and Clauses\n\n### ParamClause\n```scala\nsealed trait ParamClause {\n  def params: List[Param]\n  def isEmpty: Boolean = params.isEmpty\n  def size: Int = params.size\n}\n\nobject ParamClause {\n  final case class Regular(params: List[Param]) extends ParamClause\n  final case class Using(params: List[Param]) extends ParamClause\n  final case class Implicit(params: List[Param]) extends ParamClause\n  \n  val empty: ParamClause = Regular(Nil)\n}\n```\n\n### Param\n```scala\nfinal case class Param(\n  name: String,\n  tpe: TypeRepr,\n  hasDefault: Boolean = false,\n  isRepeated: Boolean = false  // varargs: A*\n)\n```\n\n---\n\n## Ownership and Paths\n\n### Owner\n\nRepresents the lexical owner of a type definition.\n```scala\nfinal case class Owner(segments: List[Owner.Segment]) {\n  def /(segment: Owner.Segment): Owner = Owner(segments :+ segment)\n  \n  def parent: Option[Owner] = \n    if (segments.isEmpty) None \n    else Some(Owner(segments.init))\n  \n  def isRoot: Boolean = segments.isEmpty\n  \n  def asString: String = segments.map(_.show).mkString(\".\")\n  \n  /** Check if this owner is a prefix of another */\n  def isPrefixOf(other: Owner): Boolean =\n    other.segments.startsWith(segments)\n}\n\nobject Owner {\n  sealed trait Segment {\n    def name: String\n    def show: String = name\n  }\n\n  final case class Package(name: String) extends Segment\n  final case class Term(name: String) extends Segment\n  final case class Type(name: String) extends Segment\n  final case class Local(index: Int) extends Segment {\n    def name: String = s\"<local$index>\"\n  }\n\n  val Root: Owner = Owner(Nil)\n  \n  def pkg(name: String): Owner = Owner(List(Package(name)))\n  def pkgs(names: String*): Owner = Owner(names.map(Package(_)).toList)\n}\n```\n\n### TermPath\n\nRepresents paths to terms, used for singleton and path-dependent types.\n```scala\nfinal case class TermPath(segments: List[TermPath.Segment]) {\n  def /(segment: TermPath.Segment): TermPath = \n    TermPath(segments :+ segment)\n  \n  def isStable: Boolean = segments.forall(_.isStable)\n  \n  def asString: String = segments.map(_.name).mkString(\".\")\n}\n\nobject TermPath {\n  sealed trait Segment {\n    def name: String\n    def isStable: Boolean\n  }\n\n  /** Package reference - always stable */\n  final case class Package(name: String) extends Segment {\n    def isStable: Boolean = true\n  }\n\n  /** Object/module reference - always stable */\n  final case class Module(name: String) extends Segment {\n    def isStable: Boolean = true\n  }\n\n  /** Val reference - stable */\n  final case class Val(name: String) extends Segment {\n    def isStable: Boolean = true\n  }\n\n  /** Lazy val reference - stable */\n  final case class LazyVal(name: String) extends Segment {\n    def isStable: Boolean = true\n  }\n\n  /** Var reference - NOT stable */\n  final case class Var(name: String) extends Segment {\n    def isStable: Boolean = false\n  }\n\n  /** Def/method reference - NOT stable */\n  final case class Def(name: String) extends Segment {\n    def isStable: Boolean = false\n  }\n\n  /** This reference */\n  final case class This(ownerName: String) extends Segment {\n    def name: String = s\"$ownerName.this\"\n    def isStable: Boolean = true\n  }\n\n  /** Super reference */\n  final case class Super(ownerName: String, mixinName: Option[String]) extends Segment {\n    def name: String = mixinName.fold(s\"$ownerName.super\")(m => s\"$ownerName.super[$m]\")\n    def isStable: Boolean = true\n  }\n\n  val empty: TermPath = TermPath(Nil)\n}\n```\n\n---\n\n## TypeId: Type Identity\n\nThe primary type for identifying types and type constructors.\n```scala\nsealed trait TypeId[A <: AnyKind] {\n  def name: String\n  def owner: Owner\n  def typeParams: List[TypeParam]\n  def defKind: TypeDefKind\n  def parents: List[TypeRepr]\n  def selfType: Option[TypeRepr]\n  def aliasedTo: Option[TypeRepr]      // For type aliases\n  def representation: Option[TypeRepr] // For opaque types\n  def annotations: List[Annotation]\n\n  // Derived properties\n  final def arity: Int = typeParams.size\n  \n  final def fullName: String =\n    if (owner.isRoot) name\n    else s\"${owner.asString}.$name\"\n\n  final def isProperType: Boolean = arity == 0\n  final def isTypeConstructor: Boolean = arity > 0\n\n  final def isClass: Boolean = defKind.isInstanceOf[TypeDefKind.Class]\n  final def isTrait: Boolean = defKind.isInstanceOf[TypeDefKind.Trait]\n  final def isObject: Boolean = defKind == TypeDefKind.Object\n  final def isEnum: Boolean = defKind.isInstanceOf[TypeDefKind.Enum]\n  final def isAlias: Boolean = defKind == TypeDefKind.TypeAlias\n  final def isOpaque: Boolean = defKind.isInstanceOf[TypeDefKind.OpaqueType]\n  final def isAbstract: Boolean = defKind == TypeDefKind.AbstractType\n\n  final def isSealed: Boolean = defKind match {\n    case TypeDefKind.Trait(isSealed, _) => isSealed\n    case _ => false\n  }\n\n  final def isCaseClass: Boolean = defKind match {\n    case TypeDefKind.Class(_, _, isCase, _) => isCase\n    case _ => false\n  }\n\n  final def isValueClass: Boolean = defKind match {\n    case TypeDefKind.Class(_, _, _, isValue) => isValue\n    case _ => false\n  }\n  \n  /** Get enum cases if this is an enum */\n  final def enumCases: List[EnumCaseInfo] = defKind match {\n    case TypeDefKind.Enum(cases) => cases\n    case _ => Nil\n  }\n}\n\nobject TypeId {\n  private final case class Impl[A <: AnyKind](\n    name: String,\n    owner: Owner,\n    typeParams: List[TypeParam],\n    defKind: TypeDefKind,\n    parents: List[TypeRepr],\n    selfType: Option[TypeRepr],\n    aliasedTo: Option[TypeRepr],\n    representation: Option[TypeRepr],\n    annotations: List[Annotation]\n  ) extends TypeId[A]\n\n  // ========== Smart Constructors ==========\n\n  def nominal[A <: AnyKind](\n    name: String,\n    owner: Owner,\n    typeParams: List[TypeParam] = Nil,\n    defKind: TypeDefKind,\n    parents: List[TypeRepr] = Nil,\n    selfType: Option[TypeRepr] = None,\n    annotations: List[Annotation] = Nil\n  ): TypeId[A] = Impl[A](\n    name, owner, typeParams, defKind,\n    parents, selfType, None, None, annotations\n  )\n\n  def alias[A <: AnyKind](\n    name: String,\n    owner: Owner,\n    typeParams: List[TypeParam] = Nil,\n    aliased: TypeRepr,\n    annotations: List[Annotation] = Nil\n  ): TypeId[A] = Impl[A](\n    name, owner, typeParams, TypeDefKind.TypeAlias,\n    Nil, None, Some(aliased), None, annotations\n  )\n\n  def opaque[A <: AnyKind](\n    name: String,\n    owner: Owner,\n    typeParams: List[TypeParam] = Nil,\n    representation: TypeRepr,\n    publicBounds: TypeBounds = TypeBounds.empty,\n    annotations: List[Annotation] = Nil\n  ): TypeId[A] = Impl[A](\n    name, owner, typeParams, TypeDefKind.OpaqueType(publicBounds),\n    Nil, None, None, Some(representation), annotations\n  )\n\n  // ========== Extractors ==========\n\n  object Nominal {\n    def unapply(id: TypeId[?]): Option[(String, Owner, List[TypeParam], TypeDefKind, List[TypeRepr])] =\n      if (id.aliasedTo.isEmpty && id.representation.isEmpty)\n        Some((id.name, id.owner, id.typeParams, id.defKind, id.parents))\n      else None\n  }\n\n  object Alias {\n    def unapply(id: TypeId[?]): Option[(String, Owner, List[TypeParam], TypeRepr)] =\n      id.aliasedTo.map(a => (id.name, id.owner, id.typeParams, a))\n  }\n\n  object Opaque {\n    def unapply(id: TypeId[?]): Option[(String, Owner, List[TypeParam], TypeRepr, TypeBounds)] =\n      (id.defKind, id.representation) match {\n        case (TypeDefKind.OpaqueType(bounds), Some(repr)) =>\n          Some((id.name, id.owner, id.typeParams, repr, bounds))\n        case _ => None\n      }\n  }\n\n  object Sealed {\n    def unapply(id: TypeId[?]): Option[(String, List[TypeRepr])] =\n      id.defKind match {\n        case TypeDefKind.Trait(true, subtypes) => Some((id.name, subtypes))\n        case _ => None\n      }\n  }\n  \n  object Enum {\n    def unapply(id: TypeId[?]): Option[(String, Owner, List[EnumCaseInfo])] =\n      id.defKind match {\n        case TypeDefKind.Enum(cases) => Some((id.name, id.owner, cases))\n        case _ => None\n      }\n  }\n}\n```\n\n---\n\n## TypeRepr: Type Expressions\n\nThe expression language for representing type structures.\n```scala\nsealed trait TypeRepr {\n  /** Substitute type parameters with concrete types */\n  def substitute(substitutions: Map[TypeParam, TypeRepr]): TypeRepr =\n    TypeRepr.substitute(this, substitutions)\n}\n\nobject TypeRepr {\n\n  // ==================== Type References ====================\n\n  /** Reference to a type by its TypeId */\n  final case class Ref(id: TypeId[? <: AnyKind]) extends TypeRepr\n\n  /** Reference to a type parameter */\n  final case class ParamRef(\n    param: TypeParam,\n    binderDepth: Int = 0  // De Bruijn index: 0 = innermost binder\n  ) extends TypeRepr\n\n  /** Path-dependent type: qualifier.Member */\n  final case class TypeSelect(\n    qualifier: TermPath,\n    memberName: String\n  ) extends TypeRepr {\n    def isStable: Boolean = qualifier.isStable\n  }\n\n  /** Type projection (deprecated but exists): Outer#Inner */\n  final case class TypeProjection(\n    prefix: TypeRepr,\n    memberName: String\n  ) extends TypeRepr\n\n  // ==================== Type Application ====================\n\n  /** Type constructor application: F[A, B] */\n  final case class Applied(\n    tycon: TypeRepr,\n    args: List[TypeRepr]\n  ) extends TypeRepr {\n    def arity: Int = args.size\n  }\n\n  // ==================== Type Constructors ====================\n\n  /** Type lambda: [X, Y] =>> F[X, Y] */\n  final case class TypeLambda(\n    params: List[TypeParam],\n    body: TypeRepr\n  ) extends TypeRepr {\n    def arity: Int = params.size\n  }\n\n  // ==================== Compound Types ====================\n\n  /** Intersection: A & B & C */\n  final case class Intersection(components: List[TypeRepr]) extends TypeRepr {\n    require(components.sizeIs >= 2, \"Intersection requires at least 2 types\")\n  }\n  \n  object Intersection {\n    def apply(left: TypeRepr, right: TypeRepr): Intersection =\n      (left, right) match {\n        case (Intersection(l), Intersection(r)) => Intersection(l ++ r)\n        case (Intersection(l), r) => Intersection(l :+ r)\n        case (l, Intersection(r)) => Intersection(l :: r)\n        case (l, r) => Intersection(List(l, r))\n      }\n  }\n\n  /** Union: A | B | C */\n  final case class Union(components: List[TypeRepr]) extends TypeRepr {\n    require(components.sizeIs >= 2, \"Union requires at least 2 types\")\n  }\n  \n  object Union {\n    def apply(left: TypeRepr, right: TypeRepr): Union =\n      (left, right) match {\n        case (Union(l), Union(r)) => Union(l ++ r)\n        case (Union(l), r) => Union(l :+ r)\n        case (l, Union(r)) => Union(l :: r)\n        case (l, r) => Union(List(l, r))\n      }\n  }\n\n  /** Structural/refinement type: { def foo: Int; type T } */\n  final case class Structural(\n    parents: List[TypeRepr],\n    members: List[Member]\n  ) extends TypeRepr\n\n  // ==================== Function Types ====================\n\n  /** Regular function: (A, B) => C */\n  final case class Function(\n    params: List[TypeRepr],\n    result: TypeRepr\n  ) extends TypeRepr {\n    def arity: Int = params.size\n  }\n\n  /** Context function: (A, B) ?=> C */\n  final case class ContextFunction(\n    params: List[TypeRepr],\n    result: TypeRepr\n  ) extends TypeRepr\n\n  /** Polymorphic function: [A] => A => A */\n  final case class PolyFunction(\n    typeParams: List[TypeParam],\n    result: TypeRepr\n  ) extends TypeRepr\n\n  /** Dependent function: (x: A) => x.T */\n  final case class DependentFunction(\n    params: List[Param],\n    result: TypeRepr  // May contain references to param names\n  ) extends TypeRepr\n\n  // ==================== Special Parameter Types ====================\n\n  /** By-name type: => A */\n  final case class ByName(underlying: TypeRepr) extends TypeRepr\n\n  /** Repeated/vararg type: A* */\n  final case class Repeated(underlying: TypeRepr) extends TypeRepr\n\n  // ==================== Tuple Types ====================\n\n  /** Tuple type with optional labels: (A, B) or (name: String, age: Int) */\n  final case class Tuple(elements: List[TupleElement]) extends TypeRepr {\n    def arity: Int = elements.size\n    def isNamed: Boolean = elements.exists(_.label.isDefined)\n    def isPositional: Boolean = elements.forall(_.label.isEmpty)\n    \n    def labels: List[Option[String]] = elements.map(_.label)\n    def types: List[TypeRepr] = elements.map(_.tpe)\n  }\n\n  final case class TupleElement(\n    label: Option[String],\n    tpe: TypeRepr\n  )\n  \n  object Tuple {\n    def positional(types: TypeRepr*): Tuple = \n      Tuple(types.map(t => TupleElement(None, t)).toList)\n      \n    def named(fields: (String, TypeRepr)*): Tuple =\n      Tuple(fields.map { case (n, t) => TupleElement(Some(n), t) }.toList)\n  }\n\n  // ==================== Singleton & Literal Types ====================\n\n  /** Singleton type: x.type */\n  final case class Singleton(path: TermPath) extends TypeRepr {\n    def isStable: Boolean = path.isStable\n  }\n\n  /** This type: this.type within a class */\n  final case class ThisType(owner: TypeId[? <: AnyKind]) extends TypeRepr\n\n  /** Super type reference */\n  final case class SuperType(\n    thisType: TypeRepr,\n    mixinTrait: Option[TypeRepr]\n  ) extends TypeRepr\n\n  /** Literal/constant type: 42, \"foo\", true */\n  final case class ConstantType(value: Constant) extends TypeRepr\n\n  // ==================== Match Types ====================\n\n  /** Match type: T match { case P => R; ... } */\n  final case class MatchType(\n    bound: TypeRepr,\n    scrutinee: TypeRepr,\n    cases: List[MatchTypeCase]\n  ) extends TypeRepr\n\n  final case class MatchTypeCase(\n    bindings: List[TypeParam],  // Captured type vars, e.g., `t` in `case Array[t] => t`\n    pattern: TypeRepr,\n    result: TypeRepr            // Can reference bindings via ParamRef\n  )\n\n  // ==================== Bounded/Wildcard Types ====================\n\n  /** Wildcard with bounds: ? <: Upper, ? >: Lower */\n  final case class Wildcard(bounds: TypeBounds) extends TypeRepr\n  \n  object Wildcard {\n    val unbounded: Wildcard = Wildcard(TypeBounds.empty)\n    def <:(upper: TypeRepr): Wildcard = Wildcard(TypeBounds.upper(upper))\n    def >:(lower: TypeRepr): Wildcard = Wildcard(TypeBounds.lower(lower))\n  }\n\n  // ==================== Recursive Types ====================\n\n  /** Recursive type: used for recursive type aliases */\n  final case class RecType(body: TypeRepr) extends TypeRepr\n\n  /** Reference to enclosing RecType */\n  case object RecThis extends TypeRepr\n\n  // ==================== Annotated Types ====================\n\n  /** Type with annotations: A @ann */\n  final case class Annotated(\n    underlying: TypeRepr,\n    annotations: List[Annotation]\n  ) extends TypeRepr\n\n  // ==================== Top, Bottom, and Special Types ====================\n\n  case object AnyType extends TypeRepr\n  case object AnyKindType extends TypeRepr\n  case object NothingType extends TypeRepr\n  case object NullType extends TypeRepr\n  case object UnitType extends TypeRepr\n\n  // ==================== Substitution ====================\n\n  def substitute(repr: TypeRepr, subs: Map[TypeParam, TypeRepr]): TypeRepr = {\n    def go(r: TypeRepr): TypeRepr = r match {\n      case ParamRef(param, 0) => subs.getOrElse(param, r)\n      case ParamRef(_, _) => r  // Different binder depth\n      case Ref(_) => r\n      case Applied(tycon, args) => Applied(go(tycon), args.map(go))\n      case TypeLambda(params, body) =>\n        // Shift substitutions to account for new binders\n        val shifted = subs.map { case (p, t) => p -> shiftBinderDepth(t, 1) }\n        TypeLambda(params, substitute(body, shifted))\n      case Intersection(comps) => Intersection(comps.map(go))\n      case Union(comps) => Union(comps.map(go))\n      case Structural(parents, members) =>\n        Structural(parents.map(go), members.map(substituteMember(_, subs)))\n      case Function(params, result) => Function(params.map(go), go(result))\n      case ContextFunction(params, result) => ContextFunction(params.map(go), go(result))\n      case PolyFunction(tps, result) => PolyFunction(tps, go(result))\n      case DependentFunction(params, result) =>\n        DependentFunction(params.map(p => p.copy(tpe = go(p.tpe))), go(result))\n      case ByName(u) => ByName(go(u))\n      case Repeated(u) => Repeated(go(u))\n      case Tuple(elems) => Tuple(elems.map(e => e.copy(tpe = go(e.tpe))))\n      case MatchType(bound, scrutinee, cases) =>\n        MatchType(go(bound), go(scrutinee), cases.map(substituteMatchCase(_, subs)))\n      case Wildcard(bounds) => Wildcard(substituteBounds(bounds, subs))\n      case RecType(body) => RecType(go(body))\n      case Annotated(underlying, anns) => Annotated(go(underlying), anns)\n      case TypeSelect(_, _) | TypeProjection(_, _) | Singleton(_) |\n           ThisType(_) | SuperType(_, _) | ConstantType(_) | RecThis |\n           AnyType | AnyKindType | NothingType | NullType | UnitType => r\n    }\n    go(repr)\n  }\n\n  private def shiftBinderDepth(repr: TypeRepr, delta: Int): TypeRepr = repr match {\n    case ParamRef(param, depth) => ParamRef(param, depth + delta)\n    case Applied(tycon, args) => Applied(shiftBinderDepth(tycon, delta), args.map(shiftBinderDepth(_, delta)))\n    // ... other cases follow same pattern\n    case other => other  // Simplified; full impl would recurse\n  }\n\n  private def substituteBounds(bounds: TypeBounds, subs: Map[TypeParam, TypeRepr]): TypeBounds =\n    TypeBounds(bounds.lower.map(substitute(_, subs)), bounds.upper.map(substitute(_, subs)))\n\n  private def substituteMatchCase(c: MatchTypeCase, subs: Map[TypeParam, TypeRepr]): MatchTypeCase = {\n    // Remove bindings from substitution map (they shadow outer params)\n    val shadowedSubs = subs -- c.bindings\n    MatchTypeCase(c.bindings, substitute(c.pattern, shadowedSubs), substitute(c.result, shadowedSubs))\n  }\n\n  private def substituteMember(m: Member, subs: Map[TypeParam, TypeRepr]): Member = m match {\n    case Member.Val(name, tpe, isMutable, targetName, annotations) =>\n      Member.Val(name, substitute(tpe, subs), isMutable, targetName, annotations)\n    case Member.Def(name, typeParams, paramClauses, result, targetName, annotations) =>\n      Member.Def(\n        name, typeParams,\n        paramClauses.map(substituteParamClause(_, subs)),\n        substitute(result, subs),\n        targetName, annotations\n      )\n    case Member.TypeMember(name, typeParams, bounds, alias, annotations) =>\n      Member.TypeMember(\n        name, typeParams,\n        substituteBounds(bounds, subs),\n        alias.map(substitute(_, subs)),\n        annotations\n      )\n  }\n\n  private def substituteParamClause(clause: ParamClause, subs: Map[TypeParam, TypeRepr]): ParamClause = {\n    def subParam(p: Param): Param = p.copy(tpe = substitute(p.tpe, subs))\n    clause match {\n      case ParamClause.Regular(params) => ParamClause.Regular(params.map(subParam))\n      case ParamClause.Using(params) => ParamClause.Using(params.map(subParam))\n      case ParamClause.Implicit(params) => ParamClause.Implicit(params.map(subParam))\n    }\n  }\n}\n```\n\n---\n\n## Members: For Structural Types\n```scala\nsealed trait Member\n\nobject Member {\n  final case class Val(\n    name: String,\n    tpe: TypeRepr,\n    isMutable: Boolean = false,\n    targetName: Option[String] = None,  // @targetName annotation\n    annotations: List[Annotation] = Nil\n  ) extends Member\n\n  final case class Def(\n    name: String,\n    typeParams: List[TypeParam] = Nil,\n    paramClauses: List[ParamClause] = Nil,\n    result: TypeRepr,\n    targetName: Option[String] = None,\n    annotations: List[Annotation] = Nil\n  ) extends Member {\n    def arity: Int = paramClauses.map(_.size).sum\n  }\n\n  final case class TypeMember(\n    name: String,\n    typeParams: List[TypeParam] = Nil,\n    bounds: TypeBounds = TypeBounds.empty,\n    alias: Option[TypeRepr] = None,  // Some = type alias, None = abstract\n    annotations: List[Annotation] = Nil\n  ) extends Member {\n    def isAbstract: Boolean = alias.isEmpty && bounds != TypeBounds.empty\n    def isAlias: Boolean = alias.isDefined\n  }\n}\n```\n\n---\n\n## Constants and Annotations\n\n### Constant\n```scala\nsealed trait Constant {\n  type Value\n  def value: Value\n}\n\nobject Constant {\n  final case class IntConst(value: Int) extends Constant { type Value = Int }\n  final case class LongConst(value: Long) extends Constant { type Value = Long }\n  final case class FloatConst(value: Float) extends Constant { type Value = Float }\n  final case class DoubleConst(value: Double) extends Constant { type Value = Double }\n  final case class BooleanConst(value: Boolean) extends Constant { type Value = Boolean }\n  final case class CharConst(value: Char) extends Constant { type Value = Char }\n  final case class StringConst(value: String) extends Constant { type Value = String }\n  final case class NullConst() extends Constant { type Value = Null; def value: Null = null }\n  final case class UnitConst() extends Constant { type Value = Unit; def value: Unit = () }\n  final case class ClassOfConst(tpe: TypeRepr) extends Constant { type Value = TypeRepr; def value: TypeRepr = tpe }\n}\n```\n\n### Annotation\n```scala\nfinal case class Annotation(\n  tpe: TypeRepr,\n  args: List[AnnotationArg]\n)\n\nsealed trait AnnotationArg\n\nobject AnnotationArg {\n  final case class ConstArg(value: Constant) extends AnnotationArg\n  final case class ArrayArg(elements: List[AnnotationArg]) extends AnnotationArg\n  final case class NestedArg(annotation: Annotation) extends AnnotationArg\n  final case class TypeArg(tpe: TypeRepr) extends AnnotationArg\n  final case class NamedArg(name: String, value: AnnotationArg) extends AnnotationArg\n}\n```\n\n---\n\n## Type Operations\n\n### Normalization\n\nExpands type aliases to their underlying types.\n```scala\nobject TypeNormalization {\n  \n  /**\n   * Normalize a type by expanding type aliases.\n   * Does NOT expand opaque types (they are nominally distinct).\n   */\n  def normalize(tpe: TypeRepr): TypeRepr = tpe match {\n    // Direct alias reference with no args\n    case TypeRepr.Ref(TypeId.Alias(_, _, Nil, aliased)) =>\n      normalize(aliased)\n    \n    // Applied alias: expand and substitute\n    case TypeRepr.Applied(TypeRepr.Ref(TypeId.Alias(_, _, params, aliased)), args) \n        if params.size == args.size =>\n      val subs = params.zip(args.map(normalize)).toMap\n      normalize(TypeRepr.substitute(aliased, subs))\n    \n    // Recurse into compound types\n    case TypeRepr.Applied(tycon, args) =>\n      TypeRepr.Applied(normalize(tycon), args.map(normalize))\n    \n    case TypeRepr.Intersection(comps) =>\n      TypeRepr.Intersection(comps.map(normalize))\n    \n    case TypeRepr.Union(comps) =>\n      TypeRepr.Union(comps.map(normalize))\n    \n    case TypeRepr.Function(params, result) =>\n      TypeRepr.Function(params.map(normalize), normalize(result))\n    \n    case TypeRepr.ContextFunction(params, result) =>\n      TypeRepr.ContextFunction(params.map(normalize), normalize(result))\n    \n    case TypeRepr.Tuple(elems) =>\n      TypeRepr.Tuple(elems.map(e => e.copy(tpe = normalize(e.tpe))))\n    \n    case TypeRepr.ByName(u) => TypeRepr.ByName(normalize(u))\n    case TypeRepr.Repeated(u) => TypeRepr.Repeated(normalize(u))\n    case TypeRepr.Annotated(u, anns) => TypeRepr.Annotated(normalize(u), anns)\n    case TypeRepr.Wildcard(bounds) => \n      TypeRepr.Wildcard(TypeBounds(bounds.lower.map(normalize), bounds.upper.map(normalize)))\n    \n    // Atoms don't change\n    case _ => tpe\n  }\n  \n  /**\n   * Get the underlying representation of an opaque type.\n   * Only valid within the opaque type's defining scope.\n   */\n  def unwrapOpaque(tpe: TypeRepr): Option[TypeRepr] = tpe match {\n    case TypeRepr.Ref(TypeId.Opaque(_, _, Nil, repr, _)) =>\n      Some(repr)\n    case TypeRepr.Applied(TypeRepr.Ref(TypeId.Opaque(_, _, params, repr, _)), args)\n        if params.size == args.size =>\n      val subs = params.zip(args).toMap\n      Some(TypeRepr.substitute(repr, subs))\n    case _ => None\n  }\n}\n```\n\n### Type Equality\n```scala\nobject TypeEquality {\n  \n  /**\n   * Check if two types are equal (after normalization).\n   * This is structural equality, not reference equality.\n   */\n  def areEqual(a: TypeRepr, b: TypeRepr): Boolean = {\n    val aNorm = TypeNormalization.normalize(a)\n    val bNorm = TypeNormalization.normalize(b)\n    structurallyEqual(aNorm, bNorm)\n  }\n  \n  private def structurallyEqual(a: TypeRepr, b: TypeRepr): Boolean = (a, b) match {\n    case (TypeRepr.Ref(idA), TypeRepr.Ref(idB)) =>\n      idA.fullName == idB.fullName\n    \n    case (TypeRepr.ParamRef(pA, dA), TypeRepr.ParamRef(pB, dB)) =>\n      pA.index == pB.index && dA == dB\n    \n    case (TypeRepr.Applied(tcA, argsA), TypeRepr.Applied(tcB, argsB)) =>\n      structurallyEqual(tcA, tcB) && \n        argsA.size == argsB.size &&\n        argsA.zip(argsB).forall { case (x, y) => structurallyEqual(x, y) }\n    \n    case (TypeRepr.Intersection(cA), TypeRepr.Intersection(cB)) =>\n      cA.size == cB.size && cA.zip(cB).forall { case (x, y) => structurallyEqual(x, y) }\n    \n    case (TypeRepr.Union(cA), TypeRepr.Union(cB)) =>\n      cA.size == cB.size && cA.zip(cB).forall { case (x, y) => structurallyEqual(x, y) }\n    \n    case (TypeRepr.Function(pA, rA), TypeRepr.Function(pB, rB)) =>\n      pA.size == pB.size &&\n        pA.zip(pB).forall { case (x, y) => structurallyEqual(x, y) } &&\n        structurallyEqual(rA, rB)\n    \n    case (TypeRepr.Tuple(eA), TypeRepr.Tuple(eB)) =>\n      eA.size == eB.size && eA.zip(eB).forall { case (x, y) => \n        x.label == y.label && structurallyEqual(x.tpe, y.tpe)\n      }\n    \n    case (TypeRepr.ConstantType(cA), TypeRepr.ConstantType(cB)) =>\n      cA == cB\n    \n    case (TypeRepr.AnyType, TypeRepr.AnyType) => true\n    case (TypeRepr.NothingType, TypeRepr.NothingType) => true\n    case (TypeRepr.NullType, TypeRepr.NullType) => true\n    case (TypeRepr.UnitType, TypeRepr.UnitType) => true\n    \n    // More cases for full coverage...\n    case _ => false\n  }\n}\n```\n\n### Subtyping\n```scala\nobject Subtyping {\n  \n  /**\n   * Context for subtyping calculations.\n   * Tracks assumptions to handle recursive types and avoid infinite loops.\n   */\n  final case class Context(\n    assumptions: Set[(TypeRepr, TypeRepr)] = Set.empty,\n    depth: Int = 0,\n    maxDepth: Int = 100\n  ) {\n    def assume(sub: TypeRepr, sup: TypeRepr): Context =\n      copy(assumptions = assumptions + ((sub, sup)))\n    \n    def isAssumed(sub: TypeRepr, sup: TypeRepr): Boolean =\n      assumptions.contains((sub, sup))\n    \n    def deeper: Context = copy(depth = depth + 1)\n    def tooDeep: Boolean = depth >= maxDepth\n  }\n  \n  /**\n   * Check if `sub` is a subtype of `sup`.\n   * \n   * Implements the Scala 3 subtyping rules including:\n   * - Reflexivity: A <: A\n   * - Top: A <: Any for all A\n   * - Bottom: Nothing <: A for all A  \n   * - Variance-aware generic subtyping\n   * - Union/intersection type rules\n   * - Structural subtyping\n   */\n  def isSubtype(sub: TypeRepr, sup: TypeRepr)(using ctx: Context = Context()): Boolean = ???\n  \n  /**\n   * Check if two types are equivalent (mutual subtypes).\n   */\n  def isEquivalent(a: TypeRepr, b: TypeRepr)(using ctx: Context = Context()): Boolean =\n    isSubtype(a, b) && isSubtype(b, a)\n  \n  /**\n   * Find the least upper bound (LUB) of two types.\n   * Returns the most specific type that is a supertype of both.\n   */\n  def lub(a: TypeRepr, b: TypeRepr): TypeRepr = ???\n  \n  /**\n   * Find the greatest lower bound (GLB) of two types.\n   * Returns the most general type that is a subtype of both.\n   */\n  def glb(a: TypeRepr, b: TypeRepr): TypeRepr = ???\n  \n  /**\n   * Check if a type conforms to given bounds.\n   */\n  def conformsToBounds(tpe: TypeRepr, bounds: TypeBounds)(using ctx: Context = Context()): Boolean = {\n    val lowerOk = bounds.lower.forall(lo => isSubtype(lo, tpe))\n    val upperOk = bounds.upper.forall(hi => isSubtype(tpe, hi))\n    lowerOk && upperOk\n  }\n  \n  /**\n   * Reduce a match type to its result, if possible.\n   * Returns None if the match type cannot be reduced (e.g., abstract scrutinee).\n   */\n  def reduceMatchType(mt: TypeRepr.MatchType)(using ctx: Context = Context()): Option[TypeRepr] = ???\n}\n```\n\n---\n\n## Standard Library Type Definitions\n\nPredefined `TypeId` instances for common types.\n```scala\nobject StandardTypes {\n  import TypeDefKind.*\n  \n  private val scalaOwner = Owner.pkg(\"scala\")\n  private val scalaCollectionImmutable = Owner.pkgs(\"scala\", \"collection\", \"immutable\")\n  private val javaLang = Owner.pkgs(\"java\", \"lang\")\n  \n  // ========== Primitives ==========\n  \n  val IntId: TypeId[Int] = TypeId.nominal[Int](\n    \"Int\", scalaOwner, Nil, Class(isFinal = true, isValue = true)\n  )\n  \n  val LongId: TypeId[Long] = TypeId.nominal[Long](\n    \"Long\", scalaOwner, Nil, Class(isFinal = true, isValue = true)\n  )\n  \n  val DoubleId: TypeId[Double] = TypeId.nominal[Double](\n    \"Double\", scalaOwner, Nil, Class(isFinal = true, isValue = true)\n  )\n  \n  val FloatId: TypeId[Float] = TypeId.nominal[Float](\n    \"Float\", scalaOwner, Nil, Class(isFinal = true, isValue = true)\n  )\n  \n  val BooleanId: TypeId[Boolean] = TypeId.nominal[Boolean](\n    \"Boolean\", scalaOwner, Nil, Class(isFinal = true, isValue = true)\n  )\n  \n  val CharId: TypeId[Char] = TypeId.nominal[Char](\n    \"Char\", scalaOwner, Nil, Class(isFinal = true, isValue = true)\n  )\n  \n  val ByteId: TypeId[Byte] = TypeId.nominal[Byte](\n    \"Byte\", scalaOwner, Nil, Class(isFinal = true, isValue = true)\n  )\n  \n  val ShortId: TypeId[Short] = TypeId.nominal[Short](\n    \"Short\", scalaOwner, Nil, Class(isFinal = true, isValue = true)\n  )\n  \n  val UnitId: TypeId[Unit] = TypeId.nominal[Unit](\n    \"Unit\", scalaOwner, Nil, Class(isFinal = true, isValue = true)\n  )\n  \n  // ========== Reference Types ==========\n  \n  val StringId: TypeId[String] = TypeId.nominal[String](\n    \"String\", javaLang, Nil, Class(isFinal = true)\n  )\n  \n  val AnyId: TypeId[Any] = TypeId.nominal[Any](\n    \"Any\", scalaOwner, Nil, Class(isAbstract = true)\n  )\n  \n  val AnyRefId: TypeId[AnyRef] = TypeId.nominal[AnyRef](\n    \"AnyRef\", scalaOwner, Nil, Class(isAbstract = true),\n    parents = List(TypeRepr.Ref(AnyId))\n  )\n  \n  val AnyValId: TypeId[AnyVal] = TypeId.nominal[AnyVal](\n    \"AnyVal\", scalaOwner, Nil, Class(isAbstract = true),\n    parents = List(TypeRepr.Ref(AnyId))\n  )\n  \n  val NothingId: TypeId[Nothing] = TypeId.nominal[Nothing](\n    \"Nothing\", scalaOwner, Nil, Class(isFinal = true, isAbstract = true)\n  )\n  \n  val NullId: TypeId[Null] = TypeId.nominal[Null](\n    \"Null\", scalaOwner, Nil, Class(isFinal = true)\n  )\n  \n  // ========== Collection Type Constructors ==========\n  \n  private val A = TypeParam.covariant(\"A\", 0)\n  private val K = TypeParam.invariant(\"K\", 0)\n  private val V = TypeParam.covariant(\"V\", 1)\n  \n  val ListId: TypeId[List] = TypeId.nominal[List](\n    \"List\", scalaCollectionImmutable, List(A), Trait(isSealed = true)\n  )\n  \n  val VectorId: TypeId[Vector] = TypeId.nominal[Vector](\n    \"Vector\", scalaCollectionImmutable, List(A), Class(isFinal = true)\n  )\n  \n  val SetId: TypeId[Set] = TypeId.nominal[Set](\n    \"Set\", scalaCollectionImmutable, List(A), Trait()\n  )\n  \n  val MapId: TypeId[Map] = TypeId.nominal[Map](\n    \"Map\", scalaCollectionImmutable, List(K, V), Trait()\n  )\n  \n  val OptionId: TypeId[Option] = TypeId.nominal[Option](\n    \"Option\", scalaOwner, List(A), Trait(isSealed = true)\n  )\n  \n  val EitherA = TypeParam.covariant(\"A\", 0)\n  val EitherB = TypeParam.covariant(\"B\", 1)\n  val EitherId: TypeId[Either] = TypeId.nominal[Either](\n    \"Either\", scalaOwner, List(EitherA, EitherB), Trait(isSealed = true)\n  )\n  \n  // ========== Tuple Type Constructors ==========\n  \n  val EmptyTupleId: TypeId[EmptyTuple] = TypeId.nominal[EmptyTuple](\n    \"EmptyTuple\", scalaOwner, Nil, Object\n  )\n  \n  val TupleConsH = TypeParam.covariant(\"H\", 0)\n  val TupleConsT = TypeParam.covariant(\"T\", 1, bounds = TypeBounds.upper(TypeRepr.Ref(???))) // <: Tuple\n  val TupleConsId: TypeId[*:] = TypeId.nominal[*:](\n    \"*:\", scalaOwner, List(TupleConsH, TupleConsT), Class(isFinal = true, isCase = true)\n  )\n  \n  // ========== Convenience TypeRepr Builders ==========\n  \n  def int: TypeRepr = TypeRepr.Ref(IntId)\n  def long: TypeRepr = TypeRepr.Ref(LongId)\n  def double: TypeRepr = TypeRepr.Ref(DoubleId)\n  def float: TypeRepr = TypeRepr.Ref(FloatId)\n  def boolean: TypeRepr = TypeRepr.Ref(BooleanId)\n  def string: TypeRepr = TypeRepr.Ref(StringId)\n  def unit: TypeRepr = TypeRepr.UnitType\n  def any: TypeRepr = TypeRepr.AnyType\n  def nothing: TypeRepr = TypeRepr.NothingType\n  \n  def list(elem: TypeRepr): TypeRepr = TypeRepr.Applied(TypeRepr.Ref(ListId), List(elem))\n  def option(elem: TypeRepr): TypeRepr = TypeRepr.Applied(TypeRepr.Ref(OptionId), List(elem))\n  def map(key: TypeRepr, value: TypeRepr): TypeRepr = TypeRepr.Applied(TypeRepr.Ref(MapId), List(key, value))\n  def either(left: TypeRepr, right: TypeRepr): TypeRepr = TypeRepr.Applied(TypeRepr.Ref(EitherId), List(left, right))\n}\n```\n\n---\n\n## Example Usage\n```scala\nobject Examples {\n  import TypeRepr.*\n  import StandardTypes.*\n  \n  // ========== Simple Types ==========\n  \n  val intType: TypeRepr = int\n  val stringType: TypeRepr = string\n  val listOfInt: TypeRepr = list(int)\n  val mapStringToInt: TypeRepr = map(string, int)\n  \n  // ========== Named Tuple ==========\n  \n  // (name: String, age: Int)\n  val personTuple: TypeRepr = Tuple.named(\n    \"name\" -> string,\n    \"age\" -> int\n  )\n  \n  // ========== Type Alias ==========\n  \n  // type Age = Int\n  val AgeId: TypeId[Int] = TypeId.alias[Int](\n    \"Age\",\n    Owner.pkg(\"myapp\"),\n    Nil,\n    int\n  )\n  \n  // type StringMap[V] = Map[String, V]\n  val V = TypeParam.covariant(\"V\", 0)\n  val StringMapId: TypeId[Map[String, *]] = TypeId.alias[Map[String, *]](\n    \"StringMap\",\n    Owner.pkg(\"myapp\"),\n    List(V),\n    Applied(Ref(MapId), List(string, ParamRef(V)))\n  )\n  \n  // ========== Opaque Type ==========\n  \n  // opaque type Email = String\n  val EmailId: TypeId[String] = TypeId.opaque[String](\n    \"Email\",\n    Owner.pkg(\"myapp\"),\n    Nil,\n    string\n  )\n  \n  // ========== Enum ==========\n  \n  val ColorId: TypeId[?] = TypeId.nominal(\n    \"Color\",\n    Owner.pkg(\"myapp\"),\n    Nil,\n    TypeDefKind.Enum(List(\n      EnumCaseInfo(\"Red\", 0, Nil, isObjectCase = true),\n      EnumCaseInfo(\"Green\", 1, Nil, isObjectCase = true),\n      EnumCaseInfo(\"Blue\", 2, Nil, isObjectCase = true),\n      EnumCaseInfo(\"RGB\", 3, List(\n        EnumCaseParam(\"r\", int),\n        EnumCaseParam(\"g\", int),\n        EnumCaseParam(\"b\", int)\n      ), isObjectCase = false)\n    ))\n  )\n  \n  // ========== Match Type ==========\n  \n  // type Elem[X] = X match { case String => Char; case Array[t] => t }\n  val X = TypeParam.invariant(\"X\", 0)\n  val t = TypeParam.invariant(\"t\", 0)\n  \n  val ElemId: TypeId[?] = TypeId.alias(\n    \"Elem\",\n    Owner.pkg(\"myapp\"),\n    List(X),\n    MatchType(\n      bound = any,\n      scrutinee = ParamRef(X),\n      cases = List(\n        MatchTypeCase(Nil, string, Ref(CharId)),\n        MatchTypeCase(\n          List(t),\n          Applied(Ref(???), List(ParamRef(t))), // Array[t]\n          ParamRef(t)\n        )\n      )\n    )\n  )\n  \n  // ========== Structural Type ==========\n  \n  // { def size: Int; val name: String }\n  val sizedNamed: TypeRepr = Structural(\n    parents = Nil,\n    members = List(\n      Member.Def(\"size\", Nil, Nil, int),\n      Member.Val(\"name\", string)\n    )\n  )\n  \n  // ========== Path-Dependent Type ==========\n  \n  // myModule.Inner.T\n  val pathDependent: TypeRepr = TypeSelect(\n    TermPath(List(\n      TermPath.Package(\"myapp\"),\n      TermPath.Module(\"myModule\"),\n      TermPath.Module(\"Inner\")\n    )),\n    \"T\"\n  )\n  \n  // ========== Intersection & Union ==========\n  \n  // String & { def foo: Int }\n  val stringWithFoo: TypeRepr = Intersection(\n    string,\n    Structural(Nil, List(Member.Def(\"foo\", Nil, Nil, int)))\n  )\n  \n  // String | Int\n  val stringOrInt: TypeRepr = Union(string, int)\n  \n  // ========== Function Types ==========\n  \n  // (Int, String) => Boolean\n  val func: TypeRepr = Function(List(int, string), boolean)\n  \n  // (Int, String) ?=> Boolean (context function)\n  val ctxFunc: TypeRepr = ContextFunction(List(int, string), boolean)\n  \n  // [A] => A => A (polymorphic function)\n  val polyFunc: TypeRepr = PolyFunction(\n    List(TypeParam.invariant(\"A\", 0)),\n    Function(List(ParamRef(TypeParam.invariant(\"A\", 0))), ParamRef(TypeParam.invariant(\"A\", 0)))\n  )\n}\n```\n\n---\n\n## Macro Derivation (Sketch)\n```scala\nimport scala.quoted.*\n\nobject TypeIdMacros {\n  \n  /**\n   * Derive a TypeId for any type or type constructor at compile time.\n   * Captures all type information available to the compiler.\n   */\n  inline def derive[A <: AnyKind]: TypeId[A] = ${ deriveMacro[A] }\n  \n  def deriveMacro[A <: AnyKind: Type](using Quotes): Expr[TypeId[A]] = {\n    import quotes.reflect.*\n    \n    val tpe = TypeRepr.of[A]\n    \n    // Extract type information from compiler\n    // ... implementation details ...\n    \n    ???\n  }\n  \n  /**\n   * Derive a TypeRepr for a concrete type at compile time.\n   */\n  inline def typeRepr[A]: TypeRepr = ${ typeReprMacro[A] }\n  \n  def typeReprMacro[A: Type](using Quotes): Expr[TypeRepr] = ???\n}\n```\n\n---\n\n## Open Questions / Future Work\n\n1. **Recursive type handling**: The `RecType`/`RecThis` encoding may need refinement for complex recursive types.\n\n2. **Match type reduction**: Full implementation requires tracking what patterns are \"provably disjoint.\"\n\n3. **Structural subtyping**: Member-by-member comparison with proper handling of overloaded methods.\n\n4. **Scala 2 compatibility**: Some constructs (existentials, compound types) may need additional representation.\n\n5. **Serialization format**: The data model is designed for runtime use; a compact serialization format (e.g., protobuf schema) would be a natural next step.",
              "url": "https://github.com/zio/zio-blocks/issues/471",
              "tech": [],
              "repo_name": "zio-blocks",
              "repo_owner": "zio",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "zio#3472",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "zio",
              "id": "generated-zio",
              "name": "Zio",
              "description": "",
              "members": [],
              "display_name": "Zio",
              "created_at": "2026-01-30T03:42:13.760Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/zio?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "zio",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-30T03:42:13.760Z",
            "created_at": "2026-01-30T03:42:13.760Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-zio#3472",
              "status": "open",
              "type": "issue",
              "number": 3472,
              "title": "Split into multiple modules",
              "source": {
                "data": {
                  "id": "source-zio#3472",
                  "user": {
                    "login": "987Nabil",
                    "id": 7283535,
                    "node_id": "MDQ6VXNlcjcyODM1MzU=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/7283535?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/987Nabil",
                    "html_url": "https://github.com/987Nabil",
                    "followers_url": "https://api.github.com/users/987Nabil/followers",
                    "following_url": "https://api.github.com/users/987Nabil/following{/other_user}",
                    "gists_url": "https://api.github.com/users/987Nabil/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/987Nabil/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/987Nabil/subscriptions",
                    "organizations_url": "https://api.github.com/users/987Nabil/orgs",
                    "repos_url": "https://api.github.com/users/987Nabil/repos",
                    "events_url": "https://api.github.com/users/987Nabil/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/987Nabil/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Split into multiple modules",
                  "body": "Currently, the zio-http artifact contains a lot of different parts of zio-http exclusively. They are not separate maven artifacts.\n\nWe want to change this, to support future changes/features.\n\nThere should be at least these modules that are published into maven. \n\n1. core\n2. endpoint\n3. netty\n\nShould we have client and server in different modules?",
                  "html_url": "https://github.com/zio/zio-http/issues/3472"
                },
                "type": "github"
              },
              "hash": "zio/zio-http#3472",
              "body": "Currently, the zio-http artifact contains a lot of different parts of zio-http exclusively. They are not separate maven artifacts.\n\nWe want to change this, to support future changes/features.\n\nThere should be at least these modules that are published into maven. \n\n1. core\n2. endpoint\n3. netty\n\nShould we have client and server in different modules?",
              "url": "https://github.com/zio/zio-http/issues/3472",
              "tech": [],
              "repo_name": "zio-http",
              "repo_owner": "zio",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "zio#9810",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "zio",
              "id": "generated-zio",
              "name": "Zio",
              "description": "",
              "members": [],
              "display_name": "Zio",
              "created_at": "2026-01-30T03:42:13.951Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/zio?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "zio",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-30T03:42:13.951Z",
            "created_at": "2026-01-30T03:42:13.951Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-zio#9810",
              "status": "open",
              "type": "issue",
              "number": 9810,
              "title": "ZStreams buffer(1) is buffering 2.",
              "source": {
                "data": {
                  "id": "source-zio#9810",
                  "user": {
                    "login": "douglasthomsen",
                    "id": 88000378,
                    "node_id": "MDQ6VXNlcjg4MDAwMzc4",
                    "avatar_url": "https://avatars.githubusercontent.com/u/88000378?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/douglasthomsen",
                    "html_url": "https://github.com/douglasthomsen",
                    "followers_url": "https://api.github.com/users/douglasthomsen/followers",
                    "following_url": "https://api.github.com/users/douglasthomsen/following{/other_user}",
                    "gists_url": "https://api.github.com/users/douglasthomsen/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/douglasthomsen/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/douglasthomsen/subscriptions",
                    "organizations_url": "https://api.github.com/users/douglasthomsen/orgs",
                    "repos_url": "https://api.github.com/users/douglasthomsen/repos",
                    "events_url": "https://api.github.com/users/douglasthomsen/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/douglasthomsen/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "ZStreams buffer(1) is buffering 2.",
                  "body": "I am using zio 2.1.17. When I run the following code:\n\n```scala\ndef fakeNetworkCall(n: Int): ZIO[Any, Throwable, String] = {\n  for {\n    _ <- Console.printLine(s\"Starting request $n\")\n    _ <- ZIO.sleep(1.second)\n    _ <- Console.printLine(s\"Completed request $n\")\n  } yield s\"Response for $n\"\n}\n\nval program: ZIO[Any, Throwable, Unit] =\n  ZStream\n    .fromIterator(Iterator.from(1))\n    .mapZIO(fakeNetworkCall)\n    .buffer(1)\n    .runForeach { response =>\n      for {\n        _ <- Console.printLine(s\"Press Enter to process $response...\")\n        _ <- ZIO.sleep(100.minutes)\n        _ <- Console.printLine(s\"Processing response $response\")\n        _ <- ZIO.sleep(1.second)\n        _ <- Console.printLine(s\"Done processing $response\")\n      } yield ()\n    }\n```\nThe full code is [here](https://scastie.scala-lang.org/douglasthomsen/kvRuhoAGRjarj9djF53N0g/10).\n\nWhen i get to the `_ <- ZIO.sleep(100.minutes)` line I would expect the output to be like this:\n```\nStarting request 1\nCompleted request 1\nStarting request 2\nPress Enter to process Response for 1...\nCompleted request 2\n```\n\nbut I am getting the following:\n```\nStarting request 1\nCompleted request 1\nStarting request 2\nPress Enter to process Response for 1...\nCompleted request 2\nStarting request 3\nCompleted request 3\n```\n\nMy goal is to only buffer one call to `fakeNetworkCall` at time. Right now it looks like it is buffering two. I am I doing something wrong or is this a bug?",
                  "html_url": "https://github.com/zio/zio/issues/9810"
                },
                "type": "github"
              },
              "hash": "zio/zio#9810",
              "body": "I am using zio 2.1.17. When I run the following code:\n\n```scala\ndef fakeNetworkCall(n: Int): ZIO[Any, Throwable, String] = {\n  for {\n    _ <- Console.printLine(s\"Starting request $n\")\n    _ <- ZIO.sleep(1.second)\n    _ <- Console.printLine(s\"Completed request $n\")\n  } yield s\"Response for $n\"\n}\n\nval program: ZIO[Any, Throwable, Unit] =\n  ZStream\n    .fromIterator(Iterator.from(1))\n    .mapZIO(fakeNetworkCall)\n    .buffer(1)\n    .runForeach { response =>\n      for {\n        _ <- Console.printLine(s\"Press Enter to process $response...\")\n        _ <- ZIO.sleep(100.minutes)\n        _ <- Console.printLine(s\"Processing response $response\")\n        _ <- ZIO.sleep(1.second)\n        _ <- Console.printLine(s\"Done processing $response\")\n      } yield ()\n    }\n```\nThe full code is [here](https://scastie.scala-lang.org/douglasthomsen/kvRuhoAGRjarj9djF53N0g/10).\n\nWhen i get to the `_ <- ZIO.sleep(100.minutes)` line I would expect the output to be like this:\n```\nStarting request 1\nCompleted request 1\nStarting request 2\nPress Enter to process Response for 1...\nCompleted request 2\n```\n\nbut I am getting the following:\n```\nStarting request 1\nCompleted request 1\nStarting request 2\nPress Enter to process Response for 1...\nCompleted request 2\nStarting request 3\nCompleted request 3\n```\n\nMy goal is to only buffer one call to `fakeNetworkCall` at time. Right now it looks like it is buffering two. I am I doing something wrong or is this a bug?",
              "url": "https://github.com/zio/zio/issues/9810",
              "tech": [],
              "repo_name": "zio",
              "repo_owner": "zio",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "zio#9844",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "zio",
              "id": "generated-zio",
              "name": "Zio",
              "description": "",
              "members": [],
              "display_name": "Zio",
              "created_at": "2026-01-30T03:42:14.229Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/zio?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "zio",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-30T03:42:14.229Z",
            "created_at": "2026-01-30T03:42:14.229Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-zio#9844",
              "status": "open",
              "type": "issue",
              "number": 9844,
              "title": "improved `Queue` shutdown functionality",
              "source": {
                "data": {
                  "id": "source-zio#9844",
                  "user": {
                    "login": "mberndt123",
                    "id": 11650737,
                    "node_id": "MDQ6VXNlcjExNjUwNzM3",
                    "avatar_url": "https://avatars.githubusercontent.com/u/11650737?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/mberndt123",
                    "html_url": "https://github.com/mberndt123",
                    "followers_url": "https://api.github.com/users/mberndt123/followers",
                    "following_url": "https://api.github.com/users/mberndt123/following{/other_user}",
                    "gists_url": "https://api.github.com/users/mberndt123/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/mberndt123/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/mberndt123/subscriptions",
                    "organizations_url": "https://api.github.com/users/mberndt123/orgs",
                    "repos_url": "https://api.github.com/users/mberndt123/repos",
                    "events_url": "https://api.github.com/users/mberndt123/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/mberndt123/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "improved `Queue` shutdown functionality",
                  "body": "Hey, I've recently proposed something on Discord, and since feedback has been rather positive, I'm making a ticket to track the idea.\n\nI've been working with Queues recently, and I've been having some issues around `shutdown` that I would like to address.\n\nSpecifically, I find it a common pattern that I send some kind of request object through a queue because I want another fiber to perform some action on my behalf. Along with the request, I send a `Promise` to have that fiber communicate the outcome of that action to me. By and large this works fine. The issue arises when the fiber that I'm sending requests to fails. In that case, I would like it to communicate the cause of the failure back to the other fibers. This is easy enough for the requests that I've already pulled out of the queue: I simply fail those promises.\nBut I also need to deal with other cases: fibers currently blocked in an `offer` call, future attempts to `offer` to the queue, and I also need to deal with requests that have been submitted to the queue but not yet retrieved.\n\nSo my idea is as follows:\n - add an `E` type parameter to `Queue`\n - add a `shutdownCause` method that takes a type parameter of type `Cause[E]`\n - `shutdownCause` would also return the items currently buffered in the queue in order to dispose of them\n - after `shutdownCause` has been called, any attempt to interact with the queue will fail with the cause\n - methods like `take, offer` etc. should indicate errors of type `E`\n - streams created with `ZStream.fromQueue` would also fail with this cause\n - `shutdownCause` should be atomic: when multiple fibers call it at the same time, one of them wins and the others fail with the cause supplied by the winner\n\nAfaik, adding a new method is a binary compatible change, as is adding a new type parameter. Hence I think this is a source incompatible but binary compatible change. @ghostdogpr therefore suggested it could be added in a ZIO 2.2 release.\n",
                  "html_url": "https://github.com/zio/zio/issues/9844"
                },
                "type": "github"
              },
              "hash": "zio/zio#9844",
              "body": "Hey, I've recently proposed something on Discord, and since feedback has been rather positive, I'm making a ticket to track the idea.\n\nI've been working with Queues recently, and I've been having some issues around `shutdown` that I would like to address.\n\nSpecifically, I find it a common pattern that I send some kind of request object through a queue because I want another fiber to perform some action on my behalf. Along with the request, I send a `Promise` to have that fiber communicate the outcome of that action to me. By and large this works fine. The issue arises when the fiber that I'm sending requests to fails. In that case, I would like it to communicate the cause of the failure back to the other fibers. This is easy enough for the requests that I've already pulled out of the queue: I simply fail those promises.\nBut I also need to deal with other cases: fibers currently blocked in an `offer` call, future attempts to `offer` to the queue, and I also need to deal with requests that have been submitted to the queue but not yet retrieved.\n\nSo my idea is as follows:\n - add an `E` type parameter to `Queue`\n - add a `shutdownCause` method that takes a type parameter of type `Cause[E]`\n - `shutdownCause` would also return the items currently buffered in the queue in order to dispose of them\n - after `shutdownCause` has been called, any attempt to interact with the queue will fail with the cause\n - methods like `take, offer` etc. should indicate errors of type `E`\n - streams created with `ZStream.fromQueue` would also fail with this cause\n - `shutdownCause` should be atomic: when multiple fibers call it at the same time, one of them wins and the others fail with the cause supplied by the winner\n\nAfaik, adding a new method is a binary compatible change, as is adding a new type parameter. Hence I think this is a source incompatible but binary compatible change. @ghostdogpr therefore suggested it could be added in a ZIO 2.2 release.\n",
              "url": "https://github.com/zio/zio/issues/9844",
              "tech": [],
              "repo_name": "zio",
              "repo_owner": "zio",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "zio#9878",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "zio",
              "id": "generated-zio",
              "name": "Zio",
              "description": "",
              "members": [],
              "display_name": "Zio",
              "created_at": "2026-01-30T03:42:14.474Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/zio?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "zio",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-30T03:42:14.474Z",
            "created_at": "2026-01-30T03:42:14.474Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-zio#9878",
              "status": "open",
              "type": "issue",
              "number": 9878,
              "title": "ZScheduler parks+unparks workers too frequently",
              "source": {
                "data": {
                  "id": "source-zio#9878",
                  "user": {
                    "login": "hearnadam",
                    "id": 22334119,
                    "node_id": "MDQ6VXNlcjIyMzM0MTE5",
                    "avatar_url": "https://avatars.githubusercontent.com/u/22334119?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/hearnadam",
                    "html_url": "https://github.com/hearnadam",
                    "followers_url": "https://api.github.com/users/hearnadam/followers",
                    "following_url": "https://api.github.com/users/hearnadam/following{/other_user}",
                    "gists_url": "https://api.github.com/users/hearnadam/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/hearnadam/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/hearnadam/subscriptions",
                    "organizations_url": "https://api.github.com/users/hearnadam/orgs",
                    "repos_url": "https://api.github.com/users/hearnadam/repos",
                    "events_url": "https://api.github.com/users/hearnadam/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/hearnadam/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "ZScheduler parks+unparks workers too frequently",
                  "body": "Unparking workers is slow and invoked in the hotpath too often. I think we may need to trade some fairness for aggression to avoid excessive cycling.\n\n`maybeUnparkWorker` (obviously `LockSupport.unpark(worker)`) is very expensive: https://github.com/zio/zio/blob/series/2.x/core/jvm-native/src/main/scala/zio/internal/ZScheduler.scala#L443-L454",
                  "html_url": "https://github.com/zio/zio/issues/9878"
                },
                "type": "github"
              },
              "hash": "zio/zio#9878",
              "body": "Unparking workers is slow and invoked in the hotpath too often. I think we may need to trade some fairness for aggression to avoid excessive cycling.\n\n`maybeUnparkWorker` (obviously `LockSupport.unpark(worker)`) is very expensive: https://github.com/zio/zio/blob/series/2.x/core/jvm-native/src/main/scala/zio/internal/ZScheduler.scala#L443-L454",
              "url": "https://github.com/zio/zio/issues/9878",
              "tech": [],
              "repo_name": "zio",
              "repo_owner": "zio",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "zio#9877",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "zio",
              "id": "generated-zio",
              "name": "Zio",
              "description": "",
              "members": [],
              "display_name": "Zio",
              "created_at": "2026-01-30T03:42:14.663Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/zio?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "zio",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-30T03:42:14.663Z",
            "created_at": "2026-01-30T03:42:14.663Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-zio#9877",
              "status": "open",
              "type": "issue",
              "number": 9877,
              "title": "Can Fiber(Runtime) and Promise be merged?",
              "source": {
                "data": {
                  "id": "source-zio#9877",
                  "user": {
                    "login": "hearnadam",
                    "id": 22334119,
                    "node_id": "MDQ6VXNlcjIyMzM0MTE5",
                    "avatar_url": "https://avatars.githubusercontent.com/u/22334119?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/hearnadam",
                    "html_url": "https://github.com/hearnadam",
                    "followers_url": "https://api.github.com/users/hearnadam/followers",
                    "following_url": "https://api.github.com/users/hearnadam/following{/other_user}",
                    "gists_url": "https://api.github.com/users/hearnadam/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/hearnadam/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/hearnadam/subscriptions",
                    "organizations_url": "https://api.github.com/users/hearnadam/orgs",
                    "repos_url": "https://api.github.com/users/hearnadam/repos",
                    "events_url": "https://api.github.com/users/hearnadam/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/hearnadam/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Can Fiber(Runtime) and Promise be merged?",
                  "body": "A Promise awaiting completion is essentially a Fiber parked awaiting an async callback. When a Fiber is forking work (which will eventually complete a promise), then awaiting a Promise, we end up with unnecessary allocations + indirection.\n\nit would be useful to have `Promise.become` or similar to link fibers/promises.",
                  "html_url": "https://github.com/zio/zio/issues/9877"
                },
                "type": "github"
              },
              "hash": "zio/zio#9877",
              "body": "A Promise awaiting completion is essentially a Fiber parked awaiting an async callback. When a Fiber is forking work (which will eventually complete a promise), then awaiting a Promise, we end up with unnecessary allocations + indirection.\n\nit would be useful to have `Promise.become` or similar to link fibers/promises.",
              "url": "https://github.com/zio/zio/issues/9877",
              "tech": [],
              "repo_name": "zio",
              "repo_owner": "zio",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "zio#9874",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "zio",
              "id": "generated-zio",
              "name": "Zio",
              "description": "",
              "members": [],
              "display_name": "Zio",
              "created_at": "2026-01-30T03:42:14.921Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/zio?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "zio",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-30T03:42:14.921Z",
            "created_at": "2026-01-30T03:42:14.921Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-zio#9874",
              "status": "open",
              "type": "issue",
              "number": 9874,
              "title": "Handling errors allows recovering from defects",
              "source": {
                "data": {
                  "id": "source-zio#9874",
                  "user": {
                    "login": "kyri-petrou",
                    "id": 67301607,
                    "node_id": "MDQ6VXNlcjY3MzAxNjA3",
                    "avatar_url": "https://avatars.githubusercontent.com/u/67301607?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/kyri-petrou",
                    "html_url": "https://github.com/kyri-petrou",
                    "followers_url": "https://api.github.com/users/kyri-petrou/followers",
                    "following_url": "https://api.github.com/users/kyri-petrou/following{/other_user}",
                    "gists_url": "https://api.github.com/users/kyri-petrou/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/kyri-petrou/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/kyri-petrou/subscriptions",
                    "organizations_url": "https://api.github.com/users/kyri-petrou/orgs",
                    "repos_url": "https://api.github.com/users/kyri-petrou/repos",
                    "events_url": "https://api.github.com/users/kyri-petrou/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/kyri-petrou/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Handling errors allows recovering from defects",
                  "body": "Sigh... Well, this is annoying. When a Cause contains both a failure and a defect (i.e., Fail & Die), failure handling assumes that the Cause does not contain any defects and therefor silently ignores them.\n\nRepro:\n\n```scala\nimport zio.*\n\nobject Foo extends ZIOAppDefault {\n  val dieCause: Cause[String] = Cause.die(new RuntimeException(\"boom\"))\n  val combinedCause = dieCause && Cause.fail(\"boom\")\n\n  def run = ZIO.failCause(combinedCause).catchAll { e =>\n    ZIO.debug(e)\n  } *> ZIO.debug(\"Success\")\n}\n```\nprints:\n```\nhandled: boom\nSuccess\n```\n\nHowever if we substituted `ZIO.failCause(combinedCause)` with `ZIO.failCause(dieCause)`:\n\n```\ntimestamp=2025-05-20T16:31:09.291104Z level=ERROR thread=#zio-fiber-1707930317 message=\"\" cause=\"java.lang.RuntimeException: boom\n\tat Foo$.<clinit>(Foo.scala:4)\n\tat Foo.main(Foo.scala)\n\tat <empty>.Foo.run(Foo.scala:7)\n\tat <empty>.Foo.run(Foo.scala:9)\n\"\n```\n\nWith both of these causes, the outcome should be the same as defects should always be prioritised over failures. This gets even worse when interruption is involved, because the failure handling will be prioritised over it.\n\nHaving said that, this has the potential to massively alter applications so I'm too scared to fix it.\n@ghostdogpr @jdegoes  @hearnadam @guizmaii I summon you all for some wisdom",
                  "html_url": "https://github.com/zio/zio/issues/9874"
                },
                "type": "github"
              },
              "hash": "zio/zio#9874",
              "body": "Sigh... Well, this is annoying. When a Cause contains both a failure and a defect (i.e., Fail & Die), failure handling assumes that the Cause does not contain any defects and therefor silently ignores them.\n\nRepro:\n\n```scala\nimport zio.*\n\nobject Foo extends ZIOAppDefault {\n  val dieCause: Cause[String] = Cause.die(new RuntimeException(\"boom\"))\n  val combinedCause = dieCause && Cause.fail(\"boom\")\n\n  def run = ZIO.failCause(combinedCause).catchAll { e =>\n    ZIO.debug(e)\n  } *> ZIO.debug(\"Success\")\n}\n```\nprints:\n```\nhandled: boom\nSuccess\n```\n\nHowever if we substituted `ZIO.failCause(combinedCause)` with `ZIO.failCause(dieCause)`:\n\n```\ntimestamp=2025-05-20T16:31:09.291104Z level=ERROR thread=#zio-fiber-1707930317 message=\"\" cause=\"java.lang.RuntimeException: boom\n\tat Foo$.<clinit>(Foo.scala:4)\n\tat Foo.main(Foo.scala)\n\tat <empty>.Foo.run(Foo.scala:7)\n\tat <empty>.Foo.run(Foo.scala:9)\n\"\n```\n\nWith both of these causes, the outcome should be the same as defects should always be prioritised over failures. This gets even worse when interruption is involved, because the failure handling will be prioritised over it.\n\nHaving said that, this has the potential to massively alter applications so I'm too scared to fix it.\n@ghostdogpr @jdegoes  @hearnadam @guizmaii I summon you all for some wisdom",
              "url": "https://github.com/zio/zio/issues/9874",
              "tech": [],
              "repo_name": "zio",
              "repo_owner": "zio",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "zio#9681",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "zio",
              "id": "generated-zio",
              "name": "Zio",
              "description": "",
              "members": [],
              "display_name": "Zio",
              "created_at": "2026-01-30T03:42:15.120Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/zio?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "zio",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-30T03:42:15.120Z",
            "created_at": "2026-01-30T03:42:15.120Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-zio#9681",
              "status": "open",
              "type": "issue",
              "number": 9681,
              "title": "Scala Native `WeakConcurrentBag` NPE when forking 10K fibers",
              "source": {
                "data": {
                  "id": "source-zio#9681",
                  "user": {
                    "login": "hearnadam",
                    "id": 22334119,
                    "node_id": "MDQ6VXNlcjIyMzM0MTE5",
                    "avatar_url": "https://avatars.githubusercontent.com/u/22334119?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/hearnadam",
                    "html_url": "https://github.com/hearnadam",
                    "followers_url": "https://api.github.com/users/hearnadam/followers",
                    "following_url": "https://api.github.com/users/hearnadam/following{/other_user}",
                    "gists_url": "https://api.github.com/users/hearnadam/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/hearnadam/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/hearnadam/subscriptions",
                    "organizations_url": "https://api.github.com/users/hearnadam/orgs",
                    "repos_url": "https://api.github.com/users/hearnadam/repos",
                    "events_url": "https://api.github.com/users/hearnadam/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/hearnadam/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Scala Native `WeakConcurrentBag` NPE when forking 10K fibers",
                  "body": "```\n[info]   - PromiseSpec - waiter stack safety\n[info]     Exception in thread \"zio-fiber-931\" java.lang.NullPointerException: null\n[info]     \tat scala.scalanative.runtime.package$.throwNullPointer(Unknown Source)\n[info]     \tat <none>.(Unknown Source)\n[info]     \tat java.util.concurrent.ConcurrentHashMap.treeifyBin(Unknown Source)\n[info]     \tat java.util.concurrent.ConcurrentHashMap.putVal(Unknown Source)\n[info]     \tat java.util.concurrent.ConcurrentHashMap$KeySetView.add(Unknown Source)\n[info]     \tat zio.internal.WeakConcurrentBag.addToLongTermStorage(Unknown Source)\n[info]     \tat zio.internal.WeakConcurrentBag.add(Unknown Source)\n[info]     \tat zio.internal.FiberScope$global$.add(Unknown Source)\n[info]     \tat zio.ZIO$unsafe$.makeChildFiber(Unknown Source)\n[info]     \tat zio.ZIO$unsafe$.fork(Unknown Source)\n[info]     \tat zio.ZIO.$anonfun$forkWithScopeOverride$2(Unknown Source)\n[info]     \tat zio.ZIO$$Lambda$280.apply(Unknown Source)\n[info]     \tat zio.PromiseSpec.spec(PromiseSpec.scala:127)\n[info]     \tat zio.PromiseSpec.spec(PromiseSpec.scala:124)\n```\nI introduced a new test in #9569 which resulted in this strange failure on Native.",
                  "html_url": "https://github.com/zio/zio/issues/9681"
                },
                "type": "github"
              },
              "hash": "zio/zio#9681",
              "body": "```\n[info]   - PromiseSpec - waiter stack safety\n[info]     Exception in thread \"zio-fiber-931\" java.lang.NullPointerException: null\n[info]     \tat scala.scalanative.runtime.package$.throwNullPointer(Unknown Source)\n[info]     \tat <none>.(Unknown Source)\n[info]     \tat java.util.concurrent.ConcurrentHashMap.treeifyBin(Unknown Source)\n[info]     \tat java.util.concurrent.ConcurrentHashMap.putVal(Unknown Source)\n[info]     \tat java.util.concurrent.ConcurrentHashMap$KeySetView.add(Unknown Source)\n[info]     \tat zio.internal.WeakConcurrentBag.addToLongTermStorage(Unknown Source)\n[info]     \tat zio.internal.WeakConcurrentBag.add(Unknown Source)\n[info]     \tat zio.internal.FiberScope$global$.add(Unknown Source)\n[info]     \tat zio.ZIO$unsafe$.makeChildFiber(Unknown Source)\n[info]     \tat zio.ZIO$unsafe$.fork(Unknown Source)\n[info]     \tat zio.ZIO.$anonfun$forkWithScopeOverride$2(Unknown Source)\n[info]     \tat zio.ZIO$$Lambda$280.apply(Unknown Source)\n[info]     \tat zio.PromiseSpec.spec(PromiseSpec.scala:127)\n[info]     \tat zio.PromiseSpec.spec(PromiseSpec.scala:124)\n```\nI introduced a new test in #9569 which resulted in this strange failure on Native.",
              "url": "https://github.com/zio/zio/issues/9681",
              "tech": [],
              "repo_name": "zio",
              "repo_owner": "zio",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "tscircuit#1130",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "tscircuit",
              "id": "generated-tscircuit",
              "name": "Tscircuit",
              "description": "",
              "members": [],
              "display_name": "Tscircuit",
              "created_at": "2026-01-30T03:42:37.240Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/tscircuit?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "tscircuit",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-30T03:42:37.240Z",
            "created_at": "2026-01-30T03:42:37.240Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-tscircuit#1130",
              "status": "open",
              "type": "issue",
              "number": 1130,
              "title": "Change of color on hover for traces are missing",
              "source": {
                "data": {
                  "id": "source-tscircuit#1130",
                  "user": {
                    "login": "imrishabh18",
                    "id": 38923768,
                    "node_id": "MDQ6VXNlcjM4OTIzNzY4",
                    "avatar_url": "https://avatars.githubusercontent.com/u/38923768?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/imrishabh18",
                    "html_url": "https://github.com/imrishabh18",
                    "followers_url": "https://api.github.com/users/imrishabh18/followers",
                    "following_url": "https://api.github.com/users/imrishabh18/following{/other_user}",
                    "gists_url": "https://api.github.com/users/imrishabh18/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/imrishabh18/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/imrishabh18/subscriptions",
                    "organizations_url": "https://api.github.com/users/imrishabh18/orgs",
                    "repos_url": "https://api.github.com/users/imrishabh18/repos",
                    "events_url": "https://api.github.com/users/imrishabh18/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/imrishabh18/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Change of color on hover for traces are missing",
                  "body": "<img width=\"1190\" height=\"1192\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/b8cab314-dd61-48f0-b608-8865300bd28d\" />\n\nAll the traces which connect and are under the same net should be shown on hover\n\n\nRef circuit - https://tscircuit.com/MrPicklePinosaur/tscircuit_demo#schematic",
                  "html_url": "https://github.com/tscircuit/tscircuit/issues/1130"
                },
                "type": "github"
              },
              "hash": "tscircuit/tscircuit#1130",
              "body": "<img width=\"1190\" height=\"1192\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/b8cab314-dd61-48f0-b608-8865300bd28d\" />\n\nAll the traces which connect and are under the same net should be shown on hover\n\n\nRef circuit - https://tscircuit.com/MrPicklePinosaur/tscircuit_demo#schematic",
              "url": "https://github.com/tscircuit/tscircuit/issues/1130",
              "tech": [],
              "repo_name": "tscircuit",
              "repo_owner": "tscircuit",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "tscircuit#534",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "tscircuit",
              "id": "generated-tscircuit",
              "name": "Tscircuit",
              "description": "",
              "members": [],
              "display_name": "Tscircuit",
              "created_at": "2026-01-30T03:42:37.433Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/tscircuit?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "tscircuit",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-30T03:42:37.433Z",
            "created_at": "2026-01-30T03:42:37.433Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-tscircuit#534",
              "status": "open",
              "type": "issue",
              "number": 534,
              "title": "Texture Support (PCB should have texture on box)",
              "source": {
                "data": {
                  "id": "source-tscircuit#534",
                  "user": {
                    "login": "seveibar",
                    "id": 1910070,
                    "node_id": "MDQ6VXNlcjE5MTAwNzA=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1910070?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/seveibar",
                    "html_url": "https://github.com/seveibar",
                    "followers_url": "https://api.github.com/users/seveibar/followers",
                    "following_url": "https://api.github.com/users/seveibar/following{/other_user}",
                    "gists_url": "https://api.github.com/users/seveibar/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/seveibar/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/seveibar/subscriptions",
                    "organizations_url": "https://api.github.com/users/seveibar/orgs",
                    "repos_url": "https://api.github.com/users/seveibar/repos",
                    "events_url": "https://api.github.com/users/seveibar/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/seveibar/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Texture Support (PCB should have texture on box)",
                  "body": "- use circuit-to-svg with resvg-wasm to create the png texture from circuit json\n- apply the texture to the box\n\n<img width=\"948\" height=\"716\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/cdfb9fd9-fc5f-4dad-b5c1-041e60f26c0d\" />\n\n/bounty $150",
                  "html_url": "https://github.com/tscircuit/3d-viewer/issues/534"
                },
                "type": "github"
              },
              "hash": "tscircuit/3d-viewer#534",
              "body": "- use circuit-to-svg with resvg-wasm to create the png texture from circuit json\n- apply the texture to the box\n\n<img width=\"948\" height=\"716\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/cdfb9fd9-fc5f-4dad-b5c1-041e60f26c0d\" />\n\n/bounty $150",
              "url": "https://github.com/tscircuit/3d-viewer/issues/534",
              "tech": [],
              "repo_name": "3d-viewer",
              "repo_owner": "tscircuit",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "tscircuit#419",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "tscircuit",
              "id": "generated-tscircuit",
              "name": "Tscircuit",
              "description": "",
              "members": [],
              "display_name": "Tscircuit",
              "created_at": "2026-01-30T03:42:37.581Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/tscircuit?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "tscircuit",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-30T03:42:37.581Z",
            "created_at": "2026-01-30T03:42:37.581Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-tscircuit#419",
              "status": "open",
              "type": "issue",
              "number": 419,
              "title": "Texture Support (PCB should have texture on box)",
              "source": {
                "data": {
                  "id": "source-tscircuit#419",
                  "user": {
                    "login": "seveibar",
                    "id": 1910070,
                    "node_id": "MDQ6VXNlcjE5MTAwNzA=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1910070?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/seveibar",
                    "html_url": "https://github.com/seveibar",
                    "followers_url": "https://api.github.com/users/seveibar/followers",
                    "following_url": "https://api.github.com/users/seveibar/following{/other_user}",
                    "gists_url": "https://api.github.com/users/seveibar/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/seveibar/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/seveibar/subscriptions",
                    "organizations_url": "https://api.github.com/users/seveibar/orgs",
                    "repos_url": "https://api.github.com/users/seveibar/repos",
                    "events_url": "https://api.github.com/users/seveibar/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/seveibar/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Texture Support (PCB should have texture on box)",
                  "body": "- use circuit-to-svg with resvg-wasm to create the png texture from circuit json\n- apply the texture to the box\n\n<img width=\"948\" height=\"716\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/cdfb9fd9-fc5f-4dad-b5c1-041e60f26c0d\" />\n\n/bounty $150",
                  "html_url": "https://github.com/tscircuit/3d-viewer/issues/534"
                },
                "type": "github"
              },
              "hash": "tscircuit/pcb-viewer#419",
              "body": "- use circuit-to-svg with resvg-wasm to create the png texture from circuit json\n- apply the texture to the box\n\n<img width=\"948\" height=\"716\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/cdfb9fd9-fc5f-4dad-b5c1-041e60f26c0d\" />\n\n/bounty $150",
              "url": "https://github.com/tscircuit/3d-viewer/issues/534",
              "tech": [],
              "repo_name": "pcb-viewer",
              "repo_owner": "tscircuit",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "tscircuit#1081",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "tscircuit",
              "id": "generated-tscircuit",
              "name": "Tscircuit",
              "description": "",
              "members": [],
              "display_name": "Tscircuit",
              "created_at": "2026-01-30T03:42:37.826Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/tscircuit?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "tscircuit",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-30T03:42:37.826Z",
            "created_at": "2026-01-30T03:42:37.826Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-tscircuit#1081",
              "status": "open",
              "type": "issue",
              "number": 1081,
              "title": "Make sure kicad component components create courtyards",
              "source": {
                "data": {
                  "id": "source-tscircuit#1081",
                  "user": {
                    "login": "seveibar",
                    "id": 1910070,
                    "node_id": "MDQ6VXNlcjE5MTAwNzA=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1910070?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/seveibar",
                    "html_url": "https://github.com/seveibar",
                    "followers_url": "https://api.github.com/users/seveibar/followers",
                    "following_url": "https://api.github.com/users/seveibar/following{/other_user}",
                    "gists_url": "https://api.github.com/users/seveibar/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/seveibar/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/seveibar/subscriptions",
                    "organizations_url": "https://api.github.com/users/seveibar/orgs",
                    "repos_url": "https://api.github.com/users/seveibar/repos",
                    "events_url": "https://api.github.com/users/seveibar/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/seveibar/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Make sure kicad component components create courtyards",
                  "body": "In https://kicad-component.tscircuit.com / https://github.com/tscircuit/kicad-component-converter\n\nWe need to load the kicad_mod file and produce `<courtyardrect />` elements\n\n- [ ] Find a kicad_mod file to test with that has a courtyard defined\n- [ ] Make sure courtyards are drawn in circuit-to-svg\n- [ ] Modify kicad-component-converter\n- [ ] Modify circuit-json-to-tscircuit\n\n\n/bounty $75",
                  "html_url": "https://github.com/tscircuit/tscircuit/issues/1081"
                },
                "type": "github"
              },
              "hash": "tscircuit/tscircuit#1081",
              "body": "In https://kicad-component.tscircuit.com / https://github.com/tscircuit/kicad-component-converter\n\nWe need to load the kicad_mod file and produce `<courtyardrect />` elements\n\n- [ ] Find a kicad_mod file to test with that has a courtyard defined\n- [ ] Make sure courtyards are drawn in circuit-to-svg\n- [ ] Modify kicad-component-converter\n- [ ] Modify circuit-json-to-tscircuit\n\n\n/bounty $75",
              "url": "https://github.com/tscircuit/tscircuit/issues/1081",
              "tech": [],
              "repo_name": "tscircuit",
              "repo_owner": "tscircuit",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "tscircuit#386",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "tscircuit",
              "id": "generated-tscircuit",
              "name": "Tscircuit",
              "description": "",
              "members": [],
              "display_name": "Tscircuit",
              "created_at": "2026-01-30T03:42:38.175Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/tscircuit?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "tscircuit",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-30T03:42:38.175Z",
            "created_at": "2026-01-30T03:42:38.175Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-tscircuit#386",
              "status": "open",
              "type": "issue",
              "number": 386,
              "title": "Add support for qfn32",
              "source": {
                "data": {
                  "id": "source-tscircuit#386",
                  "user": {
                    "login": "seveibar",
                    "id": 1910070,
                    "node_id": "MDQ6VXNlcjE5MTAwNzA=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1910070?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/seveibar",
                    "html_url": "https://github.com/seveibar",
                    "followers_url": "https://api.github.com/users/seveibar/followers",
                    "following_url": "https://api.github.com/users/seveibar/following{/other_user}",
                    "gists_url": "https://api.github.com/users/seveibar/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/seveibar/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/seveibar/subscriptions",
                    "organizations_url": "https://api.github.com/users/seveibar/orgs",
                    "repos_url": "https://api.github.com/users/seveibar/repos",
                    "events_url": "https://api.github.com/users/seveibar/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/seveibar/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Add support for qfn32",
                  "body": "/bounty $25",
                  "html_url": "https://github.com/tscircuit/jscad-electronics/issues/139"
                },
                "type": "github"
              },
              "hash": "tscircuit/footprinter#386",
              "body": "/bounty $25",
              "url": "https://github.com/tscircuit/jscad-electronics/issues/139",
              "tech": [],
              "repo_name": "footprinter",
              "repo_owner": "tscircuit",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "tscircuit#79",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "tscircuit",
              "id": "generated-tscircuit",
              "name": "Tscircuit",
              "description": "",
              "members": [],
              "display_name": "Tscircuit",
              "created_at": "2026-01-30T03:42:38.360Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/tscircuit?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "tscircuit",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-30T03:42:38.360Z",
            "created_at": "2026-01-30T03:42:38.360Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-tscircuit#79",
              "status": "open",
              "type": "issue",
              "number": 79,
              "title": "Fix extra net label in repro61, or remove trace",
              "source": {
                "data": {
                  "id": "source-tscircuit#79",
                  "user": {
                    "login": "seveibar",
                    "id": 1910070,
                    "node_id": "MDQ6VXNlcjE5MTAwNzA=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1910070?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/seveibar",
                    "html_url": "https://github.com/seveibar",
                    "followers_url": "https://api.github.com/users/seveibar/followers",
                    "following_url": "https://api.github.com/users/seveibar/following{/other_user}",
                    "gists_url": "https://api.github.com/users/seveibar/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/seveibar/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/seveibar/subscriptions",
                    "organizations_url": "https://api.github.com/users/seveibar/orgs",
                    "repos_url": "https://api.github.com/users/seveibar/repos",
                    "events_url": "https://api.github.com/users/seveibar/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/seveibar/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Fix extra net label in repro61, or remove trace",
                  "body": "See [#1503](https://github.com/tscircuit/core/pull/1503/files)\n\nCC @0hmX @Abse2001 \n\n<img width=\"854\" height=\"534\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/90cda586-2e2b-4937-a392-0ed549cd2eca\" />\n\n/bounty $75",
                  "html_url": "https://github.com/tscircuit/schematic-trace-solver/issues/79"
                },
                "type": "github"
              },
              "hash": "tscircuit/schematic-trace-solver#79",
              "body": "See [#1503](https://github.com/tscircuit/core/pull/1503/files)\n\nCC @0hmX @Abse2001 \n\n<img width=\"854\" height=\"534\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/90cda586-2e2b-4937-a392-0ed549cd2eca\" />\n\n/bounty $75",
              "url": "https://github.com/tscircuit/schematic-trace-solver/issues/79",
              "tech": [],
              "repo_name": "schematic-trace-solver",
              "repo_owner": "tscircuit",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "tscircuit#78",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "tscircuit",
              "id": "generated-tscircuit",
              "name": "Tscircuit",
              "description": "",
              "members": [],
              "display_name": "Tscircuit",
              "created_at": "2026-01-30T03:42:38.549Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/tscircuit?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "tscircuit",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-30T03:42:38.549Z",
            "created_at": "2026-01-30T03:42:38.549Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-tscircuit#78",
              "status": "open",
              "type": "issue",
              "number": 78,
              "title": "Fix extra trace lines in post-processing step",
              "source": {
                "data": {
                  "id": "source-tscircuit#78",
                  "user": {
                    "login": "seveibar",
                    "id": 1910070,
                    "node_id": "MDQ6VXNlcjE5MTAwNzA=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1910070?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/seveibar",
                    "html_url": "https://github.com/seveibar",
                    "followers_url": "https://api.github.com/users/seveibar/followers",
                    "following_url": "https://api.github.com/users/seveibar/following{/other_user}",
                    "gists_url": "https://api.github.com/users/seveibar/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/seveibar/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/seveibar/subscriptions",
                    "organizations_url": "https://api.github.com/users/seveibar/orgs",
                    "repos_url": "https://api.github.com/users/seveibar/repos",
                    "events_url": "https://api.github.com/users/seveibar/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/seveibar/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Fix extra trace lines in post-processing step",
                  "body": "<img width=\"1156\" height=\"812\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/e14c1b6b-975b-4c07-9632-3ada99461ac9\" />\n\n/bounty $75",
                  "html_url": "https://github.com/tscircuit/schematic-trace-solver/issues/78"
                },
                "type": "github"
              },
              "hash": "tscircuit/schematic-trace-solver#78",
              "body": "<img width=\"1156\" height=\"812\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/e14c1b6b-975b-4c07-9632-3ada99461ac9\" />\n\n/bounty $75",
              "url": "https://github.com/tscircuit/schematic-trace-solver/issues/78",
              "tech": [],
              "repo_name": "schematic-trace-solver",
              "repo_owner": "tscircuit",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "tscircuit#939",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "tscircuit",
              "id": "generated-tscircuit",
              "name": "Tscircuit",
              "description": "",
              "members": [],
              "display_name": "Tscircuit",
              "created_at": "2026-01-30T03:42:38.900Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/tscircuit?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "tscircuit",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-30T03:42:38.900Z",
            "created_at": "2026-01-30T03:42:38.900Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-tscircuit#939",
              "status": "open",
              "type": "issue",
              "number": 939,
              "title": "Figure out why documentation isn't rendering reference designators (Vercel renders with box fonts)",
              "source": {
                "data": {
                  "id": "source-tscircuit#939",
                  "user": {
                    "login": "seveibar",
                    "id": 1910070,
                    "node_id": "MDQ6VXNlcjE5MTAwNzA=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1910070?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/seveibar",
                    "html_url": "https://github.com/seveibar",
                    "followers_url": "https://api.github.com/users/seveibar/followers",
                    "following_url": "https://api.github.com/users/seveibar/following{/other_user}",
                    "gists_url": "https://api.github.com/users/seveibar/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/seveibar/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/seveibar/subscriptions",
                    "organizations_url": "https://api.github.com/users/seveibar/orgs",
                    "repos_url": "https://api.github.com/users/seveibar/repos",
                    "events_url": "https://api.github.com/users/seveibar/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/seveibar/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Figure out why documentation isn't rendering reference designators (Vercel renders with box fonts)",
                  "body": "To reproduce:\n\n1. Deploy to vercel\n2. Go to `${YOUR_SERVER_URL}?svg_type=schematic&format=png&code=H4sIAJmi92gAA0WOQQ6CMBBFrzKZFWykGFcGOITrbqodbKNtSTvGJsa7SyHIbt78l5%2F%2FQes15QOnjGekPIXIoGlUrydDVUM%2FQCU9QHcNKmp4W82ml9gK5ySCIXs3%2FOehmLMbKdnEIa4IsLLyNyrqQ%2BIWjCHwFK0vFeIkjnvilSvypd1ezVLeNcuO%2Ba7x%2BwPTyw6evAAAAA%3D%3D`\n\n<img width=\"1494\" height=\"702\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/628bd14b-edd9-4a43-931a-5da5141085b4\" />\n\n/bounty $100",
                  "html_url": "https://github.com/tscircuit/svg.tscircuit.com/issues/427"
                },
                "type": "github"
              },
              "hash": "tscircuit/tscircuit#939",
              "body": "To reproduce:\n\n1. Deploy to vercel\n2. Go to `${YOUR_SERVER_URL}?svg_type=schematic&format=png&code=H4sIAJmi92gAA0WOQQ6CMBBFrzKZFWykGFcGOITrbqodbKNtSTvGJsa7SyHIbt78l5%2F%2FQes15QOnjGekPIXIoGlUrydDVUM%2FQCU9QHcNKmp4W82ml9gK5ySCIXs3%2FOehmLMbKdnEIa4IsLLyNyrqQ%2BIWjCHwFK0vFeIkjnvilSvypd1ezVLeNcuO%2Ba7x%2BwPTyw6evAAAAA%3D%3D`\n\n<img width=\"1494\" height=\"702\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/628bd14b-edd9-4a43-931a-5da5141085b4\" />\n\n/bounty $100",
              "url": "https://github.com/tscircuit/svg.tscircuit.com/issues/427",
              "tech": [],
              "repo_name": "tscircuit",
              "repo_owner": "tscircuit",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "tscircuit#6",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "tscircuit",
              "id": "generated-tscircuit",
              "name": "Tscircuit",
              "description": "",
              "members": [],
              "display_name": "Tscircuit",
              "created_at": "2026-01-30T03:42:39.125Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/tscircuit?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "tscircuit",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-30T03:42:39.125Z",
            "created_at": "2026-01-30T03:42:39.125Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-tscircuit#6",
              "status": "open",
              "type": "issue",
              "number": 6,
              "title": "Determine why rectangles are missing in output",
              "source": {
                "data": {
                  "id": "source-tscircuit#6",
                  "user": {
                    "login": "seveibar",
                    "id": 1910070,
                    "node_id": "MDQ6VXNlcjE5MTAwNzA=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1910070?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/seveibar",
                    "html_url": "https://github.com/seveibar",
                    "followers_url": "https://api.github.com/users/seveibar/followers",
                    "following_url": "https://api.github.com/users/seveibar/following{/other_user}",
                    "gists_url": "https://api.github.com/users/seveibar/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/seveibar/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/seveibar/subscriptions",
                    "organizations_url": "https://api.github.com/users/seveibar/orgs",
                    "repos_url": "https://api.github.com/users/seveibar/repos",
                    "events_url": "https://api.github.com/users/seveibar/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/seveibar/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Determine why rectangles are missing in output",
                  "body": "You have completed the issue when the resistor blocks appear\n\n## Received\n\n<img width=\"2666\" height=\"1480\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/49f77954-6832-4a79-8f66-2e988af5d626\" />\n\n## Actual\n\n<img width=\"750\" height=\"620\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/a0a68fd0-c46d-4ac8-a10f-7efee6169eca\" />\n\n/bounty $50\n\n",
                  "html_url": "https://github.com/tscircuit/circuit-json-to-step/issues/6"
                },
                "type": "github"
              },
              "hash": "tscircuit/circuit-json-to-step#6",
              "body": "You have completed the issue when the resistor blocks appear\n\n## Received\n\n<img width=\"2666\" height=\"1480\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/49f77954-6832-4a79-8f66-2e988af5d626\" />\n\n## Actual\n\n<img width=\"750\" height=\"620\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/a0a68fd0-c46d-4ac8-a10f-7efee6169eca\" />\n\n/bounty $50\n\n",
              "url": "https://github.com/tscircuit/circuit-json-to-step/issues/6",
              "tech": [],
              "repo_name": "circuit-json-to-step",
              "repo_owner": "tscircuit",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "tscircuit#895",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "tscircuit",
              "id": "generated-tscircuit",
              "name": "Tscircuit",
              "description": "",
              "members": [],
              "display_name": "Tscircuit",
              "created_at": "2026-01-30T03:42:39.327Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/tscircuit?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "tscircuit",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-30T03:42:39.327Z",
            "created_at": "2026-01-30T03:42:39.327Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-tscircuit#895",
              "status": "open",
              "type": "issue",
              "number": 895,
              "title": "Pinout Diagram Improvements",
              "source": {
                "data": {
                  "id": "source-tscircuit#895",
                  "user": {
                    "login": "seveibar",
                    "id": 1910070,
                    "node_id": "MDQ6VXNlcjE5MTAwNzA=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1910070?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/seveibar",
                    "html_url": "https://github.com/seveibar",
                    "followers_url": "https://api.github.com/users/seveibar/followers",
                    "following_url": "https://api.github.com/users/seveibar/following{/other_user}",
                    "gists_url": "https://api.github.com/users/seveibar/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/seveibar/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/seveibar/subscriptions",
                    "organizations_url": "https://api.github.com/users/seveibar/orgs",
                    "repos_url": "https://api.github.com/users/seveibar/repos",
                    "events_url": "https://api.github.com/users/seveibar/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/seveibar/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Pinout Diagram Improvements",
                  "body": "- [ ] Multi-label support\n- [ ] Support for coloring (maybe via pinAttributes)\n- [ ] Support for board title text\n- [ ] Line overlap issue\n- [ ] Useless gray box and text\n\n\nRepos\n- tscircuit/props\n- tscircuit/core\n- tscircuit/circuit-to-svg\n\n<img width=\"2638\" height=\"1458\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/a8279fab-283a-4d35-915b-97fa3102528f\" />\n\n\nYou must be assigned. PRs will be reviewed by @ShiboSoftwareDev\n\n/bounty $150",
                  "html_url": "https://github.com/tscircuit/tscircuit/issues/895"
                },
                "type": "github"
              },
              "hash": "tscircuit/tscircuit#895",
              "body": "- [ ] Multi-label support\n- [ ] Support for coloring (maybe via pinAttributes)\n- [ ] Support for board title text\n- [ ] Line overlap issue\n- [ ] Useless gray box and text\n\n\nRepos\n- tscircuit/props\n- tscircuit/core\n- tscircuit/circuit-to-svg\n\n<img width=\"2638\" height=\"1458\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/a8279fab-283a-4d35-915b-97fa3102528f\" />\n\n\nYou must be assigned. PRs will be reviewed by @ShiboSoftwareDev\n\n/bounty $150",
              "url": "https://github.com/tscircuit/tscircuit/issues/895",
              "tech": [],
              "repo_name": "tscircuit",
              "repo_owner": "tscircuit",
              "forge": "github"
            },
            "timeouts_disabled": false
          }
        ],
        "next_cursor": null
      }
    }
  }
}