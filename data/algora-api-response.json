{
  "result": {
    "data": {
      "json": {
        "items": [
          {
            "id": "cal#18947",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "cal",
              "id": "generated-cal",
              "name": "Cal",
              "description": "",
              "members": [],
              "display_name": "Cal",
              "created_at": "2026-01-26T23:56:15.457Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/cal?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "calcom",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-26T23:56:15.461Z",
            "created_at": "2026-01-26T23:56:15.461Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-cal#18947",
              "status": "open",
              "type": "issue",
              "number": 18947,
              "title": "[CAL-5091] additional settings: \"add team member as optional guest",
              "source": {
                "data": {
                  "id": "source-cal#18947",
                  "user": {
                    "login": "PeerRich",
                    "id": 8019099,
                    "node_id": "MDQ6VXNlcjgwMTkwOTk=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/8019099?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/PeerRich",
                    "html_url": "https://github.com/PeerRich",
                    "followers_url": "https://api.github.com/users/PeerRich/followers",
                    "following_url": "https://api.github.com/users/PeerRich/following{/other_user}",
                    "gists_url": "https://api.github.com/users/PeerRich/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/PeerRich/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/PeerRich/subscriptions",
                    "organizations_url": "https://api.github.com/users/PeerRich/orgs",
                    "repos_url": "https://api.github.com/users/PeerRich/repos",
                    "events_url": "https://api.github.com/users/PeerRich/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/PeerRich/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "[CAL-5091] additional settings: \"add team member as optional guest",
                  "body": "![Image](https://github.com/user-attachments/assets/305d292b-a984-44c0-b89f-f8ed979d4c71)\n\n1. team members only (to protect spam) and show `<UpgradeTeamsBadge />`\n2.  don't check the team members calendar for conflict checking, only invite them\n3. if possible mark them as \"optional\":\n\n![Image](https://github.com/user-attachments/assets/7d2a1ec0-6c68-4334-a5ea-a1137279b98f)\n\n<sub>[CAL-5091](https://linear.app/calcom/issue/CAL-5091/additional-settings-add-team-member-as-optional-guest)</sub>",
                  "html_url": "https://github.com/calcom/cal.com/issues/18947"
                },
                "type": "github"
              },
              "hash": "calcom/cal.com#18947",
              "body": "![Image](https://github.com/user-attachments/assets/305d292b-a984-44c0-b89f-f8ed979d4c71)\n\n1. team members only (to protect spam) and show `<UpgradeTeamsBadge />`\n2.  don't check the team members calendar for conflict checking, only invite them\n3. if possible mark them as \"optional\":\n\n![Image](https://github.com/user-attachments/assets/7d2a1ec0-6c68-4334-a5ea-a1137279b98f)\n\n<sub>[CAL-5091](https://linear.app/calcom/issue/CAL-5091/additional-settings-add-team-member-as-optional-guest)</sub>",
              "url": "https://github.com/calcom/cal.com/issues/18947",
              "tech": [],
              "repo_name": "cal.com",
              "repo_owner": "calcom",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "cal#18992",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "cal",
              "id": "generated-cal",
              "name": "Cal",
              "description": "",
              "members": [],
              "display_name": "Cal",
              "created_at": "2026-01-26T23:56:16.304Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/cal?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "calcom",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-26T23:56:16.304Z",
            "created_at": "2026-01-26T23:56:16.304Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-cal#18992",
              "status": "open",
              "type": "issue",
              "number": 18992,
              "title": "[CAL-5107] add no-show to zapier (its a webhook only right now)",
              "source": {
                "data": {
                  "id": "source-cal#18992",
                  "user": {
                    "login": "PeerRich",
                    "id": 8019099,
                    "node_id": "MDQ6VXNlcjgwMTkwOTk=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/8019099?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/PeerRich",
                    "html_url": "https://github.com/PeerRich",
                    "followers_url": "https://api.github.com/users/PeerRich/followers",
                    "following_url": "https://api.github.com/users/PeerRich/following{/other_user}",
                    "gists_url": "https://api.github.com/users/PeerRich/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/PeerRich/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/PeerRich/subscriptions",
                    "organizations_url": "https://api.github.com/users/PeerRich/orgs",
                    "repos_url": "https://api.github.com/users/PeerRich/repos",
                    "events_url": "https://api.github.com/users/PeerRich/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/PeerRich/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "[CAL-5107] add no-show to zapier (its a webhook only right now)",
                  "body": "![Image](https://github.com/user-attachments/assets/d1992193-e964-4382-aff1-ba90d29c0562)\n\n<sub>[CAL-5107](https://linear.app/calcom/issue/CAL-5107/add-no-show-to-zapier-its-a-webhook-only-right-now)</sub>",
                  "html_url": "https://github.com/calcom/cal.com/issues/18992"
                },
                "type": "github"
              },
              "hash": "calcom/cal.com#18992",
              "body": "![Image](https://github.com/user-attachments/assets/d1992193-e964-4382-aff1-ba90d29c0562)\n\n<sub>[CAL-5107](https://linear.app/calcom/issue/CAL-5107/add-no-show-to-zapier-its-a-webhook-only-right-now)</sub>",
              "url": "https://github.com/calcom/cal.com/issues/18992",
              "tech": [],
              "repo_name": "cal.com",
              "repo_owner": "calcom",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "cal#18987",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "cal",
              "id": "generated-cal",
              "name": "Cal",
              "description": "",
              "members": [],
              "display_name": "Cal",
              "created_at": "2026-01-26T23:56:19.501Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/cal?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "calcom",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-26T23:56:19.502Z",
            "created_at": "2026-01-26T23:56:19.502Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-cal#18987",
              "status": "open",
              "type": "issue",
              "number": 18987,
              "title": "[CAL-5097] add the same \"booking questions\" to routing forms",
              "source": {
                "data": {
                  "id": "source-cal#18987",
                  "user": {
                    "login": "PeerRich",
                    "id": 8019099,
                    "node_id": "MDQ6VXNlcjgwMTkwOTk=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/8019099?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/PeerRich",
                    "html_url": "https://github.com/PeerRich",
                    "followers_url": "https://api.github.com/users/PeerRich/followers",
                    "following_url": "https://api.github.com/users/PeerRich/following{/other_user}",
                    "gists_url": "https://api.github.com/users/PeerRich/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/PeerRich/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/PeerRich/subscriptions",
                    "organizations_url": "https://api.github.com/users/PeerRich/orgs",
                    "repos_url": "https://api.github.com/users/PeerRich/repos",
                    "events_url": "https://api.github.com/users/PeerRich/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/PeerRich/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "[CAL-5097] add the same \"booking questions\" to routing forms",
                  "body": "right now \"booking forms\" for event-types have more (and different) inputs that routing forms:\n\n\nevent-types:\n\nhttps://github.com/user-attachments/assets/29c921ea-8677-4238-a198-55be00ce8188\n\nrouting forms:\n\nhttps://github.com/user-attachments/assets/cdaf70e0-7c5b-416b-a984-a57ded4c8525\n\n\nwe should reuse the entire event-type booking question UI inside routing forms.\n\n\nwe should also ask for the identifier **first** and not prefill it. (see event-types)\n\n<sub>[CAL-5097](https://linear.app/calcom/issue/CAL-5097/add-the-same-booking-questions-to-routing-forms)</sub>",
                  "html_url": "https://github.com/calcom/cal.com/issues/18987"
                },
                "type": "github"
              },
              "hash": "calcom/cal.com#18987",
              "body": "right now \"booking forms\" for event-types have more (and different) inputs that routing forms:\n\n\nevent-types:\n\nhttps://github.com/user-attachments/assets/29c921ea-8677-4238-a198-55be00ce8188\n\nrouting forms:\n\nhttps://github.com/user-attachments/assets/cdaf70e0-7c5b-416b-a984-a57ded4c8525\n\n\nwe should reuse the entire event-type booking question UI inside routing forms.\n\n\nwe should also ask for the identifier **first** and not prefill it. (see event-types)\n\n<sub>[CAL-5097](https://linear.app/calcom/issue/CAL-5097/add-the-same-booking-questions-to-routing-forms)</sub>",
              "url": "https://github.com/calcom/cal.com/issues/18987",
              "tech": [],
              "repo_name": "cal.com",
              "repo_owner": "calcom",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "cal#8123",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "cal",
              "id": "generated-cal",
              "name": "Cal",
              "description": "",
              "members": [],
              "display_name": "Cal",
              "created_at": "2026-01-26T23:56:23.695Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/cal?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "calcom",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-26T23:56:23.695Z",
            "created_at": "2026-01-26T23:56:23.695Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-cal#8123",
              "status": "open",
              "type": "issue",
              "number": 8123,
              "title": "[CAL-1425] Exchange on Premise 2016",
              "source": {
                "data": {
                  "id": "source-cal#8123",
                  "user": {
                    "login": "PeerRich",
                    "id": 8019099,
                    "node_id": "MDQ6VXNlcjgwMTkwOTk=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/8019099?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/PeerRich",
                    "html_url": "https://github.com/PeerRich",
                    "followers_url": "https://api.github.com/users/PeerRich/followers",
                    "following_url": "https://api.github.com/users/PeerRich/following{/other_user}",
                    "gists_url": "https://api.github.com/users/PeerRich/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/PeerRich/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/PeerRich/subscriptions",
                    "organizations_url": "https://api.github.com/users/PeerRich/orgs",
                    "repos_url": "https://api.github.com/users/PeerRich/repos",
                    "events_url": "https://api.github.com/users/PeerRich/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/PeerRich/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "[CAL-1425] Exchange on Premise 2016",
                  "body": " > If I use Exchange 2016 i get the message \"cannot added\". and if i use standard Exchange as Option I get \"unauthorized\". but i checked that the EWS login works fine via URL\r\n\r\n\n\n<sub>[CAL-1425](https://linear.app/calcom/issue/CAL-1425/exchange-on-premise-2016)</sub>",
                  "html_url": "https://github.com/calcom/cal.com/issues/8123"
                },
                "type": "github"
              },
              "hash": "calcom/cal.com#8123",
              "body": " > If I use Exchange 2016 i get the message \"cannot added\". and if i use standard Exchange as Option I get \"unauthorized\". but i checked that the EWS login works fine via URL\r\n\r\n\n\n<sub>[CAL-1425](https://linear.app/calcom/issue/CAL-1425/exchange-on-premise-2016)</sub>",
              "url": "https://github.com/calcom/cal.com/issues/8123",
              "tech": [],
              "repo_name": "cal.com",
              "repo_owner": "calcom",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "cal#16378",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "cal",
              "id": "generated-cal",
              "name": "Cal",
              "description": "",
              "members": [],
              "display_name": "Cal",
              "created_at": "2026-01-26T23:56:25.659Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/cal?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "calcom",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-26T23:56:25.659Z",
            "created_at": "2026-01-26T23:56:25.659Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-cal#16378",
              "status": "open",
              "type": "issue",
              "number": 16378,
              "title": "[CAL-4531] Take into account guest's availability when rescheduling",
              "source": {
                "data": {
                  "id": "source-cal#16378",
                  "user": {
                    "login": "pumfleet",
                    "id": 25907159,
                    "node_id": "MDQ6VXNlcjI1OTA3MTU5",
                    "avatar_url": "https://avatars.githubusercontent.com/u/25907159?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/pumfleet",
                    "html_url": "https://github.com/pumfleet",
                    "followers_url": "https://api.github.com/users/pumfleet/followers",
                    "following_url": "https://api.github.com/users/pumfleet/following{/other_user}",
                    "gists_url": "https://api.github.com/users/pumfleet/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/pumfleet/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/pumfleet/subscriptions",
                    "organizations_url": "https://api.github.com/users/pumfleet/orgs",
                    "repos_url": "https://api.github.com/users/pumfleet/repos",
                    "events_url": "https://api.github.com/users/pumfleet/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/pumfleet/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "[CAL-4531] Take into account guest's availability when rescheduling",
                  "body": "If I (a Cal.com user) book another Cal.com user and they want to reschedule it on their end (instead of requesting me to reschedule), it doesn't take into account my availability and just lets them freely choose a time.\r\n\r\nThis is because the person who booked the meeting may or may not be a Cal.com user, hence we don't bother checking for their availability. But we do have the user's email, so we should look up the user and see if they're a Cal.com user, and then if so, retrieve the available times for them, and only display those when the host tries to reschedule\n\n<sub>[CAL-4531](https://linear.app/calcom/issue/CAL-4531/take-into-account-guests-availability-when-rescheduling)</sub>",
                  "html_url": "https://github.com/calcom/cal.com/issues/16378"
                },
                "type": "github"
              },
              "hash": "calcom/cal.com#16378",
              "body": "If I (a Cal.com user) book another Cal.com user and they want to reschedule it on their end (instead of requesting me to reschedule), it doesn't take into account my availability and just lets them freely choose a time.\r\n\r\nThis is because the person who booked the meeting may or may not be a Cal.com user, hence we don't bother checking for their availability. But we do have the user's email, so we should look up the user and see if they're a Cal.com user, and then if so, retrieve the available times for them, and only display those when the host tries to reschedule\n\n<sub>[CAL-4531](https://linear.app/calcom/issue/CAL-4531/take-into-account-guests-availability-when-rescheduling)</sub>",
              "url": "https://github.com/calcom/cal.com/issues/16378",
              "tech": [],
              "repo_name": "cal.com",
              "repo_owner": "calcom",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "cal#13532",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "cal",
              "id": "generated-cal",
              "name": "Cal",
              "description": "",
              "members": [],
              "display_name": "Cal",
              "created_at": "2026-01-26T23:56:28.292Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/cal?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "calcom",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-26T23:56:28.292Z",
            "created_at": "2026-01-26T23:56:28.292Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-cal#13532",
              "status": "open",
              "type": "issue",
              "number": 13532,
              "title": "[CAL-3076] allow emails and invite people to a team event-type directly from \"assignment\" if not in team yet",
              "source": {
                "data": {
                  "id": "source-cal#13532",
                  "user": {
                    "login": "PeerRich",
                    "id": 8019099,
                    "node_id": "MDQ6VXNlcjgwMTkwOTk=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/8019099?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/PeerRich",
                    "html_url": "https://github.com/PeerRich",
                    "followers_url": "https://api.github.com/users/PeerRich/followers",
                    "following_url": "https://api.github.com/users/PeerRich/following{/other_user}",
                    "gists_url": "https://api.github.com/users/PeerRich/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/PeerRich/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/PeerRich/subscriptions",
                    "organizations_url": "https://api.github.com/users/PeerRich/orgs",
                    "repos_url": "https://api.github.com/users/PeerRich/repos",
                    "events_url": "https://api.github.com/users/PeerRich/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/PeerRich/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "[CAL-3076] allow emails and invite people to a team event-type directly from \"assignment\" if not in team yet",
                  "body": "- [ ] allow emails in assignment\n- [ ] invite person if its not in the team yet (as Member)\n- [ ] allow multiple emails comma separated: [user1@example.com](mailto:user1@example.com), [user2@example.com](mailto:user2@example.com)\n\n![CleanShot 2024-02-05 at 10 17 08@2x](https://uploads.linear.app/e86bf957-d82f-465e-b205-135559f4b623/598b18ab-0aed-491d-90f4-cd2afa2f1bbb/24eba054-180f-45cf-b858-4764d896572f?signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJwYXRoIjoiL2U4NmJmOTU3LWQ4MmYtNDY1ZS1iMjA1LTEzNTU1OWY0YjYyMy81OThiMThhYi0wYWVkLTQ5MWQtOTBmNC1jZDJhZmEyZjFiYmIvMjRlYmEwNTQtMTgwZi00NWNmLWI4NTgtNDc2NGQ4OTY1NzJmIiwiaWF0IjoxNzA3MTI4MjY3LCJleHAiOjE3MDcyMTQ2Njd9.DQDBQ-o7r2wBUIvnU0ZH2MoSkKZMbzDB9cIHtLUvV4Q)\n\n<sub>From [SyncLinear.com](https://synclinear.com) | [CAL-3076](https://linear.app/calcom/issue/CAL-3076/allow-emails-and-invite-people-to-a-team-event-type-directly-from)</sub>",
                  "html_url": "https://github.com/calcom/cal.com/issues/13532"
                },
                "type": "github"
              },
              "hash": "calcom/cal.com#13532",
              "body": "- [ ] allow emails in assignment\n- [ ] invite person if its not in the team yet (as Member)\n- [ ] allow multiple emails comma separated: [user1@example.com](mailto:user1@example.com), [user2@example.com](mailto:user2@example.com)\n\n![CleanShot 2024-02-05 at 10 17 08@2x](https://uploads.linear.app/e86bf957-d82f-465e-b205-135559f4b623/598b18ab-0aed-491d-90f4-cd2afa2f1bbb/24eba054-180f-45cf-b858-4764d896572f?signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJwYXRoIjoiL2U4NmJmOTU3LWQ4MmYtNDY1ZS1iMjA1LTEzNTU1OWY0YjYyMy81OThiMThhYi0wYWVkLTQ5MWQtOTBmNC1jZDJhZmEyZjFiYmIvMjRlYmEwNTQtMTgwZi00NWNmLWI4NTgtNDc2NGQ4OTY1NzJmIiwiaWF0IjoxNzA3MTI4MjY3LCJleHAiOjE3MDcyMTQ2Njd9.DQDBQ-o7r2wBUIvnU0ZH2MoSkKZMbzDB9cIHtLUvV4Q)\n\n<sub>From [SyncLinear.com](https://synclinear.com) | [CAL-3076](https://linear.app/calcom/issue/CAL-3076/allow-emails-and-invite-people-to-a-team-event-type-directly-from)</sub>",
              "url": "https://github.com/calcom/cal.com/issues/13532",
              "tech": [],
              "repo_name": "cal.com",
              "repo_owner": "calcom",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "cal#11340",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "cal",
              "id": "generated-cal",
              "name": "Cal",
              "description": "",
              "members": [],
              "display_name": "Cal",
              "created_at": "2026-01-26T23:56:31.084Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/cal?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "calcom",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-26T23:56:31.084Z",
            "created_at": "2026-01-26T23:56:31.084Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-cal#11340",
              "status": "open",
              "type": "issue",
              "number": 11340,
              "title": "Add Lawpay as a payment option",
              "source": {
                "data": {
                  "id": "source-cal#11340",
                  "user": {
                    "login": "Kfelts",
                    "id": 51497445,
                    "node_id": "MDQ6VXNlcjUxNDk3NDQ1",
                    "avatar_url": "https://avatars.githubusercontent.com/u/51497445?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/Kfelts",
                    "html_url": "https://github.com/Kfelts",
                    "followers_url": "https://api.github.com/users/Kfelts/followers",
                    "following_url": "https://api.github.com/users/Kfelts/following{/other_user}",
                    "gists_url": "https://api.github.com/users/Kfelts/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/Kfelts/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/Kfelts/subscriptions",
                    "organizations_url": "https://api.github.com/users/Kfelts/orgs",
                    "repos_url": "https://api.github.com/users/Kfelts/repos",
                    "events_url": "https://api.github.com/users/Kfelts/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/Kfelts/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Add Lawpay as a payment option",
                  "body": "### Is your proposal related to a problem?\r\n\r\nMany attorneys use Lawpay as their payment processor because it automatically handles trust accounting and avoids comingling funds between operations and trust accounts. Stripe doesn't have that capability. I'd like to see Lawpay (Affinipay) offered as a gateway option since they have an open API and integrate easily with other scheduling programs.\r\n\r\n\r\n### Describe the solution you'd like\r\n\r\nThe ability to connect Cal.com to Lawpay as a payment processor for appointment bookings\r\n\r\n### Requirement/Document\r\n\r\n[Lawpay Integration Partners](https://www.lawpay.com/partners/integrated-partners/)\r\n[API Reference Documents](https://developers.affinipay.com/reference/api.html)\r\n\r\n",
                  "html_url": "https://github.com/calcom/cal.com/issues/11340"
                },
                "type": "github"
              },
              "hash": "calcom/cal.com#11340",
              "body": "### Is your proposal related to a problem?\r\n\r\nMany attorneys use Lawpay as their payment processor because it automatically handles trust accounting and avoids comingling funds between operations and trust accounts. Stripe doesn't have that capability. I'd like to see Lawpay (Affinipay) offered as a gateway option since they have an open API and integrate easily with other scheduling programs.\r\n\r\n\r\n### Describe the solution you'd like\r\n\r\nThe ability to connect Cal.com to Lawpay as a payment processor for appointment bookings\r\n\r\n### Requirement/Document\r\n\r\n[Lawpay Integration Partners](https://www.lawpay.com/partners/integrated-partners/)\r\n[API Reference Documents](https://developers.affinipay.com/reference/api.html)\r\n\r\n",
              "url": "https://github.com/calcom/cal.com/issues/11340",
              "tech": [],
              "repo_name": "cal.com",
              "repo_owner": "calcom",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "cal#2",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "cal",
              "id": "generated-cal",
              "name": "Cal",
              "description": "",
              "members": [],
              "display_name": "Cal",
              "created_at": "2026-01-26T23:56:33.724Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/cal?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "calcom",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-26T23:56:33.724Z",
            "created_at": "2026-01-26T23:56:33.724Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-cal#2",
              "status": "open",
              "type": "issue",
              "number": 2,
              "title": "Plans on weights?",
              "source": {
                "data": {
                  "id": "source-cal#2",
                  "user": {
                    "login": "TaigaYamada",
                    "id": 77144664,
                    "node_id": "MDQ6VXNlcjc3MTQ0NjY0",
                    "avatar_url": "https://avatars.githubusercontent.com/u/77144664?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/TaigaYamada",
                    "html_url": "https://github.com/TaigaYamada",
                    "followers_url": "https://api.github.com/users/TaigaYamada/followers",
                    "following_url": "https://api.github.com/users/TaigaYamada/following{/other_user}",
                    "gists_url": "https://api.github.com/users/TaigaYamada/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/TaigaYamada/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/TaigaYamada/subscriptions",
                    "organizations_url": "https://api.github.com/users/TaigaYamada/orgs",
                    "repos_url": "https://api.github.com/users/TaigaYamada/repos",
                    "events_url": "https://api.github.com/users/TaigaYamada/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/TaigaYamada/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Plans on weights?",
                  "body": "I absolutely love the font! Thank you for the amazing work.\n\nAre there any plans to introduce more weights to the font in the future?",
                  "html_url": "https://github.com/calcom/sans/issues/2"
                },
                "type": "github"
              },
              "hash": "calcom/font#2",
              "body": "I absolutely love the font! Thank you for the amazing work.\n\nAre there any plans to introduce more weights to the font in the future?",
              "url": "https://github.com/calcom/sans/issues/2",
              "tech": [],
              "repo_name": "font",
              "repo_owner": "calcom",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "cal#1985",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "cal",
              "id": "generated-cal",
              "name": "Cal",
              "description": "",
              "members": [],
              "display_name": "Cal",
              "created_at": "2026-01-26T23:56:33.904Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/cal?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "calcom",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-26T23:56:33.904Z",
            "created_at": "2026-01-26T23:56:33.904Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-cal#1985",
              "status": "open",
              "type": "issue",
              "number": 1985,
              "title": "[CAL-3105] BigBlueButton Integration",
              "source": {
                "data": {
                  "id": "source-cal#1985",
                  "user": {
                    "login": "philippdormann",
                    "id": 17651032,
                    "node_id": "MDQ6VXNlcjE3NjUxMDMy",
                    "avatar_url": "https://avatars.githubusercontent.com/u/17651032?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/philippdormann",
                    "html_url": "https://github.com/philippdormann",
                    "followers_url": "https://api.github.com/users/philippdormann/followers",
                    "following_url": "https://api.github.com/users/philippdormann/following{/other_user}",
                    "gists_url": "https://api.github.com/users/philippdormann/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/philippdormann/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/philippdormann/subscriptions",
                    "organizations_url": "https://api.github.com/users/philippdormann/orgs",
                    "repos_url": "https://api.github.com/users/philippdormann/repos",
                    "events_url": "https://api.github.com/users/philippdormann/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/philippdormann/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "[CAL-3105] BigBlueButton Integration",
                  "body": "### Is your proposal related to a problem?\r\n\r\nNo, this is a new feature request\r\n\r\n### Describe the solution you'd like\r\n\r\nApp Integration for [BigBlueButton](https://bigbluebutton.org/) using the [BigBlueButton API](https://docs.bigbluebutton.org/dev/api.html#create)\n\n<sub>[CAL-3105](https://linear.app/calcom/issue/CAL-3105/bigbluebutton-integration)</sub>",
                  "html_url": "https://github.com/calcom/cal.com/issues/1985"
                },
                "type": "github"
              },
              "hash": "calcom/cal.com#1985",
              "body": "### Is your proposal related to a problem?\r\n\r\nNo, this is a new feature request\r\n\r\n### Describe the solution you'd like\r\n\r\nApp Integration for [BigBlueButton](https://bigbluebutton.org/) using the [BigBlueButton API](https://docs.bigbluebutton.org/dev/api.html#create)\n\n<sub>[CAL-3105](https://linear.app/calcom/issue/CAL-3105/bigbluebutton-integration)</sub>",
              "url": "https://github.com/calcom/cal.com/issues/1985",
              "tech": [],
              "repo_name": "cal.com",
              "repo_owner": "calcom",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "cal#3717",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "cal",
              "id": "generated-cal",
              "name": "Cal",
              "description": "",
              "members": [],
              "display_name": "Cal",
              "created_at": "2026-01-26T23:56:34.043Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/cal?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "calcom",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-26T23:56:34.043Z",
            "created_at": "2026-01-26T23:56:34.043Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-cal#3717",
              "status": "open",
              "type": "issue",
              "number": 3717,
              "title": "[CAL-3414] App: Lever.co",
              "source": {
                "data": {
                  "id": "source-cal#3717",
                  "user": {
                    "login": "PeerRich",
                    "id": 8019099,
                    "node_id": "MDQ6VXNlcjgwMTkwOTk=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/8019099?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/PeerRich",
                    "html_url": "https://github.com/PeerRich",
                    "followers_url": "https://api.github.com/users/PeerRich/followers",
                    "following_url": "https://api.github.com/users/PeerRich/following{/other_user}",
                    "gists_url": "https://api.github.com/users/PeerRich/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/PeerRich/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/PeerRich/subscriptions",
                    "organizations_url": "https://api.github.com/users/PeerRich/orgs",
                    "repos_url": "https://api.github.com/users/PeerRich/repos",
                    "events_url": "https://api.github.com/users/PeerRich/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/PeerRich/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "[CAL-3414] App: Lever.co",
                  "body": "similar to Greenhouse\n\n<sub>[CAL-3414](https://linear.app/calcom/issue/CAL-3414/app-leverco)</sub>",
                  "html_url": "https://github.com/calcom/cal.com/issues/3717"
                },
                "type": "github"
              },
              "hash": "calcom/cal.com#3717",
              "body": "similar to Greenhouse\n\n<sub>[CAL-3414](https://linear.app/calcom/issue/CAL-3414/app-leverco)</sub>",
              "url": "https://github.com/calcom/cal.com/issues/3717",
              "tech": [],
              "repo_name": "cal.com",
              "repo_owner": "calcom",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "outerbase#59",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "outerbase",
              "id": "generated-outerbase",
              "name": "Outerbase",
              "description": "",
              "members": [],
              "display_name": "Outerbase",
              "created_at": "2026-01-26T23:56:42.185Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/outerbase?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "outerbase",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-26T23:56:42.185Z",
            "created_at": "2026-01-26T23:56:42.185Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-outerbase#59",
              "status": "open",
              "type": "issue",
              "number": 59,
              "title": "Database dumps do not work on large databases",
              "source": {
                "data": {
                  "id": "source-outerbase#59",
                  "user": {
                    "login": "Brayden",
                    "id": 1066085,
                    "node_id": "MDQ6VXNlcjEwNjYwODU=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1066085?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/Brayden",
                    "html_url": "https://github.com/Brayden",
                    "followers_url": "https://api.github.com/users/Brayden/followers",
                    "following_url": "https://api.github.com/users/Brayden/following{/other_user}",
                    "gists_url": "https://api.github.com/users/Brayden/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/Brayden/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/Brayden/subscriptions",
                    "organizations_url": "https://api.github.com/users/Brayden/orgs",
                    "repos_url": "https://api.github.com/users/Brayden/repos",
                    "events_url": "https://api.github.com/users/Brayden/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/Brayden/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Database dumps do not work on large databases",
                  "body": "**Describe the bug**\nIf you try to use any of the database dump endpoints such as SQL, CSV or JSON the data is loaded into memory and then created as a dump file. To support any size database we should investigate enhancements to allow any sized database to be exported. Currently the size limitations are 1GB for Durable Objects with 10GB in the future. Operate under the assumption that we might be attempting to dump a 10GB database into a `.sql` file.\n\nAnother consideration to make is because Durable Objects execute synchronous operations we may need to allow for \"breathing intervals\". An example might be we allow our export operation to run for 5 seconds, and take 5 seconds off if other requests are in a queue, then it can pick up again. The goal here would be to prevent locking the database for long periods of time.\n\nBut then poses the questions: \n1. How do we continue operations that need more than 30 seconds to work?\n2. Where is the data stored as it's being created? (R2, S3, something else)?\n3. How do we deliver that dump information to the user after its completed?\n\n**To Reproduce**\nSteps to reproduce the behavior:\n\n1. Hit the `/export/dump` endpoint on a large database\n2. Will eventually fail when the 30 second request response time window closes\n\nRun the following command in Terminal (replace the URL with yours) and if your operation exceeds 30 seconds you should see a failed network response instead of a dump file.\n```\ncurl --location 'https://starbasedb.YOUR-ID-HERE.workers.dev/export/dump' \\\n--header 'Authorization: Bearer ABC123' \\\n--output database_dump.sql\n```\n\nIf you can't create a large enough test database feel free to add code in to `sleep` for 29 seconds before proceeding with the `/export/dump` functional code and should also see the failure.\n\n**Expected behavior**\nAs a user I would expect any and all of the specified data to be dumped out without an error and without partial results. Where it ends up for the user to access if the operation takes more than 30 seconds is up for discussion. Ideally if shorter than 30 seconds it could be returned as our cURL above works today (downloads the file from the response of the origin request), but perhaps after the timeout it continues on uploads it to a destination source to access afterwards?\n\n**Proposed Solution:**\n1. For backups require an R2 binding\n2. Have a `.sql` file that gets created in R2 with the filename like `dump_20240101-170000.sql` where it represents `2024-01-01 17:00:00`\n3. Create the file and continuously append new chunks to it until reaching the end\n4. May need to utilize a DO alarm to continue the work after X time if a timeout occurs & mark where it currently is in the process in internal memory so it can pick up and continue.\n5. Provide a callback URL when the operation is finally completed so users can create custom logic to notify them (e.g. Email, Slack, etc)",
                  "html_url": "https://github.com/outerbase/starbasedb/issues/59"
                },
                "type": "github"
              },
              "hash": "outerbase/starbasedb#59",
              "body": "**Describe the bug**\nIf you try to use any of the database dump endpoints such as SQL, CSV or JSON the data is loaded into memory and then created as a dump file. To support any size database we should investigate enhancements to allow any sized database to be exported. Currently the size limitations are 1GB for Durable Objects with 10GB in the future. Operate under the assumption that we might be attempting to dump a 10GB database into a `.sql` file.\n\nAnother consideration to make is because Durable Objects execute synchronous operations we may need to allow for \"breathing intervals\". An example might be we allow our export operation to run for 5 seconds, and take 5 seconds off if other requests are in a queue, then it can pick up again. The goal here would be to prevent locking the database for long periods of time.\n\nBut then poses the questions: \n1. How do we continue operations that need more than 30 seconds to work?\n2. Where is the data stored as it's being created? (R2, S3, something else)?\n3. How do we deliver that dump information to the user after its completed?\n\n**To Reproduce**\nSteps to reproduce the behavior:\n\n1. Hit the `/export/dump` endpoint on a large database\n2. Will eventually fail when the 30 second request response time window closes\n\nRun the following command in Terminal (replace the URL with yours) and if your operation exceeds 30 seconds you should see a failed network response instead of a dump file.\n```\ncurl --location 'https://starbasedb.YOUR-ID-HERE.workers.dev/export/dump' \\\n--header 'Authorization: Bearer ABC123' \\\n--output database_dump.sql\n```\n\nIf you can't create a large enough test database feel free to add code in to `sleep` for 29 seconds before proceeding with the `/export/dump` functional code and should also see the failure.\n\n**Expected behavior**\nAs a user I would expect any and all of the specified data to be dumped out without an error and without partial results. Where it ends up for the user to access if the operation takes more than 30 seconds is up for discussion. Ideally if shorter than 30 seconds it could be returned as our cURL above works today (downloads the file from the response of the origin request), but perhaps after the timeout it continues on uploads it to a destination source to access afterwards?\n\n**Proposed Solution:**\n1. For backups require an R2 binding\n2. Have a `.sql` file that gets created in R2 with the filename like `dump_20240101-170000.sql` where it represents `2024-01-01 17:00:00`\n3. Create the file and continuously append new chunks to it until reaching the end\n4. May need to utilize a DO alarm to continue the work after X time if a timeout occurs & mark where it currently is in the process in internal memory so it can pick up and continue.\n5. Provide a callback URL when the operation is finally completed so users can create custom logic to notify them (e.g. Email, Slack, etc)",
              "url": "https://github.com/outerbase/starbasedb/issues/59",
              "tech": [],
              "repo_name": "starbasedb",
              "repo_owner": "outerbase",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "outerbase#72",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "outerbase",
              "id": "generated-outerbase",
              "name": "Outerbase",
              "description": "",
              "members": [],
              "display_name": "Outerbase",
              "created_at": "2026-01-26T23:56:42.358Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/outerbase?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "outerbase",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-26T23:56:42.358Z",
            "created_at": "2026-01-26T23:56:42.358Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-outerbase#72",
              "status": "open",
              "type": "issue",
              "number": 72,
              "title": "Replicate data from external source to internal source with a Plugin",
              "source": {
                "data": {
                  "id": "source-outerbase#72",
                  "user": {
                    "login": "Brayden",
                    "id": 1066085,
                    "node_id": "MDQ6VXNlcjEwNjYwODU=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1066085?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/Brayden",
                    "html_url": "https://github.com/Brayden",
                    "followers_url": "https://api.github.com/users/Brayden/followers",
                    "following_url": "https://api.github.com/users/Brayden/following{/other_user}",
                    "gists_url": "https://api.github.com/users/Brayden/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/Brayden/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/Brayden/subscriptions",
                    "organizations_url": "https://api.github.com/users/Brayden/orgs",
                    "repos_url": "https://api.github.com/users/Brayden/repos",
                    "events_url": "https://api.github.com/users/Brayden/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/Brayden/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Replicate data from external source to internal source with a Plugin",
                  "body": "**Is your feature request related to a problem? Please describe.**\nStarbaseDB instances support by default an internal database (SQLite offered by the Durable Object) as well as an optional external data source. External data sources can be powered in one of two ways, both by providing values in the `wrangler.toml` file of the project.\n\n- Outerbase API Key\n- Connection details of the database\n\n<img width=\"481\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/485d4b88-a7f8-432d-9f29-d3239a6e6577\" />\n\n**Describe the solution you'd like**\nWhat would be beneficial for some use cases is the ability to bring in an external data source (e.g. a Postgres on Supabase) and have a pull mechanism where data can be brought into the internal DO SQLite so that the instance serves as a close-to-edge replica that can be queried alternatively to querying the Supabase Postgres instance.\n\n**Describe alternatives you've considered**\n- Considering the pull vs push mechanism. A pull mechanism seems to be a better global solution where a push mechanism would be required to live elsewhere on a per provider basis.\n\n**Additional context**\n- Might be beneficial for users to be able to define in the plugin what intervals data should be pulled at\n- Might be beneficial to allow users to define which tables should have data pulled into it (perhaps not all tables need replicated)\n- Likely need a way to know for each table what the last queried items were so you can do append-only type polling for new data. Does a user need to define a column to base this on (e.g. `id` or `created_at` columns perhaps)?\n",
                  "html_url": "https://github.com/outerbase/starbasedb/issues/72"
                },
                "type": "github"
              },
              "hash": "outerbase/starbasedb#72",
              "body": "**Is your feature request related to a problem? Please describe.**\nStarbaseDB instances support by default an internal database (SQLite offered by the Durable Object) as well as an optional external data source. External data sources can be powered in one of two ways, both by providing values in the `wrangler.toml` file of the project.\n\n- Outerbase API Key\n- Connection details of the database\n\n<img width=\"481\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/485d4b88-a7f8-432d-9f29-d3239a6e6577\" />\n\n**Describe the solution you'd like**\nWhat would be beneficial for some use cases is the ability to bring in an external data source (e.g. a Postgres on Supabase) and have a pull mechanism where data can be brought into the internal DO SQLite so that the instance serves as a close-to-edge replica that can be queried alternatively to querying the Supabase Postgres instance.\n\n**Describe alternatives you've considered**\n- Considering the pull vs push mechanism. A pull mechanism seems to be a better global solution where a push mechanism would be required to live elsewhere on a per provider basis.\n\n**Additional context**\n- Might be beneficial for users to be able to define in the plugin what intervals data should be pulled at\n- Might be beneficial to allow users to define which tables should have data pulled into it (perhaps not all tables need replicated)\n- Likely need a way to know for each table what the last queried items were so you can do append-only type polling for new data. Does a user need to define a column to base this on (e.g. `id` or `created_at` columns perhaps)?\n",
              "url": "https://github.com/outerbase/starbasedb/issues/72",
              "tech": [],
              "repo_name": "starbasedb",
              "repo_owner": "outerbase",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "mediar-ai#1626",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "mediar-ai",
              "id": "generated-mediar-ai",
              "name": "Mediar-ai",
              "description": "",
              "members": [],
              "display_name": "Mediar-ai",
              "created_at": "2026-01-26T23:56:53.106Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/mediar-ai?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "mediar-ai",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-26T23:56:53.106Z",
            "created_at": "2026-01-26T23:56:53.106Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-mediar-ai#1626",
              "status": "open",
              "type": "issue",
              "number": 1626,
              "title": "[bounty] $400 fix audio device randomly stopping sometimes",
              "source": {
                "data": {
                  "id": "source-mediar-ai#1626",
                  "user": {
                    "login": "louis030195",
                    "id": 25003283,
                    "node_id": "MDQ6VXNlcjI1MDAzMjgz",
                    "avatar_url": "https://avatars.githubusercontent.com/u/25003283?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/louis030195",
                    "html_url": "https://github.com/louis030195",
                    "followers_url": "https://api.github.com/users/louis030195/followers",
                    "following_url": "https://api.github.com/users/louis030195/following{/other_user}",
                    "gists_url": "https://api.github.com/users/louis030195/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/louis030195/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/louis030195/subscriptions",
                    "organizations_url": "https://api.github.com/users/louis030195/orgs",
                    "repos_url": "https://api.github.com/users/louis030195/repos",
                    "events_url": "https://api.github.com/users/louis030195/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/louis030195/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "[bounty] $400 fix audio device randomly stopping sometimes",
                  "body": "\ndisplay audio / microphone randomly stops on mac sometimes \n\nhad it running for 48h now and display audio somehow stopped a bit later after 50h\n\n/bounty 400 \n\n@EzraEllette any idea?\n\n\ni suggest finding way to reproduce and then some automated test and a fix ",
                  "html_url": "https://github.com/mediar-ai/screenpipe/issues/1626"
                },
                "type": "github"
              },
              "hash": "mediar-ai/screenpipe#1626",
              "body": "\ndisplay audio / microphone randomly stops on mac sometimes \n\nhad it running for 48h now and display audio somehow stopped a bit later after 50h\n\n/bounty 400 \n\n@EzraEllette any idea?\n\n\ni suggest finding way to reproduce and then some automated test and a fix ",
              "url": "https://github.com/mediar-ai/screenpipe/issues/1626",
              "tech": [],
              "repo_name": "screenpipe",
              "repo_owner": "mediar-ai",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "qdrant#3322",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "qdrant",
              "id": "generated-qdrant",
              "name": "Qdrant",
              "description": "",
              "members": [],
              "display_name": "Qdrant",
              "created_at": "2026-01-26T23:56:54.304Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/qdrant?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "qdrant",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-26T23:56:54.304Z",
            "created_at": "2026-01-26T23:56:54.304Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-qdrant#3322",
              "status": "open",
              "type": "issue",
              "number": 3322,
              "title": "Per-collection metrics for Prometheus",
              "source": {
                "data": {
                  "id": "source-qdrant#3322",
                  "user": {
                    "login": "generall",
                    "id": 1935623,
                    "node_id": "MDQ6VXNlcjE5MzU2MjM=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1935623?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/generall",
                    "html_url": "https://github.com/generall",
                    "followers_url": "https://api.github.com/users/generall/followers",
                    "following_url": "https://api.github.com/users/generall/following{/other_user}",
                    "gists_url": "https://api.github.com/users/generall/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/generall/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/generall/subscriptions",
                    "organizations_url": "https://api.github.com/users/generall/orgs",
                    "repos_url": "https://api.github.com/users/generall/repos",
                    "events_url": "https://api.github.com/users/generall/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/generall/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Per-collection metrics for Prometheus",
                  "body": "**Is your feature request related to a problem? Please describe.**\r\n\r\nCurrently, all metrics in `/metrics` are global, meaning that its impossible to see differences per collection.\r\n\r\nIn addition to that, all our metrics should have per-collection granularity to allow better aggregation in Prometheus, including:\r\n\r\n- point/vector counts\r\n- REST/gRPC requests\r\n\r\n**Describe the solution you'd like**\r\n\r\nExample:\r\n```\r\ngrpc_responses_min_duration_seconds{endpoint=\"/qdrant.Points/Upsert\"} 0.000046\r\ngrpc_responses_min_duration_seconds{endpoint=\"/qdrant.Points/Upsert\",collection=\"my-collection\"} 0.000049\r\ngrpc_responses_min_duration_seconds{endpoint=\"/qdrant.Points/Upsert\",collection=\"my-collection-2\"} 0.000046\r\n```\r\n\r\n**Describe alternatives you've considered**\r\n\r\nCreate dedicated endpoint for each collection `/collections/my-collecton/metrics`\r\nbut feedback from DevOps on this idea was negative.\r\n\r\n**Additional context**\r\n\r\nIt might be beneficial to allow users to disable per-collection output. It is especially relevant if there are a lot of collections and metric response could become huge. But this is a nice-to-have requirement.\r\n\r\n\r\n---\r\n\r\nNote for contributors: Please consider this as tracking issue. If you think that it would be beneficial to split the task into multiple smaller PRs, please you are welcome to do so. Bounty will be rewarded for each PR independently\r\n\r\n",
                  "html_url": "https://github.com/qdrant/qdrant/issues/3322"
                },
                "type": "github"
              },
              "hash": "qdrant/qdrant#3322",
              "body": "**Is your feature request related to a problem? Please describe.**\r\n\r\nCurrently, all metrics in `/metrics` are global, meaning that its impossible to see differences per collection.\r\n\r\nIn addition to that, all our metrics should have per-collection granularity to allow better aggregation in Prometheus, including:\r\n\r\n- point/vector counts\r\n- REST/gRPC requests\r\n\r\n**Describe the solution you'd like**\r\n\r\nExample:\r\n```\r\ngrpc_responses_min_duration_seconds{endpoint=\"/qdrant.Points/Upsert\"} 0.000046\r\ngrpc_responses_min_duration_seconds{endpoint=\"/qdrant.Points/Upsert\",collection=\"my-collection\"} 0.000049\r\ngrpc_responses_min_duration_seconds{endpoint=\"/qdrant.Points/Upsert\",collection=\"my-collection-2\"} 0.000046\r\n```\r\n\r\n**Describe alternatives you've considered**\r\n\r\nCreate dedicated endpoint for each collection `/collections/my-collecton/metrics`\r\nbut feedback from DevOps on this idea was negative.\r\n\r\n**Additional context**\r\n\r\nIt might be beneficial to allow users to disable per-collection output. It is especially relevant if there are a lot of collections and metric response could become huge. But this is a nice-to-have requirement.\r\n\r\n\r\n---\r\n\r\nNote for contributors: Please consider this as tracking issue. If you think that it would be beneficial to split the task into multiple smaller PRs, please you are welcome to do so. Bounty will be rewarded for each PR independently\r\n\r\n",
              "url": "https://github.com/qdrant/qdrant/issues/3322",
              "tech": [],
              "repo_name": "qdrant",
              "repo_owner": "qdrant",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "highlight#8635",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "highlight",
              "id": "generated-highlight",
              "name": "Highlight",
              "description": "",
              "members": [],
              "display_name": "Highlight",
              "created_at": "2026-01-26T23:56:54.197Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/highlight?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "highlight",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-26T23:56:54.197Z",
            "created_at": "2026-01-26T23:56:54.197Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-highlight#8635",
              "status": "open",
              "type": "issue",
              "number": 8635,
              "title": "Update workspace and project settings to not use antd components",
              "source": {
                "data": {
                  "id": "source-highlight#8635",
                  "user": {
                    "login": "ccschmitz",
                    "id": 308182,
                    "node_id": "MDQ6VXNlcjMwODE4Mg==",
                    "avatar_url": "https://avatars.githubusercontent.com/u/308182?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/ccschmitz",
                    "html_url": "https://github.com/ccschmitz",
                    "followers_url": "https://api.github.com/users/ccschmitz/followers",
                    "following_url": "https://api.github.com/users/ccschmitz/following{/other_user}",
                    "gists_url": "https://api.github.com/users/ccschmitz/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/ccschmitz/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/ccschmitz/subscriptions",
                    "organizations_url": "https://api.github.com/users/ccschmitz/orgs",
                    "repos_url": "https://api.github.com/users/ccschmitz/repos",
                    "events_url": "https://api.github.com/users/ccschmitz/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/ccschmitz/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Update workspace and project settings to not use antd components",
                  "body": "Whoever implements should feel free to break this up into multiple tickets, perhaps one per page.",
                  "html_url": "https://github.com/highlight/highlight/issues/8635"
                },
                "type": "github"
              },
              "hash": "highlight/highlight#8635",
              "body": "Whoever implements should feel free to break this up into multiple tickets, perhaps one per page.",
              "url": "https://github.com/highlight/highlight/issues/8635",
              "tech": [],
              "repo_name": "highlight",
              "repo_owner": "highlight",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "highlight#8614",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "highlight",
              "id": "generated-highlight",
              "name": "Highlight",
              "description": "",
              "members": [],
              "display_name": "Highlight",
              "created_at": "2026-01-26T23:56:54.337Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/highlight?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "highlight",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-26T23:56:54.337Z",
            "created_at": "2026-01-26T23:56:54.337Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-highlight#8614",
              "status": "open",
              "type": "issue",
              "number": 8614,
              "title": "update design of integrations page",
              "source": {
                "data": {
                  "id": "source-highlight#8614",
                  "user": {
                    "login": "Vadman97",
                    "id": 1351531,
                    "node_id": "MDQ6VXNlcjEzNTE1MzE=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1351531?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/Vadman97",
                    "html_url": "https://github.com/Vadman97",
                    "followers_url": "https://api.github.com/users/Vadman97/followers",
                    "following_url": "https://api.github.com/users/Vadman97/following{/other_user}",
                    "gists_url": "https://api.github.com/users/Vadman97/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/Vadman97/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/Vadman97/subscriptions",
                    "organizations_url": "https://api.github.com/users/Vadman97/orgs",
                    "repos_url": "https://api.github.com/users/Vadman97/repos",
                    "events_url": "https://api.github.com/users/Vadman97/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/Vadman97/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "update design of integrations page",
                  "body": "+30 (697) 318-4144  https://github.com/highlight/highlight/issues/8635 https://github.com/highlight/highlight/pull/10304 https://github.com/highlight/highlight/pull/9716 https://github.com/highlight/h",
                  "html_url": "https://github.com/highlight/highlight/issues/8614"
                },
                "type": "github"
              },
              "hash": "highlight/highlight#8614",
              "body": "+30 (697) 318-4144  https://github.com/highlight/highlight/issues/8635 https://github.com/highlight/highlight/pull/10304 https://github.com/highlight/highlight/pull/9716 https://github.com/highlight/h",
              "url": "https://github.com/highlight/highlight/issues/8614",
              "tech": [],
              "repo_name": "highlight",
              "repo_owner": "highlight",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "highlight#8032",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "highlight",
              "id": "generated-highlight",
              "name": "Highlight",
              "description": "",
              "members": [],
              "display_name": "Highlight",
              "created_at": "2026-01-26T23:56:54.545Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/highlight?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "highlight",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-26T23:56:54.545Z",
            "created_at": "2026-01-26T23:56:54.545Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-highlight#8032",
              "status": "open",
              "type": "issue",
              "number": 8032,
              "title": "document sveltekit backend instrumentation",
              "source": {
                "data": {
                  "id": "source-highlight#8032",
                  "user": {
                    "login": "Vadman97",
                    "id": 1351531,
                    "node_id": "MDQ6VXNlcjEzNTE1MzE=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1351531?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/Vadman97",
                    "html_url": "https://github.com/Vadman97",
                    "followers_url": "https://api.github.com/users/Vadman97/followers",
                    "following_url": "https://api.github.com/users/Vadman97/following{/other_user}",
                    "gists_url": "https://api.github.com/users/Vadman97/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/Vadman97/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/Vadman97/subscriptions",
                    "organizations_url": "https://api.github.com/users/Vadman97/orgs",
                    "repos_url": "https://api.github.com/users/Vadman97/repos",
                    "events_url": "https://api.github.com/users/Vadman97/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/Vadman97/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "document sveltekit backend instrumentation",
                  "body": "see linear thread linked for starting point\n\n[https://discord.com/channels/1026884757667188757/1217184768001839225/1218189516041621524](https://discord.com/channels/1026884757667188757/1217184768001839225/1218189516041621524)",
                  "html_url": "https://github.com/highlight/highlight/issues/8032"
                },
                "type": "github"
              },
              "hash": "highlight/highlight#8032",
              "body": "see linear thread linked for starting point\n\n[https://discord.com/channels/1026884757667188757/1217184768001839225/1218189516041621524](https://discord.com/channels/1026884757667188757/1217184768001839225/1218189516041621524)",
              "url": "https://github.com/highlight/highlight/issues/8032",
              "tech": [],
              "repo_name": "highlight",
              "repo_owner": "highlight",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "highlight#6775",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "highlight",
              "id": "generated-highlight",
              "name": "Highlight",
              "description": "",
              "members": [],
              "display_name": "Highlight",
              "created_at": "2026-01-26T23:56:54.682Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/highlight?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "highlight",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-26T23:56:54.682Z",
            "created_at": "2026-01-26T23:56:54.682Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-highlight#6775",
              "status": "open",
              "type": "issue",
              "number": 6775,
              "title": "Performance of canvas snapshotting on Safari is poor",
              "source": {
                "data": {
                  "id": "source-highlight#6775",
                  "user": {
                    "login": "Pinpickle",
                    "id": 3238878,
                    "node_id": "MDQ6VXNlcjMyMzg4Nzg=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/3238878?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/Pinpickle",
                    "html_url": "https://github.com/Pinpickle",
                    "followers_url": "https://api.github.com/users/Pinpickle/followers",
                    "following_url": "https://api.github.com/users/Pinpickle/following{/other_user}",
                    "gists_url": "https://api.github.com/users/Pinpickle/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/Pinpickle/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/Pinpickle/subscriptions",
                    "organizations_url": "https://api.github.com/users/Pinpickle/orgs",
                    "repos_url": "https://api.github.com/users/Pinpickle/repos",
                    "events_url": "https://api.github.com/users/Pinpickle/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/Pinpickle/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Performance of canvas snapshotting on Safari is poor",
                  "body": "**Describe the bug**\r\n\r\nSnapshotting a canvas element in Safari 16.x takes a long time (>20ms). This leads to a frame drop every time the canvas is snapshotted.\r\n\r\n**To Reproduce**\r\n\r\nGo to the Codsandbox full-screen here https://jqgtld.csb.app/ \r\n\r\nLook at the \"Snapshot\" stat in the top right corner (or in the console). On my computer it is ~20ms on Safari 16.5. On Chrome, it is between 0 and 0.3ms.\r\n\r\nThe window size is 1057 x 734 (retina display, so double the dimensions for the canvas)\r\n\r\nHere's the codesandbox with the editor: https://codesandbox.io/s/dazzling-roentgen-jqgtld?file=/src/App.js\r\n\r\n**Expected behavior**\r\n\r\nOverhead for snapshotting to be near 0\r\n\r\n**Screenshots**\r\n\r\n## Safari\r\n\r\n![CleanShot 2023-10-02 at 15 23 03 png](https://github.com/highlight/highlight/assets/3238878/1bc6d193-ea1f-4fda-ae03-7ea9c9cf9143)\r\n\r\n## Chrome\r\n\r\n![CleanShot 2023-10-02 at 15 23 55 png](https://github.com/highlight/highlight/assets/3238878/7a3767f7-94a0-467b-9c23-bac305507d66)\r\n\r\n## iOS\r\n\r\n![CleanShot 2023-10-02 at 15 27 57 png](https://github.com/highlight/highlight/assets/3238878/664fc6c4-27b8-43ce-be71-b35b7553716f)\r\n\r\n\r\n**Additional context**\r\n\r\nEnvironment:\r\n\r\n```\r\nSystem:\r\n    OS: macOS 13.4\r\n    CPU: (8) arm64 Apple M1\r\n    Memory: 51.78 MB / 8.00 GB\r\nBrowsers:\r\n    Chrome: 117.0.5938.92\r\n    Safari: 16.5\r\n```\r\n\r\nProvided this also affects Safari 17 (I don't know if it does), this affects _every_ Safari-based browser (including everything on iOS). This performance drop means we had to disable canvas recording for Safari on our app which really limits its usefulness.\r\n\r\nThe larger the canvas, the longer the snapshot time, from what I can tell. Changing `canvasMaxSnapshotDimension` does not appear to make a difference. Safari doesn't even respect the options parameter for `createBitmapImage`: https://developer.mozilla.org/en-US/docs/Web/API/createImageBitmap\r\n\r\nI'm reasonably confident this comes from the call to `createBitmapImage` here:\r\n\r\nhttps://github.com/highlight/highlight/blob/ed2ea183d0d11781736e2001b01e24e55c33e8cb/frontend/src/__generated/rr/rr.js#L4266-L4269\r\n\r\nIt's supposed to be asynchronous but it looks like it is blocking in Safari. I wonder if there are other ways to get the image data out of a canvas? I understand there are efforts to use WebRTC for canvas recording? I imagine this could help.\r\n",
                  "html_url": "https://github.com/highlight/highlight/issues/6775"
                },
                "type": "github"
              },
              "hash": "highlight/highlight#6775",
              "body": "**Describe the bug**\r\n\r\nSnapshotting a canvas element in Safari 16.x takes a long time (>20ms). This leads to a frame drop every time the canvas is snapshotted.\r\n\r\n**To Reproduce**\r\n\r\nGo to the Codsandbox full-screen here https://jqgtld.csb.app/ \r\n\r\nLook at the \"Snapshot\" stat in the top right corner (or in the console). On my computer it is ~20ms on Safari 16.5. On Chrome, it is between 0 and 0.3ms.\r\n\r\nThe window size is 1057 x 734 (retina display, so double the dimensions for the canvas)\r\n\r\nHere's the codesandbox with the editor: https://codesandbox.io/s/dazzling-roentgen-jqgtld?file=/src/App.js\r\n\r\n**Expected behavior**\r\n\r\nOverhead for snapshotting to be near 0\r\n\r\n**Screenshots**\r\n\r\n## Safari\r\n\r\n![CleanShot 2023-10-02 at 15 23 03 png](https://github.com/highlight/highlight/assets/3238878/1bc6d193-ea1f-4fda-ae03-7ea9c9cf9143)\r\n\r\n## Chrome\r\n\r\n![CleanShot 2023-10-02 at 15 23 55 png](https://github.com/highlight/highlight/assets/3238878/7a3767f7-94a0-467b-9c23-bac305507d66)\r\n\r\n## iOS\r\n\r\n![CleanShot 2023-10-02 at 15 27 57 png](https://github.com/highlight/highlight/assets/3238878/664fc6c4-27b8-43ce-be71-b35b7553716f)\r\n\r\n\r\n**Additional context**\r\n\r\nEnvironment:\r\n\r\n```\r\nSystem:\r\n    OS: macOS 13.4\r\n    CPU: (8) arm64 Apple M1\r\n    Memory: 51.78 MB / 8.00 GB\r\nBrowsers:\r\n    Chrome: 117.0.5938.92\r\n    Safari: 16.5\r\n```\r\n\r\nProvided this also affects Safari 17 (I don't know if it does), this affects _every_ Safari-based browser (including everything on iOS). This performance drop means we had to disable canvas recording for Safari on our app which really limits its usefulness.\r\n\r\nThe larger the canvas, the longer the snapshot time, from what I can tell. Changing `canvasMaxSnapshotDimension` does not appear to make a difference. Safari doesn't even respect the options parameter for `createBitmapImage`: https://developer.mozilla.org/en-US/docs/Web/API/createImageBitmap\r\n\r\nI'm reasonably confident this comes from the call to `createBitmapImage` here:\r\n\r\nhttps://github.com/highlight/highlight/blob/ed2ea183d0d11781736e2001b01e24e55c33e8cb/frontend/src/__generated/rr/rr.js#L4266-L4269\r\n\r\nIt's supposed to be asynchronous but it looks like it is blocking in Safari. I wonder if there are other ways to get the image data out of a canvas? I understand there are efforts to use WebRTC for canvas recording? I imagine this could help.\r\n",
              "url": "https://github.com/highlight/highlight/issues/6775",
              "tech": [],
              "repo_name": "highlight",
              "repo_owner": "highlight",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "ZIO#462",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "ZIO",
              "id": "generated-ZIO",
              "name": "ZIO",
              "description": "",
              "members": [],
              "display_name": "ZIO",
              "created_at": "2026-01-26T23:56:54.616Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/ZIO?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "zio",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-26T23:56:54.616Z",
            "created_at": "2026-01-26T23:56:54.616Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-ZIO#462",
              "status": "open",
              "type": "issue",
              "number": 462,
              "title": "JSON Schema Support",
              "source": {
                "data": {
                  "id": "source-ZIO#462",
                  "user": {
                    "login": "jdegoes",
                    "id": 156745,
                    "node_id": "MDQ6VXNlcjE1Njc0NQ==",
                    "avatar_url": "https://avatars.githubusercontent.com/u/156745?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/jdegoes",
                    "html_url": "https://github.com/jdegoes",
                    "followers_url": "https://api.github.com/users/jdegoes/followers",
                    "following_url": "https://api.github.com/users/jdegoes/following{/other_user}",
                    "gists_url": "https://api.github.com/users/jdegoes/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/jdegoes/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/jdegoes/subscriptions",
                    "organizations_url": "https://api.github.com/users/jdegoes/orgs",
                    "repos_url": "https://api.github.com/users/jdegoes/repos",
                    "events_url": "https://api.github.com/users/jdegoes/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/jdegoes/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "JSON Schema Support",
                  "body": "# Add JSON Schema 2020-12 Support\n\n## Overview\n\nThis ticket adds first-class [JSON Schema 2020-12](https://json-schema.org/draft/2020-12/json-schema-core) support to ZIO Blocks, enabling:\n\n1. A `JsonSchema` ADT that precisely models the JSON Schema specification\n2. Bidirectional conversion between `Schema[A]` and `JsonSchema`\n3. Runtime validation of `Json` values against `JsonSchema`\n4. Schema extraction from `JsonBinaryCodec[A]` instances\n\nThis follows the established pattern used by `AvroBinaryCodec`, which exposes an `avroSchema: AvroSchema` field for each codec instance.\n\n---\n\n## Background: ZIO Blocks Architecture\n\nIf you're new to ZIO Blocks (ZIO Schema 2), here's the essential context:\n\n### Core Types\n\n| Type | Purpose |\n|------|---------|\n| `Schema[A]` | Reified structure of Scala type `A` with construction/deconstruction capabilities |\n| `Reflect[F, A]` | The underlying ADT representing type structure. `Schema[A]` wraps `Reflect[Binding, A]` |\n| `DynamicValue` | A semi-structured representation (superset of JSON) that any `Schema[A]` can convert to/from |\n| `Json` | The JSON AST in `zio.blocks.schema.json` |\n| `JsonBinaryCodec[A]` | Typeclass for JSON serialization, derived from `Schema[A]` via `JsonBinaryCodecDeriver` |\n\n### How Derivation Works\n```scala\ncase class Person(name: String, age: Int)\nobject Person {\n  implicit val schema: Schema[Person] = Schema.derived\n}\n\n// Derive a JSON codec from the schema:\nval codec: JsonBinaryCodec[Person] = Schema[Person].derive(JsonFormat.deriver)\n\n// Or use encode/decode directly (caches the codec):\nSchema[Person].encode(JsonFormat)(buffer)(person)\nSchema[Person].decode(JsonFormat)(buffer)\n```\n\n### Key Insight: DynamicValue as the Bridge\n\n`Schema[A]` can convert any `A` to `DynamicValue` and back. Since `DynamicValue` is structurally similar to JSON, and `Json.fromDynamicValue` / `Json.toDynamicValue` exist, we can create `Schema[Json]` by wrapping `Schema[DynamicValue]`.\n\nThis is how `Schema.fromJsonSchema` will work: it wraps `Schema[DynamicValue]` with validation logic that checks the `JsonSchema` constraints.\n\n### Metadata That Maps to JSON Schema\n\n| ZIO Blocks Type | JSON Schema Equivalent |\n|-----------------|------------------------|\n| `TypeName[A]` | Can be stored in `$id` or custom extension for round-trip |\n| `Doc` | `title` / `description` |\n| `Validation[A]` | `minimum`, `maximum`, `minLength`, `maxLength`, `pattern`, etc. |\n| `Modifier.rename` | Affects property names |\n| `Modifier.alias` | Could map to extension for alternative names |\n| `Modifier.transient` | Field excluded from schema |\n| `Modifier.config` | Extensible metadata (e.g., `\"json-schema.format\" -> \"email\"`) |\n| `DiscriminatorKind` | Affects `oneOf`/`anyOf` structure and `discriminator` keyword |\n| `NameMapper` | Applied to field/case names during schema generation |\n\n### Reference: AvroBinaryCodec Pattern\n\nLook at `AvroBinaryCodec` for the established pattern. Each codec instance has:\n```scala\nabstract class AvroBinaryCodec[A](...) extends BinaryCodec[A] {\n  def avroSchema: AvroSchema  // <-- We want the equivalent for JSON Schema\n  // ...\n}\n```\n\nThe `AvroFormat` deriver constructs the `avroSchema` for each primitive, record, variant, sequence, map, and wrapper type.\n\n---\n\n## Requirements\n\n### 1. Create `JsonSchema` ADT\n\nCreate a new sealed trait `JsonSchema` in `zio.blocks.schema.json` that models JSON Schema 2020-12.\n\n**Location:** `schema/shared/src/main/scala/zio/blocks/schema/json/JsonSchema.scala` (and related files as needed)\n\nThe ADT must support:\n- Boolean schemas (`true` accepts all, `false` rejects all)\n- Full schema objects with all standard vocabularies (core, applicator, validation, format, content, metadata)\n- Round-trip JSON serialization (`toJson` / `fromJson`)\n- Validation (`check` method returning accumulated errors)\n- Combinators (`&&` for allOf, `||` for anyOf, `!` for not)\n\nSee the **JsonSchema Sketch** section below for a starting point.\n\n### 2. Add `toJsonSchema` to `JsonBinaryCodec[A]`\n\n**Location:** `schema/shared/src/main/scala/zio/blocks/schema/json/JsonBinaryCodec.scala`\n```scala\nabstract class JsonBinaryCodec[A](...) extends BinaryCodec[A] {\n  // ... existing methods ...\n  \n  /** Returns the JSON Schema describing values this codec encodes/decodes. */\n  def toJsonSchema: JsonSchema\n}\n```\n\nThen implement this in `JsonBinaryCodecDeriver` for each derivation case (primitives, records, variants, sequences, maps, wrappers, dynamic).\n\n**Important considerations:**\n- The schema must reflect the codec's configuration: `fieldNameMapper`, `caseNameMapper`, `discriminatorKind`, etc.\n- `Modifier.rename` and `Modifier.alias` on fields/cases affect property names\n- `Modifier.transient` fields should be excluded\n- `Modifier.config` with keys like `\"json-schema.format\"` should be respected\n- `Doc` on fields/types should map to `description`\n- `Validation[A]` on primitives should map to validation keywords\n\n### 3. Add `toJsonSchema` to `Schema[A]`\n\n**Location:** `schema/shared/src/main/scala/zio/blocks/schema/Schema.scala`\n```scala\nfinal case class Schema[A](reflect: Reflect.Bound[A]) {\n  // ... existing methods ...\n  \n  /** \n   * Convert this schema to a JsonSchema representation.\n   * This always succeedsevery Schema structure has a JsonSchema equivalent.\n   */\n  def toJsonSchema: JsonSchema\n}\n```\n\nThis can be implemented by deriving a `JsonBinaryCodec[A]` and calling its `toJsonSchema`, or by directly traversing the `Reflect` structure. The codec-based approach is recommended because it ensures the schema matches actual serialization behavior.\n\n### 4. Add `Schema.fromJsonSchema`\n\n**Location:** `schema/shared/src/main/scala/zio/blocks/schema/Schema.scala`\n```scala\nobject Schema extends SchemaCompanionVersionSpecific {\n  // ... existing methods ...\n  \n  /**\n   * Construct a Schema[Json] from a JsonSchema.\n   * Values are validated against the JsonSchema during construction.\n   */\n  def fromJsonSchema(jsonSchema: JsonSchema): Schema[Json]\n}\n```\n\n**Implementation approach:**\n```scala\ndef fromJsonSchema(jsonSchema: JsonSchema): Schema[Json] = {\n  Schema[DynamicValue].wrap[Json](\n    wrap = { dv =>\n      val json = Json.fromDynamicValue(dv)\n      jsonSchema.check(json) match {\n        case None        => Right(json)\n        case Some(error) => Left(error.message)\n      }\n    },\n    unwrap = _.toDynamicValue\n  )\n}\n```\n\nThis uses the existing `Schema.wrap` mechanism which creates a `Reflect.Wrapper` with validation on construction.\n\n### 5. Add `Schema[Json]` Instance\n\n**Location:** `schema/shared/src/main/scala/zio/blocks/schema/Schema.scala`\n```scala\nobject Schema extends SchemaCompanionVersionSpecific {\n  // ... existing methods ...\n  \n  /** Schema for Json values (no validation, accepts any Json). */\n  implicit val json: Schema[Json] = Schema[DynamicValue].wrapTotal[Json](\n    wrap = Json.fromDynamicValue,\n    unwrap = _.toDynamicValue\n  )\n}\n```\n\n### 6. Update `Json.check` and `Json.conforms`\n\n**Location:** `schema/shared/src/main/scala/zio/blocks/schema/json/Json.scala`\n\nThe current stubs are:\n```scala\ndef check(schema: Json): Either[JsonError, Unit] = ???\ndef conforms(schema: Json): Boolean = ???\n```\n\nChange to:\n```scala\n/** \n * Validates this JSON value against a JsonSchema.\n * Returns None if valid, Some(error) with accumulated failures if invalid.\n */\ndef check(schema: JsonSchema): Option[SchemaError] = schema.check(this)\n\n/** Returns true if this JSON value conforms to the schema. */\ndef conforms(schema: JsonSchema): Boolean = check(schema).isEmpty\n```\n\nNote: `SchemaError` already supports error accumulation via its `::[SchemaError.Single]` structure.\n\n### 7. Add `Schema[JsonSchema]` Instance\n\nThe `JsonSchema` type itself should have a `Schema` instance so it can be serialized, diffed, patched, etc. using ZIO Blocks machinery.\n```scala\nobject JsonSchema {\n  implicit val schema: Schema[JsonSchema] = Schema.derived // or manual construction\n}\n```\n\nThis may require careful handling of the recursive structure.\n\n---\n\n## JsonSchema Sketch\n\nBelow is a sketch of the `JsonSchema` ADT. This is a **starting point, not a final specification**. Use your judgment to refine it based on the JSON Schema 2020-12 spec and practical implementation needs.\n```scala\npackage zio.blocks.schema.json\n\nimport java.net.URI\n\n// =============================================================================\n// Newtypes for Precision\n// =============================================================================\n\n/** Non-negative integer (>= 0). Used for minLength, maxLength, minItems, etc. */\nfinal case class NonNegativeInt private (value: Int) extends AnyVal\nobject NonNegativeInt {\n  def apply(n: Int): Option[NonNegativeInt] =\n    if (n >= 0) Some(new NonNegativeInt(n)) else None\n  def unsafe(n: Int): NonNegativeInt = new NonNegativeInt(n)\n  \n  implicit val schema: Schema[NonNegativeInt] = ???\n}\n\n/** Strictly positive number (> 0). Used for multipleOf. */\nfinal case class PositiveNumber private (value: BigDecimal) extends AnyVal\nobject PositiveNumber {\n  def apply(n: BigDecimal): Option[PositiveNumber] =\n    if (n > 0) Some(new PositiveNumber(n)) else None\n  def unsafe(n: BigDecimal): PositiveNumber = new PositiveNumber(n)\n  \n  implicit val schema: Schema[PositiveNumber] = ???\n}\n\n/** ECMA-262 regular expression pattern. */\nfinal case class RegexPattern(value: String) extends AnyVal\nobject RegexPattern {\n  implicit val schema: Schema[RegexPattern] = ???\n}\n\n/** URI-Reference per RFC 3986 (may be relative). */\nfinal case class UriReference(value: String) extends AnyVal\nobject UriReference {\n  implicit val schema: Schema[UriReference] = ???\n}\n\n/** Anchor name (plain name fragment without #). */\nfinal case class Anchor(value: String) extends AnyVal\nobject Anchor {\n  implicit val schema: Schema[Anchor] = ???\n}\n\n// =============================================================================\n// JSON Primitive Type Enumeration\n// =============================================================================\n\nsealed trait JsonType extends Product with Serializable {\n  def toJsonString: String = this match {\n    case JsonType.Null    => \"null\"\n    case JsonType.Boolean => \"boolean\"\n    case JsonType.String  => \"string\"\n    case JsonType.Number  => \"number\"\n    case JsonType.Integer => \"integer\"\n    case JsonType.Array   => \"array\"\n    case JsonType.Object  => \"object\"\n  }\n}\nobject JsonType {\n  case object Null    extends JsonType\n  case object Boolean extends JsonType\n  case object String  extends JsonType\n  case object Number  extends JsonType\n  case object Integer extends JsonType\n  case object Array   extends JsonType\n  case object Object  extends JsonType\n  \n  def fromString(s: String): Option[JsonType] = s match {\n    case \"null\"    => Some(Null)\n    case \"boolean\" => Some(Boolean)\n    case \"string\"  => Some(String)\n    case \"number\"  => Some(Number)\n    case \"integer\" => Some(Integer)\n    case \"array\"   => Some(Array)\n    case \"object\"  => Some(Object)\n    case _         => None\n  }\n  \n  implicit val schema: Schema[JsonType] = ???\n}\n\n// =============================================================================\n// Type Keyword: Single Type or Array of Types\n// =============================================================================\n\nsealed trait SchemaType extends Product with Serializable {\n  def toJson: Json = this match {\n    case SchemaType.Single(t)   => Json.Str(t.toJsonString)\n    case SchemaType.Union(ts)   => Json.Arr(ts.map(t => Json.Str(t.toJsonString)): _*)\n  }\n}\nobject SchemaType {\n  final case class Single(value: JsonType)     extends SchemaType\n  final case class Union(values: ::[JsonType]) extends SchemaType\n  \n  def fromJson(json: Json): Either[SchemaError, SchemaType] = ???\n  \n  implicit val schema: Schema[SchemaType] = ???\n}\n\n// =============================================================================\n// JSON Schema 2020-12 ADT\n// =============================================================================\n\nsealed trait JsonSchema extends Product with Serializable {\n  \n  /** Serialize this schema to its canonical JSON representation. */\n  def toJson: Json\n  \n  /** \n   * Validate a JSON value against this schema.\n   * Returns None if valid, Some(error) with accumulated failures if invalid.\n   */\n  def check(json: Json): Option[SchemaError]\n  \n  /** Returns true if the JSON value conforms to this schema. */\n  def conforms(json: Json): Boolean = check(json).isEmpty\n  \n  // ===========================================================================\n  // Combinators\n  // ===========================================================================\n  \n  /** Combine with another schema using allOf. */\n  def &&(that: JsonSchema): JsonSchema\n  \n  /** Combine with another schema using anyOf. */\n  def ||(that: JsonSchema): JsonSchema\n  \n  /** Negate this schema. */\n  def unary_! : JsonSchema = JsonSchema.SchemaObject(not = Some(this))\n}\n\nobject JsonSchema {\n  \n  // ===========================================================================\n  // Parsing\n  // ===========================================================================\n  \n  /** Parse a JsonSchema from its JSON representation. */\n  def fromJson(json: Json): Either[SchemaError, JsonSchema]\n  \n  /** Parse a JsonSchema from a JSON string. */\n  def parse(jsonString: String): Either[SchemaError, JsonSchema]\n  \n  // ===========================================================================\n  // Schema & Codec instances\n  // ===========================================================================\n  \n  implicit val schema: Schema[JsonSchema] = ???\n  implicit val jsonBinaryCodec: JsonBinaryCodec[JsonSchema] = ???\n  \n  // ===========================================================================\n  // Boolean Schemas\n  // ===========================================================================\n\n  /** Schema that accepts all instances. Equivalent to `{}`. */\n  case object True extends JsonSchema {\n    override def toJson: Json = Json.Bool(true)\n    override def check(json: Json): Option[SchemaError] = None\n  }\n\n  /** Schema that rejects all instances. Equivalent to `{\"not\": {}}`. */\n  case object False extends JsonSchema {\n    override def toJson: Json = Json.Bool(false)\n    override def check(json: Json): Option[SchemaError] = \n      Some(SchemaError.expectationMismatch(Nil, \"Schema rejects all values\"))\n  }\n\n  // ===========================================================================\n  // Schema Object\n  // ===========================================================================\n  \n  /** \n   * A schema object containing keywords from JSON Schema 2020-12.\n   * All fields are optional; an empty SchemaObject is equivalent to True.\n   */\n  final case class SchemaObject(\n    // =========================================================================\n    // Core Vocabulary\n    // =========================================================================\n    \n    $id: Option[UriReference] = None,\n    $schema: Option[URI] = None,\n    $anchor: Option[Anchor] = None,\n    $dynamicAnchor: Option[Anchor] = None,\n    $ref: Option[UriReference] = None,\n    $dynamicRef: Option[UriReference] = None,\n    $vocabulary: Option[Map[URI, Boolean]] = None,\n    $defs: Option[Map[String, JsonSchema]] = None,\n    $comment: Option[String] = None,\n\n    // =========================================================================\n    // Applicator Vocabulary (Composition)\n    // =========================================================================\n    \n    allOf: Option[::[JsonSchema]] = None,\n    anyOf: Option[::[JsonSchema]] = None,\n    oneOf: Option[::[JsonSchema]] = None,\n    not: Option[JsonSchema] = None,\n\n    // =========================================================================\n    // Applicator Vocabulary (Conditional)\n    // =========================================================================\n    \n    `if`: Option[JsonSchema] = None,\n    `then`: Option[JsonSchema] = None,\n    `else`: Option[JsonSchema] = None,\n\n    // =========================================================================\n    // Applicator Vocabulary (Object)\n    // =========================================================================\n    \n    properties: Option[Map[String, JsonSchema]] = None,\n    patternProperties: Option[Map[RegexPattern, JsonSchema]] = None,\n    additionalProperties: Option[JsonSchema] = None,\n    propertyNames: Option[JsonSchema] = None,\n    dependentSchemas: Option[Map[String, JsonSchema]] = None,\n\n    // =========================================================================\n    // Applicator Vocabulary (Array)\n    // =========================================================================\n    \n    prefixItems: Option[::[JsonSchema]] = None,\n    items: Option[JsonSchema] = None,\n    contains: Option[JsonSchema] = None,\n\n    // =========================================================================\n    // Unevaluated Vocabulary\n    // =========================================================================\n    \n    unevaluatedProperties: Option[JsonSchema] = None,\n    unevaluatedItems: Option[JsonSchema] = None,\n\n    // =========================================================================\n    // Validation Vocabulary (Type)\n    // =========================================================================\n    \n    `type`: Option[SchemaType] = None,\n    `enum`: Option[::[Json]] = None,\n    const: Option[Json] = None,\n\n    // =========================================================================\n    // Validation Vocabulary (Numeric)\n    // =========================================================================\n    \n    multipleOf: Option[PositiveNumber] = None,\n    maximum: Option[BigDecimal] = None,\n    exclusiveMaximum: Option[BigDecimal] = None,\n    minimum: Option[BigDecimal] = None,\n    exclusiveMinimum: Option[BigDecimal] = None,\n\n    // =========================================================================\n    // Validation Vocabulary (String)\n    // =========================================================================\n    \n    minLength: Option[NonNegativeInt] = None,\n    maxLength: Option[NonNegativeInt] = None,\n    pattern: Option[RegexPattern] = None,\n\n    // =========================================================================\n    // Validation Vocabulary (Array)\n    // =========================================================================\n    \n    minItems: Option[NonNegativeInt] = None,\n    maxItems: Option[NonNegativeInt] = None,\n    uniqueItems: Option[Boolean] = None,\n    minContains: Option[NonNegativeInt] = None,\n    maxContains: Option[NonNegativeInt] = None,\n\n    // =========================================================================\n    // Validation Vocabulary (Object)\n    // =========================================================================\n    \n    minProperties: Option[NonNegativeInt] = None,\n    maxProperties: Option[NonNegativeInt] = None,\n    required: Option[Set[String]] = None,\n    dependentRequired: Option[Map[String, Set[String]]] = None,\n\n    // =========================================================================\n    // Format Vocabulary\n    // =========================================================================\n    \n    format: Option[String] = None,\n\n    // =========================================================================\n    // Content Vocabulary\n    // =========================================================================\n    \n    contentEncoding: Option[String] = None,\n    contentMediaType: Option[String] = None,\n    contentSchema: Option[JsonSchema] = None,\n\n    // =========================================================================\n    // Meta-Data Vocabulary\n    // =========================================================================\n    \n    title: Option[String] = None,\n    description: Option[String] = None,\n    default: Option[Json] = None,\n    deprecated: Option[Boolean] = None,\n    readOnly: Option[Boolean] = None,\n    writeOnly: Option[Boolean] = None,\n    examples: Option[::[Json]] = None,\n\n    // =========================================================================\n    // Extensions\n    // =========================================================================\n    \n    /** Unrecognized keywords for round-trip fidelity and vendor extensions. */\n    extensions: Map[String, Json] = Map.empty\n\n  ) extends JsonSchema {\n    override def toJson: Json = ???\n    override def check(json: Json): Option[SchemaError] = ???\n  }\n\n  object SchemaObject {\n    val empty: SchemaObject = SchemaObject()\n  }\n  \n  // ===========================================================================\n  // Smart Constructors\n  // ===========================================================================\n  \n  def ofType(t: JsonType): JsonSchema = \n    SchemaObject(`type` = Some(SchemaType.Single(t)))\n  \n  def string(\n    minLength: Option[NonNegativeInt] = None,\n    maxLength: Option[NonNegativeInt] = None,\n    pattern: Option[RegexPattern] = None,\n    format: Option[String] = None\n  ): JsonSchema = SchemaObject(\n    `type` = Some(SchemaType.Single(JsonType.String)),\n    minLength = minLength,\n    maxLength = maxLength,\n    pattern = pattern,\n    format = format\n  )\n  \n  def number(\n    minimum: Option[BigDecimal] = None,\n    maximum: Option[BigDecimal] = None,\n    exclusiveMinimum: Option[BigDecimal] = None,\n    exclusiveMaximum: Option[BigDecimal] = None,\n    multipleOf: Option[PositiveNumber] = None\n  ): JsonSchema = SchemaObject(\n    `type` = Some(SchemaType.Single(JsonType.Number)),\n    minimum = minimum,\n    maximum = maximum,\n    exclusiveMinimum = exclusiveMinimum,\n    exclusiveMaximum = exclusiveMaximum,\n    multipleOf = multipleOf\n  )\n  \n  def integer(\n    minimum: Option[BigDecimal] = None,\n    maximum: Option[BigDecimal] = None\n  ): JsonSchema = SchemaObject(\n    `type` = Some(SchemaType.Single(JsonType.Integer)),\n    minimum = minimum,\n    maximum = maximum\n  )\n  \n  def array(\n    items: Option[JsonSchema] = None,\n    minItems: Option[NonNegativeInt] = None,\n    maxItems: Option[NonNegativeInt] = None,\n    uniqueItems: Option[Boolean] = None\n  ): JsonSchema = SchemaObject(\n    `type` = Some(SchemaType.Single(JsonType.Array)),\n    items = items,\n    minItems = minItems,\n    maxItems = maxItems,\n    uniqueItems = uniqueItems\n  )\n  \n  def `object`(\n    properties: Option[Map[String, JsonSchema]] = None,\n    required: Option[Set[String]] = None,\n    additionalProperties: Option[JsonSchema] = None\n  ): JsonSchema = SchemaObject(\n    `type` = Some(SchemaType.Single(JsonType.Object)),\n    properties = properties,\n    required = required,\n    additionalProperties = additionalProperties\n  )\n  \n  def enumOf(values: ::[Json]): JsonSchema = SchemaObject(`enum` = Some(values))\n  \n  def constOf(value: Json): JsonSchema = SchemaObject(const = Some(value))\n  \n  def ref(uri: UriReference): JsonSchema = SchemaObject($ref = Some(uri))\n  \n  val `null`: JsonSchema = ofType(JsonType.Null)\n  val boolean: JsonSchema = ofType(JsonType.Boolean)\n}\n```\n\n---\n\n## Validation to JsonSchema Mapping\n\nThe `Validation[A]` type in ZIO Blocks maps to JSON Schema validation keywords. Implement this mapping when generating schemas from `PrimitiveType`:\n\n| `Validation[A]` | JSON Schema Keywords |\n|-----------------|---------------------|\n| `Validation.None` | (no constraints) |\n| `Validation.Numeric.Positive` | `exclusiveMinimum: 0` |\n| `Validation.Numeric.NonNegative` | `minimum: 0` |\n| `Validation.Numeric.Negative` | `exclusiveMaximum: 0` |\n| `Validation.Numeric.NonPositive` | `maximum: 0` |\n| `Validation.Numeric.Range(min, max)` | `minimum` / `maximum` |\n| `Validation.Numeric.Set(values)` | `enum: [...]` |\n| `Validation.String.NonEmpty` | `minLength: 1` |\n| `Validation.String.Empty` | `maxLength: 0` |\n| `Validation.String.Length(min, max)` | `minLength` / `maxLength` |\n| `Validation.String.Pattern(regex)` | `pattern` |\n\n---\n\n## Modifier.config Keys\n\nSupport these `Modifier.config` keys when generating JSON Schema:\n\n| Key | Effect |\n|-----|--------|\n| `json-schema.format` | Sets `format` keyword (e.g., `\"email\"`, `\"date-time\"`, `\"uuid\"`) |\n| `json-schema.deprecated` | Sets `deprecated: true` |\n| `json-schema.title` | Overrides `title` |\n| `json-schema.description` | Overrides `description` |\n\n---\n\n## Files to Create or Modify\n\n| File | Action |\n|------|--------|\n| `schema/shared/src/main/scala/zio/blocks/schema/json/JsonSchema.scala` | **CREATE** - Main ADT |\n| `schema/shared/src/main/scala/zio/blocks/schema/json/JsonBinaryCodec.scala` | **MODIFY** - Add `def toJsonSchema: JsonSchema` |\n| `schema/shared/src/main/scala/zio/blocks/schema/json/JsonBinaryCodecDeriver.scala` | **MODIFY** - Implement `toJsonSchema` for all derivation cases |\n| `schema/shared/src/main/scala/zio/blocks/schema/Schema.scala` | **MODIFY** - Add `toJsonSchema`, `fromJsonSchema`, `Schema[Json]` |\n| `schema/shared/src/main/scala/zio/blocks/schema/json/Json.scala` | **MODIFY** - Update `check`/`conforms` signatures |\n\n---\n\n## Required Test Suites\n\nAll tests should use ZIO Test and follow the existing test patterns in the codebase.\n\n### 1. `JsonSchemaSpec`  Core ADT Tests\n\n**Location:** `schema/shared/src/test/scala/zio/blocks/schema/json/JsonSchemaSpec.scala`\n\nMust test:\n\n- **Boolean schemas**: `True` accepts all JSON, `False` rejects all JSON\n- **Type validation**: Each `JsonType` validates correctly (null, boolean, string, number, integer, array, object)\n- **Type unions**: `type: [\"string\", \"number\"]` accepts either\n- **Numeric constraints**: `minimum`, `maximum`, `exclusiveMinimum`, `exclusiveMaximum`, `multipleOf`\n- **String constraints**: `minLength`, `maxLength`, `pattern`\n- **Array constraints**: `minItems`, `maxItems`, `uniqueItems`, `prefixItems`, `items`, `contains`, `minContains`, `maxContains`\n- **Object constraints**: `properties`, `required`, `additionalProperties`, `propertyNames`, `minProperties`, `maxProperties`, `patternProperties`, `dependentRequired`, `dependentSchemas`\n- **Composition**: `allOf`, `anyOf`, `oneOf`, `not`\n- **Conditional**: `if`/`then`/`else`\n- **Enum and const**: exact value matching\n- **Error accumulation**: Multiple validation failures are collected, not just the first\n\n### 2. `JsonSchemaRoundTripSpec`  Serialization Tests\n\n**Location:** `schema/shared/src/test/scala/zio/blocks/schema/json/JsonSchemaRoundTripSpec.scala`\n\nMust test:\n\n- **`toJson` / `fromJson` round-trip**: For every `JsonSchema`, `JsonSchema.fromJson(schema.toJson) == Right(schema)`\n- **Parse canonical examples**: Parse schemas from the JSON Schema test suite or spec examples\n- **Boolean schema serialization**: `true` and `false` as JSON booleans\n- **Empty object equivalence**: `{}` parses to `SchemaObject.empty` which is equivalent to `True`\n- **Extension preservation**: Unknown keywords in `extensions` survive round-trip\n- **All keyword serialization**: Every field in `SchemaObject` serializes to the correct JSON keyword\n\n### 3. `JsonBinaryCodecToJsonSchemaSpec`  Codec Schema Extraction Tests\n\n**Location:** `schema/shared/src/test/scala/zio/blocks/schema/json/JsonBinaryCodecToJsonSchemaSpec.scala`\n\nMust test:\n\n- **Primitives**: Each primitive type produces correct JSON Schema (`String`  `type: \"string\"`, `Int`  `type: \"integer\"`, etc.)\n- **Temporal types**: `Instant`, `LocalDate`, etc. produce `type: \"string\"` with appropriate `format`\n- **Records**: Case classes produce `type: \"object\"` with `properties` and `required`\n- **Variants (sealed traits)**: Produce `oneOf` or discriminator-based schema depending on `DiscriminatorKind`\n- **Enumerations**: Sealed traits with all case objects produce `enum`\n- **Option fields**: Non-required properties or union with `null`\n- **Collections**: `List[A]`, `Set[A]`, `Vector[A]` produce `type: \"array\"` with `items`\n- **Maps**: `Map[String, V]` produces `type: \"object\"` with `additionalProperties`\n- **Nested structures**: Deeply nested case classes produce correct nested schemas\n- **Field renaming**: `Modifier.rename` and `fieldNameMapper` affect property names\n- **Transient fields**: `Modifier.transient` fields are excluded from schema\n- **Documentation**: `Doc` maps to `description`\n- **Validation constraints**: `Validation[A]` on primitives maps to validation keywords\n- **Config modifiers**: `Modifier.config(\"json-schema.format\", \"email\")` sets `format`\n\n### 4. `SchemaToJsonSchemaSpec`  Schema Conversion Tests\n\n**Location:** `schema/shared/src/test/scala/zio/blocks/schema/json/SchemaToJsonSchemaSpec.scala`\n\nMust test:\n\n- **All built-in schemas**: `Schema[Int]`, `Schema[String]`, `Schema[Boolean]`, etc.\n- **Derived schemas**: `Schema.derived` for case classes and sealed traits\n- **Consistency with codec**: `Schema[A].toJsonSchema` should match `Schema[A].derive(JsonFormat.deriver).toJsonSchema`\n- **Recursive types**: Self-referential case classes produce schemas with `$ref` or equivalent\n\n### 5. `SchemaFromJsonSchemaSpec`  Schema Construction Tests\n\n**Location:** `schema/shared/src/test/scala/zio/blocks/schema/json/SchemaFromJsonSchemaSpec.scala`\n\nMust test:\n\n- **Valid JSON passes**: `Schema.fromJsonSchema(schema)` accepts conforming JSON\n- **Invalid JSON fails**: Non-conforming JSON fails with descriptive error\n- **Error messages**: Validation errors include path information\n- **Round-trip through DynamicValue**: JSON  DynamicValue  JSON preserves structure\n- **Encode/decode works**: The resulting `Schema[Json]` can be used with `JsonFormat` for encoding/decoding\n\n### 6. `JsonCheckSpec`  Json.check/conforms Tests\n\n**Location:** `schema/shared/src/test/scala/zio/blocks/schema/json/JsonCheckSpec.scala`\n\nMust test:\n\n- **Method signatures**: `check` returns `Option[SchemaError]`, `conforms` returns `Boolean`\n- **Delegation**: These methods delegate to `JsonSchema.check`\n- **All validation scenarios**: Mirror tests from `JsonSchemaSpec` but called via `Json` methods\n\n### 7. `JsonSchemaCombinatorSpec`  Combinator Tests\n\n**Location:** `schema/shared/src/test/scala/zio/blocks/schema/json/JsonSchemaCombinatorSpec.scala`\n\nMust test:\n\n- **`&&` (allOf)**: `schema1 && schema2` validates if both pass\n- **`||` (anyOf)**: `schema1 || schema2` validates if either passes\n- **`!` (not)**: `!schema` validates if schema fails\n- **Associativity**: `(a && b) && c` equivalent to `a && (b && c)`\n- **Commutativity**: `a && b` equivalent to `b && a` (for validation purposes)\n- **De Morgan's laws**: `!(a && b)` equivalent to `!a || !b`\n\n---\n\n## Acceptance Criteria\n\n- [ ] All test suites pass\n- [ ] `JsonSchema` ADT covers JSON Schema 2020-12 core, applicator, validation, format, content, and metadata vocabularies\n- [ ] `JsonSchema#toJson` produces valid JSON Schema documents\n- [ ] `JsonSchema.fromJson` parses valid JSON Schema documents\n- [ ] `JsonSchema#check` validates JSON values with accumulated errors\n- [ ] `JsonBinaryCodec[A].toJsonSchema` produces accurate schemas reflecting codec configuration\n- [ ] `Schema[A].toJsonSchema` works for all derivable types\n- [ ] `Schema.fromJsonSchema` produces a working `Schema[Json]` with validation\n- [ ] `Json#check` and `Json#conforms` work with the new `JsonSchema` parameter type\n- [ ] `Validation[A]` constraints map to appropriate JSON Schema keywords\n- [ ] `Doc` maps to `description`\n- [ ] `Modifier.rename`, `Modifier.transient`, and `Modifier.config` are respected\n- [ ] Code follows existing project style and conventions\n- [ ] No new dependencies are introduced (use existing `Json` type, not a third-party JSON library)\n\n---\n\n## Notes for Implementers\n\n1. **Start with the ADT**: Get `JsonSchema` working with `toJson`/`fromJson`/`check` before integrating with `JsonBinaryCodec`.\n\n2. **Study the Avro implementation**: `AvroFormat` and `AvroBinaryCodec` show the established pattern for schema extraction from codecs.\n\n3. **Validation is the hard part**: The `check` method needs to correctly implement JSON Schema validation semantics, including `unevaluatedProperties`/`unevaluatedItems` which require tracking which properties/items were \"evaluated\" by other keywords.\n\n4. **Error accumulation**: Use `SchemaError` which already supports multiple errors. Include path information using `DynamicOptic`.\n\n5. **`$ref` resolution**: For this initial implementation, `$ref` within the same document (using `$defs`) should work. Cross-document references are out of scope.\n\n6. **Format validation**: The `format` keyword is an annotation by default in 2020-12. Implement validation for common formats (`date-time`, `date`, `time`, `email`, `uuid`, `uri`) but make it non-fatal or configurable.\n\n7. **Test against the official test suite**: The [JSON Schema Test Suite](https://github.com/json-schema-org/JSON-Schema-Test-Suite) provides comprehensive test cases. Consider using it to validate your implementation.",
                  "html_url": "https://github.com/zio/zio-blocks/issues/462"
                },
                "type": "github"
              },
              "hash": "zio/zio-blocks#462",
              "body": "# Add JSON Schema 2020-12 Support\n\n## Overview\n\nThis ticket adds first-class [JSON Schema 2020-12](https://json-schema.org/draft/2020-12/json-schema-core) support to ZIO Blocks, enabling:\n\n1. A `JsonSchema` ADT that precisely models the JSON Schema specification\n2. Bidirectional conversion between `Schema[A]` and `JsonSchema`\n3. Runtime validation of `Json` values against `JsonSchema`\n4. Schema extraction from `JsonBinaryCodec[A]` instances\n\nThis follows the established pattern used by `AvroBinaryCodec`, which exposes an `avroSchema: AvroSchema` field for each codec instance.\n\n---\n\n## Background: ZIO Blocks Architecture\n\nIf you're new to ZIO Blocks (ZIO Schema 2), here's the essential context:\n\n### Core Types\n\n| Type | Purpose |\n|------|---------|\n| `Schema[A]` | Reified structure of Scala type `A` with construction/deconstruction capabilities |\n| `Reflect[F, A]` | The underlying ADT representing type structure. `Schema[A]` wraps `Reflect[Binding, A]` |\n| `DynamicValue` | A semi-structured representation (superset of JSON) that any `Schema[A]` can convert to/from |\n| `Json` | The JSON AST in `zio.blocks.schema.json` |\n| `JsonBinaryCodec[A]` | Typeclass for JSON serialization, derived from `Schema[A]` via `JsonBinaryCodecDeriver` |\n\n### How Derivation Works\n```scala\ncase class Person(name: String, age: Int)\nobject Person {\n  implicit val schema: Schema[Person] = Schema.derived\n}\n\n// Derive a JSON codec from the schema:\nval codec: JsonBinaryCodec[Person] = Schema[Person].derive(JsonFormat.deriver)\n\n// Or use encode/decode directly (caches the codec):\nSchema[Person].encode(JsonFormat)(buffer)(person)\nSchema[Person].decode(JsonFormat)(buffer)\n```\n\n### Key Insight: DynamicValue as the Bridge\n\n`Schema[A]` can convert any `A` to `DynamicValue` and back. Since `DynamicValue` is structurally similar to JSON, and `Json.fromDynamicValue` / `Json.toDynamicValue` exist, we can create `Schema[Json]` by wrapping `Schema[DynamicValue]`.\n\nThis is how `Schema.fromJsonSchema` will work: it wraps `Schema[DynamicValue]` with validation logic that checks the `JsonSchema` constraints.\n\n### Metadata That Maps to JSON Schema\n\n| ZIO Blocks Type | JSON Schema Equivalent |\n|-----------------|------------------------|\n| `TypeName[A]` | Can be stored in `$id` or custom extension for round-trip |\n| `Doc` | `title` / `description` |\n| `Validation[A]` | `minimum`, `maximum`, `minLength`, `maxLength`, `pattern`, etc. |\n| `Modifier.rename` | Affects property names |\n| `Modifier.alias` | Could map to extension for alternative names |\n| `Modifier.transient` | Field excluded from schema |\n| `Modifier.config` | Extensible metadata (e.g., `\"json-schema.format\" -> \"email\"`) |\n| `DiscriminatorKind` | Affects `oneOf`/`anyOf` structure and `discriminator` keyword |\n| `NameMapper` | Applied to field/case names during schema generation |\n\n### Reference: AvroBinaryCodec Pattern\n\nLook at `AvroBinaryCodec` for the established pattern. Each codec instance has:\n```scala\nabstract class AvroBinaryCodec[A](...) extends BinaryCodec[A] {\n  def avroSchema: AvroSchema  // <-- We want the equivalent for JSON Schema\n  // ...\n}\n```\n\nThe `AvroFormat` deriver constructs the `avroSchema` for each primitive, record, variant, sequence, map, and wrapper type.\n\n---\n\n## Requirements\n\n### 1. Create `JsonSchema` ADT\n\nCreate a new sealed trait `JsonSchema` in `zio.blocks.schema.json` that models JSON Schema 2020-12.\n\n**Location:** `schema/shared/src/main/scala/zio/blocks/schema/json/JsonSchema.scala` (and related files as needed)\n\nThe ADT must support:\n- Boolean schemas (`true` accepts all, `false` rejects all)\n- Full schema objects with all standard vocabularies (core, applicator, validation, format, content, metadata)\n- Round-trip JSON serialization (`toJson` / `fromJson`)\n- Validation (`check` method returning accumulated errors)\n- Combinators (`&&` for allOf, `||` for anyOf, `!` for not)\n\nSee the **JsonSchema Sketch** section below for a starting point.\n\n### 2. Add `toJsonSchema` to `JsonBinaryCodec[A]`\n\n**Location:** `schema/shared/src/main/scala/zio/blocks/schema/json/JsonBinaryCodec.scala`\n```scala\nabstract class JsonBinaryCodec[A](...) extends BinaryCodec[A] {\n  // ... existing methods ...\n  \n  /** Returns the JSON Schema describing values this codec encodes/decodes. */\n  def toJsonSchema: JsonSchema\n}\n```\n\nThen implement this in `JsonBinaryCodecDeriver` for each derivation case (primitives, records, variants, sequences, maps, wrappers, dynamic).\n\n**Important considerations:**\n- The schema must reflect the codec's configuration: `fieldNameMapper`, `caseNameMapper`, `discriminatorKind`, etc.\n- `Modifier.rename` and `Modifier.alias` on fields/cases affect property names\n- `Modifier.transient` fields should be excluded\n- `Modifier.config` with keys like `\"json-schema.format\"` should be respected\n- `Doc` on fields/types should map to `description`\n- `Validation[A]` on primitives should map to validation keywords\n\n### 3. Add `toJsonSchema` to `Schema[A]`\n\n**Location:** `schema/shared/src/main/scala/zio/blocks/schema/Schema.scala`\n```scala\nfinal case class Schema[A](reflect: Reflect.Bound[A]) {\n  // ... existing methods ...\n  \n  /** \n   * Convert this schema to a JsonSchema representation.\n   * This always succeedsevery Schema structure has a JsonSchema equivalent.\n   */\n  def toJsonSchema: JsonSchema\n}\n```\n\nThis can be implemented by deriving a `JsonBinaryCodec[A]` and calling its `toJsonSchema`, or by directly traversing the `Reflect` structure. The codec-based approach is recommended because it ensures the schema matches actual serialization behavior.\n\n### 4. Add `Schema.fromJsonSchema`\n\n**Location:** `schema/shared/src/main/scala/zio/blocks/schema/Schema.scala`\n```scala\nobject Schema extends SchemaCompanionVersionSpecific {\n  // ... existing methods ...\n  \n  /**\n   * Construct a Schema[Json] from a JsonSchema.\n   * Values are validated against the JsonSchema during construction.\n   */\n  def fromJsonSchema(jsonSchema: JsonSchema): Schema[Json]\n}\n```\n\n**Implementation approach:**\n```scala\ndef fromJsonSchema(jsonSchema: JsonSchema): Schema[Json] = {\n  Schema[DynamicValue].wrap[Json](\n    wrap = { dv =>\n      val json = Json.fromDynamicValue(dv)\n      jsonSchema.check(json) match {\n        case None        => Right(json)\n        case Some(error) => Left(error.message)\n      }\n    },\n    unwrap = _.toDynamicValue\n  )\n}\n```\n\nThis uses the existing `Schema.wrap` mechanism which creates a `Reflect.Wrapper` with validation on construction.\n\n### 5. Add `Schema[Json]` Instance\n\n**Location:** `schema/shared/src/main/scala/zio/blocks/schema/Schema.scala`\n```scala\nobject Schema extends SchemaCompanionVersionSpecific {\n  // ... existing methods ...\n  \n  /** Schema for Json values (no validation, accepts any Json). */\n  implicit val json: Schema[Json] = Schema[DynamicValue].wrapTotal[Json](\n    wrap = Json.fromDynamicValue,\n    unwrap = _.toDynamicValue\n  )\n}\n```\n\n### 6. Update `Json.check` and `Json.conforms`\n\n**Location:** `schema/shared/src/main/scala/zio/blocks/schema/json/Json.scala`\n\nThe current stubs are:\n```scala\ndef check(schema: Json): Either[JsonError, Unit] = ???\ndef conforms(schema: Json): Boolean = ???\n```\n\nChange to:\n```scala\n/** \n * Validates this JSON value against a JsonSchema.\n * Returns None if valid, Some(error) with accumulated failures if invalid.\n */\ndef check(schema: JsonSchema): Option[SchemaError] = schema.check(this)\n\n/** Returns true if this JSON value conforms to the schema. */\ndef conforms(schema: JsonSchema): Boolean = check(schema).isEmpty\n```\n\nNote: `SchemaError` already supports error accumulation via its `::[SchemaError.Single]` structure.\n\n### 7. Add `Schema[JsonSchema]` Instance\n\nThe `JsonSchema` type itself should have a `Schema` instance so it can be serialized, diffed, patched, etc. using ZIO Blocks machinery.\n```scala\nobject JsonSchema {\n  implicit val schema: Schema[JsonSchema] = Schema.derived // or manual construction\n}\n```\n\nThis may require careful handling of the recursive structure.\n\n---\n\n## JsonSchema Sketch\n\nBelow is a sketch of the `JsonSchema` ADT. This is a **starting point, not a final specification**. Use your judgment to refine it based on the JSON Schema 2020-12 spec and practical implementation needs.\n```scala\npackage zio.blocks.schema.json\n\nimport java.net.URI\n\n// =============================================================================\n// Newtypes for Precision\n// =============================================================================\n\n/** Non-negative integer (>= 0). Used for minLength, maxLength, minItems, etc. */\nfinal case class NonNegativeInt private (value: Int) extends AnyVal\nobject NonNegativeInt {\n  def apply(n: Int): Option[NonNegativeInt] =\n    if (n >= 0) Some(new NonNegativeInt(n)) else None\n  def unsafe(n: Int): NonNegativeInt = new NonNegativeInt(n)\n  \n  implicit val schema: Schema[NonNegativeInt] = ???\n}\n\n/** Strictly positive number (> 0). Used for multipleOf. */\nfinal case class PositiveNumber private (value: BigDecimal) extends AnyVal\nobject PositiveNumber {\n  def apply(n: BigDecimal): Option[PositiveNumber] =\n    if (n > 0) Some(new PositiveNumber(n)) else None\n  def unsafe(n: BigDecimal): PositiveNumber = new PositiveNumber(n)\n  \n  implicit val schema: Schema[PositiveNumber] = ???\n}\n\n/** ECMA-262 regular expression pattern. */\nfinal case class RegexPattern(value: String) extends AnyVal\nobject RegexPattern {\n  implicit val schema: Schema[RegexPattern] = ???\n}\n\n/** URI-Reference per RFC 3986 (may be relative). */\nfinal case class UriReference(value: String) extends AnyVal\nobject UriReference {\n  implicit val schema: Schema[UriReference] = ???\n}\n\n/** Anchor name (plain name fragment without #). */\nfinal case class Anchor(value: String) extends AnyVal\nobject Anchor {\n  implicit val schema: Schema[Anchor] = ???\n}\n\n// =============================================================================\n// JSON Primitive Type Enumeration\n// =============================================================================\n\nsealed trait JsonType extends Product with Serializable {\n  def toJsonString: String = this match {\n    case JsonType.Null    => \"null\"\n    case JsonType.Boolean => \"boolean\"\n    case JsonType.String  => \"string\"\n    case JsonType.Number  => \"number\"\n    case JsonType.Integer => \"integer\"\n    case JsonType.Array   => \"array\"\n    case JsonType.Object  => \"object\"\n  }\n}\nobject JsonType {\n  case object Null    extends JsonType\n  case object Boolean extends JsonType\n  case object String  extends JsonType\n  case object Number  extends JsonType\n  case object Integer extends JsonType\n  case object Array   extends JsonType\n  case object Object  extends JsonType\n  \n  def fromString(s: String): Option[JsonType] = s match {\n    case \"null\"    => Some(Null)\n    case \"boolean\" => Some(Boolean)\n    case \"string\"  => Some(String)\n    case \"number\"  => Some(Number)\n    case \"integer\" => Some(Integer)\n    case \"array\"   => Some(Array)\n    case \"object\"  => Some(Object)\n    case _         => None\n  }\n  \n  implicit val schema: Schema[JsonType] = ???\n}\n\n// =============================================================================\n// Type Keyword: Single Type or Array of Types\n// =============================================================================\n\nsealed trait SchemaType extends Product with Serializable {\n  def toJson: Json = this match {\n    case SchemaType.Single(t)   => Json.Str(t.toJsonString)\n    case SchemaType.Union(ts)   => Json.Arr(ts.map(t => Json.Str(t.toJsonString)): _*)\n  }\n}\nobject SchemaType {\n  final case class Single(value: JsonType)     extends SchemaType\n  final case class Union(values: ::[JsonType]) extends SchemaType\n  \n  def fromJson(json: Json): Either[SchemaError, SchemaType] = ???\n  \n  implicit val schema: Schema[SchemaType] = ???\n}\n\n// =============================================================================\n// JSON Schema 2020-12 ADT\n// =============================================================================\n\nsealed trait JsonSchema extends Product with Serializable {\n  \n  /** Serialize this schema to its canonical JSON representation. */\n  def toJson: Json\n  \n  /** \n   * Validate a JSON value against this schema.\n   * Returns None if valid, Some(error) with accumulated failures if invalid.\n   */\n  def check(json: Json): Option[SchemaError]\n  \n  /** Returns true if the JSON value conforms to this schema. */\n  def conforms(json: Json): Boolean = check(json).isEmpty\n  \n  // ===========================================================================\n  // Combinators\n  // ===========================================================================\n  \n  /** Combine with another schema using allOf. */\n  def &&(that: JsonSchema): JsonSchema\n  \n  /** Combine with another schema using anyOf. */\n  def ||(that: JsonSchema): JsonSchema\n  \n  /** Negate this schema. */\n  def unary_! : JsonSchema = JsonSchema.SchemaObject(not = Some(this))\n}\n\nobject JsonSchema {\n  \n  // ===========================================================================\n  // Parsing\n  // ===========================================================================\n  \n  /** Parse a JsonSchema from its JSON representation. */\n  def fromJson(json: Json): Either[SchemaError, JsonSchema]\n  \n  /** Parse a JsonSchema from a JSON string. */\n  def parse(jsonString: String): Either[SchemaError, JsonSchema]\n  \n  // ===========================================================================\n  // Schema & Codec instances\n  // ===========================================================================\n  \n  implicit val schema: Schema[JsonSchema] = ???\n  implicit val jsonBinaryCodec: JsonBinaryCodec[JsonSchema] = ???\n  \n  // ===========================================================================\n  // Boolean Schemas\n  // ===========================================================================\n\n  /** Schema that accepts all instances. Equivalent to `{}`. */\n  case object True extends JsonSchema {\n    override def toJson: Json = Json.Bool(true)\n    override def check(json: Json): Option[SchemaError] = None\n  }\n\n  /** Schema that rejects all instances. Equivalent to `{\"not\": {}}`. */\n  case object False extends JsonSchema {\n    override def toJson: Json = Json.Bool(false)\n    override def check(json: Json): Option[SchemaError] = \n      Some(SchemaError.expectationMismatch(Nil, \"Schema rejects all values\"))\n  }\n\n  // ===========================================================================\n  // Schema Object\n  // ===========================================================================\n  \n  /** \n   * A schema object containing keywords from JSON Schema 2020-12.\n   * All fields are optional; an empty SchemaObject is equivalent to True.\n   */\n  final case class SchemaObject(\n    // =========================================================================\n    // Core Vocabulary\n    // =========================================================================\n    \n    $id: Option[UriReference] = None,\n    $schema: Option[URI] = None,\n    $anchor: Option[Anchor] = None,\n    $dynamicAnchor: Option[Anchor] = None,\n    $ref: Option[UriReference] = None,\n    $dynamicRef: Option[UriReference] = None,\n    $vocabulary: Option[Map[URI, Boolean]] = None,\n    $defs: Option[Map[String, JsonSchema]] = None,\n    $comment: Option[String] = None,\n\n    // =========================================================================\n    // Applicator Vocabulary (Composition)\n    // =========================================================================\n    \n    allOf: Option[::[JsonSchema]] = None,\n    anyOf: Option[::[JsonSchema]] = None,\n    oneOf: Option[::[JsonSchema]] = None,\n    not: Option[JsonSchema] = None,\n\n    // =========================================================================\n    // Applicator Vocabulary (Conditional)\n    // =========================================================================\n    \n    `if`: Option[JsonSchema] = None,\n    `then`: Option[JsonSchema] = None,\n    `else`: Option[JsonSchema] = None,\n\n    // =========================================================================\n    // Applicator Vocabulary (Object)\n    // =========================================================================\n    \n    properties: Option[Map[String, JsonSchema]] = None,\n    patternProperties: Option[Map[RegexPattern, JsonSchema]] = None,\n    additionalProperties: Option[JsonSchema] = None,\n    propertyNames: Option[JsonSchema] = None,\n    dependentSchemas: Option[Map[String, JsonSchema]] = None,\n\n    // =========================================================================\n    // Applicator Vocabulary (Array)\n    // =========================================================================\n    \n    prefixItems: Option[::[JsonSchema]] = None,\n    items: Option[JsonSchema] = None,\n    contains: Option[JsonSchema] = None,\n\n    // =========================================================================\n    // Unevaluated Vocabulary\n    // =========================================================================\n    \n    unevaluatedProperties: Option[JsonSchema] = None,\n    unevaluatedItems: Option[JsonSchema] = None,\n\n    // =========================================================================\n    // Validation Vocabulary (Type)\n    // =========================================================================\n    \n    `type`: Option[SchemaType] = None,\n    `enum`: Option[::[Json]] = None,\n    const: Option[Json] = None,\n\n    // =========================================================================\n    // Validation Vocabulary (Numeric)\n    // =========================================================================\n    \n    multipleOf: Option[PositiveNumber] = None,\n    maximum: Option[BigDecimal] = None,\n    exclusiveMaximum: Option[BigDecimal] = None,\n    minimum: Option[BigDecimal] = None,\n    exclusiveMinimum: Option[BigDecimal] = None,\n\n    // =========================================================================\n    // Validation Vocabulary (String)\n    // =========================================================================\n    \n    minLength: Option[NonNegativeInt] = None,\n    maxLength: Option[NonNegativeInt] = None,\n    pattern: Option[RegexPattern] = None,\n\n    // =========================================================================\n    // Validation Vocabulary (Array)\n    // =========================================================================\n    \n    minItems: Option[NonNegativeInt] = None,\n    maxItems: Option[NonNegativeInt] = None,\n    uniqueItems: Option[Boolean] = None,\n    minContains: Option[NonNegativeInt] = None,\n    maxContains: Option[NonNegativeInt] = None,\n\n    // =========================================================================\n    // Validation Vocabulary (Object)\n    // =========================================================================\n    \n    minProperties: Option[NonNegativeInt] = None,\n    maxProperties: Option[NonNegativeInt] = None,\n    required: Option[Set[String]] = None,\n    dependentRequired: Option[Map[String, Set[String]]] = None,\n\n    // =========================================================================\n    // Format Vocabulary\n    // =========================================================================\n    \n    format: Option[String] = None,\n\n    // =========================================================================\n    // Content Vocabulary\n    // =========================================================================\n    \n    contentEncoding: Option[String] = None,\n    contentMediaType: Option[String] = None,\n    contentSchema: Option[JsonSchema] = None,\n\n    // =========================================================================\n    // Meta-Data Vocabulary\n    // =========================================================================\n    \n    title: Option[String] = None,\n    description: Option[String] = None,\n    default: Option[Json] = None,\n    deprecated: Option[Boolean] = None,\n    readOnly: Option[Boolean] = None,\n    writeOnly: Option[Boolean] = None,\n    examples: Option[::[Json]] = None,\n\n    // =========================================================================\n    // Extensions\n    // =========================================================================\n    \n    /** Unrecognized keywords for round-trip fidelity and vendor extensions. */\n    extensions: Map[String, Json] = Map.empty\n\n  ) extends JsonSchema {\n    override def toJson: Json = ???\n    override def check(json: Json): Option[SchemaError] = ???\n  }\n\n  object SchemaObject {\n    val empty: SchemaObject = SchemaObject()\n  }\n  \n  // ===========================================================================\n  // Smart Constructors\n  // ===========================================================================\n  \n  def ofType(t: JsonType): JsonSchema = \n    SchemaObject(`type` = Some(SchemaType.Single(t)))\n  \n  def string(\n    minLength: Option[NonNegativeInt] = None,\n    maxLength: Option[NonNegativeInt] = None,\n    pattern: Option[RegexPattern] = None,\n    format: Option[String] = None\n  ): JsonSchema = SchemaObject(\n    `type` = Some(SchemaType.Single(JsonType.String)),\n    minLength = minLength,\n    maxLength = maxLength,\n    pattern = pattern,\n    format = format\n  )\n  \n  def number(\n    minimum: Option[BigDecimal] = None,\n    maximum: Option[BigDecimal] = None,\n    exclusiveMinimum: Option[BigDecimal] = None,\n    exclusiveMaximum: Option[BigDecimal] = None,\n    multipleOf: Option[PositiveNumber] = None\n  ): JsonSchema = SchemaObject(\n    `type` = Some(SchemaType.Single(JsonType.Number)),\n    minimum = minimum,\n    maximum = maximum,\n    exclusiveMinimum = exclusiveMinimum,\n    exclusiveMaximum = exclusiveMaximum,\n    multipleOf = multipleOf\n  )\n  \n  def integer(\n    minimum: Option[BigDecimal] = None,\n    maximum: Option[BigDecimal] = None\n  ): JsonSchema = SchemaObject(\n    `type` = Some(SchemaType.Single(JsonType.Integer)),\n    minimum = minimum,\n    maximum = maximum\n  )\n  \n  def array(\n    items: Option[JsonSchema] = None,\n    minItems: Option[NonNegativeInt] = None,\n    maxItems: Option[NonNegativeInt] = None,\n    uniqueItems: Option[Boolean] = None\n  ): JsonSchema = SchemaObject(\n    `type` = Some(SchemaType.Single(JsonType.Array)),\n    items = items,\n    minItems = minItems,\n    maxItems = maxItems,\n    uniqueItems = uniqueItems\n  )\n  \n  def `object`(\n    properties: Option[Map[String, JsonSchema]] = None,\n    required: Option[Set[String]] = None,\n    additionalProperties: Option[JsonSchema] = None\n  ): JsonSchema = SchemaObject(\n    `type` = Some(SchemaType.Single(JsonType.Object)),\n    properties = properties,\n    required = required,\n    additionalProperties = additionalProperties\n  )\n  \n  def enumOf(values: ::[Json]): JsonSchema = SchemaObject(`enum` = Some(values))\n  \n  def constOf(value: Json): JsonSchema = SchemaObject(const = Some(value))\n  \n  def ref(uri: UriReference): JsonSchema = SchemaObject($ref = Some(uri))\n  \n  val `null`: JsonSchema = ofType(JsonType.Null)\n  val boolean: JsonSchema = ofType(JsonType.Boolean)\n}\n```\n\n---\n\n## Validation to JsonSchema Mapping\n\nThe `Validation[A]` type in ZIO Blocks maps to JSON Schema validation keywords. Implement this mapping when generating schemas from `PrimitiveType`:\n\n| `Validation[A]` | JSON Schema Keywords |\n|-----------------|---------------------|\n| `Validation.None` | (no constraints) |\n| `Validation.Numeric.Positive` | `exclusiveMinimum: 0` |\n| `Validation.Numeric.NonNegative` | `minimum: 0` |\n| `Validation.Numeric.Negative` | `exclusiveMaximum: 0` |\n| `Validation.Numeric.NonPositive` | `maximum: 0` |\n| `Validation.Numeric.Range(min, max)` | `minimum` / `maximum` |\n| `Validation.Numeric.Set(values)` | `enum: [...]` |\n| `Validation.String.NonEmpty` | `minLength: 1` |\n| `Validation.String.Empty` | `maxLength: 0` |\n| `Validation.String.Length(min, max)` | `minLength` / `maxLength` |\n| `Validation.String.Pattern(regex)` | `pattern` |\n\n---\n\n## Modifier.config Keys\n\nSupport these `Modifier.config` keys when generating JSON Schema:\n\n| Key | Effect |\n|-----|--------|\n| `json-schema.format` | Sets `format` keyword (e.g., `\"email\"`, `\"date-time\"`, `\"uuid\"`) |\n| `json-schema.deprecated` | Sets `deprecated: true` |\n| `json-schema.title` | Overrides `title` |\n| `json-schema.description` | Overrides `description` |\n\n---\n\n## Files to Create or Modify\n\n| File | Action |\n|------|--------|\n| `schema/shared/src/main/scala/zio/blocks/schema/json/JsonSchema.scala` | **CREATE** - Main ADT |\n| `schema/shared/src/main/scala/zio/blocks/schema/json/JsonBinaryCodec.scala` | **MODIFY** - Add `def toJsonSchema: JsonSchema` |\n| `schema/shared/src/main/scala/zio/blocks/schema/json/JsonBinaryCodecDeriver.scala` | **MODIFY** - Implement `toJsonSchema` for all derivation cases |\n| `schema/shared/src/main/scala/zio/blocks/schema/Schema.scala` | **MODIFY** - Add `toJsonSchema`, `fromJsonSchema`, `Schema[Json]` |\n| `schema/shared/src/main/scala/zio/blocks/schema/json/Json.scala` | **MODIFY** - Update `check`/`conforms` signatures |\n\n---\n\n## Required Test Suites\n\nAll tests should use ZIO Test and follow the existing test patterns in the codebase.\n\n### 1. `JsonSchemaSpec`  Core ADT Tests\n\n**Location:** `schema/shared/src/test/scala/zio/blocks/schema/json/JsonSchemaSpec.scala`\n\nMust test:\n\n- **Boolean schemas**: `True` accepts all JSON, `False` rejects all JSON\n- **Type validation**: Each `JsonType` validates correctly (null, boolean, string, number, integer, array, object)\n- **Type unions**: `type: [\"string\", \"number\"]` accepts either\n- **Numeric constraints**: `minimum`, `maximum`, `exclusiveMinimum`, `exclusiveMaximum`, `multipleOf`\n- **String constraints**: `minLength`, `maxLength`, `pattern`\n- **Array constraints**: `minItems`, `maxItems`, `uniqueItems`, `prefixItems`, `items`, `contains`, `minContains`, `maxContains`\n- **Object constraints**: `properties`, `required`, `additionalProperties`, `propertyNames`, `minProperties`, `maxProperties`, `patternProperties`, `dependentRequired`, `dependentSchemas`\n- **Composition**: `allOf`, `anyOf`, `oneOf`, `not`\n- **Conditional**: `if`/`then`/`else`\n- **Enum and const**: exact value matching\n- **Error accumulation**: Multiple validation failures are collected, not just the first\n\n### 2. `JsonSchemaRoundTripSpec`  Serialization Tests\n\n**Location:** `schema/shared/src/test/scala/zio/blocks/schema/json/JsonSchemaRoundTripSpec.scala`\n\nMust test:\n\n- **`toJson` / `fromJson` round-trip**: For every `JsonSchema`, `JsonSchema.fromJson(schema.toJson) == Right(schema)`\n- **Parse canonical examples**: Parse schemas from the JSON Schema test suite or spec examples\n- **Boolean schema serialization**: `true` and `false` as JSON booleans\n- **Empty object equivalence**: `{}` parses to `SchemaObject.empty` which is equivalent to `True`\n- **Extension preservation**: Unknown keywords in `extensions` survive round-trip\n- **All keyword serialization**: Every field in `SchemaObject` serializes to the correct JSON keyword\n\n### 3. `JsonBinaryCodecToJsonSchemaSpec`  Codec Schema Extraction Tests\n\n**Location:** `schema/shared/src/test/scala/zio/blocks/schema/json/JsonBinaryCodecToJsonSchemaSpec.scala`\n\nMust test:\n\n- **Primitives**: Each primitive type produces correct JSON Schema (`String`  `type: \"string\"`, `Int`  `type: \"integer\"`, etc.)\n- **Temporal types**: `Instant`, `LocalDate`, etc. produce `type: \"string\"` with appropriate `format`\n- **Records**: Case classes produce `type: \"object\"` with `properties` and `required`\n- **Variants (sealed traits)**: Produce `oneOf` or discriminator-based schema depending on `DiscriminatorKind`\n- **Enumerations**: Sealed traits with all case objects produce `enum`\n- **Option fields**: Non-required properties or union with `null`\n- **Collections**: `List[A]`, `Set[A]`, `Vector[A]` produce `type: \"array\"` with `items`\n- **Maps**: `Map[String, V]` produces `type: \"object\"` with `additionalProperties`\n- **Nested structures**: Deeply nested case classes produce correct nested schemas\n- **Field renaming**: `Modifier.rename` and `fieldNameMapper` affect property names\n- **Transient fields**: `Modifier.transient` fields are excluded from schema\n- **Documentation**: `Doc` maps to `description`\n- **Validation constraints**: `Validation[A]` on primitives maps to validation keywords\n- **Config modifiers**: `Modifier.config(\"json-schema.format\", \"email\")` sets `format`\n\n### 4. `SchemaToJsonSchemaSpec`  Schema Conversion Tests\n\n**Location:** `schema/shared/src/test/scala/zio/blocks/schema/json/SchemaToJsonSchemaSpec.scala`\n\nMust test:\n\n- **All built-in schemas**: `Schema[Int]`, `Schema[String]`, `Schema[Boolean]`, etc.\n- **Derived schemas**: `Schema.derived` for case classes and sealed traits\n- **Consistency with codec**: `Schema[A].toJsonSchema` should match `Schema[A].derive(JsonFormat.deriver).toJsonSchema`\n- **Recursive types**: Self-referential case classes produce schemas with `$ref` or equivalent\n\n### 5. `SchemaFromJsonSchemaSpec`  Schema Construction Tests\n\n**Location:** `schema/shared/src/test/scala/zio/blocks/schema/json/SchemaFromJsonSchemaSpec.scala`\n\nMust test:\n\n- **Valid JSON passes**: `Schema.fromJsonSchema(schema)` accepts conforming JSON\n- **Invalid JSON fails**: Non-conforming JSON fails with descriptive error\n- **Error messages**: Validation errors include path information\n- **Round-trip through DynamicValue**: JSON  DynamicValue  JSON preserves structure\n- **Encode/decode works**: The resulting `Schema[Json]` can be used with `JsonFormat` for encoding/decoding\n\n### 6. `JsonCheckSpec`  Json.check/conforms Tests\n\n**Location:** `schema/shared/src/test/scala/zio/blocks/schema/json/JsonCheckSpec.scala`\n\nMust test:\n\n- **Method signatures**: `check` returns `Option[SchemaError]`, `conforms` returns `Boolean`\n- **Delegation**: These methods delegate to `JsonSchema.check`\n- **All validation scenarios**: Mirror tests from `JsonSchemaSpec` but called via `Json` methods\n\n### 7. `JsonSchemaCombinatorSpec`  Combinator Tests\n\n**Location:** `schema/shared/src/test/scala/zio/blocks/schema/json/JsonSchemaCombinatorSpec.scala`\n\nMust test:\n\n- **`&&` (allOf)**: `schema1 && schema2` validates if both pass\n- **`||` (anyOf)**: `schema1 || schema2` validates if either passes\n- **`!` (not)**: `!schema` validates if schema fails\n- **Associativity**: `(a && b) && c` equivalent to `a && (b && c)`\n- **Commutativity**: `a && b` equivalent to `b && a` (for validation purposes)\n- **De Morgan's laws**: `!(a && b)` equivalent to `!a || !b`\n\n---\n\n## Acceptance Criteria\n\n- [ ] All test suites pass\n- [ ] `JsonSchema` ADT covers JSON Schema 2020-12 core, applicator, validation, format, content, and metadata vocabularies\n- [ ] `JsonSchema#toJson` produces valid JSON Schema documents\n- [ ] `JsonSchema.fromJson` parses valid JSON Schema documents\n- [ ] `JsonSchema#check` validates JSON values with accumulated errors\n- [ ] `JsonBinaryCodec[A].toJsonSchema` produces accurate schemas reflecting codec configuration\n- [ ] `Schema[A].toJsonSchema` works for all derivable types\n- [ ] `Schema.fromJsonSchema` produces a working `Schema[Json]` with validation\n- [ ] `Json#check` and `Json#conforms` work with the new `JsonSchema` parameter type\n- [ ] `Validation[A]` constraints map to appropriate JSON Schema keywords\n- [ ] `Doc` maps to `description`\n- [ ] `Modifier.rename`, `Modifier.transient`, and `Modifier.config` are respected\n- [ ] Code follows existing project style and conventions\n- [ ] No new dependencies are introduced (use existing `Json` type, not a third-party JSON library)\n\n---\n\n## Notes for Implementers\n\n1. **Start with the ADT**: Get `JsonSchema` working with `toJson`/`fromJson`/`check` before integrating with `JsonBinaryCodec`.\n\n2. **Study the Avro implementation**: `AvroFormat` and `AvroBinaryCodec` show the established pattern for schema extraction from codecs.\n\n3. **Validation is the hard part**: The `check` method needs to correctly implement JSON Schema validation semantics, including `unevaluatedProperties`/`unevaluatedItems` which require tracking which properties/items were \"evaluated\" by other keywords.\n\n4. **Error accumulation**: Use `SchemaError` which already supports multiple errors. Include path information using `DynamicOptic`.\n\n5. **`$ref` resolution**: For this initial implementation, `$ref` within the same document (using `$defs`) should work. Cross-document references are out of scope.\n\n6. **Format validation**: The `format` keyword is an annotation by default in 2020-12. Implement validation for common formats (`date-time`, `date`, `time`, `email`, `uuid`, `uri`) but make it non-fatal or configurable.\n\n7. **Test against the official test suite**: The [JSON Schema Test Suite](https://github.com/json-schema-org/JSON-Schema-Test-Suite) provides comprehensive test cases. Consider using it to validate your implementation.",
              "url": "https://github.com/zio/zio-blocks/issues/462",
              "tech": [],
              "repo_name": "zio-blocks",
              "repo_owner": "zio",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "ZIO#517",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "ZIO",
              "id": "generated-ZIO",
              "name": "ZIO",
              "description": "",
              "members": [],
              "display_name": "ZIO",
              "created_at": "2026-01-26T23:56:54.772Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/ZIO?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "zio",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-26T23:56:54.772Z",
            "created_at": "2026-01-26T23:56:54.772Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-ZIO#517",
              "status": "open",
              "type": "issue",
              "number": 517,
              "title": "Add structural schemas",
              "source": {
                "data": {
                  "id": "source-ZIO#517",
                  "user": {
                    "login": "jdegoes",
                    "id": 156745,
                    "node_id": "MDQ6VXNlcjE1Njc0NQ==",
                    "avatar_url": "https://avatars.githubusercontent.com/u/156745?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/jdegoes",
                    "html_url": "https://github.com/jdegoes",
                    "followers_url": "https://api.github.com/users/jdegoes/followers",
                    "following_url": "https://api.github.com/users/jdegoes/following{/other_user}",
                    "gists_url": "https://api.github.com/users/jdegoes/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/jdegoes/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/jdegoes/subscriptions",
                    "organizations_url": "https://api.github.com/users/jdegoes/orgs",
                    "repos_url": "https://api.github.com/users/jdegoes/repos",
                    "events_url": "https://api.github.com/users/jdegoes/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/jdegoes/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Add structural schemas",
                  "body": "# Structural Type Schema Support\n\n## Overview\n\nExtend `Schema[A]` to support structural types, enabling schema derivation for types defined by their structure rather than their nominal identity. This allows for duck-typed schema validation and conversion between nominal and structural representations.\n\n## Core Concepts\n\n### Direct Structural Schema Derivation\n\nSchemas can be derived directly for structural types:\n\n```scala\n// Scala 3\ntype Person = { def name: String; def age: Int }\nval schema = Schema.derived[Person]\n\n// Scala 2\ntype Person = { def name: String; def age: Int }\nval schema = Schema.derived[Person]\n```\n\n**Note**: Both Scala 2 and Scala 3 use `def` for uniformity, even though Scala 3 supports `val` in structural types.\n\n**Implementation**: Schemas have bindings, which allow construction / deconstruction of values. Values for structural types are backed by:\n- **Scala 3**: `Selectable` \n- **Scala 2**: `Dynamic`\n\n### Nominal to Structural Conversion\n\nConvert nominal type schemas to their structural equivalents:\n\n```scala\ncase class Person(name: String, age: Int)\n\n// Get the structural schema corresponding to Person's shape\nval structuralSchema: Schema[{ def name: String; def age: Int }] = \n  Schema.derived[Person].structural\n```\n\n### Schema API Extension\n\n```scala\ncase class Schema[A](/* existing fields */) {\n  /**\n   * Convert this schema to a structural type schema.\n   * \n   * The structural type represents the \"shape\" of A without its nominal identity.\n   * This enables duck typing and structural validation.\n   * \n   * @param toStructural Macro-generated conversion to structural representation\n   * @return Schema for the structural type corresponding to A\n   */\n  def structural(implicit toStructural: ToStructural[A]): Schema[toStructural.StructuralType] = \n    toStructural.apply(this)\n}\n\n/**\n * Type class for converting nominal schemas to structural schemas.\n * Generated by macro for all supported types. Macro fails if a structural\n * type cannot be generated.\n *\n * NOTE: This approach has to be tested to yield inferrable types, and revised\n * if necessary. Inferrable types (from calling Schema#structural) are a must-have.\n */\ntrait ToStructural[A] {\n  type StructuralType\n  def apply(schema: Schema[A]): Schema[StructuralType]\n}\n\nobject ToStructural {\n  type Aux[A, S] = ToStructural[A] { type StructuralType = S }\n  \n  // Scala 3\n  transparent inline given [A]: ToStructural[A] = ${toStructuralMacro[A]}\n  \n  // Scala 2\n  implicit def materialize[A]: ToStructural[A] = macro toStructuralImpl[A]\n}\n```\n\n---\n\n## Examples\n\n### 1. Simple Product Types\n\n#### Case Class to Structural\n\n```scala\n// Both Scala 2 and Scala 3\ncase class Person(name: String, age: Int)\n\n// Original nominal schema\nval nominalSchema: Schema[Person] = Schema.derived[Person]\n\n// Convert to structural\nval structuralSchema: Schema[{ def name: String; def age: Int }] = \n  nominalSchema.structural\n\n// Direct structural derivation (equivalent)\nval directStructural: Schema[{ def name: String; def age: Int }] = \n  Schema.derived[{ def name: String; def age: Int }]\n```\n\n### 2. Nested Structures\n\n```scala\ncase class Address(street: String, city: String, zip: Int)\ncase class Person(name: String, age: Int, address: Address)\n\nval structuralSchema = Schema.derived[Person].structural\n// Type: Schema[{ \n//   def name: String\n//   def age: Int\n//   def address: { def street: String; def city: String; def zip: Int }\n// }]\n```\n\n### 3. Collections and Options\n\n```scala\ncase class Team(name: String, members: List[String], leader: Option[String])\n\nval structuralSchema = Schema.derived[Team].structural\n// Type: Schema[{\n//   def name: String\n//   def members: List[String]\n//   def leader: Option[String]\n// }]\n```\n\n### 4. Tuples to Structural\n\n```scala\n// Tuples can be converted to structural types\nval tupleSchema: Schema[(String, Int, Boolean)] = Schema.derived[(String, Int, Boolean)]\n\nval structuralSchema = tupleSchema.structural\n// Type: Schema[{ def _1: String; def _2: Int; def _3: Boolean }]\n```\n\n### 5. Sum Types (Sealed Traits) - Scala 3 Only\n\nSealed traits become union types of structural representations, with tag information stored at the type level:\n\n```scala\n// Scala 3 only\nsealed trait Result\ncase class Success(value: Int) extends Result\ncase class Failure(error: String) extends Result\n\nval structuralSchema = Schema.derived[Result].structural\n// Type: Schema[\n//   { type Tag = \"Success\"; def value: Int } | { type Tag = \"Failure\"; def error: String }\n// ]\n```\n\n**Note**: Sum type to structural conversion is **not supported in Scala 2** because it requires union types. Attempting to call `.structural` on a sealed trait schema in Scala 2 will result in a compile-time error.\n\n### 6. Enums (Scala 3 Only)\n\n```scala\nenum Status:\n  case Active, Inactive, Suspended\n\nval structuralSchema = Schema.derived[Status].structural\n// Type: Schema[{type Tag = \"Active\"} | {type Tag = \"Inactive\"} | {type Tag = \"Suspended\"}]\n```\n\n### 7. Opaque Types (Scala 3)\n\n```scala\nopaque type UserId = String\nobject UserId:\n  def apply(value: String): Either[String, UserId] = \n    if value.nonEmpty then Right(value) else Left(\"Empty user ID\")\n\ncase class User(id: UserId, name: String)\n\nval structuralSchema = Schema.derived[User].structural\n// Type: Schema[{ def id: String; def name: String }]\n// Opaque type is unwrapped to its underlying type\n```\n\n### 8. Bidirectional Conversion\n\nStructural schemas work seamlessly with `Into`/`As` (if this ticket is implemented **after** that ticket):\n\n```scala\ncase class Person(name: String, age: Int)\n\nval structuralSchema = Schema.derived[Person].structural\n\n// Create structural value (Scala 3)\nval structuralPerson = new Selectable {\n  def selectDynamic(field: String): Any = field match {\n    case \"name\" => \"Alice\"\n    case \"age\" => 30\n  }\n}\n\n// Convert structural to nominal using Into\nval person: Either[SchemaError, Person] = \n  Into[{ def name: String; def age: Int }, Person].into(structuralPerson)\n// => Right(Person(\"Alice\", 30))\n\n// Convert nominal to structural\nval backToStructural: Either[SchemaError, { def name: String; def age: Int }] = \n  Into[Person, { def name: String; def age: Int }].into(Person(\"Bob\", 25))\n```\n\n### 9. Empty and Single-Field Products\n\n```scala\n// Empty case class\ncase class Empty()\nval emptyStructural = Schema.derived[Empty].structural\n// Type: Schema[{}]\n\n// Single field\ncase class Id(value: String)\nval idStructural = Schema.derived[Id].structural\n// Type: Schema[{ def value: String }]\n```\n\n### 10. Large Products\n\n```scala\ncase class LargeRecord(\n  f1: String, f2: Int, f3: Boolean, f4: Double, f5: Long,\n  f6: String, f7: Int, f8: Boolean, f9: Double, f10: Long,\n  f11: String, f12: Int, f13: Boolean, f14: Double, f15: Long,\n  f16: String, f17: Int, f18: Boolean, f19: Double, f20: Long,\n  f21: String\n)\n\nval structuralSchema = Schema.derived[LargeRecord].structural\n// Type: Schema[{\n//   def f1: String; def f2: Int; def f3: Boolean; ...\n//   def f21: String\n// }]\n```\n\n---\n\n## Type Name Handling\n\n### Current Limitation\n\nSchemas currently use `TypeName[A]` to identify types. Structural types don't have meaningful nominal type names, which creates a mismatch.\n\n### Temporary Solution\n\nUntil `TypeName[A]` is replaced with `TypeId[A]` (see issue #471), structural schemas will use a normalized string representation of the structural type as a fake type name:\n\n```scala\ncase class Person(name: String, age: Int)\n\nval schema = Schema.derived[Person]\nschema.typeName // => TypeName for \"Person\"\n\nval structural = schema.structural\nstructural.typeName // => TypeName for \"{age:Int,name:String}\"\n// Normalized: fields sorted alphabetically, types fully qualified\n```\n\n### Normalization Rules\n\n1. **Field ordering**: Alphabetical by field name\n2. **Type qualification**: Use simple names for primitives and standard library types\n3. **Whitespace**: No whitespace in generated names\n4. **Collections**: Standard notation (e.g., `List[Int]`)\n5. **Options**: Explicit `Option[T]` notation\n6. **Nested structures**: Recursive application of rules\n7. **Deterministic**: Same structure always produces same normalized name\n\n### Examples\n\n```scala\n// Simple product\ncase class Point(x: Int, y: Int)\nSchema.derived[Point].structural.typeName \n// => \"{x:Int,y:Int}\"\n\n// Nested product\ncase class Address(street: String, zip: Int)\ncase class Person(name: String, address: Address)\nSchema.derived[Person].structural.typeName\n// => \"{address:{street:String,zip:Int},name:String}\"\n\n// With collections\ncase class Team(name: String, members: List[String])\nSchema.derived[Team].structural.typeName\n// => \"{members:List[String],name:String}\"\n\n// Union type (Scala 3)\nsealed trait Result\ncase class Success(value: Int) extends Result\ncase class Failure(error: String) extends Result\nSchema.derived[Result].structural.typeName\n// => \"{error:String}|{value:Int}\"\n```\n\n### Future: TypeId[A]\n\nThe upcoming `TypeId[A]` replacement will properly handle structural types by representing them by their structure rather than a string-based hack. See issue #471 for details.\n\n---\n\n## Limitations and Edge Cases\n\n### 1. Generic Types\n\n**Behavior depends on existing Schema derivation support for generic types.**\n\nIf `Schema.derived[Container[Int]]` already works, then structural conversion should work:\n\n```scala\ncase class Container[T](value: T)\n\n// If this works:\nval schema = Schema.derived[Container[Int]]\n\n// Then this should work:\nval structural = schema.structural\n// Type: Schema[{ def value: Int }]\n```\n\nIf generic type derivation is not currently supported, this ticket **does not require implementing it**. The macro should produce a clear compile-time error for unsupported generic types.\n\n### 2. Recursive Types\n\nRecursive types will **fail at compile-time** because Scala does not support infinite types:\n\n```scala\ncase class Tree(value: Int, children: List[Tree])\n\n// This will FAIL at compile-time:\nval structural = Schema.derived[Tree].structural\n// Compile error: Cannot generate infinite structural type\n\n// The structural type would need to be:\n// { def value: Int; def children: List[{ def value: Int; def children: List[...] }] }\n// which is infinite and unsupported\n```\n\nThe macro must detect recursive types and produce a helpful error message:\n\n```\nCompile error: Cannot generate structural type for recursive type Tree.\nStructural types cannot represent recursive structures.\n```\n\n### 3. Mutually Recursive Types\n\nSimilarly, mutually recursive types are unsupported:\n\n```scala\ncase class Node(id: Int, edges: List[Edge])\ncase class Edge(from: Int, to: Node)\n\n// This will FAIL at compile-time:\nval nodeStructural = Schema.derived[Node].structural\n// Compile error: Cannot generate structural type for mutually recursive types\n```\n\n### 4. Sum Types in Scala 2\n\nSealed traits and sum types **cannot be converted to structural types in Scala 2** because they require union types:\n\n```scala\n// Scala 2\nsealed trait Result\ncase class Success(value: Int) extends Result\ncase class Failure(error: String) extends Result\n\n// This will FAIL at compile-time in Scala 2:\nval structural = Schema.derived[Result].structural\n// Compile error: Cannot generate structural type for sum types in Scala 2.\n// Union types are required, which are only available in Scala 3.\n```\n\nThe macro must detect sum types in Scala 2 and produce a clear error.\n\n### 5. Case Objects\n\nCase objects become empty structural types:\n\n```scala\ncase object Singleton\n\nval structural = Schema.derived[Singleton.type].structural\n// Type: Schema[{}]\n```\n\nFor sum types with case objects (Scala 3):\n\n```scala\nsealed trait Status\ncase object Active extends Status\ncase object Inactive extends Status\n\nval structural = Schema.derived[Status].structural\n// Type: Schema[{} | {}]\n// Not particularly useful, but valid\n```\n\n### 6. Structural Types as Source\n\nDeriving schemas directly for structural types is supported:\n\n```scala\ntype PersonStructure = { def name: String; def age: Int }\n\nval schema = Schema.derived[PersonStructure]\n// Should work if structural type derivation is implemented\n```\n\nThe schema's bindings will use `Selectable` (Scala 3) or `Dynamic` (Scala 2) to construct and deconstruct values.\n\n---\n\n## Integration with Into/As\n\nStructural schemas compose naturally with `Into`/`As` conversions.\n\n### Nominal  Structural\n\n```scala\ncase class Person(name: String, age: Int)\n\n// Auto-derived conversion\nval nominalToStructural: Into[Person, { def name: String; def age: Int }] = \n  Into.derived\n\nval person = Person(\"Alice\", 30)\nval structural = nominalToStructural.into(person)\n// => Right(<Selectable/Dynamic instance>)\n```\n\n### Structural  Nominal\n\n```scala\ntype PersonStructure = { def name: String; def age: Int }\ncase class Person(name: String, age: Int)\n\n// Auto-derived conversion\nval structuralToNominal: Into[PersonStructure, Person] = \n  Into.derived\n\nval structural: PersonStructure = new Selectable {\n  def selectDynamic(field: String): Any = field match {\n    case \"name\" => \"Bob\"\n    case \"age\" => 25\n  }\n}\n\nval person = structuralToNominal.into(structural)\n// => Right(Person(\"Bob\", 25))\n```\n\n### Bidirectional (As)\n\n```scala\ncase class Person(name: String, age: Int)\n\n// Bidirectional conversion\nval personAs: As[Person, { def name: String; def age: Int }] = \n  As.derived\n\n// Nominal  Structural\nval structural = personAs.into(Person(\"Alice\", 30))\n\n// Structural  Nominal\nval nominal = structural.flatMap(personAs.from)\n// Round-trip successful\n```\n\n### Schema-Guided Conversion\n\n```scala\ncase class PersonV1(firstName: String, lastName: String, age: Int)\ncase class PersonV2(name: String, age: Int)\n\n// Use structural type as intermediary\ntype PersonStructure = { def name: String; def age: Int }\n\n// Step 1: Transform V1 to structural (custom logic)\nval v1ToStructural: Into[PersonV1, PersonStructure] = \n  new Into[PersonV1, PersonStructure] {\n    def into(v1: PersonV1): Either[SchemaError, PersonStructure] = {\n      Right(new Selectable {\n        def selectDynamic(field: String): Any = field match {\n          case \"name\" => s\"${v1.firstName} ${v1.lastName}\"\n          case \"age\" => v1.age\n        }\n      })\n    }\n  }\n\n// Step 2: Auto-convert structural to V2\nval structuralToV2: Into[PersonStructure, PersonV2] = Into.derived\n\n// Composed migration\ndef migrate(v1: PersonV1): Either[SchemaError, PersonV2] = {\n  v1ToStructural.into(v1).flatMap(structuralToV2.into)\n}\n```\n\n---\n\n## Testing Requirements\n\n### Test Matrix\n\n1. **Direct Structural Derivation**\n   - Simple products (case classes)\n   - Nested products\n   - Collections (List, Vector, Set, Map, Option, Either)\n   - Tuples (2-22 elements)\n   - Empty case classes\n   - Single-field case classes\n   - Large products (20+ fields)\n   - Case objects\n\n2. **Nominal to Structural Conversion**\n   - Case class  structural\n   - Tuple  structural\n   - Nested case classes  nested structural\n   - Case class with collections  structural with collections\n   - Empty case class  empty structural\n\n3. **Sum Types (Scala 3 Only)**\n   - Sealed trait  union type structural\n   - Sealed trait with case objects\n   - Enum  union type structural\n   - Nested sum types\n\n4. **Type Name Generation**\n   - Simple product normalized name\n   - Nested product normalized name\n   - Name determinism (same structure = same name)\n   - Alphabetical field ordering in names\n   - Union type names (Scala 3)\n\n5. **Selectable/Dynamic Implementation**\n   - Scala 3 Selectable field access\n   - Scala 2 Dynamic field access\n   - Field access correctness\n   - Missing field behavior\n   - Extra field behavior\n\n6. **Integration with Into/As**\n   - Nominal  Structural via Into\n   - Structural  Nominal via Into\n   - Round-trip via As\n   - Composed conversions with structural intermediary\n\n7. **Error Cases (Compile-Time)**\n   - Recursive types produce error\n   - Mutually recursive types produce error\n   - Sum types in Scala 2 produce error\n   - Unsupported types produce helpful errors\n\n8. **Generic Types** (if supported by existing Schema derivation)\n   - Fully applied generic  structural\n   - Generic with nested structural fields\n\n### Scala 2 vs Scala 3 Test Separation\n\n```\nsrc/test/scala/\n  structural/\n    common/\n      SimpleProductSpec.scala\n      NestedProductSpec.scala\n      CollectionsSpec.scala\n      TuplesSpec.scala\n      EmptyProductSpec.scala\n      SingleFieldSpec.scala\n      LargeProductSpec.scala\n      TypeNameNormalizationSpec.scala\n      IntoIntegrationSpec.scala\n      AsIntegrationSpec.scala\n      \n    scala3/\n      UnionTypesSpec.scala\n      SealedTraitToUnionSpec.scala\n      EnumToUnionSpec.scala\n      SelectableImplementationSpec.scala\n      \n    scala2/\n      DynamicImplementationSpec.scala\n      SumTypeErrorSpec.scala (verifies compile error)\n      \n    errors/\n      RecursiveTypeErrorSpec.scala\n      MutualRecursionErrorSpec.scala\n      UnsupportedTypeErrorSpec.scala\n```\n\n### Test Examples\n\n```scala\n// Test: Simple product to structural\ntest(\"case class converts to structural schema\") {\n  case class Person(name: String, age: Int)\n  \n  val structural = Schema.derived[Person].structural\n  \n  // Type check (this is a compile-time test)\n  val _: Schema[{ def name: String; def age: Int }] = structural\n  \n  assert(structural.typeName.toString.contains(\"name\"))\n  assert(structural.typeName.toString.contains(\"age\"))\n}\n\n// Test: Nested products\ntest(\"nested case classes convert to nested structural\") {\n  case class Address(street: String, zip: Int)\n  case class Person(name: String, address: Address)\n  \n  val structural = Schema.derived[Person].structural\n  \n  val _: Schema[{ \n    def name: String\n    def address: { def street: String; def zip: Int }\n  }] = structural\n}\n\n// Test: Tuple to structural\ntest(\"tuple converts to structural with _N fields\") {\n  val structural = Schema.derived[(String, Int, Boolean)].structural\n  \n  val _: Schema[{ def _1: String; def _2: Int; def _3: Boolean }] = structural\n}\n\n// Test: Union type (Scala 3 only)\ntest(\"sealed trait converts to union type structural\") {\n  sealed trait Result\n  case class Success(value: Int) extends Result\n  case class Failure(error: String) extends Result\n  \n  val structural = Schema.derived[Result].structural\n  \n  val _: Schema[{ def value: Int } | { def error: String }] = structural\n}\n\n// Test: Type name normalization\ntest(\"structural type names are normalized and deterministic\") {\n  case class Person(name: String, age: Int)\n  case class User(age: Int, name: String) // Different field order\n  \n  val personStructural = Schema.derived[Person].structural\n  val userStructural = Schema.derived[User].structural\n  \n  // Same structure, same normalized name\n  assert(personStructural.typeName == userStructural.typeName)\n  \n  // Alphabetical ordering\n  assert(personStructural.typeName.toString.contains(\"age\"))\n  assert(personStructural.typeName.toString.indexOf(\"age\") < \n         personStructural.typeName.toString.indexOf(\"name\"))\n}\n\n// Test: Integration with Into\ntest(\"structural to nominal conversion via Into\") {\n  case class Person(name: String, age: Int)\n  type PersonStructure = { def name: String; def age: Int }\n  \n  val structural: PersonStructure = new Selectable {\n    def selectDynamic(field: String): Any = field match {\n      case \"name\" => \"Alice\"\n      case \"age\" => 30\n    }\n  }\n  \n  val person = Into[PersonStructure, Person].into(structural)\n  assert(person == Right(Person(\"Alice\", 30)))\n}\n\n// Test: Round-trip via As\ntest(\"nominal to structural and back preserves data\") {\n  case class Person(name: String, age: Int)\n  type PersonStructure = { def name: String; def age: Int }\n  \n  val original = Person(\"Alice\", 30)\n  \n  val toStructural = As[Person, PersonStructure].into(original)\n  val backToNominal = toStructural.flatMap(As[Person, PersonStructure].from)\n  \n  assert(backToNominal == Right(original))\n}\n\n// Test: Recursive type compile error\ntest(\"recursive types produce compile error\") {\n  case class Tree(value: Int, children: List[Tree])\n  \n  assertDoesNotCompile(\"Schema.derived[Tree].structural\")\n}\n\n// Test: Sum type in Scala 2 compile error\ntest(\"sum types in Scala 2 produce compile error\") {\n  sealed trait Result\n  case class Success(value: Int) extends Result\n  \n  // Scala 2 only\n  assertDoesNotCompile(\"Schema.derived[Result].structural\")\n}\n```\n\n---\n\n## Implementation Notes\n\n### Macro Behavior\n\nThe macro must:\n\n1. **Detect product types** (case classes, tuples) and generate structural types with `def` members\n2. **Detect sum types** (sealed traits, enums) and:\n   - In Scala 3: Generate union types of structural representations\n   - In Scala 2: Fail with clear error message\n3. **Detect recursive types** and fail with clear error message\n4. **Normalize structural type representations** for type name generation\n5. **Generate `ToStructural` instance** with:\n   - `StructuralType` type member set to the generated structural type\n   - `apply` method that transforms the schema appropriately\n6. **Preserve field metadata** from original schema where applicable\n7. **Generate appropriate bindings** using `Selectable` (Scala 3) or `Dynamic` (Scala 2)\n\n### Schema Transformation\n\nWhen converting `Schema[A]` to `Schema[StructuralType]`:\n\n1. **Preserve field information**: Field names, types, optional/required status\n2. **Update type name**: Use normalized structural representation\n3. **Transform bindings**: Replace nominal constructors/deconstructors with structural equivalents\n4. **Preserve validation**: Maintain any validation logic that applies to field values\n5. **Handle nested schemas**: Recursively transform nested product types\n\n### Error Messages\n\nProvide clear compile-time errors:\n\n```scala\n// Recursive type\ncase class Tree(value: Int, children: List[Tree])\nSchema.derived[Tree].structural\n\n// Error:\n\"\"\"\nCannot generate structural type for recursive type Tree.\nStructural types cannot represent recursive structures.\nScala's type system does not support infinite types.\n\"\"\"\n\n// Sum type in Scala 2\nsealed trait Result\ncase class Success(value: Int) extends Result\nSchema.derived[Result].structural\n\n// Error (Scala 2 only):\n\"\"\"\nCannot generate structural type for sum type Result.\nStructural representation of sum types requires union types,\nwhich are only available in Scala 3.\nConsider upgrading to Scala 3 or using a different approach.\n\"\"\"\n```\n\n---\n\n## Deliverables\n\n1.  `ToStructural[A]` trait and macro for Scala 2.13\n2.  `ToStructural[A]` trait and macro for Scala 3.5\n3.  `structural` method on `Schema[A]`\n4.  Support for product types (case classes, tuples)\n5.  Support for sum types (sealed traits, enums) in Scala 3 only\n6.  Normalized type name generation\n7.  `Selectable` bindings (Scala 3) and `Dynamic` bindings (Scala 2)\n8.  Integration with `Into`/`As` for structural  nominal conversions\n9.  Comprehensive test suite (300+ test cases)\n10.  Clear error messages for unsupported cases\n11.  Documentation with examples",
                  "html_url": "https://github.com/zio/zio-blocks/issues/517"
                },
                "type": "github"
              },
              "hash": "zio/zio-blocks#517",
              "body": "# Structural Type Schema Support\n\n## Overview\n\nExtend `Schema[A]` to support structural types, enabling schema derivation for types defined by their structure rather than their nominal identity. This allows for duck-typed schema validation and conversion between nominal and structural representations.\n\n## Core Concepts\n\n### Direct Structural Schema Derivation\n\nSchemas can be derived directly for structural types:\n\n```scala\n// Scala 3\ntype Person = { def name: String; def age: Int }\nval schema = Schema.derived[Person]\n\n// Scala 2\ntype Person = { def name: String; def age: Int }\nval schema = Schema.derived[Person]\n```\n\n**Note**: Both Scala 2 and Scala 3 use `def` for uniformity, even though Scala 3 supports `val` in structural types.\n\n**Implementation**: Schemas have bindings, which allow construction / deconstruction of values. Values for structural types are backed by:\n- **Scala 3**: `Selectable` \n- **Scala 2**: `Dynamic`\n\n### Nominal to Structural Conversion\n\nConvert nominal type schemas to their structural equivalents:\n\n```scala\ncase class Person(name: String, age: Int)\n\n// Get the structural schema corresponding to Person's shape\nval structuralSchema: Schema[{ def name: String; def age: Int }] = \n  Schema.derived[Person].structural\n```\n\n### Schema API Extension\n\n```scala\ncase class Schema[A](/* existing fields */) {\n  /**\n   * Convert this schema to a structural type schema.\n   * \n   * The structural type represents the \"shape\" of A without its nominal identity.\n   * This enables duck typing and structural validation.\n   * \n   * @param toStructural Macro-generated conversion to structural representation\n   * @return Schema for the structural type corresponding to A\n   */\n  def structural(implicit toStructural: ToStructural[A]): Schema[toStructural.StructuralType] = \n    toStructural.apply(this)\n}\n\n/**\n * Type class for converting nominal schemas to structural schemas.\n * Generated by macro for all supported types. Macro fails if a structural\n * type cannot be generated.\n *\n * NOTE: This approach has to be tested to yield inferrable types, and revised\n * if necessary. Inferrable types (from calling Schema#structural) are a must-have.\n */\ntrait ToStructural[A] {\n  type StructuralType\n  def apply(schema: Schema[A]): Schema[StructuralType]\n}\n\nobject ToStructural {\n  type Aux[A, S] = ToStructural[A] { type StructuralType = S }\n  \n  // Scala 3\n  transparent inline given [A]: ToStructural[A] = ${toStructuralMacro[A]}\n  \n  // Scala 2\n  implicit def materialize[A]: ToStructural[A] = macro toStructuralImpl[A]\n}\n```\n\n---\n\n## Examples\n\n### 1. Simple Product Types\n\n#### Case Class to Structural\n\n```scala\n// Both Scala 2 and Scala 3\ncase class Person(name: String, age: Int)\n\n// Original nominal schema\nval nominalSchema: Schema[Person] = Schema.derived[Person]\n\n// Convert to structural\nval structuralSchema: Schema[{ def name: String; def age: Int }] = \n  nominalSchema.structural\n\n// Direct structural derivation (equivalent)\nval directStructural: Schema[{ def name: String; def age: Int }] = \n  Schema.derived[{ def name: String; def age: Int }]\n```\n\n### 2. Nested Structures\n\n```scala\ncase class Address(street: String, city: String, zip: Int)\ncase class Person(name: String, age: Int, address: Address)\n\nval structuralSchema = Schema.derived[Person].structural\n// Type: Schema[{ \n//   def name: String\n//   def age: Int\n//   def address: { def street: String; def city: String; def zip: Int }\n// }]\n```\n\n### 3. Collections and Options\n\n```scala\ncase class Team(name: String, members: List[String], leader: Option[String])\n\nval structuralSchema = Schema.derived[Team].structural\n// Type: Schema[{\n//   def name: String\n//   def members: List[String]\n//   def leader: Option[String]\n// }]\n```\n\n### 4. Tuples to Structural\n\n```scala\n// Tuples can be converted to structural types\nval tupleSchema: Schema[(String, Int, Boolean)] = Schema.derived[(String, Int, Boolean)]\n\nval structuralSchema = tupleSchema.structural\n// Type: Schema[{ def _1: String; def _2: Int; def _3: Boolean }]\n```\n\n### 5. Sum Types (Sealed Traits) - Scala 3 Only\n\nSealed traits become union types of structural representations, with tag information stored at the type level:\n\n```scala\n// Scala 3 only\nsealed trait Result\ncase class Success(value: Int) extends Result\ncase class Failure(error: String) extends Result\n\nval structuralSchema = Schema.derived[Result].structural\n// Type: Schema[\n//   { type Tag = \"Success\"; def value: Int } | { type Tag = \"Failure\"; def error: String }\n// ]\n```\n\n**Note**: Sum type to structural conversion is **not supported in Scala 2** because it requires union types. Attempting to call `.structural` on a sealed trait schema in Scala 2 will result in a compile-time error.\n\n### 6. Enums (Scala 3 Only)\n\n```scala\nenum Status:\n  case Active, Inactive, Suspended\n\nval structuralSchema = Schema.derived[Status].structural\n// Type: Schema[{type Tag = \"Active\"} | {type Tag = \"Inactive\"} | {type Tag = \"Suspended\"}]\n```\n\n### 7. Opaque Types (Scala 3)\n\n```scala\nopaque type UserId = String\nobject UserId:\n  def apply(value: String): Either[String, UserId] = \n    if value.nonEmpty then Right(value) else Left(\"Empty user ID\")\n\ncase class User(id: UserId, name: String)\n\nval structuralSchema = Schema.derived[User].structural\n// Type: Schema[{ def id: String; def name: String }]\n// Opaque type is unwrapped to its underlying type\n```\n\n### 8. Bidirectional Conversion\n\nStructural schemas work seamlessly with `Into`/`As` (if this ticket is implemented **after** that ticket):\n\n```scala\ncase class Person(name: String, age: Int)\n\nval structuralSchema = Schema.derived[Person].structural\n\n// Create structural value (Scala 3)\nval structuralPerson = new Selectable {\n  def selectDynamic(field: String): Any = field match {\n    case \"name\" => \"Alice\"\n    case \"age\" => 30\n  }\n}\n\n// Convert structural to nominal using Into\nval person: Either[SchemaError, Person] = \n  Into[{ def name: String; def age: Int }, Person].into(structuralPerson)\n// => Right(Person(\"Alice\", 30))\n\n// Convert nominal to structural\nval backToStructural: Either[SchemaError, { def name: String; def age: Int }] = \n  Into[Person, { def name: String; def age: Int }].into(Person(\"Bob\", 25))\n```\n\n### 9. Empty and Single-Field Products\n\n```scala\n// Empty case class\ncase class Empty()\nval emptyStructural = Schema.derived[Empty].structural\n// Type: Schema[{}]\n\n// Single field\ncase class Id(value: String)\nval idStructural = Schema.derived[Id].structural\n// Type: Schema[{ def value: String }]\n```\n\n### 10. Large Products\n\n```scala\ncase class LargeRecord(\n  f1: String, f2: Int, f3: Boolean, f4: Double, f5: Long,\n  f6: String, f7: Int, f8: Boolean, f9: Double, f10: Long,\n  f11: String, f12: Int, f13: Boolean, f14: Double, f15: Long,\n  f16: String, f17: Int, f18: Boolean, f19: Double, f20: Long,\n  f21: String\n)\n\nval structuralSchema = Schema.derived[LargeRecord].structural\n// Type: Schema[{\n//   def f1: String; def f2: Int; def f3: Boolean; ...\n//   def f21: String\n// }]\n```\n\n---\n\n## Type Name Handling\n\n### Current Limitation\n\nSchemas currently use `TypeName[A]` to identify types. Structural types don't have meaningful nominal type names, which creates a mismatch.\n\n### Temporary Solution\n\nUntil `TypeName[A]` is replaced with `TypeId[A]` (see issue #471), structural schemas will use a normalized string representation of the structural type as a fake type name:\n\n```scala\ncase class Person(name: String, age: Int)\n\nval schema = Schema.derived[Person]\nschema.typeName // => TypeName for \"Person\"\n\nval structural = schema.structural\nstructural.typeName // => TypeName for \"{age:Int,name:String}\"\n// Normalized: fields sorted alphabetically, types fully qualified\n```\n\n### Normalization Rules\n\n1. **Field ordering**: Alphabetical by field name\n2. **Type qualification**: Use simple names for primitives and standard library types\n3. **Whitespace**: No whitespace in generated names\n4. **Collections**: Standard notation (e.g., `List[Int]`)\n5. **Options**: Explicit `Option[T]` notation\n6. **Nested structures**: Recursive application of rules\n7. **Deterministic**: Same structure always produces same normalized name\n\n### Examples\n\n```scala\n// Simple product\ncase class Point(x: Int, y: Int)\nSchema.derived[Point].structural.typeName \n// => \"{x:Int,y:Int}\"\n\n// Nested product\ncase class Address(street: String, zip: Int)\ncase class Person(name: String, address: Address)\nSchema.derived[Person].structural.typeName\n// => \"{address:{street:String,zip:Int},name:String}\"\n\n// With collections\ncase class Team(name: String, members: List[String])\nSchema.derived[Team].structural.typeName\n// => \"{members:List[String],name:String}\"\n\n// Union type (Scala 3)\nsealed trait Result\ncase class Success(value: Int) extends Result\ncase class Failure(error: String) extends Result\nSchema.derived[Result].structural.typeName\n// => \"{error:String}|{value:Int}\"\n```\n\n### Future: TypeId[A]\n\nThe upcoming `TypeId[A]` replacement will properly handle structural types by representing them by their structure rather than a string-based hack. See issue #471 for details.\n\n---\n\n## Limitations and Edge Cases\n\n### 1. Generic Types\n\n**Behavior depends on existing Schema derivation support for generic types.**\n\nIf `Schema.derived[Container[Int]]` already works, then structural conversion should work:\n\n```scala\ncase class Container[T](value: T)\n\n// If this works:\nval schema = Schema.derived[Container[Int]]\n\n// Then this should work:\nval structural = schema.structural\n// Type: Schema[{ def value: Int }]\n```\n\nIf generic type derivation is not currently supported, this ticket **does not require implementing it**. The macro should produce a clear compile-time error for unsupported generic types.\n\n### 2. Recursive Types\n\nRecursive types will **fail at compile-time** because Scala does not support infinite types:\n\n```scala\ncase class Tree(value: Int, children: List[Tree])\n\n// This will FAIL at compile-time:\nval structural = Schema.derived[Tree].structural\n// Compile error: Cannot generate infinite structural type\n\n// The structural type would need to be:\n// { def value: Int; def children: List[{ def value: Int; def children: List[...] }] }\n// which is infinite and unsupported\n```\n\nThe macro must detect recursive types and produce a helpful error message:\n\n```\nCompile error: Cannot generate structural type for recursive type Tree.\nStructural types cannot represent recursive structures.\n```\n\n### 3. Mutually Recursive Types\n\nSimilarly, mutually recursive types are unsupported:\n\n```scala\ncase class Node(id: Int, edges: List[Edge])\ncase class Edge(from: Int, to: Node)\n\n// This will FAIL at compile-time:\nval nodeStructural = Schema.derived[Node].structural\n// Compile error: Cannot generate structural type for mutually recursive types\n```\n\n### 4. Sum Types in Scala 2\n\nSealed traits and sum types **cannot be converted to structural types in Scala 2** because they require union types:\n\n```scala\n// Scala 2\nsealed trait Result\ncase class Success(value: Int) extends Result\ncase class Failure(error: String) extends Result\n\n// This will FAIL at compile-time in Scala 2:\nval structural = Schema.derived[Result].structural\n// Compile error: Cannot generate structural type for sum types in Scala 2.\n// Union types are required, which are only available in Scala 3.\n```\n\nThe macro must detect sum types in Scala 2 and produce a clear error.\n\n### 5. Case Objects\n\nCase objects become empty structural types:\n\n```scala\ncase object Singleton\n\nval structural = Schema.derived[Singleton.type].structural\n// Type: Schema[{}]\n```\n\nFor sum types with case objects (Scala 3):\n\n```scala\nsealed trait Status\ncase object Active extends Status\ncase object Inactive extends Status\n\nval structural = Schema.derived[Status].structural\n// Type: Schema[{} | {}]\n// Not particularly useful, but valid\n```\n\n### 6. Structural Types as Source\n\nDeriving schemas directly for structural types is supported:\n\n```scala\ntype PersonStructure = { def name: String; def age: Int }\n\nval schema = Schema.derived[PersonStructure]\n// Should work if structural type derivation is implemented\n```\n\nThe schema's bindings will use `Selectable` (Scala 3) or `Dynamic` (Scala 2) to construct and deconstruct values.\n\n---\n\n## Integration with Into/As\n\nStructural schemas compose naturally with `Into`/`As` conversions.\n\n### Nominal  Structural\n\n```scala\ncase class Person(name: String, age: Int)\n\n// Auto-derived conversion\nval nominalToStructural: Into[Person, { def name: String; def age: Int }] = \n  Into.derived\n\nval person = Person(\"Alice\", 30)\nval structural = nominalToStructural.into(person)\n// => Right(<Selectable/Dynamic instance>)\n```\n\n### Structural  Nominal\n\n```scala\ntype PersonStructure = { def name: String; def age: Int }\ncase class Person(name: String, age: Int)\n\n// Auto-derived conversion\nval structuralToNominal: Into[PersonStructure, Person] = \n  Into.derived\n\nval structural: PersonStructure = new Selectable {\n  def selectDynamic(field: String): Any = field match {\n    case \"name\" => \"Bob\"\n    case \"age\" => 25\n  }\n}\n\nval person = structuralToNominal.into(structural)\n// => Right(Person(\"Bob\", 25))\n```\n\n### Bidirectional (As)\n\n```scala\ncase class Person(name: String, age: Int)\n\n// Bidirectional conversion\nval personAs: As[Person, { def name: String; def age: Int }] = \n  As.derived\n\n// Nominal  Structural\nval structural = personAs.into(Person(\"Alice\", 30))\n\n// Structural  Nominal\nval nominal = structural.flatMap(personAs.from)\n// Round-trip successful\n```\n\n### Schema-Guided Conversion\n\n```scala\ncase class PersonV1(firstName: String, lastName: String, age: Int)\ncase class PersonV2(name: String, age: Int)\n\n// Use structural type as intermediary\ntype PersonStructure = { def name: String; def age: Int }\n\n// Step 1: Transform V1 to structural (custom logic)\nval v1ToStructural: Into[PersonV1, PersonStructure] = \n  new Into[PersonV1, PersonStructure] {\n    def into(v1: PersonV1): Either[SchemaError, PersonStructure] = {\n      Right(new Selectable {\n        def selectDynamic(field: String): Any = field match {\n          case \"name\" => s\"${v1.firstName} ${v1.lastName}\"\n          case \"age\" => v1.age\n        }\n      })\n    }\n  }\n\n// Step 2: Auto-convert structural to V2\nval structuralToV2: Into[PersonStructure, PersonV2] = Into.derived\n\n// Composed migration\ndef migrate(v1: PersonV1): Either[SchemaError, PersonV2] = {\n  v1ToStructural.into(v1).flatMap(structuralToV2.into)\n}\n```\n\n---\n\n## Testing Requirements\n\n### Test Matrix\n\n1. **Direct Structural Derivation**\n   - Simple products (case classes)\n   - Nested products\n   - Collections (List, Vector, Set, Map, Option, Either)\n   - Tuples (2-22 elements)\n   - Empty case classes\n   - Single-field case classes\n   - Large products (20+ fields)\n   - Case objects\n\n2. **Nominal to Structural Conversion**\n   - Case class  structural\n   - Tuple  structural\n   - Nested case classes  nested structural\n   - Case class with collections  structural with collections\n   - Empty case class  empty structural\n\n3. **Sum Types (Scala 3 Only)**\n   - Sealed trait  union type structural\n   - Sealed trait with case objects\n   - Enum  union type structural\n   - Nested sum types\n\n4. **Type Name Generation**\n   - Simple product normalized name\n   - Nested product normalized name\n   - Name determinism (same structure = same name)\n   - Alphabetical field ordering in names\n   - Union type names (Scala 3)\n\n5. **Selectable/Dynamic Implementation**\n   - Scala 3 Selectable field access\n   - Scala 2 Dynamic field access\n   - Field access correctness\n   - Missing field behavior\n   - Extra field behavior\n\n6. **Integration with Into/As**\n   - Nominal  Structural via Into\n   - Structural  Nominal via Into\n   - Round-trip via As\n   - Composed conversions with structural intermediary\n\n7. **Error Cases (Compile-Time)**\n   - Recursive types produce error\n   - Mutually recursive types produce error\n   - Sum types in Scala 2 produce error\n   - Unsupported types produce helpful errors\n\n8. **Generic Types** (if supported by existing Schema derivation)\n   - Fully applied generic  structural\n   - Generic with nested structural fields\n\n### Scala 2 vs Scala 3 Test Separation\n\n```\nsrc/test/scala/\n  structural/\n    common/\n      SimpleProductSpec.scala\n      NestedProductSpec.scala\n      CollectionsSpec.scala\n      TuplesSpec.scala\n      EmptyProductSpec.scala\n      SingleFieldSpec.scala\n      LargeProductSpec.scala\n      TypeNameNormalizationSpec.scala\n      IntoIntegrationSpec.scala\n      AsIntegrationSpec.scala\n      \n    scala3/\n      UnionTypesSpec.scala\n      SealedTraitToUnionSpec.scala\n      EnumToUnionSpec.scala\n      SelectableImplementationSpec.scala\n      \n    scala2/\n      DynamicImplementationSpec.scala\n      SumTypeErrorSpec.scala (verifies compile error)\n      \n    errors/\n      RecursiveTypeErrorSpec.scala\n      MutualRecursionErrorSpec.scala\n      UnsupportedTypeErrorSpec.scala\n```\n\n### Test Examples\n\n```scala\n// Test: Simple product to structural\ntest(\"case class converts to structural schema\") {\n  case class Person(name: String, age: Int)\n  \n  val structural = Schema.derived[Person].structural\n  \n  // Type check (this is a compile-time test)\n  val _: Schema[{ def name: String; def age: Int }] = structural\n  \n  assert(structural.typeName.toString.contains(\"name\"))\n  assert(structural.typeName.toString.contains(\"age\"))\n}\n\n// Test: Nested products\ntest(\"nested case classes convert to nested structural\") {\n  case class Address(street: String, zip: Int)\n  case class Person(name: String, address: Address)\n  \n  val structural = Schema.derived[Person].structural\n  \n  val _: Schema[{ \n    def name: String\n    def address: { def street: String; def zip: Int }\n  }] = structural\n}\n\n// Test: Tuple to structural\ntest(\"tuple converts to structural with _N fields\") {\n  val structural = Schema.derived[(String, Int, Boolean)].structural\n  \n  val _: Schema[{ def _1: String; def _2: Int; def _3: Boolean }] = structural\n}\n\n// Test: Union type (Scala 3 only)\ntest(\"sealed trait converts to union type structural\") {\n  sealed trait Result\n  case class Success(value: Int) extends Result\n  case class Failure(error: String) extends Result\n  \n  val structural = Schema.derived[Result].structural\n  \n  val _: Schema[{ def value: Int } | { def error: String }] = structural\n}\n\n// Test: Type name normalization\ntest(\"structural type names are normalized and deterministic\") {\n  case class Person(name: String, age: Int)\n  case class User(age: Int, name: String) // Different field order\n  \n  val personStructural = Schema.derived[Person].structural\n  val userStructural = Schema.derived[User].structural\n  \n  // Same structure, same normalized name\n  assert(personStructural.typeName == userStructural.typeName)\n  \n  // Alphabetical ordering\n  assert(personStructural.typeName.toString.contains(\"age\"))\n  assert(personStructural.typeName.toString.indexOf(\"age\") < \n         personStructural.typeName.toString.indexOf(\"name\"))\n}\n\n// Test: Integration with Into\ntest(\"structural to nominal conversion via Into\") {\n  case class Person(name: String, age: Int)\n  type PersonStructure = { def name: String; def age: Int }\n  \n  val structural: PersonStructure = new Selectable {\n    def selectDynamic(field: String): Any = field match {\n      case \"name\" => \"Alice\"\n      case \"age\" => 30\n    }\n  }\n  \n  val person = Into[PersonStructure, Person].into(structural)\n  assert(person == Right(Person(\"Alice\", 30)))\n}\n\n// Test: Round-trip via As\ntest(\"nominal to structural and back preserves data\") {\n  case class Person(name: String, age: Int)\n  type PersonStructure = { def name: String; def age: Int }\n  \n  val original = Person(\"Alice\", 30)\n  \n  val toStructural = As[Person, PersonStructure].into(original)\n  val backToNominal = toStructural.flatMap(As[Person, PersonStructure].from)\n  \n  assert(backToNominal == Right(original))\n}\n\n// Test: Recursive type compile error\ntest(\"recursive types produce compile error\") {\n  case class Tree(value: Int, children: List[Tree])\n  \n  assertDoesNotCompile(\"Schema.derived[Tree].structural\")\n}\n\n// Test: Sum type in Scala 2 compile error\ntest(\"sum types in Scala 2 produce compile error\") {\n  sealed trait Result\n  case class Success(value: Int) extends Result\n  \n  // Scala 2 only\n  assertDoesNotCompile(\"Schema.derived[Result].structural\")\n}\n```\n\n---\n\n## Implementation Notes\n\n### Macro Behavior\n\nThe macro must:\n\n1. **Detect product types** (case classes, tuples) and generate structural types with `def` members\n2. **Detect sum types** (sealed traits, enums) and:\n   - In Scala 3: Generate union types of structural representations\n   - In Scala 2: Fail with clear error message\n3. **Detect recursive types** and fail with clear error message\n4. **Normalize structural type representations** for type name generation\n5. **Generate `ToStructural` instance** with:\n   - `StructuralType` type member set to the generated structural type\n   - `apply` method that transforms the schema appropriately\n6. **Preserve field metadata** from original schema where applicable\n7. **Generate appropriate bindings** using `Selectable` (Scala 3) or `Dynamic` (Scala 2)\n\n### Schema Transformation\n\nWhen converting `Schema[A]` to `Schema[StructuralType]`:\n\n1. **Preserve field information**: Field names, types, optional/required status\n2. **Update type name**: Use normalized structural representation\n3. **Transform bindings**: Replace nominal constructors/deconstructors with structural equivalents\n4. **Preserve validation**: Maintain any validation logic that applies to field values\n5. **Handle nested schemas**: Recursively transform nested product types\n\n### Error Messages\n\nProvide clear compile-time errors:\n\n```scala\n// Recursive type\ncase class Tree(value: Int, children: List[Tree])\nSchema.derived[Tree].structural\n\n// Error:\n\"\"\"\nCannot generate structural type for recursive type Tree.\nStructural types cannot represent recursive structures.\nScala's type system does not support infinite types.\n\"\"\"\n\n// Sum type in Scala 2\nsealed trait Result\ncase class Success(value: Int) extends Result\nSchema.derived[Result].structural\n\n// Error (Scala 2 only):\n\"\"\"\nCannot generate structural type for sum type Result.\nStructural representation of sum types requires union types,\nwhich are only available in Scala 3.\nConsider upgrading to Scala 3 or using a different approach.\n\"\"\"\n```\n\n---\n\n## Deliverables\n\n1.  `ToStructural[A]` trait and macro for Scala 2.13\n2.  `ToStructural[A]` trait and macro for Scala 3.5\n3.  `structural` method on `Schema[A]`\n4.  Support for product types (case classes, tuples)\n5.  Support for sum types (sealed traits, enums) in Scala 3 only\n6.  Normalized type name generation\n7.  `Selectable` bindings (Scala 3) and `Dynamic` bindings (Scala 2)\n8.  Integration with `Into`/`As` for structural  nominal conversions\n9.  Comprehensive test suite (300+ test cases)\n10.  Clear error messages for unsupported cases\n11.  Documentation with examples",
              "url": "https://github.com/zio/zio-blocks/issues/517",
              "tech": [],
              "repo_name": "zio-blocks",
              "repo_owner": "zio",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "ZIO#685",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "ZIO",
              "id": "generated-ZIO",
              "name": "ZIO",
              "description": "",
              "members": [],
              "display_name": "ZIO",
              "created_at": "2026-01-26T23:56:54.910Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/ZIO?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "zio",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-26T23:56:54.910Z",
            "created_at": "2026-01-26T23:56:54.910Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-ZIO#685",
              "status": "open",
              "type": "issue",
              "number": 685,
              "title": "Add JsonPatch - Depends on #679",
              "source": {
                "data": {
                  "id": "source-ZIO#685",
                  "user": {
                    "login": "jdegoes",
                    "id": 156745,
                    "node_id": "MDQ6VXNlcjE1Njc0NQ==",
                    "avatar_url": "https://avatars.githubusercontent.com/u/156745?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/jdegoes",
                    "html_url": "https://github.com/jdegoes",
                    "followers_url": "https://api.github.com/users/jdegoes/followers",
                    "following_url": "https://api.github.com/users/jdegoes/following{/other_user}",
                    "gists_url": "https://api.github.com/users/jdegoes/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/jdegoes/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/jdegoes/subscriptions",
                    "organizations_url": "https://api.github.com/users/jdegoes/orgs",
                    "repos_url": "https://api.github.com/users/jdegoes/repos",
                    "events_url": "https://api.github.com/users/jdegoes/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/jdegoes/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Add JsonPatch - Depends on #679",
                  "body": "<html><head></head><body><h1>Add <code>JsonPatch</code> type for diffing and patching JSON values</h1>\n<h2>Summary</h2>\n<p>Implement a <code>JsonPatch</code> type that enables computing diffs between JSON values and applying patches to transform one JSON value into another. This type should mirror the existing <code>DynamicPatch</code> implementation, adapted for JSON's simpler data model.</p>\n<h2>Motivation</h2>\n<p><code>DynamicValue</code> has a well-designed <code>DynamicPatch</code> system with:</p>\n<ul>\n<li>Monoid composition (<code>++</code> with <code>empty</code> identity)</li>\n<li>LCS-based sequence diffing</li>\n<li>Primitive delta operations (numeric deltas, string edits)</li>\n<li>Comprehensive algebraic laws verified by property tests</li>\n</ul>\n<p>The proposed <code>Json</code> type (see #TBD) needs equivalent patching capabilities. Rather than converting <code>Json  DynamicValue</code> for every patch operation, a native <code>JsonPatch</code> provides:</p>\n<ul>\n<li>Type safety (no conversion errors for JSON-incompatible DynamicPatch operations)</li>\n<li>API consistency with the <code>Json</code> type</li>\n<li>Potential for JSON-specific optimizations</li>\n</ul>\n<h2>Design Sketch</h2>\n<p>A design sketch is available at <a href=\"https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/json/JsonPatch.scala\"><code>schema/shared/src/main/scala/zio/blocks/schema/json/JsonPatch.scala</code></a>. This sketch is <strong>a guide, not a specification</strong>  implementers should use judgment and deviate where appropriate.</p>\n<h3>Core Types</h3>\n<p>The design mirrors <code>DynamicPatch</code> with JSON-specific adaptations:</p>\n\nDynamicPatch | JsonPatch | Notes\n-- | -- | --\nDynamicPatch(Vector[DynamicPatchOp]) | JsonPatch(Vector[JsonPatchOp]) | Same structure\nOperation.Set | Op.Set | Same\nOperation.PrimitiveDelta | Op.PrimitiveDelta | Simplified for JSON types\nOperation.SequenceEdit | Op.ArrayEdit | Renamed\nOperation.MapEdit | Op.ObjectEdit | String keys only\nOperation.Patch | Op.Nested | Same\nSeqOp | ArrayOp | Same operations\nMapOp | ObjectOp | String keys only\nPrimitiveOp (14 variants) | PrimitiveOp (2 variants) | See below\n\n\n<h3>StringOp</h3>\n<p>Mirror <code>DynamicPatch.StringOp</code> exactly:</p>\n<ul>\n<li><code>Insert(index: Int, text: String)</code></li>\n<li><code>Delete(index: Int, length: Int)</code></li>\n<li><code>Append(text: String)</code></li>\n<li><code>Modify(index: Int, length: Int, text: String)</code></li>\n</ul>\n<h3>ArrayOp</h3>\n<p>Mirror <code>DynamicPatch.SeqOp</code>:</p>\n<ul>\n<li><code>Insert(index: Int, values: Vector[Json])</code></li>\n<li><code>Append(values: Vector[Json])</code></li>\n<li><code>Delete(index: Int, count: Int)</code></li>\n<li><code>Modify(index: Int, op: Op)</code></li>\n</ul>\n<h3>ObjectOp</h3>\n<p>Mirror <code>DynamicPatch.MapOp</code> with string keys:</p>\n<ul>\n<li><code>Add(key: String, value: Json)</code></li>\n<li><code>Remove(key: String)</code></li>\n<li><code>Modify(key: String, patch: JsonPatch)</code></li>\n</ul>\n<h2>Requirements</h2>\n<h3>Functional Requirements</h3>\n<ul>\n<li>[ ] <strong>F1</strong>: <code>JsonPatch.diff(source, target)</code> computes a patch transforming source to target</li>\n<li>[ ] <strong>F2</strong>: <code>patch.apply(json, mode)</code> applies a patch with configurable failure handling</li>\n<li>[ ] <strong>F3</strong>: <code>patch1 ++ patch2</code> composes patches (apply first, then second)</li>\n<li>[ ] <strong>F4</strong>: <code>JsonPatch.empty</code> is the identity element for composition</li>\n<li>[ ] <strong>F5</strong>: Support <code>JsonPatchMode.Strict</code>, <code>Lenient</code>, and <code>Clobber</code> modes</li>\n<li>[ ] <strong>F6</strong>: Bidirectional conversion: <code>toDynamicPatch</code> / <code>fromDynamicPatch</code></li>\n</ul>\n<h3>Algebraic Laws</h3>\n<p>All laws must be verified with property-based tests (see <code>PatchLawsSpec</code> for reference):</p>\n<ul>\n<li>[ ] <strong>L1</strong>: Left identity  <code>(empty ++ p)(j) == p(j)</code></li>\n<li>[ ] <strong>L2</strong>: Right identity  <code>(p ++ empty)(j) == p(j)</code></li>\n<li>[ ] <strong>L3</strong>: Associativity  <code>((p1 ++ p2) ++ p3)(j) == (p1 ++ (p2 ++ p3))(j)</code></li>\n<li>[ ] <strong>L4</strong>: Roundtrip  <code>diff(a, b)(a) == Right(b)</code></li>\n<li>[ ] <strong>L5</strong>: Identity diff  <code>diff(j, j).isEmpty</code></li>\n<li>[ ] <strong>L6</strong>: Diff composition  <code>(diff(a, b) ++ diff(b, c))(a) == Right(c)</code></li>\n<li>[ ] <strong>L7</strong>: Lenient subsumes Strict  if <code>p(j, Strict) == Right(r)</code> then <code>p(j, Lenient) == Right(r)</code></li>\n</ul>\n<h3>Testing Requirements</h3>\n<ul>\n<li>[ ] <strong>T1</strong>: Property-based tests for all algebraic laws (see <code>PatchLawsSpec</code>)</li>\n<li>[ ] <strong>T2</strong>: Test each operation type (<code>Set</code>, <code>PrimitiveDelta</code>, <code>ArrayEdit</code>, <code>ObjectEdit</code>, <code>Nested</code>)</li>\n<li>[ ] <strong>T3</strong>: Test each <code>ArrayOp</code> variant (<code>Insert</code>, <code>Append</code>, <code>Delete</code>, <code>Modify</code>)</li>\n<li>[ ] <strong>T4</strong>: Test each <code>ObjectOp</code> variant (<code>Add</code>, <code>Remove</code>, <code>Modify</code>)</li>\n<li>[ ] <strong>T5</strong>: Test each <code>StringOp</code> variant (<code>Insert</code>, <code>Delete</code>, <code>Append</code>, <code>Modify</code>)</li>\n<li>[ ] <strong>T6</strong>: Test <code>NumberDelta</code> with positive, negative, zero, and decimal deltas</li>\n<li>[ ] <strong>T7</strong>: Test all three <code>JsonPatchMode</code> behaviors</li>\n<li>[ ] <strong>T8</strong>: Test <code>toDynamicPatch</code> / <code>fromDynamicPatch</code> roundtrip</li>\n<li>[ ] <strong>T9</strong>: Test edge cases: empty arrays, empty objects, empty strings, nested structures</li>\n<li>[ ] <strong>T10</strong>: Test error cases: invalid paths, type mismatches, out-of-bounds indices</li>\n</ul>\n<h3>Documentation Requirements</h3>\n<ul>\n<li>[ ] <strong>D1</strong>: ScalaDoc for all public types and methods</li>\n<li>[ ] <strong>D2</strong>: Usage examples in ScalaDoc (see sketch for examples)</li>\n<li>[ ] <strong>D3</strong>: Document algebraic laws in type-level comments</li>\n<li>[ ] <strong>D4</strong>: Document relationship to <code>DynamicPatch</code></li>\n</ul>\n<h3>Implementation Notes</h3>\n<ol>\n<li>\n<p><strong>Follow <code>DynamicPatch</code> patterns</strong>: The implementation in <code>DynamicPatch.scala</code> is the reference. Study <code>Differ.scala</code> for diff algorithms (especially LCS for sequences and strings).</p>\n</li>\n<li>\n<p><strong>Reuse algorithms where possible</strong>: Consider whether <code>JsonPatch</code> can delegate to <code>DynamicPatch</code> internally, or share algorithm implementations.</p>\n</li>\n<li>\n<p><strong>Keep it minimal</strong>: Resist adding operations not present in <code>DynamicPatch</code>. The design is intentionally minimal and principled.</p>\n</li>\n<li>\n<p><strong>Performance considerations</strong>: The register-based design of ZIO Blocks prioritizes performance. Avoid unnecessary allocations in hot paths.</p>\n</li>\n</ol>\n<h2>Out of Scope</h2>\n<p>The following are explicitly <strong>not</strong> part of this issue:</p>\n<ul>\n<li>RFC 6902 JSON Patch serialization format (separate issue)</li>\n<li>Patch inversion / undo support (separate issue)</li>\n<li>Patch optimization / compaction (separate issue)</li>\n<li>Integration with <code>Json</code> type methods like <code>json.diff(other)</code> (depends on <code>Json</code> implementation)</li>\n</ul>\n<h2>Related</h2>\n<ul>\n<li><code>DynamicPatch</code>  <a href=\"https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/DynamicPatch.scala\"><code>schema/shared/src/main/scala/zio/blocks/schema/patch/DynamicPatch.scala</code></a></li>\n<li><code>Differ</code>  <a href=\"https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/Differ.scala\"><code>schema/shared/src/main/scala/zio/blocks/schema/patch/Differ.scala</code></a></li>\n<li><code>PatchLawsSpec</code>  <a href=\"https://claude.ai/chat/schema/shared/src/test/scala/zio/blocks/schema/patch/PatchLawsSpec.scala\"><code>schema/shared/src/test/scala/zio/blocks/schema/patch/PatchLawsSpec.scala</code></a></li>\n<li><code>PatchMode</code>  <a href=\"https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/PatchMode.scala\"><code>schema/shared/src/main/scala/zio/blocks/schema/patch/PatchMode.scala</code></a></li>\n</ul>\n<h2>Acceptance Criteria</h2>\n<ul>\n<li>[ ] All functional requirements (F1-F6) implemented</li>\n<li>[ ] All algebraic laws (L1-L7) pass property-based tests</li>\n<li>[ ] All testing requirements (T1-T10) have corresponding test cases</li>\n<li>[ ] All documentation requirements (D1-D4) complete</li>\n<li>[ ] Code reviewed and approved</li>\n<li>[ ] CI passing</li>\n</ul></body></html># Add `JsonPatch` type for diffing and patching JSON values\n\n## Summary\n\nImplement a `JsonPatch` type that enables computing diffs between JSON values and applying patches to transform one JSON value into another. This type should mirror the existing `DynamicPatch` implementation, adapted for JSON's simpler data model.\n\n## Motivation\n\n`DynamicValue` has a well-designed `DynamicPatch` system with:\n- Monoid composition (`++` with `empty` identity)\n- LCS-based sequence diffing\n- Primitive delta operations (numeric deltas, string edits)\n- Comprehensive algebraic laws verified by property tests\n\nThe proposed `Json` type (see #TBD) needs equivalent patching capabilities. Rather than converting `Json  DynamicValue` for every patch operation, a native `JsonPatch` provides:\n- Type safety (no conversion errors for JSON-incompatible DynamicPatch operations)\n- API consistency with the `Json` type\n- Potential for JSON-specific optimizations\n\n## Design Sketch\n\nA design sketch is available at [`[schema/shared/src/main/scala/zio/blocks/schema/json/JsonPatch.scala](https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/json/JsonPatch.scala)`](./schema/shared/src/main/scala/zio/blocks/schema/json/JsonPatch.scala). This sketch is **a guide, not a specification**  implementers should use judgment and deviate where appropriate.\n\n### Core Types\n\nThe design mirrors `DynamicPatch` with JSON-specific adaptations:\n\n| DynamicPatch | JsonPatch | Notes |\n|--------------|-----------|-------|\n| `DynamicPatch(Vector[DynamicPatchOp])` | `JsonPatch(Vector[JsonPatchOp])` | Same structure |\n| `Operation.Set` | `Op.Set` | Same |\n| `Operation.PrimitiveDelta` | `Op.PrimitiveDelta` | Simplified for JSON types |\n| `Operation.SequenceEdit` | `Op.ArrayEdit` | Renamed |\n| `Operation.MapEdit` | `Op.ObjectEdit` | String keys only |\n| `Operation.Patch` | `Op.Nested` | Same |\n| `SeqOp` | `ArrayOp` | Same operations |\n| `MapOp` | `ObjectOp` | String keys only |\n| `PrimitiveOp` (14 variants) | `PrimitiveOp` (2 variants) | See below |\n\n### Primitive Operations\n\nJSON has a simpler type system than `DynamicValue`:\n\n| JSON Type | Delta Operation | Notes |\n|-----------|-----------------|-------|\n| Number | `NumberDelta(BigDecimal)` | Unifies all numeric deltas |\n| String | `StringEdit(Vector[StringOp])` | Same as `DynamicPatch` |\n| Boolean | Use `Op.Set` | No delta (same as `DynamicPatch`) |\n| Null | Use `Op.Set` | No delta |\n\n### StringOp\n\nMirror `DynamicPatch.StringOp` exactly:\n- `Insert(index: Int, text: String)`\n- `Delete(index: Int, length: Int)`\n- `Append(text: String)`\n- `Modify(index: Int, length: Int, text: String)`\n\n### ArrayOp\n\nMirror `DynamicPatch.SeqOp`:\n- `Insert(index: Int, values: Vector[Json])`\n- `Append(values: Vector[Json])`\n- `Delete(index: Int, count: Int)`\n- `Modify(index: Int, op: Op)`\n\n### ObjectOp\n\nMirror `DynamicPatch.MapOp` with string keys:\n- `Add(key: String, value: Json)`\n- `Remove(key: String)`\n- `Modify(key: String, patch: JsonPatch)`\n\n## Requirements\n\n### Functional Requirements\n\n- [ ] **F1**: `JsonPatch.diff(source, target)` computes a patch transforming source to target\n- [ ] **F2**: `patch.apply(json, mode)` applies a patch with configurable failure handling\n- [ ] **F3**: `patch1 ++ patch2` composes patches (apply first, then second)\n- [ ] **F4**: `JsonPatch.empty` is the identity element for composition\n- [ ] **F5**: Support `JsonPatchMode.Strict`, `Lenient`, and `Clobber` modes\n- [ ] **F6**: Bidirectional conversion: `toDynamicPatch` / `fromDynamicPatch`\n\n### Algebraic Laws\n\nAll laws must be verified with property-based tests (see `PatchLawsSpec` for reference):\n\n- [ ] **L1**: Left identity  `(empty ++ p)(j) == p(j)`\n- [ ] **L2**: Right identity  `(p ++ empty)(j) == p(j)`\n- [ ] **L3**: Associativity  `((p1 ++ p2) ++ p3)(j) == (p1 ++ (p2 ++ p3))(j)`\n- [ ] **L4**: Roundtrip  `diff(a, b)(a) == Right(b)`\n- [ ] **L5**: Identity diff  `diff(j, j).isEmpty`\n- [ ] **L6**: Diff composition  `(diff(a, b) ++ diff(b, c))(a) == Right(c)`\n- [ ] **L7**: Lenient subsumes Strict  if `p(j, Strict) == Right(r)` then `p(j, Lenient) == Right(r)`\n\n### Testing Requirements\n\n- [ ] **T1**: Property-based tests for all algebraic laws (see `PatchLawsSpec`)\n- [ ] **T2**: Test each operation type (`Set`, `PrimitiveDelta`, `ArrayEdit`, `ObjectEdit`, `Nested`)\n- [ ] **T3**: Test each `ArrayOp` variant (`Insert`, `Append`, `Delete`, `Modify`)\n- [ ] **T4**: Test each `ObjectOp` variant (`Add`, `Remove`, `Modify`)\n- [ ] **T5**: Test each `StringOp` variant (`Insert`, `Delete`, `Append`, `Modify`)\n- [ ] **T6**: Test `NumberDelta` with positive, negative, zero, and decimal deltas\n- [ ] **T7**: Test all three `JsonPatchMode` behaviors\n- [ ] **T8**: Test `toDynamicPatch` / `fromDynamicPatch` roundtrip\n- [ ] **T9**: Test edge cases: empty arrays, empty objects, empty strings, nested structures\n- [ ] **T10**: Test error cases: invalid paths, type mismatches, out-of-bounds indices\n\n### Documentation Requirements\n\n- [ ] **D1**: ScalaDoc for all public types and methods\n- [ ] **D2**: Usage examples in ScalaDoc (see sketch for examples)\n- [ ] **D3**: Document algebraic laws in type-level comments\n- [ ] **D4**: Document relationship to `DynamicPatch`\n\n## Related\n\n- `DynamicPatch`  [`[schema/shared/src/main/scala/zio/blocks/schema/patch/DynamicPatch.scala](https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/DynamicPatch.scala)`](./schema/shared/src/main/scala/zio/blocks/schema/patch/DynamicPatch.scala)\n- `Differ`  [`[schema/shared/src/main/scala/zio/blocks/schema/patch/Differ.scala](https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/Differ.scala)`](./schema/shared/src/main/scala/zio/blocks/schema/patch/Differ.scala)\n- `PatchLawsSpec`  [`[schema/shared/src/test/scala/zio/blocks/schema/patch/PatchLawsSpec.scala](https://claude.ai/chat/schema/shared/src/test/scala/zio/blocks/schema/patch/PatchLawsSpec.scala)`](./schema/shared/src/test/scala/zio/blocks/schema/patch/PatchLawsSpec.scala)\n- `PatchMode`  [`[schema/shared/src/main/scala/zio/blocks/schema/patch/PatchMode.scala](https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/PatchMode.scala)`](./schema/shared/src/main/scala/zio/blocks/schema/patch/PatchMode.scala)\n\n## Acceptance Criteria\n\n- [ ] All functional requirements (F1-F6) implemented\n- [ ] All algebraic laws (L1-L7) pass property-based tests\n- [ ] All testing requirements (T1-T10) have corresponding test cases\n- [ ] All documentation requirements (D1-D4) complete\n- [ ] Code reviewed and approved\n- [ ] CI passing\n\n# Sketch\n\n```scala\npackage zio.blocks.schema.json\n\nimport zio.blocks.schema.DynamicOptic\nimport zio.blocks.schema.patch.DynamicPatch\n\n// =============================================================================\n// JSON PATCH\n// =============================================================================\n\n/**\n * An untyped patch that operates on [[Json]] values.\n *\n * `JsonPatch` is the JSON-specific counterpart to [[DynamicPatch]]. It represents\n * a sequence of operations that transform one JSON value into another. Patches\n * are serializable and composable.\n *\n * ==Design==\n *\n * This type directly mirrors [[DynamicPatch]] but is specialized for JSON's\n * simpler data model:\n *  - JSON has 4 leaf types (String, Number, Boolean, Null) vs 30 PrimitiveValues\n *  - JSON objects have string keys only (no arbitrary-keyed maps)\n *  - JSON has no native Variant type\n *\n * ==Algebraic Laws==\n *\n * '''Monoid Laws''' (under `++` composition):\n * {{{\n * // 1. LEFT IDENTITY\n *  p: JsonPatch, j: Json.\n *   (JsonPatch.empty ++ p)(j, mode) == p(j, mode)\n *\n * // 2. RIGHT IDENTITY\n *  p: JsonPatch, j: Json.\n *   (p ++ JsonPatch.empty)(j, mode) == p(j, mode)\n *\n * // 3. ASSOCIATIVITY\n *  p1, p2, p3: JsonPatch, j: Json.\n *   ((p1 ++ p2) ++ p3)(j, mode) == (p1 ++ (p2 ++ p3))(j, mode)\n * }}}\n *\n * '''Diff/Apply Laws''':\n * {{{\n * // 4. ROUNDTRIP\n *  source, target: Json.\n *   JsonPatch.diff(source, target)(source, Strict) == Right(target)\n *\n * // 5. IDENTITY DIFF\n *  j: Json.\n *   JsonPatch.diff(j, j).isEmpty == true\n *\n * // 6. DIFF COMPOSITION\n *  a, b, c: Json.\n *   (JsonPatch.diff(a, b) ++ JsonPatch.diff(b, c))(a, Strict) == Right(c)\n * }}}\n *\n * '''PatchMode Laws''':\n * {{{\n * // 7. STRICT FAILS ON ERROR\n * // Strict mode fails on first precondition violation\n *\n * // 8. LENIENT SKIPS ERRORS\n * // Lenient mode skips failing operations, always returns Right\n *\n * // 9. LENIENT SUBSUMES STRICT\n *  p: JsonPatch, j: Json.\n *   p(j, Strict) == Right(r) implies p(j, Lenient) == Right(r)\n *\n * // 10. CLOBBER FORCES SUCCESS\n * // Clobber mode creates missing paths, always returns Right\n * }}}\n *\n * @param ops The sequence of patch operations\n */\nfinal case class JsonPatch(ops: Vector[JsonPatch.JsonPatchOp]) {\n\n  /**\n   * Applies this patch to a JSON value.\n   *\n   * @param json The JSON value to patch\n   * @param mode The patch mode (default: Strict)\n   * @return Either an error or the patched value\n   */\n  def apply(json: Json, mode: JsonPatchMode = JsonPatchMode.Strict): Either[JsonError, Json]\n\n  /**\n   * Composes this patch with another. Applies this patch first, then `that`.\n   *\n   * This is the monoid `combine` operation.\n   */\n  def ++(that: JsonPatch): JsonPatch = JsonPatch(ops ++ that.ops)\n\n  /**\n   * Returns true if this patch contains no operations.\n   */\n  def isEmpty: Boolean = ops.isEmpty\n\n  /**\n   * Converts this JSON patch to a [[DynamicPatch]].\n   */\n  def toDynamicPatch: DynamicPatch\n}\n\nobject JsonPatch {\n\n  /**\n   * Empty patch  the identity element for `++` composition.\n   */\n  val empty: JsonPatch = JsonPatch(Vector.empty)\n\n  /**\n   * Creates a patch with a single operation at the root path.\n   */\n  def root(op: Op): JsonPatch =\n    JsonPatch(Vector(JsonPatchOp(DynamicOptic.root, op)))\n\n  /**\n   * Creates a patch with a single operation at the given path.\n   */\n  def apply(path: DynamicOptic, op: Op): JsonPatch =\n    JsonPatch(Vector(JsonPatchOp(path, op)))\n\n  /**\n   * Computes a patch that transforms `oldJson` into `newJson`.\n   *\n   * Law: `diff(old, new)(old, Strict) == Right(new)`\n   */\n  def diff(oldJson: Json, newJson: Json): JsonPatch\n\n  /**\n   * Creates a JSON patch from a [[DynamicPatch]].\n   *\n   * May fail if the DynamicPatch contains operations not representable in JSON\n   * (e.g., non-string map keys, temporal deltas, variant operations).\n   */\n  def fromDynamicPatch(patch: DynamicPatch): Either[JsonError, JsonPatch]\n\n  // ===========================================================================\n  // JsonPatchOp  a single operation at a path\n  // ===========================================================================\n\n  /**\n   * A single patch operation: a path and what to do there.\n   *\n   * Mirrors [[DynamicPatch.DynamicPatchOp]].\n   */\n  final case class JsonPatchOp(path: DynamicOptic, op: Op)\n\n  // ===========================================================================\n  // Op  the operation to perform at a path\n  // ===========================================================================\n\n  /**\n   * The operation to perform at a target location.\n   *\n   * Mirrors [[DynamicPatch.Operation]] but specialized for JSON.\n   */\n  sealed trait Op\n\n  object Op {\n\n    /**\n     * Set a value directly (replacement).\n     *\n     * Mirrors [[DynamicPatch.Operation.Set]].\n     */\n    final case class Set(value: Json) extends Op\n\n    /**\n     * Apply a primitive delta operation.\n     *\n     * Used for numeric deltas and string edits.\n     * Mirrors [[DynamicPatch.Operation.PrimitiveDelta]].\n     */\n    final case class PrimitiveDelta(op: PrimitiveOp) extends Op\n\n    /**\n     * Apply array edit operations.\n     *\n     * Used for inserting, appending, deleting, or modifying array elements.\n     * Mirrors [[DynamicPatch.Operation.SequenceEdit]].\n     */\n    final case class ArrayEdit(ops: Vector[ArrayOp]) extends Op\n\n    /**\n     * Apply object edit operations.\n     *\n     * Used for adding, removing, or modifying object fields.\n     * Mirrors [[DynamicPatch.Operation.MapEdit]] but with string keys.\n     */\n    final case class ObjectEdit(ops: Vector[ObjectOp]) extends Op\n\n    /**\n     * Apply a nested patch.\n     *\n     * Used to group operations sharing a common path prefix.\n     * Mirrors [[DynamicPatch.Operation.Patch]].\n     */\n    final case class Nested(patch: JsonPatch) extends Op\n  }\n\n  // ===========================================================================\n  // PrimitiveOp  delta operations for JSON primitives\n  // ===========================================================================\n\n  /**\n   * Delta operations for JSON primitive values.\n   *\n   * JSON has only one numeric type, so we use BigDecimal for deltas.\n   * Boolean has no delta (use Set to toggle).\n   * Null has no delta (use Set to change).\n   *\n   * Mirrors [[DynamicPatch.PrimitiveOp]] but simplified for JSON's type system.\n   */\n  sealed trait PrimitiveOp\n\n  object PrimitiveOp {\n\n    /**\n     * Add a delta to a JSON number.\n     *\n     * Applied by: `currentValue + delta`\n     *\n     * Mirrors the numeric delta operations in [[DynamicPatch.PrimitiveOp]]\n     * (IntDelta, LongDelta, DoubleDelta, etc.) unified into one type.\n     */\n    final case class NumberDelta(delta: BigDecimal) extends PrimitiveOp\n\n    /**\n     * Apply string edit operations.\n     *\n     * Mirrors [[DynamicPatch.PrimitiveOp.StringEdit]].\n     */\n    final case class StringEdit(ops: Vector[StringOp]) extends PrimitiveOp\n  }\n\n  // ===========================================================================\n  // StringOp  edit operations for strings\n  // ===========================================================================\n\n  /**\n   * Edit operations for JSON strings.\n   *\n   * Mirrors [[DynamicPatch.StringOp]] exactly.\n   */\n  sealed trait StringOp\n\n  object StringOp {\n\n    /**\n     * Insert text at the given index.\n     */\n    final case class Insert(index: Int, text: String) extends StringOp\n\n    /**\n     * Delete characters starting at the given index.\n     */\n    final case class Delete(index: Int, length: Int) extends StringOp\n\n    /**\n     * Append text to the end of the string.\n     */\n    final case class Append(text: String) extends StringOp\n\n    /**\n     * Replace characters starting at index with new text.\n     */\n    final case class Modify(index: Int, length: Int, text: String) extends StringOp\n  }\n\n  // ===========================================================================\n  // ArrayOp  edit operations for arrays\n  // ===========================================================================\n\n  /**\n   * Edit operations for JSON arrays.\n   *\n   * Mirrors [[DynamicPatch.SeqOp]] but with Json values.\n   */\n  sealed trait ArrayOp\n\n  object ArrayOp {\n\n    /**\n     * Insert values at the given index.\n     */\n    final case class Insert(index: Int, values: Vector[Json]) extends ArrayOp\n\n    /**\n     * Append values to the end of the array.\n     */\n    final case class Append(values: Vector[Json]) extends ArrayOp\n\n    /**\n     * Delete elements starting at the given index.\n     */\n    final case class Delete(index: Int, count: Int) extends ArrayOp\n\n    /**\n     * Modify the element at the given index with a nested operation.\n     */\n    final case class Modify(index: Int, op: Op) extends ArrayOp\n  }\n\n  // ===========================================================================\n  // ObjectOp  edit operations for objects\n  // ===========================================================================\n\n  /**\n   * Edit operations for JSON objects.\n   *\n   * Mirrors [[DynamicPatch.MapOp]] but with string keys (JSON constraint).\n   */\n  sealed trait ObjectOp\n\n  object ObjectOp {\n\n    /**\n     * Add a field to the object.\n     */\n    final case class Add(key: String, value: Json) extends ObjectOp\n\n    /**\n     * Remove a field from the object.\n     */\n    final case class Remove(key: String) extends ObjectOp\n\n    /**\n     * Modify a field's value with a nested patch.\n     */\n    final case class Modify(key: String, patch: JsonPatch) extends ObjectOp\n  }\n}\n\n// =============================================================================\n// PATCH MODE\n// =============================================================================\n\n/**\n * Controls how patch application handles failures.\n *\n * Mirrors [[zio.blocks.schema.patch.PatchMode]].\n */\nsealed trait JsonPatchMode\n\nobject JsonPatchMode {\n\n  /**\n   * Fail on precondition violations.\n   */\n  case object Strict extends JsonPatchMode\n\n  /**\n   * Skip operations that fail preconditions.\n   */\n  case object Lenient extends JsonPatchMode\n\n  /**\n   * Replace/overwrite on conflicts (create missing paths).\n   */\n  case object Clobber extends JsonPatchMode\n}\n\n// =============================================================================\n// USAGE EXAMPLES\n// =============================================================================\n\n/*\n * ==Example 1: Basic Patching==\n *\n * {{{\n * import zio.blocks.schema.json._\n *\n * val json = Json.Object(Vector(\n *   \"name\" -> Json.String(\"Alice\"),\n *   \"age\" -> Json.Number(\"30\")\n * ))\n *\n * // Replace name\n * val patch = JsonPatch.root(JsonPatch.Op.Set(Json.String(\"Bob\")))\n *   // Or at a specific path:\n *   // JsonPatch(DynamicOptic.root.field(\"name\"), JsonPatch.Op.Set(Json.String(\"Bob\")))\n *\n * val result = patch(json, JsonPatchMode.Strict)\n * }}}\n *\n * ==Example 2: Diff and Apply (Roundtrip Law)==\n *\n * {{{\n * val source = Json.Object(Vector(\"x\" -> Json.Number(\"1\")))\n * val target = Json.Object(Vector(\"x\" -> Json.Number(\"5\")))\n *\n * val patch = JsonPatch.diff(source, target)\n *\n * // Roundtrip law\n * assert(patch(source, JsonPatchMode.Strict) == Right(target))\n *\n * // Identity diff law\n * assert(JsonPatch.diff(source, source).isEmpty)\n * }}}\n *\n * ==Example 3: Monoid Laws==\n *\n * {{{\n * val p1 = JsonPatch.diff(a, b)\n * val p2 = JsonPatch.diff(b, c)\n * val p3 = JsonPatch.diff(c, d)\n *\n * // Left identity\n * assert((JsonPatch.empty ++ p1)(a, Strict) == p1(a, Strict))\n *\n * // Right identity\n * assert((p1 ++ JsonPatch.empty)(a, Strict) == p1(a, Strict))\n *\n * // Associativity\n * assert(((p1 ++ p2) ++ p3)(a, Strict) == (p1 ++ (p2 ++ p3))(a, Strict))\n * }}}\n *\n * ==Example 4: Numeric Delta==\n *\n * {{{\n * val json = Json.Number(\"10\")\n *\n * // Add 5 to the number (more efficient than Set for large structures)\n * val patch = JsonPatch.root(\n *   JsonPatch.Op.PrimitiveDelta(JsonPatch.PrimitiveOp.NumberDelta(BigDecimal(5)))\n * )\n *\n * assert(patch(json, Strict) == Right(Json.Number(\"15\")))\n * }}}\n *\n * ==Example 5: String Edit==\n *\n * {{{\n * val json = Json.String(\"hello world\")\n *\n * // Change \"hello\" to \"hi\" using LCS-based edits\n * val patch = JsonPatch.root(\n *   JsonPatch.Op.PrimitiveDelta(\n *     JsonPatch.PrimitiveOp.StringEdit(Vector(\n *       JsonPatch.StringOp.Delete(0, 5),\n *       JsonPatch.StringOp.Insert(0, \"hi\")\n *     ))\n *   )\n * )\n *\n * assert(patch(json, Strict) == Right(Json.String(\"hi world\")))\n * }}}\n *\n * ==Example 6: Array Edit==\n *\n * {{{\n * val json = Json.Array(Vector(Json.Number(\"1\"), Json.Number(\"2\"), Json.Number(\"3\")))\n *\n * // Delete element at index 1, append new element\n * val patch = JsonPatch.root(\n *   JsonPatch.Op.ArrayEdit(Vector(\n *     JsonPatch.ArrayOp.Delete(1, 1),\n *     JsonPatch.ArrayOp.Append(Vector(Json.Number(\"4\")))\n *   ))\n * )\n *\n * // Result: [1, 3, 4]\n * }}}\n *\n * ==Example 7: Object Edit==\n *\n * {{{\n * val json = Json.Object(Vector(\"a\" -> Json.Number(\"1\"), \"b\" -> Json.Number(\"2\")))\n *\n * // Remove field \"a\", add field \"c\"\n * val patch = JsonPatch.root(\n *   JsonPatch.Op.ObjectEdit(Vector(\n *     JsonPatch.ObjectOp.Remove(\"a\"),\n *     JsonPatch.ObjectOp.Add(\"c\", Json.Number(\"3\"))\n *   ))\n * )\n *\n * // Result: {\"b\": 2, \"c\": 3}\n * }}}\n *\n * ==Example 8: Nested Patch==\n *\n * {{{\n * val json = Json.Object(Vector(\n *   \"user\" -> Json.Object(Vector(\n *     \"name\" -> Json.String(\"Alice\"),\n *     \"age\" -> Json.Number(\"30\")\n *   ))\n * ))\n *\n * // Patch nested inside \"user\"\n * val innerPatch = JsonPatch(Vector(\n *   JsonPatch.JsonPatchOp(\n *     DynamicOptic.root.field(\"age\"),\n *     JsonPatch.Op.PrimitiveDelta(JsonPatch.PrimitiveOp.NumberDelta(BigDecimal(1)))\n *   )\n * ))\n *\n * val patch = JsonPatch(\n *   DynamicOptic.root.field(\"user\"),\n *   JsonPatch.Op.Nested(innerPatch)\n * )\n *\n * // Increments user.age by 1\n * }}}\n *\n * ==Example 9: Diff Composition Law==\n *\n * {{{\n * val a = Json.Number(\"1\")\n * val b = Json.Number(\"5\")\n * val c = Json.Number(\"10\")\n *\n * val p1 = JsonPatch.diff(a, b)  // delta +4\n * val p2 = JsonPatch.diff(b, c)  // delta +5\n *\n * // Composition law: applying composed patch equals applying sequentially\n * assert((p1 ++ p2)(a, Strict) == Right(c))\n * }}}\n *\n * ==Example 10: PatchMode Behavior==\n *\n * {{{\n * val json = Json.Object(Vector(\"a\" -> Json.Number(\"1\")))\n *\n * // Try to remove non-existent field\n * val patch = JsonPatch.root(\n *   JsonPatch.Op.ObjectEdit(Vector(JsonPatch.ObjectOp.Remove(\"nonexistent\")))\n * )\n *\n * // Strict: fails\n * assert(patch(json, JsonPatchMode.Strict).isLeft)\n *\n * // Lenient: skips, returns unchanged\n * assert(patch(json, JsonPatchMode.Lenient) == Right(json))\n *\n * // Clobber: skips (nothing to clobber), returns unchanged\n * assert(patch(json, JsonPatchMode.Clobber) == Right(json))\n * }}}\n */\n```",
                  "html_url": "https://github.com/zio/zio-blocks/issues/685"
                },
                "type": "github"
              },
              "hash": "zio/zio-blocks#685",
              "body": "<html><head></head><body><h1>Add <code>JsonPatch</code> type for diffing and patching JSON values</h1>\n<h2>Summary</h2>\n<p>Implement a <code>JsonPatch</code> type that enables computing diffs between JSON values and applying patches to transform one JSON value into another. This type should mirror the existing <code>DynamicPatch</code> implementation, adapted for JSON's simpler data model.</p>\n<h2>Motivation</h2>\n<p><code>DynamicValue</code> has a well-designed <code>DynamicPatch</code> system with:</p>\n<ul>\n<li>Monoid composition (<code>++</code> with <code>empty</code> identity)</li>\n<li>LCS-based sequence diffing</li>\n<li>Primitive delta operations (numeric deltas, string edits)</li>\n<li>Comprehensive algebraic laws verified by property tests</li>\n</ul>\n<p>The proposed <code>Json</code> type (see #TBD) needs equivalent patching capabilities. Rather than converting <code>Json  DynamicValue</code> for every patch operation, a native <code>JsonPatch</code> provides:</p>\n<ul>\n<li>Type safety (no conversion errors for JSON-incompatible DynamicPatch operations)</li>\n<li>API consistency with the <code>Json</code> type</li>\n<li>Potential for JSON-specific optimizations</li>\n</ul>\n<h2>Design Sketch</h2>\n<p>A design sketch is available at <a href=\"https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/json/JsonPatch.scala\"><code>schema/shared/src/main/scala/zio/blocks/schema/json/JsonPatch.scala</code></a>. This sketch is <strong>a guide, not a specification</strong>  implementers should use judgment and deviate where appropriate.</p>\n<h3>Core Types</h3>\n<p>The design mirrors <code>DynamicPatch</code> with JSON-specific adaptations:</p>\n\nDynamicPatch | JsonPatch | Notes\n-- | -- | --\nDynamicPatch(Vector[DynamicPatchOp]) | JsonPatch(Vector[JsonPatchOp]) | Same structure\nOperation.Set | Op.Set | Same\nOperation.PrimitiveDelta | Op.PrimitiveDelta | Simplified for JSON types\nOperation.SequenceEdit | Op.ArrayEdit | Renamed\nOperation.MapEdit | Op.ObjectEdit | String keys only\nOperation.Patch | Op.Nested | Same\nSeqOp | ArrayOp | Same operations\nMapOp | ObjectOp | String keys only\nPrimitiveOp (14 variants) | PrimitiveOp (2 variants) | See below\n\n\n<h3>StringOp</h3>\n<p>Mirror <code>DynamicPatch.StringOp</code> exactly:</p>\n<ul>\n<li><code>Insert(index: Int, text: String)</code></li>\n<li><code>Delete(index: Int, length: Int)</code></li>\n<li><code>Append(text: String)</code></li>\n<li><code>Modify(index: Int, length: Int, text: String)</code></li>\n</ul>\n<h3>ArrayOp</h3>\n<p>Mirror <code>DynamicPatch.SeqOp</code>:</p>\n<ul>\n<li><code>Insert(index: Int, values: Vector[Json])</code></li>\n<li><code>Append(values: Vector[Json])</code></li>\n<li><code>Delete(index: Int, count: Int)</code></li>\n<li><code>Modify(index: Int, op: Op)</code></li>\n</ul>\n<h3>ObjectOp</h3>\n<p>Mirror <code>DynamicPatch.MapOp</code> with string keys:</p>\n<ul>\n<li><code>Add(key: String, value: Json)</code></li>\n<li><code>Remove(key: String)</code></li>\n<li><code>Modify(key: String, patch: JsonPatch)</code></li>\n</ul>\n<h2>Requirements</h2>\n<h3>Functional Requirements</h3>\n<ul>\n<li>[ ] <strong>F1</strong>: <code>JsonPatch.diff(source, target)</code> computes a patch transforming source to target</li>\n<li>[ ] <strong>F2</strong>: <code>patch.apply(json, mode)</code> applies a patch with configurable failure handling</li>\n<li>[ ] <strong>F3</strong>: <code>patch1 ++ patch2</code> composes patches (apply first, then second)</li>\n<li>[ ] <strong>F4</strong>: <code>JsonPatch.empty</code> is the identity element for composition</li>\n<li>[ ] <strong>F5</strong>: Support <code>JsonPatchMode.Strict</code>, <code>Lenient</code>, and <code>Clobber</code> modes</li>\n<li>[ ] <strong>F6</strong>: Bidirectional conversion: <code>toDynamicPatch</code> / <code>fromDynamicPatch</code></li>\n</ul>\n<h3>Algebraic Laws</h3>\n<p>All laws must be verified with property-based tests (see <code>PatchLawsSpec</code> for reference):</p>\n<ul>\n<li>[ ] <strong>L1</strong>: Left identity  <code>(empty ++ p)(j) == p(j)</code></li>\n<li>[ ] <strong>L2</strong>: Right identity  <code>(p ++ empty)(j) == p(j)</code></li>\n<li>[ ] <strong>L3</strong>: Associativity  <code>((p1 ++ p2) ++ p3)(j) == (p1 ++ (p2 ++ p3))(j)</code></li>\n<li>[ ] <strong>L4</strong>: Roundtrip  <code>diff(a, b)(a) == Right(b)</code></li>\n<li>[ ] <strong>L5</strong>: Identity diff  <code>diff(j, j).isEmpty</code></li>\n<li>[ ] <strong>L6</strong>: Diff composition  <code>(diff(a, b) ++ diff(b, c))(a) == Right(c)</code></li>\n<li>[ ] <strong>L7</strong>: Lenient subsumes Strict  if <code>p(j, Strict) == Right(r)</code> then <code>p(j, Lenient) == Right(r)</code></li>\n</ul>\n<h3>Testing Requirements</h3>\n<ul>\n<li>[ ] <strong>T1</strong>: Property-based tests for all algebraic laws (see <code>PatchLawsSpec</code>)</li>\n<li>[ ] <strong>T2</strong>: Test each operation type (<code>Set</code>, <code>PrimitiveDelta</code>, <code>ArrayEdit</code>, <code>ObjectEdit</code>, <code>Nested</code>)</li>\n<li>[ ] <strong>T3</strong>: Test each <code>ArrayOp</code> variant (<code>Insert</code>, <code>Append</code>, <code>Delete</code>, <code>Modify</code>)</li>\n<li>[ ] <strong>T4</strong>: Test each <code>ObjectOp</code> variant (<code>Add</code>, <code>Remove</code>, <code>Modify</code>)</li>\n<li>[ ] <strong>T5</strong>: Test each <code>StringOp</code> variant (<code>Insert</code>, <code>Delete</code>, <code>Append</code>, <code>Modify</code>)</li>\n<li>[ ] <strong>T6</strong>: Test <code>NumberDelta</code> with positive, negative, zero, and decimal deltas</li>\n<li>[ ] <strong>T7</strong>: Test all three <code>JsonPatchMode</code> behaviors</li>\n<li>[ ] <strong>T8</strong>: Test <code>toDynamicPatch</code> / <code>fromDynamicPatch</code> roundtrip</li>\n<li>[ ] <strong>T9</strong>: Test edge cases: empty arrays, empty objects, empty strings, nested structures</li>\n<li>[ ] <strong>T10</strong>: Test error cases: invalid paths, type mismatches, out-of-bounds indices</li>\n</ul>\n<h3>Documentation Requirements</h3>\n<ul>\n<li>[ ] <strong>D1</strong>: ScalaDoc for all public types and methods</li>\n<li>[ ] <strong>D2</strong>: Usage examples in ScalaDoc (see sketch for examples)</li>\n<li>[ ] <strong>D3</strong>: Document algebraic laws in type-level comments</li>\n<li>[ ] <strong>D4</strong>: Document relationship to <code>DynamicPatch</code></li>\n</ul>\n<h3>Implementation Notes</h3>\n<ol>\n<li>\n<p><strong>Follow <code>DynamicPatch</code> patterns</strong>: The implementation in <code>DynamicPatch.scala</code> is the reference. Study <code>Differ.scala</code> for diff algorithms (especially LCS for sequences and strings).</p>\n</li>\n<li>\n<p><strong>Reuse algorithms where possible</strong>: Consider whether <code>JsonPatch</code> can delegate to <code>DynamicPatch</code> internally, or share algorithm implementations.</p>\n</li>\n<li>\n<p><strong>Keep it minimal</strong>: Resist adding operations not present in <code>DynamicPatch</code>. The design is intentionally minimal and principled.</p>\n</li>\n<li>\n<p><strong>Performance considerations</strong>: The register-based design of ZIO Blocks prioritizes performance. Avoid unnecessary allocations in hot paths.</p>\n</li>\n</ol>\n<h2>Out of Scope</h2>\n<p>The following are explicitly <strong>not</strong> part of this issue:</p>\n<ul>\n<li>RFC 6902 JSON Patch serialization format (separate issue)</li>\n<li>Patch inversion / undo support (separate issue)</li>\n<li>Patch optimization / compaction (separate issue)</li>\n<li>Integration with <code>Json</code> type methods like <code>json.diff(other)</code> (depends on <code>Json</code> implementation)</li>\n</ul>\n<h2>Related</h2>\n<ul>\n<li><code>DynamicPatch</code>  <a href=\"https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/DynamicPatch.scala\"><code>schema/shared/src/main/scala/zio/blocks/schema/patch/DynamicPatch.scala</code></a></li>\n<li><code>Differ</code>  <a href=\"https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/Differ.scala\"><code>schema/shared/src/main/scala/zio/blocks/schema/patch/Differ.scala</code></a></li>\n<li><code>PatchLawsSpec</code>  <a href=\"https://claude.ai/chat/schema/shared/src/test/scala/zio/blocks/schema/patch/PatchLawsSpec.scala\"><code>schema/shared/src/test/scala/zio/blocks/schema/patch/PatchLawsSpec.scala</code></a></li>\n<li><code>PatchMode</code>  <a href=\"https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/PatchMode.scala\"><code>schema/shared/src/main/scala/zio/blocks/schema/patch/PatchMode.scala</code></a></li>\n</ul>\n<h2>Acceptance Criteria</h2>\n<ul>\n<li>[ ] All functional requirements (F1-F6) implemented</li>\n<li>[ ] All algebraic laws (L1-L7) pass property-based tests</li>\n<li>[ ] All testing requirements (T1-T10) have corresponding test cases</li>\n<li>[ ] All documentation requirements (D1-D4) complete</li>\n<li>[ ] Code reviewed and approved</li>\n<li>[ ] CI passing</li>\n</ul></body></html># Add `JsonPatch` type for diffing and patching JSON values\n\n## Summary\n\nImplement a `JsonPatch` type that enables computing diffs between JSON values and applying patches to transform one JSON value into another. This type should mirror the existing `DynamicPatch` implementation, adapted for JSON's simpler data model.\n\n## Motivation\n\n`DynamicValue` has a well-designed `DynamicPatch` system with:\n- Monoid composition (`++` with `empty` identity)\n- LCS-based sequence diffing\n- Primitive delta operations (numeric deltas, string edits)\n- Comprehensive algebraic laws verified by property tests\n\nThe proposed `Json` type (see #TBD) needs equivalent patching capabilities. Rather than converting `Json  DynamicValue` for every patch operation, a native `JsonPatch` provides:\n- Type safety (no conversion errors for JSON-incompatible DynamicPatch operations)\n- API consistency with the `Json` type\n- Potential for JSON-specific optimizations\n\n## Design Sketch\n\nA design sketch is available at [`[schema/shared/src/main/scala/zio/blocks/schema/json/JsonPatch.scala](https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/json/JsonPatch.scala)`](./schema/shared/src/main/scala/zio/blocks/schema/json/JsonPatch.scala). This sketch is **a guide, not a specification**  implementers should use judgment and deviate where appropriate.\n\n### Core Types\n\nThe design mirrors `DynamicPatch` with JSON-specific adaptations:\n\n| DynamicPatch | JsonPatch | Notes |\n|--------------|-----------|-------|\n| `DynamicPatch(Vector[DynamicPatchOp])` | `JsonPatch(Vector[JsonPatchOp])` | Same structure |\n| `Operation.Set` | `Op.Set` | Same |\n| `Operation.PrimitiveDelta` | `Op.PrimitiveDelta` | Simplified for JSON types |\n| `Operation.SequenceEdit` | `Op.ArrayEdit` | Renamed |\n| `Operation.MapEdit` | `Op.ObjectEdit` | String keys only |\n| `Operation.Patch` | `Op.Nested` | Same |\n| `SeqOp` | `ArrayOp` | Same operations |\n| `MapOp` | `ObjectOp` | String keys only |\n| `PrimitiveOp` (14 variants) | `PrimitiveOp` (2 variants) | See below |\n\n### Primitive Operations\n\nJSON has a simpler type system than `DynamicValue`:\n\n| JSON Type | Delta Operation | Notes |\n|-----------|-----------------|-------|\n| Number | `NumberDelta(BigDecimal)` | Unifies all numeric deltas |\n| String | `StringEdit(Vector[StringOp])` | Same as `DynamicPatch` |\n| Boolean | Use `Op.Set` | No delta (same as `DynamicPatch`) |\n| Null | Use `Op.Set` | No delta |\n\n### StringOp\n\nMirror `DynamicPatch.StringOp` exactly:\n- `Insert(index: Int, text: String)`\n- `Delete(index: Int, length: Int)`\n- `Append(text: String)`\n- `Modify(index: Int, length: Int, text: String)`\n\n### ArrayOp\n\nMirror `DynamicPatch.SeqOp`:\n- `Insert(index: Int, values: Vector[Json])`\n- `Append(values: Vector[Json])`\n- `Delete(index: Int, count: Int)`\n- `Modify(index: Int, op: Op)`\n\n### ObjectOp\n\nMirror `DynamicPatch.MapOp` with string keys:\n- `Add(key: String, value: Json)`\n- `Remove(key: String)`\n- `Modify(key: String, patch: JsonPatch)`\n\n## Requirements\n\n### Functional Requirements\n\n- [ ] **F1**: `JsonPatch.diff(source, target)` computes a patch transforming source to target\n- [ ] **F2**: `patch.apply(json, mode)` applies a patch with configurable failure handling\n- [ ] **F3**: `patch1 ++ patch2` composes patches (apply first, then second)\n- [ ] **F4**: `JsonPatch.empty` is the identity element for composition\n- [ ] **F5**: Support `JsonPatchMode.Strict`, `Lenient`, and `Clobber` modes\n- [ ] **F6**: Bidirectional conversion: `toDynamicPatch` / `fromDynamicPatch`\n\n### Algebraic Laws\n\nAll laws must be verified with property-based tests (see `PatchLawsSpec` for reference):\n\n- [ ] **L1**: Left identity  `(empty ++ p)(j) == p(j)`\n- [ ] **L2**: Right identity  `(p ++ empty)(j) == p(j)`\n- [ ] **L3**: Associativity  `((p1 ++ p2) ++ p3)(j) == (p1 ++ (p2 ++ p3))(j)`\n- [ ] **L4**: Roundtrip  `diff(a, b)(a) == Right(b)`\n- [ ] **L5**: Identity diff  `diff(j, j).isEmpty`\n- [ ] **L6**: Diff composition  `(diff(a, b) ++ diff(b, c))(a) == Right(c)`\n- [ ] **L7**: Lenient subsumes Strict  if `p(j, Strict) == Right(r)` then `p(j, Lenient) == Right(r)`\n\n### Testing Requirements\n\n- [ ] **T1**: Property-based tests for all algebraic laws (see `PatchLawsSpec`)\n- [ ] **T2**: Test each operation type (`Set`, `PrimitiveDelta`, `ArrayEdit`, `ObjectEdit`, `Nested`)\n- [ ] **T3**: Test each `ArrayOp` variant (`Insert`, `Append`, `Delete`, `Modify`)\n- [ ] **T4**: Test each `ObjectOp` variant (`Add`, `Remove`, `Modify`)\n- [ ] **T5**: Test each `StringOp` variant (`Insert`, `Delete`, `Append`, `Modify`)\n- [ ] **T6**: Test `NumberDelta` with positive, negative, zero, and decimal deltas\n- [ ] **T7**: Test all three `JsonPatchMode` behaviors\n- [ ] **T8**: Test `toDynamicPatch` / `fromDynamicPatch` roundtrip\n- [ ] **T9**: Test edge cases: empty arrays, empty objects, empty strings, nested structures\n- [ ] **T10**: Test error cases: invalid paths, type mismatches, out-of-bounds indices\n\n### Documentation Requirements\n\n- [ ] **D1**: ScalaDoc for all public types and methods\n- [ ] **D2**: Usage examples in ScalaDoc (see sketch for examples)\n- [ ] **D3**: Document algebraic laws in type-level comments\n- [ ] **D4**: Document relationship to `DynamicPatch`\n\n## Related\n\n- `DynamicPatch`  [`[schema/shared/src/main/scala/zio/blocks/schema/patch/DynamicPatch.scala](https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/DynamicPatch.scala)`](./schema/shared/src/main/scala/zio/blocks/schema/patch/DynamicPatch.scala)\n- `Differ`  [`[schema/shared/src/main/scala/zio/blocks/schema/patch/Differ.scala](https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/Differ.scala)`](./schema/shared/src/main/scala/zio/blocks/schema/patch/Differ.scala)\n- `PatchLawsSpec`  [`[schema/shared/src/test/scala/zio/blocks/schema/patch/PatchLawsSpec.scala](https://claude.ai/chat/schema/shared/src/test/scala/zio/blocks/schema/patch/PatchLawsSpec.scala)`](./schema/shared/src/test/scala/zio/blocks/schema/patch/PatchLawsSpec.scala)\n- `PatchMode`  [`[schema/shared/src/main/scala/zio/blocks/schema/patch/PatchMode.scala](https://claude.ai/chat/schema/shared/src/main/scala/zio/blocks/schema/patch/PatchMode.scala)`](./schema/shared/src/main/scala/zio/blocks/schema/patch/PatchMode.scala)\n\n## Acceptance Criteria\n\n- [ ] All functional requirements (F1-F6) implemented\n- [ ] All algebraic laws (L1-L7) pass property-based tests\n- [ ] All testing requirements (T1-T10) have corresponding test cases\n- [ ] All documentation requirements (D1-D4) complete\n- [ ] Code reviewed and approved\n- [ ] CI passing\n\n# Sketch\n\n```scala\npackage zio.blocks.schema.json\n\nimport zio.blocks.schema.DynamicOptic\nimport zio.blocks.schema.patch.DynamicPatch\n\n// =============================================================================\n// JSON PATCH\n// =============================================================================\n\n/**\n * An untyped patch that operates on [[Json]] values.\n *\n * `JsonPatch` is the JSON-specific counterpart to [[DynamicPatch]]. It represents\n * a sequence of operations that transform one JSON value into another. Patches\n * are serializable and composable.\n *\n * ==Design==\n *\n * This type directly mirrors [[DynamicPatch]] but is specialized for JSON's\n * simpler data model:\n *  - JSON has 4 leaf types (String, Number, Boolean, Null) vs 30 PrimitiveValues\n *  - JSON objects have string keys only (no arbitrary-keyed maps)\n *  - JSON has no native Variant type\n *\n * ==Algebraic Laws==\n *\n * '''Monoid Laws''' (under `++` composition):\n * {{{\n * // 1. LEFT IDENTITY\n *  p: JsonPatch, j: Json.\n *   (JsonPatch.empty ++ p)(j, mode) == p(j, mode)\n *\n * // 2. RIGHT IDENTITY\n *  p: JsonPatch, j: Json.\n *   (p ++ JsonPatch.empty)(j, mode) == p(j, mode)\n *\n * // 3. ASSOCIATIVITY\n *  p1, p2, p3: JsonPatch, j: Json.\n *   ((p1 ++ p2) ++ p3)(j, mode) == (p1 ++ (p2 ++ p3))(j, mode)\n * }}}\n *\n * '''Diff/Apply Laws''':\n * {{{\n * // 4. ROUNDTRIP\n *  source, target: Json.\n *   JsonPatch.diff(source, target)(source, Strict) == Right(target)\n *\n * // 5. IDENTITY DIFF\n *  j: Json.\n *   JsonPatch.diff(j, j).isEmpty == true\n *\n * // 6. DIFF COMPOSITION\n *  a, b, c: Json.\n *   (JsonPatch.diff(a, b) ++ JsonPatch.diff(b, c))(a, Strict) == Right(c)\n * }}}\n *\n * '''PatchMode Laws''':\n * {{{\n * // 7. STRICT FAILS ON ERROR\n * // Strict mode fails on first precondition violation\n *\n * // 8. LENIENT SKIPS ERRORS\n * // Lenient mode skips failing operations, always returns Right\n *\n * // 9. LENIENT SUBSUMES STRICT\n *  p: JsonPatch, j: Json.\n *   p(j, Strict) == Right(r) implies p(j, Lenient) == Right(r)\n *\n * // 10. CLOBBER FORCES SUCCESS\n * // Clobber mode creates missing paths, always returns Right\n * }}}\n *\n * @param ops The sequence of patch operations\n */\nfinal case class JsonPatch(ops: Vector[JsonPatch.JsonPatchOp]) {\n\n  /**\n   * Applies this patch to a JSON value.\n   *\n   * @param json The JSON value to patch\n   * @param mode The patch mode (default: Strict)\n   * @return Either an error or the patched value\n   */\n  def apply(json: Json, mode: JsonPatchMode = JsonPatchMode.Strict): Either[JsonError, Json]\n\n  /**\n   * Composes this patch with another. Applies this patch first, then `that`.\n   *\n   * This is the monoid `combine` operation.\n   */\n  def ++(that: JsonPatch): JsonPatch = JsonPatch(ops ++ that.ops)\n\n  /**\n   * Returns true if this patch contains no operations.\n   */\n  def isEmpty: Boolean = ops.isEmpty\n\n  /**\n   * Converts this JSON patch to a [[DynamicPatch]].\n   */\n  def toDynamicPatch: DynamicPatch\n}\n\nobject JsonPatch {\n\n  /**\n   * Empty patch  the identity element for `++` composition.\n   */\n  val empty: JsonPatch = JsonPatch(Vector.empty)\n\n  /**\n   * Creates a patch with a single operation at the root path.\n   */\n  def root(op: Op): JsonPatch =\n    JsonPatch(Vector(JsonPatchOp(DynamicOptic.root, op)))\n\n  /**\n   * Creates a patch with a single operation at the given path.\n   */\n  def apply(path: DynamicOptic, op: Op): JsonPatch =\n    JsonPatch(Vector(JsonPatchOp(path, op)))\n\n  /**\n   * Computes a patch that transforms `oldJson` into `newJson`.\n   *\n   * Law: `diff(old, new)(old, Strict) == Right(new)`\n   */\n  def diff(oldJson: Json, newJson: Json): JsonPatch\n\n  /**\n   * Creates a JSON patch from a [[DynamicPatch]].\n   *\n   * May fail if the DynamicPatch contains operations not representable in JSON\n   * (e.g., non-string map keys, temporal deltas, variant operations).\n   */\n  def fromDynamicPatch(patch: DynamicPatch): Either[JsonError, JsonPatch]\n\n  // ===========================================================================\n  // JsonPatchOp  a single operation at a path\n  // ===========================================================================\n\n  /**\n   * A single patch operation: a path and what to do there.\n   *\n   * Mirrors [[DynamicPatch.DynamicPatchOp]].\n   */\n  final case class JsonPatchOp(path: DynamicOptic, op: Op)\n\n  // ===========================================================================\n  // Op  the operation to perform at a path\n  // ===========================================================================\n\n  /**\n   * The operation to perform at a target location.\n   *\n   * Mirrors [[DynamicPatch.Operation]] but specialized for JSON.\n   */\n  sealed trait Op\n\n  object Op {\n\n    /**\n     * Set a value directly (replacement).\n     *\n     * Mirrors [[DynamicPatch.Operation.Set]].\n     */\n    final case class Set(value: Json) extends Op\n\n    /**\n     * Apply a primitive delta operation.\n     *\n     * Used for numeric deltas and string edits.\n     * Mirrors [[DynamicPatch.Operation.PrimitiveDelta]].\n     */\n    final case class PrimitiveDelta(op: PrimitiveOp) extends Op\n\n    /**\n     * Apply array edit operations.\n     *\n     * Used for inserting, appending, deleting, or modifying array elements.\n     * Mirrors [[DynamicPatch.Operation.SequenceEdit]].\n     */\n    final case class ArrayEdit(ops: Vector[ArrayOp]) extends Op\n\n    /**\n     * Apply object edit operations.\n     *\n     * Used for adding, removing, or modifying object fields.\n     * Mirrors [[DynamicPatch.Operation.MapEdit]] but with string keys.\n     */\n    final case class ObjectEdit(ops: Vector[ObjectOp]) extends Op\n\n    /**\n     * Apply a nested patch.\n     *\n     * Used to group operations sharing a common path prefix.\n     * Mirrors [[DynamicPatch.Operation.Patch]].\n     */\n    final case class Nested(patch: JsonPatch) extends Op\n  }\n\n  // ===========================================================================\n  // PrimitiveOp  delta operations for JSON primitives\n  // ===========================================================================\n\n  /**\n   * Delta operations for JSON primitive values.\n   *\n   * JSON has only one numeric type, so we use BigDecimal for deltas.\n   * Boolean has no delta (use Set to toggle).\n   * Null has no delta (use Set to change).\n   *\n   * Mirrors [[DynamicPatch.PrimitiveOp]] but simplified for JSON's type system.\n   */\n  sealed trait PrimitiveOp\n\n  object PrimitiveOp {\n\n    /**\n     * Add a delta to a JSON number.\n     *\n     * Applied by: `currentValue + delta`\n     *\n     * Mirrors the numeric delta operations in [[DynamicPatch.PrimitiveOp]]\n     * (IntDelta, LongDelta, DoubleDelta, etc.) unified into one type.\n     */\n    final case class NumberDelta(delta: BigDecimal) extends PrimitiveOp\n\n    /**\n     * Apply string edit operations.\n     *\n     * Mirrors [[DynamicPatch.PrimitiveOp.StringEdit]].\n     */\n    final case class StringEdit(ops: Vector[StringOp]) extends PrimitiveOp\n  }\n\n  // ===========================================================================\n  // StringOp  edit operations for strings\n  // ===========================================================================\n\n  /**\n   * Edit operations for JSON strings.\n   *\n   * Mirrors [[DynamicPatch.StringOp]] exactly.\n   */\n  sealed trait StringOp\n\n  object StringOp {\n\n    /**\n     * Insert text at the given index.\n     */\n    final case class Insert(index: Int, text: String) extends StringOp\n\n    /**\n     * Delete characters starting at the given index.\n     */\n    final case class Delete(index: Int, length: Int) extends StringOp\n\n    /**\n     * Append text to the end of the string.\n     */\n    final case class Append(text: String) extends StringOp\n\n    /**\n     * Replace characters starting at index with new text.\n     */\n    final case class Modify(index: Int, length: Int, text: String) extends StringOp\n  }\n\n  // ===========================================================================\n  // ArrayOp  edit operations for arrays\n  // ===========================================================================\n\n  /**\n   * Edit operations for JSON arrays.\n   *\n   * Mirrors [[DynamicPatch.SeqOp]] but with Json values.\n   */\n  sealed trait ArrayOp\n\n  object ArrayOp {\n\n    /**\n     * Insert values at the given index.\n     */\n    final case class Insert(index: Int, values: Vector[Json]) extends ArrayOp\n\n    /**\n     * Append values to the end of the array.\n     */\n    final case class Append(values: Vector[Json]) extends ArrayOp\n\n    /**\n     * Delete elements starting at the given index.\n     */\n    final case class Delete(index: Int, count: Int) extends ArrayOp\n\n    /**\n     * Modify the element at the given index with a nested operation.\n     */\n    final case class Modify(index: Int, op: Op) extends ArrayOp\n  }\n\n  // ===========================================================================\n  // ObjectOp  edit operations for objects\n  // ===========================================================================\n\n  /**\n   * Edit operations for JSON objects.\n   *\n   * Mirrors [[DynamicPatch.MapOp]] but with string keys (JSON constraint).\n   */\n  sealed trait ObjectOp\n\n  object ObjectOp {\n\n    /**\n     * Add a field to the object.\n     */\n    final case class Add(key: String, value: Json) extends ObjectOp\n\n    /**\n     * Remove a field from the object.\n     */\n    final case class Remove(key: String) extends ObjectOp\n\n    /**\n     * Modify a field's value with a nested patch.\n     */\n    final case class Modify(key: String, patch: JsonPatch) extends ObjectOp\n  }\n}\n\n// =============================================================================\n// PATCH MODE\n// =============================================================================\n\n/**\n * Controls how patch application handles failures.\n *\n * Mirrors [[zio.blocks.schema.patch.PatchMode]].\n */\nsealed trait JsonPatchMode\n\nobject JsonPatchMode {\n\n  /**\n   * Fail on precondition violations.\n   */\n  case object Strict extends JsonPatchMode\n\n  /**\n   * Skip operations that fail preconditions.\n   */\n  case object Lenient extends JsonPatchMode\n\n  /**\n   * Replace/overwrite on conflicts (create missing paths).\n   */\n  case object Clobber extends JsonPatchMode\n}\n\n// =============================================================================\n// USAGE EXAMPLES\n// =============================================================================\n\n/*\n * ==Example 1: Basic Patching==\n *\n * {{{\n * import zio.blocks.schema.json._\n *\n * val json = Json.Object(Vector(\n *   \"name\" -> Json.String(\"Alice\"),\n *   \"age\" -> Json.Number(\"30\")\n * ))\n *\n * // Replace name\n * val patch = JsonPatch.root(JsonPatch.Op.Set(Json.String(\"Bob\")))\n *   // Or at a specific path:\n *   // JsonPatch(DynamicOptic.root.field(\"name\"), JsonPatch.Op.Set(Json.String(\"Bob\")))\n *\n * val result = patch(json, JsonPatchMode.Strict)\n * }}}\n *\n * ==Example 2: Diff and Apply (Roundtrip Law)==\n *\n * {{{\n * val source = Json.Object(Vector(\"x\" -> Json.Number(\"1\")))\n * val target = Json.Object(Vector(\"x\" -> Json.Number(\"5\")))\n *\n * val patch = JsonPatch.diff(source, target)\n *\n * // Roundtrip law\n * assert(patch(source, JsonPatchMode.Strict) == Right(target))\n *\n * // Identity diff law\n * assert(JsonPatch.diff(source, source).isEmpty)\n * }}}\n *\n * ==Example 3: Monoid Laws==\n *\n * {{{\n * val p1 = JsonPatch.diff(a, b)\n * val p2 = JsonPatch.diff(b, c)\n * val p3 = JsonPatch.diff(c, d)\n *\n * // Left identity\n * assert((JsonPatch.empty ++ p1)(a, Strict) == p1(a, Strict))\n *\n * // Right identity\n * assert((p1 ++ JsonPatch.empty)(a, Strict) == p1(a, Strict))\n *\n * // Associativity\n * assert(((p1 ++ p2) ++ p3)(a, Strict) == (p1 ++ (p2 ++ p3))(a, Strict))\n * }}}\n *\n * ==Example 4: Numeric Delta==\n *\n * {{{\n * val json = Json.Number(\"10\")\n *\n * // Add 5 to the number (more efficient than Set for large structures)\n * val patch = JsonPatch.root(\n *   JsonPatch.Op.PrimitiveDelta(JsonPatch.PrimitiveOp.NumberDelta(BigDecimal(5)))\n * )\n *\n * assert(patch(json, Strict) == Right(Json.Number(\"15\")))\n * }}}\n *\n * ==Example 5: String Edit==\n *\n * {{{\n * val json = Json.String(\"hello world\")\n *\n * // Change \"hello\" to \"hi\" using LCS-based edits\n * val patch = JsonPatch.root(\n *   JsonPatch.Op.PrimitiveDelta(\n *     JsonPatch.PrimitiveOp.StringEdit(Vector(\n *       JsonPatch.StringOp.Delete(0, 5),\n *       JsonPatch.StringOp.Insert(0, \"hi\")\n *     ))\n *   )\n * )\n *\n * assert(patch(json, Strict) == Right(Json.String(\"hi world\")))\n * }}}\n *\n * ==Example 6: Array Edit==\n *\n * {{{\n * val json = Json.Array(Vector(Json.Number(\"1\"), Json.Number(\"2\"), Json.Number(\"3\")))\n *\n * // Delete element at index 1, append new element\n * val patch = JsonPatch.root(\n *   JsonPatch.Op.ArrayEdit(Vector(\n *     JsonPatch.ArrayOp.Delete(1, 1),\n *     JsonPatch.ArrayOp.Append(Vector(Json.Number(\"4\")))\n *   ))\n * )\n *\n * // Result: [1, 3, 4]\n * }}}\n *\n * ==Example 7: Object Edit==\n *\n * {{{\n * val json = Json.Object(Vector(\"a\" -> Json.Number(\"1\"), \"b\" -> Json.Number(\"2\")))\n *\n * // Remove field \"a\", add field \"c\"\n * val patch = JsonPatch.root(\n *   JsonPatch.Op.ObjectEdit(Vector(\n *     JsonPatch.ObjectOp.Remove(\"a\"),\n *     JsonPatch.ObjectOp.Add(\"c\", Json.Number(\"3\"))\n *   ))\n * )\n *\n * // Result: {\"b\": 2, \"c\": 3}\n * }}}\n *\n * ==Example 8: Nested Patch==\n *\n * {{{\n * val json = Json.Object(Vector(\n *   \"user\" -> Json.Object(Vector(\n *     \"name\" -> Json.String(\"Alice\"),\n *     \"age\" -> Json.Number(\"30\")\n *   ))\n * ))\n *\n * // Patch nested inside \"user\"\n * val innerPatch = JsonPatch(Vector(\n *   JsonPatch.JsonPatchOp(\n *     DynamicOptic.root.field(\"age\"),\n *     JsonPatch.Op.PrimitiveDelta(JsonPatch.PrimitiveOp.NumberDelta(BigDecimal(1)))\n *   )\n * ))\n *\n * val patch = JsonPatch(\n *   DynamicOptic.root.field(\"user\"),\n *   JsonPatch.Op.Nested(innerPatch)\n * )\n *\n * // Increments user.age by 1\n * }}}\n *\n * ==Example 9: Diff Composition Law==\n *\n * {{{\n * val a = Json.Number(\"1\")\n * val b = Json.Number(\"5\")\n * val c = Json.Number(\"10\")\n *\n * val p1 = JsonPatch.diff(a, b)  // delta +4\n * val p2 = JsonPatch.diff(b, c)  // delta +5\n *\n * // Composition law: applying composed patch equals applying sequentially\n * assert((p1 ++ p2)(a, Strict) == Right(c))\n * }}}\n *\n * ==Example 10: PatchMode Behavior==\n *\n * {{{\n * val json = Json.Object(Vector(\"a\" -> Json.Number(\"1\")))\n *\n * // Try to remove non-existent field\n * val patch = JsonPatch.root(\n *   JsonPatch.Op.ObjectEdit(Vector(JsonPatch.ObjectOp.Remove(\"nonexistent\")))\n * )\n *\n * // Strict: fails\n * assert(patch(json, JsonPatchMode.Strict).isLeft)\n *\n * // Lenient: skips, returns unchanged\n * assert(patch(json, JsonPatchMode.Lenient) == Right(json))\n *\n * // Clobber: skips (nothing to clobber), returns unchanged\n * assert(patch(json, JsonPatchMode.Clobber) == Right(json))\n * }}}\n */\n```",
              "url": "https://github.com/zio/zio-blocks/issues/685",
              "tech": [],
              "repo_name": "zio-blocks",
              "repo_owner": "zio",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "ZIO#519",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "ZIO",
              "id": "generated-ZIO",
              "name": "ZIO",
              "description": "",
              "members": [],
              "display_name": "ZIO",
              "created_at": "2026-01-26T23:56:55.025Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/ZIO?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "zio",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-26T23:56:55.025Z",
            "created_at": "2026-01-26T23:56:55.025Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-ZIO#519",
              "status": "open",
              "type": "issue",
              "number": 519,
              "title": "Schema Migration System for ZIO Schema 2",
              "source": {
                "data": {
                  "id": "source-ZIO#519",
                  "user": {
                    "login": "jdegoes",
                    "id": 156745,
                    "node_id": "MDQ6VXNlcjE1Njc0NQ==",
                    "avatar_url": "https://avatars.githubusercontent.com/u/156745?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/jdegoes",
                    "html_url": "https://github.com/jdegoes",
                    "followers_url": "https://api.github.com/users/jdegoes/followers",
                    "following_url": "https://api.github.com/users/jdegoes/following{/other_user}",
                    "gists_url": "https://api.github.com/users/jdegoes/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/jdegoes/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/jdegoes/subscriptions",
                    "organizations_url": "https://api.github.com/users/jdegoes/orgs",
                    "repos_url": "https://api.github.com/users/jdegoes/repos",
                    "events_url": "https://api.github.com/users/jdegoes/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/jdegoes/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Schema Migration System for ZIO Schema 2",
                  "body": "## Overview\n\nImplement a **pure, algebraic migration system** for ZIO Schema 2 that represents **structural transformations between schema versions** as first-class, serializable data.\n\nA migration describes how to transform data from one schema version to another, enabling:\n\n* schema evolution\n* backward / forward compatibility\n* data versioning\n* offline migrations (JSON, SQL, data lakes, registries, etc.)\n\nThe system provides a **typed, macro-validated user API** (`Migration[A, B]`) built on a **pure, serializable core** (`DynamicMigration`) that operates on `DynamicValue`. \n\nThe ADT is fully introspectable and can be used to generate DDL, etc.\n\n## Motivation & Big Picture\n\n### Why structural types?\n\nWhen evolving schemas over time, **older versions of data types should not require runtime representations**.\n\nIn this design:\n\n* **Current versions** are represented by real case classes / enums\n* **Past versions** are represented using:\n\n  * **structural types** for records\n  * **abstract types + intersection types** for sum types\n\nThese types:\n\n* exist **only at compile time**\n* have **no runtime representation**\n* introduce **zero runtime overhead**\n* do **not require optics or instances to be kept around**\n\nThis allows you to describe arbitrarily old versions of data *without polluting your runtime or codebase*.\n\n#### Typical Workflow\n\nA typical workflow looks like:\n\n1. You have a current type:\n\n   ```scala\n   @schema\n   case class Person(name: String, age: Int)\n   ```\n\n2. You derive and copy its structural shape:\n\n   ```scala\n   type PersonV1 = { def name: String; def age: Int }\n   ```\n\n3. You evolve the real type:\n\n   ```scala\n   @schema\n   case class Person(fullName: String, age: Int, country: String)\n   ```\n\n4. You keep only:\n\n   * the **current** runtime type\n   * the **structural type** for the old version\n   * a **pure migration** between them\n\nNo old case classes. No old optics. No runtime baggage.\n\nNote there is no requirement that the \"current\" type actually be a real case class, enum, etc.--so you can work purely with structural types, allowing you to define migrations for data types that are never materialized as runtime structures.\n\n---\n\n### Why pure data migrations?\n\nMigrations are represented entirely as **pure data**:\n\n* no user functions\n* no closures\n* no reflection\n* no runtime code generation\n\nAs a result:\n\n* migrations can be **serialized**\n* stored in **registries**\n* applied **dynamically**\n* inspected and transformed\n* used to generate:\n\n  * upgraders\n  * downgraders\n  * SQL DDL / DML\n  * offline data transforms\n\nWhile code generation is **out of scope for this ticket**, this explains many design decisions (invertibility, path-based actions, no functions).\n\n---\n\n## Core Architecture\n\n### Type Hierarchy\n\n```scala\n// Typed migration (user-facing API)\ncase class Migration[A, B](\n  dynamicMigration: DynamicMigration,\n  sourceSchema: Schema[A], // These are structural schemas!!!\n  targetSchema: Schema[B] // These are structural schemas!!!\n) {\n  /** Apply migration to transform A to B */\n  def apply(value: A): Either[MigrationError, B]\n\n  /** Compose migrations sequentially */\n  def ++[C](that: Migration[B, C]): Migration[A, C]\n\n  /** Alias for ++ */\n  def andThen[C](that: Migration[B, C]): Migration[A, C] = this ++ that\n\n  /** Reverse migration (structural inverse; runtime is best-effort) */\n  def reverse: Migration[B, A]\n}\n```\n\n```scala\n// Untyped migration (pure data, fully serializable)\ncase class DynamicMigration(\n  actions: Vector[MigrationAction]\n) {\n  def apply(value: DynamicValue): Either[MigrationError, DynamicValue]\n  def ++(that: DynamicMigration): DynamicMigration\n  def reverse: DynamicMigration\n}\n```\n\n* `Migration[A, B]` is introspectable, but not pure data due to bindings inside schemas\n* `DynamicMigration` is **fully serializable**\n\n---\n\n## User-Facing API: Selector Expressions\n\n### Selectors, not optics\n\nThe user-facing API **does not expose optics**.\n\nInstead, all locations are specified using **selector expressions**:\n\n```scala\nS => A\n```\n\nExamples:\n\n```scala\n_.name\n_.address.street\n_.addresses.each.streetNumber\n_.country.when[UK]\n```\n\nTo see the syntax, one can look at the `optic` macro, which utilizes the same selector syntax for optic creation (e.g. `optic(_.address.street)`, etc.).\n\n### Macro extraction\n\nAll builder methods that accept selectors are **implemented via macros** (or via a macro-generated type class such as `ToDynamicOptic`).\n\nThe macro:\n\n1. Inspects the selector expression\n2. Validates it is a supported projection\n3. Converts it into a `DynamicOptic`\n4. Stores that optic in the migration action\n\nSupported projections include:\n\n* field access (`_.foo.bar`)\n* case selection (`_.country.when[UK]`)\n* collection traversal (`_.items.each`)\n* (future) key access, wrappers, etc.\n\n`DynamicOptic` is **never exposed publicly**.\n\n---\n\n## Migration Builder\n\nAll selector-accepting methods are implemented via macros. For simplicity, these are shown as functions (e.g. `A => Any`), but this is NOT the way to implement them. Either all these functions need to be macros, or a macro needs to be used to generate an implicit / given at each call site. Macros may do additional validation to constrain the validity of these different types of transformations.\n\n```scala\nclass MigrationBuilder[A, B](\n  sourceSchema: Schema[A],\n  targetSchema: Schema[B],\n  actions: Vector[MigrationAction]\n) {\n\n  // ----- Record operations -----\n\n  def addField(\n    target: B => Any,\n    default: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  def dropField(\n    source: A => Any,\n    defaultForReverse: SchemaExpr[B, ?] = SchemaExpr.DefaultValue\n  ): MigrationBuilder[A, B]\n\n  def renameField(\n    from: A => Any,\n    to: B => Any\n  ): MigrationBuilder[A, B]\n\n  def transformField(\n    from: A => Any,\n    to: B => Any,\n    transform: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  def mandateField(\n    source: A => Option[?],\n    target: B => Any,\n    default: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  def optionalizeField(\n    source: A => Any,\n    target: B => Option[?]\n  ): MigrationBuilder[A, B]\n\n  def changeFieldType(\n    source: A => Any,\n    target: B => Any,\n    converter: SchemaExpr[A, ?]  // primitive-to-primitive only\n  ): MigrationBuilder[A, B]\n\n  // ----- Enum operations (limited) -----\n\n  def renameCase[SumA, SumB](\n    from: String,\n    to: String\n  ): MigrationBuilder[A, B]\n\n  def transformCase[SumA, CaseA, SumB, CaseB](\n    caseMigration: MigrationBuilder[CaseA, CaseB] => MigrationBuilder[CaseA, CaseB]\n  ): MigrationBuilder[A, B]\n\n  // ----- Collections -----\n\n  def transformElements(\n    at: A => Vector[?],\n    transform: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  // ----- Maps -----\n\n  def transformKeys(\n    at: A => Map[?, ?],\n    transform: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  def transformValues(\n    at: A => Map[?, ?],\n    transform: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  /** Build migration with full macro validation */\n  def build: Migration[A, B]\n\n  /** Build migration without full validation */\n  def buildPartial: Migration[A, B]\n}\n```\n\n---\n\n## Migration Actions (Untyped Core)\n\nAll actions operate at a **path**, represented by `DynamicOptic`.\n\n```scala\nsealed trait MigrationAction {\n  def at: DynamicOptic\n  def reverse: MigrationAction\n}\n```\n\n### Record Actions\n\n```scala\ncase class AddField(\n  at: DynamicOptic,\n  default: SchemaExpr[?]\n) extends MigrationAction\n\ncase class DropField(\n  at: DynamicOptic,\n  defaultForReverse: SchemaExpr[?]\n) extends MigrationAction\n\ncase class Rename(\n  at: DynamicOptic,\n  to: String\n) extends MigrationAction\n\ncase class TransformValue(\n  at: DynamicOptic,\n  transform: SchemaExpr[?]\n) extends MigrationAction\n\ncase class Mandate(\n  at: DynamicOptic,\n  default: SchemaExpr[?]\n) extends MigrationAction\n\ncase class Optionalize(\n  at: DynamicOptic\n) extends MigrationAction\n\ncase class Join(\n  at: DynamicOptic,\n  sourcePaths: Vector[DynamicOptic],\n  combiner: SchemaExpr[?]\n) extends MigrationAction\n\ncase class Split(\n  at: DynamicOptic,\n  targetPaths: Vector[DynamicOptic],\n  splitter: SchemaExpr[?]\n) extends MigrationAction\n\ncase class ChangeType(\n  at: DynamicOptic,\n  converter: SchemaExpr[?]\n) extends MigrationAction\n```\n\n---\n\n### Enum Actions (Supported)\n\n```scala\ncase class RenameCase(\n  at: DynamicOptic,\n  from: String,\n  to: String\n) extends MigrationAction\n\ncase class TransformCase(\n  at: DynamicOptic,\n  actions: Vector[MigrationAction]\n) extends MigrationAction\n```\n\n> Enum case addition / removal is **out of scope** for this ticket\n> (requires composite value construction).\n\n---\n\n### Collection / Map Actions\n\n```scala\ncase class TransformElements(\n  at: DynamicOptic,\n  transform: SchemaExpr[?]\n) extends MigrationAction\n\ncase class TransformKeys(\n  at: DynamicOptic,\n  transform: SchemaExpr[?]\n) extends MigrationAction\n\ncase class TransformValues(\n  at: DynamicOptic,\n  transform: SchemaExpr[?]\n) extends MigrationAction\n```\n\n---\n\n## SchemaExpr Integration\n\n* Used for all value-level transformations\n* **Constraints for this ticket**:\n\n  * primitive  primitive only\n  * joins / splits must produce primitives\n  * no record / enum construction\n\n### `SchemaExpr.DefaultValue`\n\nA special expression that:\n\n1. uses the macro-captured field schema\n2. calls `schema.defaultValue`\n3. converts the value to `DynamicValue`\n4. is stored for reverse migrations\n\n---\n\n## Type Modeling\n\n### Records (Structural Types)\n\n```scala\ntype PersonV0 = { val firstName: String; val lastName: String }\ntype PersonV1 = { val fullName: String; val age: Int }\n\nimplicit val v0Schema: Schema[PersonV0] = Schema.structural[PersonV0]\nimplicit val v1Schema: Schema[PersonV1] = Schema.structural[PersonV1]\n```\n\n---\n\n### Enums (Union of Structural Types with Tags)\n\nEnums are encoded into structural types by using union types, together with singleton types (string literals, which represent the name of the case of the enum).\n\nIn structural types, the names of the type aliases shown below are not relevant, nor are they used.\n\n```scala\ntype OldCreditCard =\n  { type Tag = \"CreditCard\"; def number: String; def exp: String }\ntype OldWireTransfer =\n  { type Tag = \"WireTransfer\"; def account: String; def routing: String }\ntype OldPaymentMethod = OldCreditCard | OldWireTransfer\n```\n\nMacros extract:\n\n* refinement type  structure of the case\n* type `Tag` with singleton type  case tag\n\n---\n\n## Laws\n\n### Identity\n\n```scala\nMigration.identity[A].apply(a) == Right(a)\n```\n\n### Associativity\n\n```scala\n(m1 ++ m2) ++ m3 == m1 ++ (m2 ++ m3)\n```\n\n### Structural Reverse\n\n```scala\nm.reverse.reverse == m\n```\n\n### Best-Effort Semantic Inverse\n\n```scala\nm.apply(a) == Right(b)  m.reverse.apply(b) == Right(a)\n```\n\n(when sufficient information exists)\n\n---\n\n## Error Handling\n\n* All runtime errors return `MigrationError`\n* Errors must capture **path information** (`DynamicOptic`)\n* Enables diagnostics such as:\n\n> Failed to apply TransformValue at `.addresses.each.streetNumber`\n\n---\n\n## Example\n\n```scala\ntype PersonV0 = { val firstName: String; val lastName: String }\n\n@schema\ncase class Person(fullName: String, age: Int)\n\nval migration =\n  Migration.newBuilder[PersonV0, Person]\n    .addField(_.age, 0)\n    .build\n\nval old =\n  new { val firstName = \"John\"; val lastName = \"Doe\" }\n\nmigration(old)\n// Right(Person(\"John Doe\", 0))\n```\n\n---\n\n## Success Criteria\n\n* [ ] `DynamicMigration` fully serializable\n* [ ] `Migration[A, B]` wraps schemas and actions\n* [ ] All actions path-based via `DynamicOptic`\n* [ ] User API uses selector functions (`S => A`) for \"optics\" on old and new types\n* [ ] Macro validation in `.build` to confirm \"old\" has been migrated to \"new\"\n* [ ] `.buildPartial` supported\n* [ ] Structural reverse implemented\n* [ ] Identity & associativity laws hold\n* [ ] Enum rename / transform supported\n* [ ] Errors include path information\n* [ ] Comprehensive tests\n* [ ] Scala 2.13 and Scala 3.5+ supported\n",
                  "html_url": "https://github.com/zio/zio-blocks/issues/519"
                },
                "type": "github"
              },
              "hash": "zio/zio-blocks#519",
              "body": "## Overview\n\nImplement a **pure, algebraic migration system** for ZIO Schema 2 that represents **structural transformations between schema versions** as first-class, serializable data.\n\nA migration describes how to transform data from one schema version to another, enabling:\n\n* schema evolution\n* backward / forward compatibility\n* data versioning\n* offline migrations (JSON, SQL, data lakes, registries, etc.)\n\nThe system provides a **typed, macro-validated user API** (`Migration[A, B]`) built on a **pure, serializable core** (`DynamicMigration`) that operates on `DynamicValue`. \n\nThe ADT is fully introspectable and can be used to generate DDL, etc.\n\n## Motivation & Big Picture\n\n### Why structural types?\n\nWhen evolving schemas over time, **older versions of data types should not require runtime representations**.\n\nIn this design:\n\n* **Current versions** are represented by real case classes / enums\n* **Past versions** are represented using:\n\n  * **structural types** for records\n  * **abstract types + intersection types** for sum types\n\nThese types:\n\n* exist **only at compile time**\n* have **no runtime representation**\n* introduce **zero runtime overhead**\n* do **not require optics or instances to be kept around**\n\nThis allows you to describe arbitrarily old versions of data *without polluting your runtime or codebase*.\n\n#### Typical Workflow\n\nA typical workflow looks like:\n\n1. You have a current type:\n\n   ```scala\n   @schema\n   case class Person(name: String, age: Int)\n   ```\n\n2. You derive and copy its structural shape:\n\n   ```scala\n   type PersonV1 = { def name: String; def age: Int }\n   ```\n\n3. You evolve the real type:\n\n   ```scala\n   @schema\n   case class Person(fullName: String, age: Int, country: String)\n   ```\n\n4. You keep only:\n\n   * the **current** runtime type\n   * the **structural type** for the old version\n   * a **pure migration** between them\n\nNo old case classes. No old optics. No runtime baggage.\n\nNote there is no requirement that the \"current\" type actually be a real case class, enum, etc.--so you can work purely with structural types, allowing you to define migrations for data types that are never materialized as runtime structures.\n\n---\n\n### Why pure data migrations?\n\nMigrations are represented entirely as **pure data**:\n\n* no user functions\n* no closures\n* no reflection\n* no runtime code generation\n\nAs a result:\n\n* migrations can be **serialized**\n* stored in **registries**\n* applied **dynamically**\n* inspected and transformed\n* used to generate:\n\n  * upgraders\n  * downgraders\n  * SQL DDL / DML\n  * offline data transforms\n\nWhile code generation is **out of scope for this ticket**, this explains many design decisions (invertibility, path-based actions, no functions).\n\n---\n\n## Core Architecture\n\n### Type Hierarchy\n\n```scala\n// Typed migration (user-facing API)\ncase class Migration[A, B](\n  dynamicMigration: DynamicMigration,\n  sourceSchema: Schema[A], // These are structural schemas!!!\n  targetSchema: Schema[B] // These are structural schemas!!!\n) {\n  /** Apply migration to transform A to B */\n  def apply(value: A): Either[MigrationError, B]\n\n  /** Compose migrations sequentially */\n  def ++[C](that: Migration[B, C]): Migration[A, C]\n\n  /** Alias for ++ */\n  def andThen[C](that: Migration[B, C]): Migration[A, C] = this ++ that\n\n  /** Reverse migration (structural inverse; runtime is best-effort) */\n  def reverse: Migration[B, A]\n}\n```\n\n```scala\n// Untyped migration (pure data, fully serializable)\ncase class DynamicMigration(\n  actions: Vector[MigrationAction]\n) {\n  def apply(value: DynamicValue): Either[MigrationError, DynamicValue]\n  def ++(that: DynamicMigration): DynamicMigration\n  def reverse: DynamicMigration\n}\n```\n\n* `Migration[A, B]` is introspectable, but not pure data due to bindings inside schemas\n* `DynamicMigration` is **fully serializable**\n\n---\n\n## User-Facing API: Selector Expressions\n\n### Selectors, not optics\n\nThe user-facing API **does not expose optics**.\n\nInstead, all locations are specified using **selector expressions**:\n\n```scala\nS => A\n```\n\nExamples:\n\n```scala\n_.name\n_.address.street\n_.addresses.each.streetNumber\n_.country.when[UK]\n```\n\nTo see the syntax, one can look at the `optic` macro, which utilizes the same selector syntax for optic creation (e.g. `optic(_.address.street)`, etc.).\n\n### Macro extraction\n\nAll builder methods that accept selectors are **implemented via macros** (or via a macro-generated type class such as `ToDynamicOptic`).\n\nThe macro:\n\n1. Inspects the selector expression\n2. Validates it is a supported projection\n3. Converts it into a `DynamicOptic`\n4. Stores that optic in the migration action\n\nSupported projections include:\n\n* field access (`_.foo.bar`)\n* case selection (`_.country.when[UK]`)\n* collection traversal (`_.items.each`)\n* (future) key access, wrappers, etc.\n\n`DynamicOptic` is **never exposed publicly**.\n\n---\n\n## Migration Builder\n\nAll selector-accepting methods are implemented via macros. For simplicity, these are shown as functions (e.g. `A => Any`), but this is NOT the way to implement them. Either all these functions need to be macros, or a macro needs to be used to generate an implicit / given at each call site. Macros may do additional validation to constrain the validity of these different types of transformations.\n\n```scala\nclass MigrationBuilder[A, B](\n  sourceSchema: Schema[A],\n  targetSchema: Schema[B],\n  actions: Vector[MigrationAction]\n) {\n\n  // ----- Record operations -----\n\n  def addField(\n    target: B => Any,\n    default: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  def dropField(\n    source: A => Any,\n    defaultForReverse: SchemaExpr[B, ?] = SchemaExpr.DefaultValue\n  ): MigrationBuilder[A, B]\n\n  def renameField(\n    from: A => Any,\n    to: B => Any\n  ): MigrationBuilder[A, B]\n\n  def transformField(\n    from: A => Any,\n    to: B => Any,\n    transform: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  def mandateField(\n    source: A => Option[?],\n    target: B => Any,\n    default: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  def optionalizeField(\n    source: A => Any,\n    target: B => Option[?]\n  ): MigrationBuilder[A, B]\n\n  def changeFieldType(\n    source: A => Any,\n    target: B => Any,\n    converter: SchemaExpr[A, ?]  // primitive-to-primitive only\n  ): MigrationBuilder[A, B]\n\n  // ----- Enum operations (limited) -----\n\n  def renameCase[SumA, SumB](\n    from: String,\n    to: String\n  ): MigrationBuilder[A, B]\n\n  def transformCase[SumA, CaseA, SumB, CaseB](\n    caseMigration: MigrationBuilder[CaseA, CaseB] => MigrationBuilder[CaseA, CaseB]\n  ): MigrationBuilder[A, B]\n\n  // ----- Collections -----\n\n  def transformElements(\n    at: A => Vector[?],\n    transform: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  // ----- Maps -----\n\n  def transformKeys(\n    at: A => Map[?, ?],\n    transform: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  def transformValues(\n    at: A => Map[?, ?],\n    transform: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  /** Build migration with full macro validation */\n  def build: Migration[A, B]\n\n  /** Build migration without full validation */\n  def buildPartial: Migration[A, B]\n}\n```\n\n---\n\n## Migration Actions (Untyped Core)\n\nAll actions operate at a **path**, represented by `DynamicOptic`.\n\n```scala\nsealed trait MigrationAction {\n  def at: DynamicOptic\n  def reverse: MigrationAction\n}\n```\n\n### Record Actions\n\n```scala\ncase class AddField(\n  at: DynamicOptic,\n  default: SchemaExpr[?]\n) extends MigrationAction\n\ncase class DropField(\n  at: DynamicOptic,\n  defaultForReverse: SchemaExpr[?]\n) extends MigrationAction\n\ncase class Rename(\n  at: DynamicOptic,\n  to: String\n) extends MigrationAction\n\ncase class TransformValue(\n  at: DynamicOptic,\n  transform: SchemaExpr[?]\n) extends MigrationAction\n\ncase class Mandate(\n  at: DynamicOptic,\n  default: SchemaExpr[?]\n) extends MigrationAction\n\ncase class Optionalize(\n  at: DynamicOptic\n) extends MigrationAction\n\ncase class Join(\n  at: DynamicOptic,\n  sourcePaths: Vector[DynamicOptic],\n  combiner: SchemaExpr[?]\n) extends MigrationAction\n\ncase class Split(\n  at: DynamicOptic,\n  targetPaths: Vector[DynamicOptic],\n  splitter: SchemaExpr[?]\n) extends MigrationAction\n\ncase class ChangeType(\n  at: DynamicOptic,\n  converter: SchemaExpr[?]\n) extends MigrationAction\n```\n\n---\n\n### Enum Actions (Supported)\n\n```scala\ncase class RenameCase(\n  at: DynamicOptic,\n  from: String,\n  to: String\n) extends MigrationAction\n\ncase class TransformCase(\n  at: DynamicOptic,\n  actions: Vector[MigrationAction]\n) extends MigrationAction\n```\n\n> Enum case addition / removal is **out of scope** for this ticket\n> (requires composite value construction).\n\n---\n\n### Collection / Map Actions\n\n```scala\ncase class TransformElements(\n  at: DynamicOptic,\n  transform: SchemaExpr[?]\n) extends MigrationAction\n\ncase class TransformKeys(\n  at: DynamicOptic,\n  transform: SchemaExpr[?]\n) extends MigrationAction\n\ncase class TransformValues(\n  at: DynamicOptic,\n  transform: SchemaExpr[?]\n) extends MigrationAction\n```\n\n---\n\n## SchemaExpr Integration\n\n* Used for all value-level transformations\n* **Constraints for this ticket**:\n\n  * primitive  primitive only\n  * joins / splits must produce primitives\n  * no record / enum construction\n\n### `SchemaExpr.DefaultValue`\n\nA special expression that:\n\n1. uses the macro-captured field schema\n2. calls `schema.defaultValue`\n3. converts the value to `DynamicValue`\n4. is stored for reverse migrations\n\n---\n\n## Type Modeling\n\n### Records (Structural Types)\n\n```scala\ntype PersonV0 = { val firstName: String; val lastName: String }\ntype PersonV1 = { val fullName: String; val age: Int }\n\nimplicit val v0Schema: Schema[PersonV0] = Schema.structural[PersonV0]\nimplicit val v1Schema: Schema[PersonV1] = Schema.structural[PersonV1]\n```\n\n---\n\n### Enums (Union of Structural Types with Tags)\n\nEnums are encoded into structural types by using union types, together with singleton types (string literals, which represent the name of the case of the enum).\n\nIn structural types, the names of the type aliases shown below are not relevant, nor are they used.\n\n```scala\ntype OldCreditCard =\n  { type Tag = \"CreditCard\"; def number: String; def exp: String }\ntype OldWireTransfer =\n  { type Tag = \"WireTransfer\"; def account: String; def routing: String }\ntype OldPaymentMethod = OldCreditCard | OldWireTransfer\n```\n\nMacros extract:\n\n* refinement type  structure of the case\n* type `Tag` with singleton type  case tag\n\n---\n\n## Laws\n\n### Identity\n\n```scala\nMigration.identity[A].apply(a) == Right(a)\n```\n\n### Associativity\n\n```scala\n(m1 ++ m2) ++ m3 == m1 ++ (m2 ++ m3)\n```\n\n### Structural Reverse\n\n```scala\nm.reverse.reverse == m\n```\n\n### Best-Effort Semantic Inverse\n\n```scala\nm.apply(a) == Right(b)  m.reverse.apply(b) == Right(a)\n```\n\n(when sufficient information exists)\n\n---\n\n## Error Handling\n\n* All runtime errors return `MigrationError`\n* Errors must capture **path information** (`DynamicOptic`)\n* Enables diagnostics such as:\n\n> Failed to apply TransformValue at `.addresses.each.streetNumber`\n\n---\n\n## Example\n\n```scala\ntype PersonV0 = { val firstName: String; val lastName: String }\n\n@schema\ncase class Person(fullName: String, age: Int)\n\nval migration =\n  Migration.newBuilder[PersonV0, Person]\n    .addField(_.age, 0)\n    .build\n\nval old =\n  new { val firstName = \"John\"; val lastName = \"Doe\" }\n\nmigration(old)\n// Right(Person(\"John Doe\", 0))\n```\n\n---\n\n## Success Criteria\n\n* [ ] `DynamicMigration` fully serializable\n* [ ] `Migration[A, B]` wraps schemas and actions\n* [ ] All actions path-based via `DynamicOptic`\n* [ ] User API uses selector functions (`S => A`) for \"optics\" on old and new types\n* [ ] Macro validation in `.build` to confirm \"old\" has been migrated to \"new\"\n* [ ] `.buildPartial` supported\n* [ ] Structural reverse implemented\n* [ ] Identity & associativity laws hold\n* [ ] Enum rename / transform supported\n* [ ] Errors include path information\n* [ ] Comprehensive tests\n* [ ] Scala 2.13 and Scala 3.5+ supported\n",
              "url": "https://github.com/zio/zio-blocks/issues/519",
              "tech": [],
              "repo_name": "zio-blocks",
              "repo_owner": "zio",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "ZIO#517",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "ZIO",
              "id": "generated-ZIO",
              "name": "ZIO",
              "description": "",
              "members": [],
              "display_name": "ZIO",
              "created_at": "2026-01-26T23:56:55.043Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/ZIO?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "zio",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-26T23:56:55.043Z",
            "created_at": "2026-01-26T23:56:55.043Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-ZIO#517",
              "status": "open",
              "type": "issue",
              "number": 517,
              "title": "Add structural schemas",
              "source": {
                "data": {
                  "id": "source-ZIO#517",
                  "user": {
                    "login": "jdegoes",
                    "id": 156745,
                    "node_id": "MDQ6VXNlcjE1Njc0NQ==",
                    "avatar_url": "https://avatars.githubusercontent.com/u/156745?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/jdegoes",
                    "html_url": "https://github.com/jdegoes",
                    "followers_url": "https://api.github.com/users/jdegoes/followers",
                    "following_url": "https://api.github.com/users/jdegoes/following{/other_user}",
                    "gists_url": "https://api.github.com/users/jdegoes/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/jdegoes/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/jdegoes/subscriptions",
                    "organizations_url": "https://api.github.com/users/jdegoes/orgs",
                    "repos_url": "https://api.github.com/users/jdegoes/repos",
                    "events_url": "https://api.github.com/users/jdegoes/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/jdegoes/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Add structural schemas",
                  "body": "# Structural Type Schema Support\n\n## Overview\n\nExtend `Schema[A]` to support structural types, enabling schema derivation for types defined by their structure rather than their nominal identity. This allows for duck-typed schema validation and conversion between nominal and structural representations.\n\n## Core Concepts\n\n### Direct Structural Schema Derivation\n\nSchemas can be derived directly for structural types:\n\n```scala\n// Scala 3\ntype Person = { def name: String; def age: Int }\nval schema = Schema.derived[Person]\n\n// Scala 2\ntype Person = { def name: String; def age: Int }\nval schema = Schema.derived[Person]\n```\n\n**Note**: Both Scala 2 and Scala 3 use `def` for uniformity, even though Scala 3 supports `val` in structural types.\n\n**Implementation**: Schemas have bindings, which allow construction / deconstruction of values. Values for structural types are backed by:\n- **Scala 3**: `Selectable` \n- **Scala 2**: `Dynamic`\n\n### Nominal to Structural Conversion\n\nConvert nominal type schemas to their structural equivalents:\n\n```scala\ncase class Person(name: String, age: Int)\n\n// Get the structural schema corresponding to Person's shape\nval structuralSchema: Schema[{ def name: String; def age: Int }] = \n  Schema.derived[Person].structural\n```\n\n### Schema API Extension\n\n```scala\ncase class Schema[A](/* existing fields */) {\n  /**\n   * Convert this schema to a structural type schema.\n   * \n   * The structural type represents the \"shape\" of A without its nominal identity.\n   * This enables duck typing and structural validation.\n   * \n   * @param toStructural Macro-generated conversion to structural representation\n   * @return Schema for the structural type corresponding to A\n   */\n  def structural(implicit toStructural: ToStructural[A]): Schema[toStructural.StructuralType] = \n    toStructural.apply(this)\n}\n\n/**\n * Type class for converting nominal schemas to structural schemas.\n * Generated by macro for all supported types. Macro fails if a structural\n * type cannot be generated.\n *\n * NOTE: This approach has to be tested to yield inferrable types, and revised\n * if necessary. Inferrable types (from calling Schema#structural) are a must-have.\n */\ntrait ToStructural[A] {\n  type StructuralType\n  def apply(schema: Schema[A]): Schema[StructuralType]\n}\n\nobject ToStructural {\n  type Aux[A, S] = ToStructural[A] { type StructuralType = S }\n  \n  // Scala 3\n  transparent inline given [A]: ToStructural[A] = ${toStructuralMacro[A]}\n  \n  // Scala 2\n  implicit def materialize[A]: ToStructural[A] = macro toStructuralImpl[A]\n}\n```\n\n---\n\n## Examples\n\n### 1. Simple Product Types\n\n#### Case Class to Structural\n\n```scala\n// Both Scala 2 and Scala 3\ncase class Person(name: String, age: Int)\n\n// Original nominal schema\nval nominalSchema: Schema[Person] = Schema.derived[Person]\n\n// Convert to structural\nval structuralSchema: Schema[{ def name: String; def age: Int }] = \n  nominalSchema.structural\n\n// Direct structural derivation (equivalent)\nval directStructural: Schema[{ def name: String; def age: Int }] = \n  Schema.derived[{ def name: String; def age: Int }]\n```\n\n### 2. Nested Structures\n\n```scala\ncase class Address(street: String, city: String, zip: Int)\ncase class Person(name: String, age: Int, address: Address)\n\nval structuralSchema = Schema.derived[Person].structural\n// Type: Schema[{ \n//   def name: String\n//   def age: Int\n//   def address: { def street: String; def city: String; def zip: Int }\n// }]\n```\n\n### 3. Collections and Options\n\n```scala\ncase class Team(name: String, members: List[String], leader: Option[String])\n\nval structuralSchema = Schema.derived[Team].structural\n// Type: Schema[{\n//   def name: String\n//   def members: List[String]\n//   def leader: Option[String]\n// }]\n```\n\n### 4. Tuples to Structural\n\n```scala\n// Tuples can be converted to structural types\nval tupleSchema: Schema[(String, Int, Boolean)] = Schema.derived[(String, Int, Boolean)]\n\nval structuralSchema = tupleSchema.structural\n// Type: Schema[{ def _1: String; def _2: Int; def _3: Boolean }]\n```\n\n### 5. Sum Types (Sealed Traits) - Scala 3 Only\n\nSealed traits become union types of structural representations, with tag information stored at the type level:\n\n```scala\n// Scala 3 only\nsealed trait Result\ncase class Success(value: Int) extends Result\ncase class Failure(error: String) extends Result\n\nval structuralSchema = Schema.derived[Result].structural\n// Type: Schema[\n//   { type Tag = \"Success\"; def value: Int } | { type Tag = \"Failure\"; def error: String }\n// ]\n```\n\n**Note**: Sum type to structural conversion is **not supported in Scala 2** because it requires union types. Attempting to call `.structural` on a sealed trait schema in Scala 2 will result in a compile-time error.\n\n### 6. Enums (Scala 3 Only)\n\n```scala\nenum Status:\n  case Active, Inactive, Suspended\n\nval structuralSchema = Schema.derived[Status].structural\n// Type: Schema[{type Tag = \"Active\"} | {type Tag = \"Inactive\"} | {type Tag = \"Suspended\"}]\n```\n\n### 7. Opaque Types (Scala 3)\n\n```scala\nopaque type UserId = String\nobject UserId:\n  def apply(value: String): Either[String, UserId] = \n    if value.nonEmpty then Right(value) else Left(\"Empty user ID\")\n\ncase class User(id: UserId, name: String)\n\nval structuralSchema = Schema.derived[User].structural\n// Type: Schema[{ def id: String; def name: String }]\n// Opaque type is unwrapped to its underlying type\n```\n\n### 8. Bidirectional Conversion\n\nStructural schemas work seamlessly with `Into`/`As` (if this ticket is implemented **after** that ticket):\n\n```scala\ncase class Person(name: String, age: Int)\n\nval structuralSchema = Schema.derived[Person].structural\n\n// Create structural value (Scala 3)\nval structuralPerson = new Selectable {\n  def selectDynamic(field: String): Any = field match {\n    case \"name\" => \"Alice\"\n    case \"age\" => 30\n  }\n}\n\n// Convert structural to nominal using Into\nval person: Either[SchemaError, Person] = \n  Into[{ def name: String; def age: Int }, Person].into(structuralPerson)\n// => Right(Person(\"Alice\", 30))\n\n// Convert nominal to structural\nval backToStructural: Either[SchemaError, { def name: String; def age: Int }] = \n  Into[Person, { def name: String; def age: Int }].into(Person(\"Bob\", 25))\n```\n\n### 9. Empty and Single-Field Products\n\n```scala\n// Empty case class\ncase class Empty()\nval emptyStructural = Schema.derived[Empty].structural\n// Type: Schema[{}]\n\n// Single field\ncase class Id(value: String)\nval idStructural = Schema.derived[Id].structural\n// Type: Schema[{ def value: String }]\n```\n\n### 10. Large Products\n\n```scala\ncase class LargeRecord(\n  f1: String, f2: Int, f3: Boolean, f4: Double, f5: Long,\n  f6: String, f7: Int, f8: Boolean, f9: Double, f10: Long,\n  f11: String, f12: Int, f13: Boolean, f14: Double, f15: Long,\n  f16: String, f17: Int, f18: Boolean, f19: Double, f20: Long,\n  f21: String\n)\n\nval structuralSchema = Schema.derived[LargeRecord].structural\n// Type: Schema[{\n//   def f1: String; def f2: Int; def f3: Boolean; ...\n//   def f21: String\n// }]\n```\n\n---\n\n## Type Name Handling\n\n### Current Limitation\n\nSchemas currently use `TypeName[A]` to identify types. Structural types don't have meaningful nominal type names, which creates a mismatch.\n\n### Temporary Solution\n\nUntil `TypeName[A]` is replaced with `TypeId[A]` (see issue #471), structural schemas will use a normalized string representation of the structural type as a fake type name:\n\n```scala\ncase class Person(name: String, age: Int)\n\nval schema = Schema.derived[Person]\nschema.typeName // => TypeName for \"Person\"\n\nval structural = schema.structural\nstructural.typeName // => TypeName for \"{age:Int,name:String}\"\n// Normalized: fields sorted alphabetically, types fully qualified\n```\n\n### Normalization Rules\n\n1. **Field ordering**: Alphabetical by field name\n2. **Type qualification**: Use simple names for primitives and standard library types\n3. **Whitespace**: No whitespace in generated names\n4. **Collections**: Standard notation (e.g., `List[Int]`)\n5. **Options**: Explicit `Option[T]` notation\n6. **Nested structures**: Recursive application of rules\n7. **Deterministic**: Same structure always produces same normalized name\n\n### Examples\n\n```scala\n// Simple product\ncase class Point(x: Int, y: Int)\nSchema.derived[Point].structural.typeName \n// => \"{x:Int,y:Int}\"\n\n// Nested product\ncase class Address(street: String, zip: Int)\ncase class Person(name: String, address: Address)\nSchema.derived[Person].structural.typeName\n// => \"{address:{street:String,zip:Int},name:String}\"\n\n// With collections\ncase class Team(name: String, members: List[String])\nSchema.derived[Team].structural.typeName\n// => \"{members:List[String],name:String}\"\n\n// Union type (Scala 3)\nsealed trait Result\ncase class Success(value: Int) extends Result\ncase class Failure(error: String) extends Result\nSchema.derived[Result].structural.typeName\n// => \"{error:String}|{value:Int}\"\n```\n\n### Future: TypeId[A]\n\nThe upcoming `TypeId[A]` replacement will properly handle structural types by representing them by their structure rather than a string-based hack. See issue #471 for details.\n\n---\n\n## Limitations and Edge Cases\n\n### 1. Generic Types\n\n**Behavior depends on existing Schema derivation support for generic types.**\n\nIf `Schema.derived[Container[Int]]` already works, then structural conversion should work:\n\n```scala\ncase class Container[T](value: T)\n\n// If this works:\nval schema = Schema.derived[Container[Int]]\n\n// Then this should work:\nval structural = schema.structural\n// Type: Schema[{ def value: Int }]\n```\n\nIf generic type derivation is not currently supported, this ticket **does not require implementing it**. The macro should produce a clear compile-time error for unsupported generic types.\n\n### 2. Recursive Types\n\nRecursive types will **fail at compile-time** because Scala does not support infinite types:\n\n```scala\ncase class Tree(value: Int, children: List[Tree])\n\n// This will FAIL at compile-time:\nval structural = Schema.derived[Tree].structural\n// Compile error: Cannot generate infinite structural type\n\n// The structural type would need to be:\n// { def value: Int; def children: List[{ def value: Int; def children: List[...] }] }\n// which is infinite and unsupported\n```\n\nThe macro must detect recursive types and produce a helpful error message:\n\n```\nCompile error: Cannot generate structural type for recursive type Tree.\nStructural types cannot represent recursive structures.\n```\n\n### 3. Mutually Recursive Types\n\nSimilarly, mutually recursive types are unsupported:\n\n```scala\ncase class Node(id: Int, edges: List[Edge])\ncase class Edge(from: Int, to: Node)\n\n// This will FAIL at compile-time:\nval nodeStructural = Schema.derived[Node].structural\n// Compile error: Cannot generate structural type for mutually recursive types\n```\n\n### 4. Sum Types in Scala 2\n\nSealed traits and sum types **cannot be converted to structural types in Scala 2** because they require union types:\n\n```scala\n// Scala 2\nsealed trait Result\ncase class Success(value: Int) extends Result\ncase class Failure(error: String) extends Result\n\n// This will FAIL at compile-time in Scala 2:\nval structural = Schema.derived[Result].structural\n// Compile error: Cannot generate structural type for sum types in Scala 2.\n// Union types are required, which are only available in Scala 3.\n```\n\nThe macro must detect sum types in Scala 2 and produce a clear error.\n\n### 5. Case Objects\n\nCase objects become empty structural types:\n\n```scala\ncase object Singleton\n\nval structural = Schema.derived[Singleton.type].structural\n// Type: Schema[{}]\n```\n\nFor sum types with case objects (Scala 3):\n\n```scala\nsealed trait Status\ncase object Active extends Status\ncase object Inactive extends Status\n\nval structural = Schema.derived[Status].structural\n// Type: Schema[{} | {}]\n// Not particularly useful, but valid\n```\n\n### 6. Structural Types as Source\n\nDeriving schemas directly for structural types is supported:\n\n```scala\ntype PersonStructure = { def name: String; def age: Int }\n\nval schema = Schema.derived[PersonStructure]\n// Should work if structural type derivation is implemented\n```\n\nThe schema's bindings will use `Selectable` (Scala 3) or `Dynamic` (Scala 2) to construct and deconstruct values.\n\n---\n\n## Integration with Into/As\n\nStructural schemas compose naturally with `Into`/`As` conversions.\n\n### Nominal  Structural\n\n```scala\ncase class Person(name: String, age: Int)\n\n// Auto-derived conversion\nval nominalToStructural: Into[Person, { def name: String; def age: Int }] = \n  Into.derived\n\nval person = Person(\"Alice\", 30)\nval structural = nominalToStructural.into(person)\n// => Right(<Selectable/Dynamic instance>)\n```\n\n### Structural  Nominal\n\n```scala\ntype PersonStructure = { def name: String; def age: Int }\ncase class Person(name: String, age: Int)\n\n// Auto-derived conversion\nval structuralToNominal: Into[PersonStructure, Person] = \n  Into.derived\n\nval structural: PersonStructure = new Selectable {\n  def selectDynamic(field: String): Any = field match {\n    case \"name\" => \"Bob\"\n    case \"age\" => 25\n  }\n}\n\nval person = structuralToNominal.into(structural)\n// => Right(Person(\"Bob\", 25))\n```\n\n### Bidirectional (As)\n\n```scala\ncase class Person(name: String, age: Int)\n\n// Bidirectional conversion\nval personAs: As[Person, { def name: String; def age: Int }] = \n  As.derived\n\n// Nominal  Structural\nval structural = personAs.into(Person(\"Alice\", 30))\n\n// Structural  Nominal\nval nominal = structural.flatMap(personAs.from)\n// Round-trip successful\n```\n\n### Schema-Guided Conversion\n\n```scala\ncase class PersonV1(firstName: String, lastName: String, age: Int)\ncase class PersonV2(name: String, age: Int)\n\n// Use structural type as intermediary\ntype PersonStructure = { def name: String; def age: Int }\n\n// Step 1: Transform V1 to structural (custom logic)\nval v1ToStructural: Into[PersonV1, PersonStructure] = \n  new Into[PersonV1, PersonStructure] {\n    def into(v1: PersonV1): Either[SchemaError, PersonStructure] = {\n      Right(new Selectable {\n        def selectDynamic(field: String): Any = field match {\n          case \"name\" => s\"${v1.firstName} ${v1.lastName}\"\n          case \"age\" => v1.age\n        }\n      })\n    }\n  }\n\n// Step 2: Auto-convert structural to V2\nval structuralToV2: Into[PersonStructure, PersonV2] = Into.derived\n\n// Composed migration\ndef migrate(v1: PersonV1): Either[SchemaError, PersonV2] = {\n  v1ToStructural.into(v1).flatMap(structuralToV2.into)\n}\n```\n\n---\n\n## Testing Requirements\n\n### Test Matrix\n\n1. **Direct Structural Derivation**\n   - Simple products (case classes)\n   - Nested products\n   - Collections (List, Vector, Set, Map, Option, Either)\n   - Tuples (2-22 elements)\n   - Empty case classes\n   - Single-field case classes\n   - Large products (20+ fields)\n   - Case objects\n\n2. **Nominal to Structural Conversion**\n   - Case class  structural\n   - Tuple  structural\n   - Nested case classes  nested structural\n   - Case class with collections  structural with collections\n   - Empty case class  empty structural\n\n3. **Sum Types (Scala 3 Only)**\n   - Sealed trait  union type structural\n   - Sealed trait with case objects\n   - Enum  union type structural\n   - Nested sum types\n\n4. **Type Name Generation**\n   - Simple product normalized name\n   - Nested product normalized name\n   - Name determinism (same structure = same name)\n   - Alphabetical field ordering in names\n   - Union type names (Scala 3)\n\n5. **Selectable/Dynamic Implementation**\n   - Scala 3 Selectable field access\n   - Scala 2 Dynamic field access\n   - Field access correctness\n   - Missing field behavior\n   - Extra field behavior\n\n6. **Integration with Into/As**\n   - Nominal  Structural via Into\n   - Structural  Nominal via Into\n   - Round-trip via As\n   - Composed conversions with structural intermediary\n\n7. **Error Cases (Compile-Time)**\n   - Recursive types produce error\n   - Mutually recursive types produce error\n   - Sum types in Scala 2 produce error\n   - Unsupported types produce helpful errors\n\n8. **Generic Types** (if supported by existing Schema derivation)\n   - Fully applied generic  structural\n   - Generic with nested structural fields\n\n### Scala 2 vs Scala 3 Test Separation\n\n```\nsrc/test/scala/\n  structural/\n    common/\n      SimpleProductSpec.scala\n      NestedProductSpec.scala\n      CollectionsSpec.scala\n      TuplesSpec.scala\n      EmptyProductSpec.scala\n      SingleFieldSpec.scala\n      LargeProductSpec.scala\n      TypeNameNormalizationSpec.scala\n      IntoIntegrationSpec.scala\n      AsIntegrationSpec.scala\n      \n    scala3/\n      UnionTypesSpec.scala\n      SealedTraitToUnionSpec.scala\n      EnumToUnionSpec.scala\n      SelectableImplementationSpec.scala\n      \n    scala2/\n      DynamicImplementationSpec.scala\n      SumTypeErrorSpec.scala (verifies compile error)\n      \n    errors/\n      RecursiveTypeErrorSpec.scala\n      MutualRecursionErrorSpec.scala\n      UnsupportedTypeErrorSpec.scala\n```\n\n### Test Examples\n\n```scala\n// Test: Simple product to structural\ntest(\"case class converts to structural schema\") {\n  case class Person(name: String, age: Int)\n  \n  val structural = Schema.derived[Person].structural\n  \n  // Type check (this is a compile-time test)\n  val _: Schema[{ def name: String; def age: Int }] = structural\n  \n  assert(structural.typeName.toString.contains(\"name\"))\n  assert(structural.typeName.toString.contains(\"age\"))\n}\n\n// Test: Nested products\ntest(\"nested case classes convert to nested structural\") {\n  case class Address(street: String, zip: Int)\n  case class Person(name: String, address: Address)\n  \n  val structural = Schema.derived[Person].structural\n  \n  val _: Schema[{ \n    def name: String\n    def address: { def street: String; def zip: Int }\n  }] = structural\n}\n\n// Test: Tuple to structural\ntest(\"tuple converts to structural with _N fields\") {\n  val structural = Schema.derived[(String, Int, Boolean)].structural\n  \n  val _: Schema[{ def _1: String; def _2: Int; def _3: Boolean }] = structural\n}\n\n// Test: Union type (Scala 3 only)\ntest(\"sealed trait converts to union type structural\") {\n  sealed trait Result\n  case class Success(value: Int) extends Result\n  case class Failure(error: String) extends Result\n  \n  val structural = Schema.derived[Result].structural\n  \n  val _: Schema[{ def value: Int } | { def error: String }] = structural\n}\n\n// Test: Type name normalization\ntest(\"structural type names are normalized and deterministic\") {\n  case class Person(name: String, age: Int)\n  case class User(age: Int, name: String) // Different field order\n  \n  val personStructural = Schema.derived[Person].structural\n  val userStructural = Schema.derived[User].structural\n  \n  // Same structure, same normalized name\n  assert(personStructural.typeName == userStructural.typeName)\n  \n  // Alphabetical ordering\n  assert(personStructural.typeName.toString.contains(\"age\"))\n  assert(personStructural.typeName.toString.indexOf(\"age\") < \n         personStructural.typeName.toString.indexOf(\"name\"))\n}\n\n// Test: Integration with Into\ntest(\"structural to nominal conversion via Into\") {\n  case class Person(name: String, age: Int)\n  type PersonStructure = { def name: String; def age: Int }\n  \n  val structural: PersonStructure = new Selectable {\n    def selectDynamic(field: String): Any = field match {\n      case \"name\" => \"Alice\"\n      case \"age\" => 30\n    }\n  }\n  \n  val person = Into[PersonStructure, Person].into(structural)\n  assert(person == Right(Person(\"Alice\", 30)))\n}\n\n// Test: Round-trip via As\ntest(\"nominal to structural and back preserves data\") {\n  case class Person(name: String, age: Int)\n  type PersonStructure = { def name: String; def age: Int }\n  \n  val original = Person(\"Alice\", 30)\n  \n  val toStructural = As[Person, PersonStructure].into(original)\n  val backToNominal = toStructural.flatMap(As[Person, PersonStructure].from)\n  \n  assert(backToNominal == Right(original))\n}\n\n// Test: Recursive type compile error\ntest(\"recursive types produce compile error\") {\n  case class Tree(value: Int, children: List[Tree])\n  \n  assertDoesNotCompile(\"Schema.derived[Tree].structural\")\n}\n\n// Test: Sum type in Scala 2 compile error\ntest(\"sum types in Scala 2 produce compile error\") {\n  sealed trait Result\n  case class Success(value: Int) extends Result\n  \n  // Scala 2 only\n  assertDoesNotCompile(\"Schema.derived[Result].structural\")\n}\n```\n\n---\n\n## Implementation Notes\n\n### Macro Behavior\n\nThe macro must:\n\n1. **Detect product types** (case classes, tuples) and generate structural types with `def` members\n2. **Detect sum types** (sealed traits, enums) and:\n   - In Scala 3: Generate union types of structural representations\n   - In Scala 2: Fail with clear error message\n3. **Detect recursive types** and fail with clear error message\n4. **Normalize structural type representations** for type name generation\n5. **Generate `ToStructural` instance** with:\n   - `StructuralType` type member set to the generated structural type\n   - `apply` method that transforms the schema appropriately\n6. **Preserve field metadata** from original schema where applicable\n7. **Generate appropriate bindings** using `Selectable` (Scala 3) or `Dynamic` (Scala 2)\n\n### Schema Transformation\n\nWhen converting `Schema[A]` to `Schema[StructuralType]`:\n\n1. **Preserve field information**: Field names, types, optional/required status\n2. **Update type name**: Use normalized structural representation\n3. **Transform bindings**: Replace nominal constructors/deconstructors with structural equivalents\n4. **Preserve validation**: Maintain any validation logic that applies to field values\n5. **Handle nested schemas**: Recursively transform nested product types\n\n### Error Messages\n\nProvide clear compile-time errors:\n\n```scala\n// Recursive type\ncase class Tree(value: Int, children: List[Tree])\nSchema.derived[Tree].structural\n\n// Error:\n\"\"\"\nCannot generate structural type for recursive type Tree.\nStructural types cannot represent recursive structures.\nScala's type system does not support infinite types.\n\"\"\"\n\n// Sum type in Scala 2\nsealed trait Result\ncase class Success(value: Int) extends Result\nSchema.derived[Result].structural\n\n// Error (Scala 2 only):\n\"\"\"\nCannot generate structural type for sum type Result.\nStructural representation of sum types requires union types,\nwhich are only available in Scala 3.\nConsider upgrading to Scala 3 or using a different approach.\n\"\"\"\n```\n\n---\n\n## Deliverables\n\n1.  `ToStructural[A]` trait and macro for Scala 2.13\n2.  `ToStructural[A]` trait and macro for Scala 3.5\n3.  `structural` method on `Schema[A]`\n4.  Support for product types (case classes, tuples)\n5.  Support for sum types (sealed traits, enums) in Scala 3 only\n6.  Normalized type name generation\n7.  `Selectable` bindings (Scala 3) and `Dynamic` bindings (Scala 2)\n8.  Integration with `Into`/`As` for structural  nominal conversions\n9.  Comprehensive test suite (300+ test cases)\n10.  Clear error messages for unsupported cases\n11.  Documentation with examples",
                  "html_url": "https://github.com/zio/zio-blocks/issues/517"
                },
                "type": "github"
              },
              "hash": "zio/zio-blocks#517",
              "body": "# Structural Type Schema Support\n\n## Overview\n\nExtend `Schema[A]` to support structural types, enabling schema derivation for types defined by their structure rather than their nominal identity. This allows for duck-typed schema validation and conversion between nominal and structural representations.\n\n## Core Concepts\n\n### Direct Structural Schema Derivation\n\nSchemas can be derived directly for structural types:\n\n```scala\n// Scala 3\ntype Person = { def name: String; def age: Int }\nval schema = Schema.derived[Person]\n\n// Scala 2\ntype Person = { def name: String; def age: Int }\nval schema = Schema.derived[Person]\n```\n\n**Note**: Both Scala 2 and Scala 3 use `def` for uniformity, even though Scala 3 supports `val` in structural types.\n\n**Implementation**: Schemas have bindings, which allow construction / deconstruction of values. Values for structural types are backed by:\n- **Scala 3**: `Selectable` \n- **Scala 2**: `Dynamic`\n\n### Nominal to Structural Conversion\n\nConvert nominal type schemas to their structural equivalents:\n\n```scala\ncase class Person(name: String, age: Int)\n\n// Get the structural schema corresponding to Person's shape\nval structuralSchema: Schema[{ def name: String; def age: Int }] = \n  Schema.derived[Person].structural\n```\n\n### Schema API Extension\n\n```scala\ncase class Schema[A](/* existing fields */) {\n  /**\n   * Convert this schema to a structural type schema.\n   * \n   * The structural type represents the \"shape\" of A without its nominal identity.\n   * This enables duck typing and structural validation.\n   * \n   * @param toStructural Macro-generated conversion to structural representation\n   * @return Schema for the structural type corresponding to A\n   */\n  def structural(implicit toStructural: ToStructural[A]): Schema[toStructural.StructuralType] = \n    toStructural.apply(this)\n}\n\n/**\n * Type class for converting nominal schemas to structural schemas.\n * Generated by macro for all supported types. Macro fails if a structural\n * type cannot be generated.\n *\n * NOTE: This approach has to be tested to yield inferrable types, and revised\n * if necessary. Inferrable types (from calling Schema#structural) are a must-have.\n */\ntrait ToStructural[A] {\n  type StructuralType\n  def apply(schema: Schema[A]): Schema[StructuralType]\n}\n\nobject ToStructural {\n  type Aux[A, S] = ToStructural[A] { type StructuralType = S }\n  \n  // Scala 3\n  transparent inline given [A]: ToStructural[A] = ${toStructuralMacro[A]}\n  \n  // Scala 2\n  implicit def materialize[A]: ToStructural[A] = macro toStructuralImpl[A]\n}\n```\n\n---\n\n## Examples\n\n### 1. Simple Product Types\n\n#### Case Class to Structural\n\n```scala\n// Both Scala 2 and Scala 3\ncase class Person(name: String, age: Int)\n\n// Original nominal schema\nval nominalSchema: Schema[Person] = Schema.derived[Person]\n\n// Convert to structural\nval structuralSchema: Schema[{ def name: String; def age: Int }] = \n  nominalSchema.structural\n\n// Direct structural derivation (equivalent)\nval directStructural: Schema[{ def name: String; def age: Int }] = \n  Schema.derived[{ def name: String; def age: Int }]\n```\n\n### 2. Nested Structures\n\n```scala\ncase class Address(street: String, city: String, zip: Int)\ncase class Person(name: String, age: Int, address: Address)\n\nval structuralSchema = Schema.derived[Person].structural\n// Type: Schema[{ \n//   def name: String\n//   def age: Int\n//   def address: { def street: String; def city: String; def zip: Int }\n// }]\n```\n\n### 3. Collections and Options\n\n```scala\ncase class Team(name: String, members: List[String], leader: Option[String])\n\nval structuralSchema = Schema.derived[Team].structural\n// Type: Schema[{\n//   def name: String\n//   def members: List[String]\n//   def leader: Option[String]\n// }]\n```\n\n### 4. Tuples to Structural\n\n```scala\n// Tuples can be converted to structural types\nval tupleSchema: Schema[(String, Int, Boolean)] = Schema.derived[(String, Int, Boolean)]\n\nval structuralSchema = tupleSchema.structural\n// Type: Schema[{ def _1: String; def _2: Int; def _3: Boolean }]\n```\n\n### 5. Sum Types (Sealed Traits) - Scala 3 Only\n\nSealed traits become union types of structural representations, with tag information stored at the type level:\n\n```scala\n// Scala 3 only\nsealed trait Result\ncase class Success(value: Int) extends Result\ncase class Failure(error: String) extends Result\n\nval structuralSchema = Schema.derived[Result].structural\n// Type: Schema[\n//   { type Tag = \"Success\"; def value: Int } | { type Tag = \"Failure\"; def error: String }\n// ]\n```\n\n**Note**: Sum type to structural conversion is **not supported in Scala 2** because it requires union types. Attempting to call `.structural` on a sealed trait schema in Scala 2 will result in a compile-time error.\n\n### 6. Enums (Scala 3 Only)\n\n```scala\nenum Status:\n  case Active, Inactive, Suspended\n\nval structuralSchema = Schema.derived[Status].structural\n// Type: Schema[{type Tag = \"Active\"} | {type Tag = \"Inactive\"} | {type Tag = \"Suspended\"}]\n```\n\n### 7. Opaque Types (Scala 3)\n\n```scala\nopaque type UserId = String\nobject UserId:\n  def apply(value: String): Either[String, UserId] = \n    if value.nonEmpty then Right(value) else Left(\"Empty user ID\")\n\ncase class User(id: UserId, name: String)\n\nval structuralSchema = Schema.derived[User].structural\n// Type: Schema[{ def id: String; def name: String }]\n// Opaque type is unwrapped to its underlying type\n```\n\n### 8. Bidirectional Conversion\n\nStructural schemas work seamlessly with `Into`/`As` (if this ticket is implemented **after** that ticket):\n\n```scala\ncase class Person(name: String, age: Int)\n\nval structuralSchema = Schema.derived[Person].structural\n\n// Create structural value (Scala 3)\nval structuralPerson = new Selectable {\n  def selectDynamic(field: String): Any = field match {\n    case \"name\" => \"Alice\"\n    case \"age\" => 30\n  }\n}\n\n// Convert structural to nominal using Into\nval person: Either[SchemaError, Person] = \n  Into[{ def name: String; def age: Int }, Person].into(structuralPerson)\n// => Right(Person(\"Alice\", 30))\n\n// Convert nominal to structural\nval backToStructural: Either[SchemaError, { def name: String; def age: Int }] = \n  Into[Person, { def name: String; def age: Int }].into(Person(\"Bob\", 25))\n```\n\n### 9. Empty and Single-Field Products\n\n```scala\n// Empty case class\ncase class Empty()\nval emptyStructural = Schema.derived[Empty].structural\n// Type: Schema[{}]\n\n// Single field\ncase class Id(value: String)\nval idStructural = Schema.derived[Id].structural\n// Type: Schema[{ def value: String }]\n```\n\n### 10. Large Products\n\n```scala\ncase class LargeRecord(\n  f1: String, f2: Int, f3: Boolean, f4: Double, f5: Long,\n  f6: String, f7: Int, f8: Boolean, f9: Double, f10: Long,\n  f11: String, f12: Int, f13: Boolean, f14: Double, f15: Long,\n  f16: String, f17: Int, f18: Boolean, f19: Double, f20: Long,\n  f21: String\n)\n\nval structuralSchema = Schema.derived[LargeRecord].structural\n// Type: Schema[{\n//   def f1: String; def f2: Int; def f3: Boolean; ...\n//   def f21: String\n// }]\n```\n\n---\n\n## Type Name Handling\n\n### Current Limitation\n\nSchemas currently use `TypeName[A]` to identify types. Structural types don't have meaningful nominal type names, which creates a mismatch.\n\n### Temporary Solution\n\nUntil `TypeName[A]` is replaced with `TypeId[A]` (see issue #471), structural schemas will use a normalized string representation of the structural type as a fake type name:\n\n```scala\ncase class Person(name: String, age: Int)\n\nval schema = Schema.derived[Person]\nschema.typeName // => TypeName for \"Person\"\n\nval structural = schema.structural\nstructural.typeName // => TypeName for \"{age:Int,name:String}\"\n// Normalized: fields sorted alphabetically, types fully qualified\n```\n\n### Normalization Rules\n\n1. **Field ordering**: Alphabetical by field name\n2. **Type qualification**: Use simple names for primitives and standard library types\n3. **Whitespace**: No whitespace in generated names\n4. **Collections**: Standard notation (e.g., `List[Int]`)\n5. **Options**: Explicit `Option[T]` notation\n6. **Nested structures**: Recursive application of rules\n7. **Deterministic**: Same structure always produces same normalized name\n\n### Examples\n\n```scala\n// Simple product\ncase class Point(x: Int, y: Int)\nSchema.derived[Point].structural.typeName \n// => \"{x:Int,y:Int}\"\n\n// Nested product\ncase class Address(street: String, zip: Int)\ncase class Person(name: String, address: Address)\nSchema.derived[Person].structural.typeName\n// => \"{address:{street:String,zip:Int},name:String}\"\n\n// With collections\ncase class Team(name: String, members: List[String])\nSchema.derived[Team].structural.typeName\n// => \"{members:List[String],name:String}\"\n\n// Union type (Scala 3)\nsealed trait Result\ncase class Success(value: Int) extends Result\ncase class Failure(error: String) extends Result\nSchema.derived[Result].structural.typeName\n// => \"{error:String}|{value:Int}\"\n```\n\n### Future: TypeId[A]\n\nThe upcoming `TypeId[A]` replacement will properly handle structural types by representing them by their structure rather than a string-based hack. See issue #471 for details.\n\n---\n\n## Limitations and Edge Cases\n\n### 1. Generic Types\n\n**Behavior depends on existing Schema derivation support for generic types.**\n\nIf `Schema.derived[Container[Int]]` already works, then structural conversion should work:\n\n```scala\ncase class Container[T](value: T)\n\n// If this works:\nval schema = Schema.derived[Container[Int]]\n\n// Then this should work:\nval structural = schema.structural\n// Type: Schema[{ def value: Int }]\n```\n\nIf generic type derivation is not currently supported, this ticket **does not require implementing it**. The macro should produce a clear compile-time error for unsupported generic types.\n\n### 2. Recursive Types\n\nRecursive types will **fail at compile-time** because Scala does not support infinite types:\n\n```scala\ncase class Tree(value: Int, children: List[Tree])\n\n// This will FAIL at compile-time:\nval structural = Schema.derived[Tree].structural\n// Compile error: Cannot generate infinite structural type\n\n// The structural type would need to be:\n// { def value: Int; def children: List[{ def value: Int; def children: List[...] }] }\n// which is infinite and unsupported\n```\n\nThe macro must detect recursive types and produce a helpful error message:\n\n```\nCompile error: Cannot generate structural type for recursive type Tree.\nStructural types cannot represent recursive structures.\n```\n\n### 3. Mutually Recursive Types\n\nSimilarly, mutually recursive types are unsupported:\n\n```scala\ncase class Node(id: Int, edges: List[Edge])\ncase class Edge(from: Int, to: Node)\n\n// This will FAIL at compile-time:\nval nodeStructural = Schema.derived[Node].structural\n// Compile error: Cannot generate structural type for mutually recursive types\n```\n\n### 4. Sum Types in Scala 2\n\nSealed traits and sum types **cannot be converted to structural types in Scala 2** because they require union types:\n\n```scala\n// Scala 2\nsealed trait Result\ncase class Success(value: Int) extends Result\ncase class Failure(error: String) extends Result\n\n// This will FAIL at compile-time in Scala 2:\nval structural = Schema.derived[Result].structural\n// Compile error: Cannot generate structural type for sum types in Scala 2.\n// Union types are required, which are only available in Scala 3.\n```\n\nThe macro must detect sum types in Scala 2 and produce a clear error.\n\n### 5. Case Objects\n\nCase objects become empty structural types:\n\n```scala\ncase object Singleton\n\nval structural = Schema.derived[Singleton.type].structural\n// Type: Schema[{}]\n```\n\nFor sum types with case objects (Scala 3):\n\n```scala\nsealed trait Status\ncase object Active extends Status\ncase object Inactive extends Status\n\nval structural = Schema.derived[Status].structural\n// Type: Schema[{} | {}]\n// Not particularly useful, but valid\n```\n\n### 6. Structural Types as Source\n\nDeriving schemas directly for structural types is supported:\n\n```scala\ntype PersonStructure = { def name: String; def age: Int }\n\nval schema = Schema.derived[PersonStructure]\n// Should work if structural type derivation is implemented\n```\n\nThe schema's bindings will use `Selectable` (Scala 3) or `Dynamic` (Scala 2) to construct and deconstruct values.\n\n---\n\n## Integration with Into/As\n\nStructural schemas compose naturally with `Into`/`As` conversions.\n\n### Nominal  Structural\n\n```scala\ncase class Person(name: String, age: Int)\n\n// Auto-derived conversion\nval nominalToStructural: Into[Person, { def name: String; def age: Int }] = \n  Into.derived\n\nval person = Person(\"Alice\", 30)\nval structural = nominalToStructural.into(person)\n// => Right(<Selectable/Dynamic instance>)\n```\n\n### Structural  Nominal\n\n```scala\ntype PersonStructure = { def name: String; def age: Int }\ncase class Person(name: String, age: Int)\n\n// Auto-derived conversion\nval structuralToNominal: Into[PersonStructure, Person] = \n  Into.derived\n\nval structural: PersonStructure = new Selectable {\n  def selectDynamic(field: String): Any = field match {\n    case \"name\" => \"Bob\"\n    case \"age\" => 25\n  }\n}\n\nval person = structuralToNominal.into(structural)\n// => Right(Person(\"Bob\", 25))\n```\n\n### Bidirectional (As)\n\n```scala\ncase class Person(name: String, age: Int)\n\n// Bidirectional conversion\nval personAs: As[Person, { def name: String; def age: Int }] = \n  As.derived\n\n// Nominal  Structural\nval structural = personAs.into(Person(\"Alice\", 30))\n\n// Structural  Nominal\nval nominal = structural.flatMap(personAs.from)\n// Round-trip successful\n```\n\n### Schema-Guided Conversion\n\n```scala\ncase class PersonV1(firstName: String, lastName: String, age: Int)\ncase class PersonV2(name: String, age: Int)\n\n// Use structural type as intermediary\ntype PersonStructure = { def name: String; def age: Int }\n\n// Step 1: Transform V1 to structural (custom logic)\nval v1ToStructural: Into[PersonV1, PersonStructure] = \n  new Into[PersonV1, PersonStructure] {\n    def into(v1: PersonV1): Either[SchemaError, PersonStructure] = {\n      Right(new Selectable {\n        def selectDynamic(field: String): Any = field match {\n          case \"name\" => s\"${v1.firstName} ${v1.lastName}\"\n          case \"age\" => v1.age\n        }\n      })\n    }\n  }\n\n// Step 2: Auto-convert structural to V2\nval structuralToV2: Into[PersonStructure, PersonV2] = Into.derived\n\n// Composed migration\ndef migrate(v1: PersonV1): Either[SchemaError, PersonV2] = {\n  v1ToStructural.into(v1).flatMap(structuralToV2.into)\n}\n```\n\n---\n\n## Testing Requirements\n\n### Test Matrix\n\n1. **Direct Structural Derivation**\n   - Simple products (case classes)\n   - Nested products\n   - Collections (List, Vector, Set, Map, Option, Either)\n   - Tuples (2-22 elements)\n   - Empty case classes\n   - Single-field case classes\n   - Large products (20+ fields)\n   - Case objects\n\n2. **Nominal to Structural Conversion**\n   - Case class  structural\n   - Tuple  structural\n   - Nested case classes  nested structural\n   - Case class with collections  structural with collections\n   - Empty case class  empty structural\n\n3. **Sum Types (Scala 3 Only)**\n   - Sealed trait  union type structural\n   - Sealed trait with case objects\n   - Enum  union type structural\n   - Nested sum types\n\n4. **Type Name Generation**\n   - Simple product normalized name\n   - Nested product normalized name\n   - Name determinism (same structure = same name)\n   - Alphabetical field ordering in names\n   - Union type names (Scala 3)\n\n5. **Selectable/Dynamic Implementation**\n   - Scala 3 Selectable field access\n   - Scala 2 Dynamic field access\n   - Field access correctness\n   - Missing field behavior\n   - Extra field behavior\n\n6. **Integration with Into/As**\n   - Nominal  Structural via Into\n   - Structural  Nominal via Into\n   - Round-trip via As\n   - Composed conversions with structural intermediary\n\n7. **Error Cases (Compile-Time)**\n   - Recursive types produce error\n   - Mutually recursive types produce error\n   - Sum types in Scala 2 produce error\n   - Unsupported types produce helpful errors\n\n8. **Generic Types** (if supported by existing Schema derivation)\n   - Fully applied generic  structural\n   - Generic with nested structural fields\n\n### Scala 2 vs Scala 3 Test Separation\n\n```\nsrc/test/scala/\n  structural/\n    common/\n      SimpleProductSpec.scala\n      NestedProductSpec.scala\n      CollectionsSpec.scala\n      TuplesSpec.scala\n      EmptyProductSpec.scala\n      SingleFieldSpec.scala\n      LargeProductSpec.scala\n      TypeNameNormalizationSpec.scala\n      IntoIntegrationSpec.scala\n      AsIntegrationSpec.scala\n      \n    scala3/\n      UnionTypesSpec.scala\n      SealedTraitToUnionSpec.scala\n      EnumToUnionSpec.scala\n      SelectableImplementationSpec.scala\n      \n    scala2/\n      DynamicImplementationSpec.scala\n      SumTypeErrorSpec.scala (verifies compile error)\n      \n    errors/\n      RecursiveTypeErrorSpec.scala\n      MutualRecursionErrorSpec.scala\n      UnsupportedTypeErrorSpec.scala\n```\n\n### Test Examples\n\n```scala\n// Test: Simple product to structural\ntest(\"case class converts to structural schema\") {\n  case class Person(name: String, age: Int)\n  \n  val structural = Schema.derived[Person].structural\n  \n  // Type check (this is a compile-time test)\n  val _: Schema[{ def name: String; def age: Int }] = structural\n  \n  assert(structural.typeName.toString.contains(\"name\"))\n  assert(structural.typeName.toString.contains(\"age\"))\n}\n\n// Test: Nested products\ntest(\"nested case classes convert to nested structural\") {\n  case class Address(street: String, zip: Int)\n  case class Person(name: String, address: Address)\n  \n  val structural = Schema.derived[Person].structural\n  \n  val _: Schema[{ \n    def name: String\n    def address: { def street: String; def zip: Int }\n  }] = structural\n}\n\n// Test: Tuple to structural\ntest(\"tuple converts to structural with _N fields\") {\n  val structural = Schema.derived[(String, Int, Boolean)].structural\n  \n  val _: Schema[{ def _1: String; def _2: Int; def _3: Boolean }] = structural\n}\n\n// Test: Union type (Scala 3 only)\ntest(\"sealed trait converts to union type structural\") {\n  sealed trait Result\n  case class Success(value: Int) extends Result\n  case class Failure(error: String) extends Result\n  \n  val structural = Schema.derived[Result].structural\n  \n  val _: Schema[{ def value: Int } | { def error: String }] = structural\n}\n\n// Test: Type name normalization\ntest(\"structural type names are normalized and deterministic\") {\n  case class Person(name: String, age: Int)\n  case class User(age: Int, name: String) // Different field order\n  \n  val personStructural = Schema.derived[Person].structural\n  val userStructural = Schema.derived[User].structural\n  \n  // Same structure, same normalized name\n  assert(personStructural.typeName == userStructural.typeName)\n  \n  // Alphabetical ordering\n  assert(personStructural.typeName.toString.contains(\"age\"))\n  assert(personStructural.typeName.toString.indexOf(\"age\") < \n         personStructural.typeName.toString.indexOf(\"name\"))\n}\n\n// Test: Integration with Into\ntest(\"structural to nominal conversion via Into\") {\n  case class Person(name: String, age: Int)\n  type PersonStructure = { def name: String; def age: Int }\n  \n  val structural: PersonStructure = new Selectable {\n    def selectDynamic(field: String): Any = field match {\n      case \"name\" => \"Alice\"\n      case \"age\" => 30\n    }\n  }\n  \n  val person = Into[PersonStructure, Person].into(structural)\n  assert(person == Right(Person(\"Alice\", 30)))\n}\n\n// Test: Round-trip via As\ntest(\"nominal to structural and back preserves data\") {\n  case class Person(name: String, age: Int)\n  type PersonStructure = { def name: String; def age: Int }\n  \n  val original = Person(\"Alice\", 30)\n  \n  val toStructural = As[Person, PersonStructure].into(original)\n  val backToNominal = toStructural.flatMap(As[Person, PersonStructure].from)\n  \n  assert(backToNominal == Right(original))\n}\n\n// Test: Recursive type compile error\ntest(\"recursive types produce compile error\") {\n  case class Tree(value: Int, children: List[Tree])\n  \n  assertDoesNotCompile(\"Schema.derived[Tree].structural\")\n}\n\n// Test: Sum type in Scala 2 compile error\ntest(\"sum types in Scala 2 produce compile error\") {\n  sealed trait Result\n  case class Success(value: Int) extends Result\n  \n  // Scala 2 only\n  assertDoesNotCompile(\"Schema.derived[Result].structural\")\n}\n```\n\n---\n\n## Implementation Notes\n\n### Macro Behavior\n\nThe macro must:\n\n1. **Detect product types** (case classes, tuples) and generate structural types with `def` members\n2. **Detect sum types** (sealed traits, enums) and:\n   - In Scala 3: Generate union types of structural representations\n   - In Scala 2: Fail with clear error message\n3. **Detect recursive types** and fail with clear error message\n4. **Normalize structural type representations** for type name generation\n5. **Generate `ToStructural` instance** with:\n   - `StructuralType` type member set to the generated structural type\n   - `apply` method that transforms the schema appropriately\n6. **Preserve field metadata** from original schema where applicable\n7. **Generate appropriate bindings** using `Selectable` (Scala 3) or `Dynamic` (Scala 2)\n\n### Schema Transformation\n\nWhen converting `Schema[A]` to `Schema[StructuralType]`:\n\n1. **Preserve field information**: Field names, types, optional/required status\n2. **Update type name**: Use normalized structural representation\n3. **Transform bindings**: Replace nominal constructors/deconstructors with structural equivalents\n4. **Preserve validation**: Maintain any validation logic that applies to field values\n5. **Handle nested schemas**: Recursively transform nested product types\n\n### Error Messages\n\nProvide clear compile-time errors:\n\n```scala\n// Recursive type\ncase class Tree(value: Int, children: List[Tree])\nSchema.derived[Tree].structural\n\n// Error:\n\"\"\"\nCannot generate structural type for recursive type Tree.\nStructural types cannot represent recursive structures.\nScala's type system does not support infinite types.\n\"\"\"\n\n// Sum type in Scala 2\nsealed trait Result\ncase class Success(value: Int) extends Result\nSchema.derived[Result].structural\n\n// Error (Scala 2 only):\n\"\"\"\nCannot generate structural type for sum type Result.\nStructural representation of sum types requires union types,\nwhich are only available in Scala 3.\nConsider upgrading to Scala 3 or using a different approach.\n\"\"\"\n```\n\n---\n\n## Deliverables\n\n1.  `ToStructural[A]` trait and macro for Scala 2.13\n2.  `ToStructural[A]` trait and macro for Scala 3.5\n3.  `structural` method on `Schema[A]`\n4.  Support for product types (case classes, tuples)\n5.  Support for sum types (sealed traits, enums) in Scala 3 only\n6.  Normalized type name generation\n7.  `Selectable` bindings (Scala 3) and `Dynamic` bindings (Scala 2)\n8.  Integration with `Into`/`As` for structural  nominal conversions\n9.  Comprehensive test suite (300+ test cases)\n10.  Clear error messages for unsupported cases\n11.  Documentation with examples",
              "url": "https://github.com/zio/zio-blocks/issues/517",
              "tech": [],
              "repo_name": "zio-blocks",
              "repo_owner": "zio",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "ZIO#471",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "ZIO",
              "id": "generated-ZIO",
              "name": "ZIO",
              "description": "",
              "members": [],
              "display_name": "ZIO",
              "created_at": "2026-01-26T23:56:55.061Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/ZIO?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "zio",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-26T23:56:55.061Z",
            "created_at": "2026-01-26T23:56:55.061Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-ZIO#471",
              "status": "open",
              "type": "issue",
              "number": 471,
              "title": "Issue #471",
              "source": {
                "data": {
                  "id": "source-ZIO#471",
                  "user": {
                    "id": 0,
                    "name": "ZIO Team",
                    "location": "",
                    "company": "ZIO",
                    "avatar_url": "https://avatars.githubusercontent.com/u/ZIO?v=4",
                    "login": "ZIO-team",
                    "twitter_username": "",
                    "html_url": "https://github.com/ZIO-team"
                  },
                  "title": "Issue #471",
                  "body": "https://github.com/zio/zio-blocks/pull/650 https://github.com/zio/zio-blocks/pull/529 https://github.com/zio/zio-blocks/pull/612 https://github.com/zio/zio-blocks/pull/780 https://github.com/zio/zio-b",
                  "html_url": "github.com/zio/zio-blocks/issues/471"
                },
                "type": "github"
              },
              "hash": "zio/zio-blocks#471",
              "body": "https://github.com/zio/zio-blocks/pull/650 https://github.com/zio/zio-blocks/pull/529 https://github.com/zio/zio-blocks/pull/612 https://github.com/zio/zio-blocks/pull/780 https://github.com/zio/zio-b",
              "url": "github.com/zio/zio-blocks/issues/471",
              "tech": [],
              "repo_name": "zio-blocks",
              "repo_owner": "zio",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "ZIO#3472",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "ZIO",
              "id": "generated-ZIO",
              "name": "ZIO",
              "description": "",
              "members": [],
              "display_name": "ZIO",
              "created_at": "2026-01-26T23:56:55.079Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/ZIO?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "zio",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-26T23:56:55.079Z",
            "created_at": "2026-01-26T23:56:55.079Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-ZIO#3472",
              "status": "open",
              "type": "issue",
              "number": 3472,
              "title": "Issue #3472",
              "source": {
                "data": {
                  "id": "source-ZIO#3472",
                  "user": {
                    "id": 0,
                    "name": "ZIO Team",
                    "location": "",
                    "company": "ZIO",
                    "avatar_url": "https://avatars.githubusercontent.com/u/ZIO?v=4",
                    "login": "ZIO-team",
                    "twitter_username": "",
                    "html_url": "https://github.com/ZIO-team"
                  },
                  "title": "Issue #3472",
                  "body": "https://github.com/zio/zio-blocks/pull/741 https://github.com/zio/zio-blocks/pull/531 https://github.com/zio/zio-blocks/pull/605 https://github.com/zio/zio-blocks/pull/533 https://github.com/zio/zio-b",
                  "html_url": "github.com/zio/zio-http/issues/3472"
                },
                "type": "github"
              },
              "hash": "zio/zio-http#3472",
              "body": "https://github.com/zio/zio-blocks/pull/741 https://github.com/zio/zio-blocks/pull/531 https://github.com/zio/zio-blocks/pull/605 https://github.com/zio/zio-blocks/pull/533 https://github.com/zio/zio-b",
              "url": "github.com/zio/zio-http/issues/3472",
              "tech": [],
              "repo_name": "zio-http",
              "repo_owner": "zio",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "ZIO#9810",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "ZIO",
              "id": "generated-ZIO",
              "name": "ZIO",
              "description": "",
              "members": [],
              "display_name": "ZIO",
              "created_at": "2026-01-26T23:56:55.097Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/ZIO?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "zio",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-26T23:56:55.097Z",
            "created_at": "2026-01-26T23:56:55.097Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-ZIO#9810",
              "status": "open",
              "type": "issue",
              "number": 9810,
              "title": "Issue #9810",
              "source": {
                "data": {
                  "id": "source-ZIO#9810",
                  "user": {
                    "id": 0,
                    "name": "ZIO Team",
                    "location": "",
                    "company": "ZIO",
                    "avatar_url": "https://avatars.githubusercontent.com/u/ZIO?v=4",
                    "login": "ZIO-team",
                    "twitter_username": "",
                    "html_url": "https://github.com/ZIO-team"
                  },
                  "title": "Issue #9810",
                  "body": "https://github.com/zio/zio-blocks/pull/531 https://github.com/zio/zio-blocks/pull/605 https://github.com/zio/zio-blocks/pull/533 https://github.com/zio/zio-blocks/pull/766 https://github.com/zio/zio-h",
                  "html_url": "github.com/zio/zio/issues/9810"
                },
                "type": "github"
              },
              "hash": "zio/zio#9810",
              "body": "https://github.com/zio/zio-blocks/pull/531 https://github.com/zio/zio-blocks/pull/605 https://github.com/zio/zio-blocks/pull/533 https://github.com/zio/zio-blocks/pull/766 https://github.com/zio/zio-h",
              "url": "github.com/zio/zio/issues/9810",
              "tech": [],
              "repo_name": "zio",
              "repo_owner": "zio",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "ZIO#9844",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "ZIO",
              "id": "generated-ZIO",
              "name": "ZIO",
              "description": "",
              "members": [],
              "display_name": "ZIO",
              "created_at": "2026-01-26T23:56:55.115Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/ZIO?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "zio",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-26T23:56:55.115Z",
            "created_at": "2026-01-26T23:56:55.115Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-ZIO#9844",
              "status": "open",
              "type": "issue",
              "number": 9844,
              "title": "Issue #9844",
              "source": {
                "data": {
                  "id": "source-ZIO#9844",
                  "user": {
                    "id": 0,
                    "name": "ZIO Team",
                    "location": "",
                    "company": "ZIO",
                    "avatar_url": "https://avatars.githubusercontent.com/u/ZIO?v=4",
                    "login": "ZIO-team",
                    "twitter_username": "",
                    "html_url": "https://github.com/ZIO-team"
                  },
                  "title": "Issue #9844",
                  "body": "https://github.com/zio/zio-blocks/pull/533 https://github.com/zio/zio-blocks/pull/766 https://github.com/zio/zio-http/issues/3472 https://github.com/zio/zio/issues/9810 https://github.com/zio/zio/pull",
                  "html_url": "github.com/zio/zio/issues/9844"
                },
                "type": "github"
              },
              "hash": "zio/zio#9844",
              "body": "https://github.com/zio/zio-blocks/pull/533 https://github.com/zio/zio-blocks/pull/766 https://github.com/zio/zio-http/issues/3472 https://github.com/zio/zio/issues/9810 https://github.com/zio/zio/pull",
              "url": "github.com/zio/zio/issues/9844",
              "tech": [],
              "repo_name": "zio",
              "repo_owner": "zio",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "ZIO#9878",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "ZIO",
              "id": "generated-ZIO",
              "name": "ZIO",
              "description": "",
              "members": [],
              "display_name": "ZIO",
              "created_at": "2026-01-26T23:56:55.134Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/ZIO?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "zio",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2026-01-26T23:56:55.134Z",
            "created_at": "2026-01-26T23:56:55.134Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-ZIO#9878",
              "status": "open",
              "type": "issue",
              "number": 9878,
              "title": "Issue #9878",
              "source": {
                "data": {
                  "id": "source-ZIO#9878",
                  "user": {
                    "id": 0,
                    "name": "ZIO Team",
                    "location": "",
                    "company": "ZIO",
                    "avatar_url": "https://avatars.githubusercontent.com/u/ZIO?v=4",
                    "login": "ZIO-team",
                    "twitter_username": "",
                    "html_url": "https://github.com/ZIO-team"
                  },
                  "title": "Issue #9878",
                  "body": "https://github.com/zio/zio/issues/9844 https://github.com/zio/zio/pull/10020 https://github.com/zio/zio/pull/10398 https://github.com/zio/zio/pull/10022 https://github.com/zio/zio/pull/9928 https://gi",
                  "html_url": "github.com/zio/zio/issues/9878"
                },
                "type": "github"
              },
              "hash": "zio/zio#9878",
              "body": "https://github.com/zio/zio/issues/9844 https://github.com/zio/zio/pull/10020 https://github.com/zio/zio/pull/10398 https://github.com/zio/zio/pull/10022 https://github.com/zio/zio/pull/9928 https://gi",
              "url": "github.com/zio/zio/issues/9878",
              "tech": [],
              "repo_name": "zio",
              "repo_owner": "zio",
              "forge": "github"
            },
            "timeouts_disabled": false
          }
        ],
        "next_cursor": null
      }
    }
  }
}