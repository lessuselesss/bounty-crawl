{
  "result": {
    "data": {
      "json": {
        "items": [
          {
            "id": "triggerdotdev#2654",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "triggerdotdev",
              "id": "generated-triggerdotdev",
              "name": "Triggerdotdev",
              "description": "",
              "members": [],
              "display_name": "Triggerdotdev",
              "created_at": "2025-12-30T19:50:04.429Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/triggerdotdev?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "colinhacks",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2025-12-30T19:50:04.429Z",
            "created_at": "2025-12-30T19:50:04.429Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-triggerdotdev#2654",
              "status": "open",
              "type": "issue",
              "number": 2654,
              "title": "Schema in object being inferred differently (and weirdly)",
              "source": {
                "data": {
                  "id": "source-triggerdotdev#2654",
                  "user": {
                    "login": "ericallam",
                    "id": 534,
                    "node_id": "MDQ6VXNlcjUzNA==",
                    "avatar_url": "https://avatars.githubusercontent.com/u/534?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/ericallam",
                    "html_url": "https://github.com/ericallam",
                    "followers_url": "https://api.github.com/users/ericallam/followers",
                    "following_url": "https://api.github.com/users/ericallam/following{/other_user}",
                    "gists_url": "https://api.github.com/users/ericallam/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/ericallam/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/ericallam/subscriptions",
                    "organizations_url": "https://api.github.com/users/ericallam/orgs",
                    "repos_url": "https://api.github.com/users/ericallam/repos",
                    "events_url": "https://api.github.com/users/ericallam/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/ericallam/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Schema in object being inferred differently (and weirdly)",
                  "body": "See the following TS snippet:\r\n\r\n```ts\r\nimport { z } from \"zod\";\r\n\r\nconst EventNameSchema = z.string().or(z.array(z.string()));\r\n\r\ntype EventName = z.infer<typeof EventNameSchema>;\r\n// EventName is string | string[]\r\n\r\nconst EventSchema = z.object({\r\n  name: z.string().or(z.array(z.string())) // this is the same as the EventNameSchema\r\n});\r\n\r\ntype EventWithName = z.infer<typeof EventSchema>;\r\ntype EventName2 = EventWithName[\"name\"];\r\n// EventName2 is (string | string[]) & (string | string[] | undefined)\r\n```\r\n\r\nAnd the TS playground: [link](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgLzgXzgMyhEcBEyEAJvgNwBQFAxhAHYDO8AogG4CmdMAcgIYjsAytQAW7ELzgBeFADomUYHQDmACgCUs6KuSzeUKLwCeO+TEUqN69ZQowjYdnDace-JzN1LM7KAB57RwhMZw4uPgFhMQkAPkoAenjQ1winYAY4BSVlOAAfTPNsgG0AXSpaRhYwmCjxSU8tACMAK3ZqGFUECjg4OncALjksy01tXX1DE11htWt1CjQbKkCnFy4AdWAYEVTpOW9fAId2YOSuWtjKFbO3AQAmPbWYTe3Uovw+gXwShKSn1Ie6TgqhmeQKFmUpXUcAAZMDQfkZqUwQBXOjEdiYJTsYjqIA)\r\n\r\nI'm not sure if this is intended or a bug or maybe just a user error. Using zod `3.21.4` and TS `4.8.4`",
                  "html_url": "https://github.com/colinhacks/zod/issues/2654"
                },
                "type": "github"
              },
              "hash": "colinhacks/zod#2654",
              "body": "See the following TS snippet:\r\n\r\n```ts\r\nimport { z } from \"zod\";\r\n\r\nconst EventNameSchema = z.string().or(z.array(z.string()));\r\n\r\ntype EventName = z.infer<typeof EventNameSchema>;\r\n// EventName is string | string[]\r\n\r\nconst EventSchema = z.object({\r\n  name: z.string().or(z.array(z.string())) // this is the same as the EventNameSchema\r\n});\r\n\r\ntype EventWithName = z.infer<typeof EventSchema>;\r\ntype EventName2 = EventWithName[\"name\"];\r\n// EventName2 is (string | string[]) & (string | string[] | undefined)\r\n```\r\n\r\nAnd the TS playground: [link](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgLzgXzgMyhEcBEyEAJvgNwBQFAxhAHYDO8AogG4CmdMAcgIYjsAytQAW7ELzgBeFADomUYHQDmACgCUs6KuSzeUKLwCeO+TEUqN69ZQowjYdnDace-JzN1LM7KAB57RwhMZw4uPgFhMQkAPkoAenjQ1winYAY4BSVlOAAfTPNsgG0AXSpaRhYwmCjxSU8tACMAK3ZqGFUECjg4OncALjksy01tXX1DE11htWt1CjQbKkCnFy4AdWAYEVTpOW9fAId2YOSuWtjKFbO3AQAmPbWYTe3Uovw+gXwShKSn1Ie6TgqhmeQKFmUpXUcAAZMDQfkZqUwQBXOjEdiYJTsYjqIA)\r\n\r\nI'm not sure if this is intended or a bug or maybe just a user error. Using zod `3.21.4` and TS `4.8.4`",
              "url": "https://github.com/colinhacks/zod/issues/2654",
              "tech": [],
              "repo_name": "zod",
              "repo_owner": "colinhacks",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "omnigres#823",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "omnigres",
              "id": "generated-omnigres",
              "name": "Omnigres",
              "description": "",
              "members": [],
              "display_name": "Omnigres",
              "created_at": "2025-12-30T19:50:04.442Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/omnigres?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "omnigres",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2025-12-30T19:50:04.442Z",
            "created_at": "2025-12-30T19:50:04.442Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-omnigres#823",
              "status": "open",
              "type": "issue",
              "number": 823,
              "title": "Problem: omni_schema.dependency and omni_schema.acl views are slow",
              "source": {
                "data": {
                  "id": "source-omnigres#823",
                  "user": {
                    "login": "yrashk",
                    "id": 452,
                    "node_id": "MDQ6VXNlcjQ1Mg==",
                    "avatar_url": "https://avatars.githubusercontent.com/u/452?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/yrashk",
                    "html_url": "https://github.com/yrashk",
                    "followers_url": "https://api.github.com/users/yrashk/followers",
                    "following_url": "https://api.github.com/users/yrashk/following{/other_user}",
                    "gists_url": "https://api.github.com/users/yrashk/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/yrashk/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/yrashk/subscriptions",
                    "organizations_url": "https://api.github.com/users/yrashk/orgs",
                    "repos_url": "https://api.github.com/users/yrashk/repos",
                    "events_url": "https://api.github.com/users/yrashk/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/yrashk/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Problem: omni_schema.dependency and omni_schema.acl views are slow",
                  "body": "This gravely impacts some of our functionality like schema diffing as we scan through all these views and `dependency` and `acl` views are the worst offenders.\n\nProposed solution: find a way to significantly optimize the queries\n\nOne thing is to see what else can be done for the queries themselves â€“ at the very least in `dependency` and `acl` and maybe even other meta views. \n\nhttps://github.com/omnigres/omnigres/blob/master/extensions/omni_schema/src/meta/catalog.sql#L76\n",
                  "html_url": "https://github.com/omnigres/omnigres/issues/823"
                },
                "type": "github"
              },
              "hash": "omnigres/omnigres#823",
              "body": "This gravely impacts some of our functionality like schema diffing as we scan through all these views and `dependency` and `acl` views are the worst offenders.\n\nProposed solution: find a way to significantly optimize the queries\n\nOne thing is to see what else can be done for the queries themselves â€“ at the very least in `dependency` and `acl` and maybe even other meta views. \n\nhttps://github.com/omnigres/omnigres/blob/master/extensions/omni_schema/src/meta/catalog.sql#L76\n",
              "url": "https://github.com/omnigres/omnigres/issues/823",
              "tech": [],
              "repo_name": "omnigres",
              "repo_owner": "omnigres",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "keephq#3960",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "keephq",
              "id": "generated-keephq",
              "name": "Keephq",
              "description": "",
              "members": [],
              "display_name": "Keephq",
              "created_at": "2025-12-30T19:50:06.420Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/keephq?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "keephq",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2025-12-30T19:50:06.420Z",
            "created_at": "2025-12-30T19:50:06.420Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-keephq#3960",
              "status": "open",
              "type": "issue",
              "number": 3960,
              "title": "[ðŸ”Œ Provider]: Nagios Provider",
              "source": {
                "data": {
                  "id": "source-keephq#3960",
                  "user": {
                    "login": "talboren",
                    "id": 68807791,
                    "node_id": "MDQ6VXNlcjY4ODA3Nzkx",
                    "avatar_url": "https://avatars.githubusercontent.com/u/68807791?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/talboren",
                    "html_url": "https://github.com/talboren",
                    "followers_url": "https://api.github.com/users/talboren/followers",
                    "following_url": "https://api.github.com/users/talboren/following{/other_user}",
                    "gists_url": "https://api.github.com/users/talboren/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/talboren/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/talboren/subscriptions",
                    "organizations_url": "https://api.github.com/users/talboren/orgs",
                    "repos_url": "https://api.github.com/users/talboren/repos",
                    "events_url": "https://api.github.com/users/talboren/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/talboren/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "[ðŸ”Œ Provider]: Nagios Provider",
                  "body": "https://www.nagios.org/",
                  "html_url": "https://github.com/keephq/keep/issues/3960"
                },
                "type": "github"
              },
              "hash": "keephq/keep#3960",
              "body": "https://www.nagios.org/",
              "url": "https://github.com/keephq/keep/issues/3960",
              "tech": [],
              "repo_name": "keep",
              "repo_owner": "keephq",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "keephq#3526",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "keephq",
              "id": "generated-keephq",
              "name": "Keephq",
              "description": "",
              "members": [],
              "display_name": "Keephq",
              "created_at": "2025-12-30T19:50:10.170Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/keephq?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "keephq",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2025-12-30T19:50:10.170Z",
            "created_at": "2025-12-30T19:50:10.170Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-keephq#3526",
              "status": "open",
              "type": "issue",
              "number": 3526,
              "title": "[ðŸ”Œ Provider]: Solarwinds",
              "source": {
                "data": {
                  "id": "source-keephq#3526",
                  "user": {
                    "login": "Matvey-Kuk",
                    "id": 3284841,
                    "node_id": "MDQ6VXNlcjMyODQ4NDE=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/3284841?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/Matvey-Kuk",
                    "html_url": "https://github.com/Matvey-Kuk",
                    "followers_url": "https://api.github.com/users/Matvey-Kuk/followers",
                    "following_url": "https://api.github.com/users/Matvey-Kuk/following{/other_user}",
                    "gists_url": "https://api.github.com/users/Matvey-Kuk/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/Matvey-Kuk/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/Matvey-Kuk/subscriptions",
                    "organizations_url": "https://api.github.com/users/Matvey-Kuk/orgs",
                    "repos_url": "https://api.github.com/users/Matvey-Kuk/repos",
                    "events_url": "https://api.github.com/users/Matvey-Kuk/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/Matvey-Kuk/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "[ðŸ”Œ Provider]: Solarwinds",
                  "body": "We're looking for a https://www.solarwinds.com/ provider for Keep.",
                  "html_url": "https://github.com/keephq/keep/issues/3526"
                },
                "type": "github"
              },
              "hash": "keephq/keep#3526",
              "body": "We're looking for a https://www.solarwinds.com/ provider for Keep.",
              "url": "https://github.com/keephq/keep/issues/3526",
              "tech": [],
              "repo_name": "keep",
              "repo_owner": "keephq",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "keephq#3376",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "keephq",
              "id": "generated-keephq",
              "name": "Keephq",
              "description": "",
              "members": [],
              "display_name": "Keephq",
              "created_at": "2025-12-30T19:50:14.302Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/keephq?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "keephq",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2025-12-30T19:50:14.302Z",
            "created_at": "2025-12-30T19:50:14.302Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-keephq#3376",
              "status": "open",
              "type": "issue",
              "number": 3376,
              "title": "[âž• Feature]: Add a way to validate Keep workflows from CI",
              "source": {
                "data": {
                  "id": "source-keephq#3376",
                  "user": {
                    "login": "shahargl",
                    "id": 12069200,
                    "node_id": "MDQ6VXNlcjEyMDY5MjAw",
                    "avatar_url": "https://avatars.githubusercontent.com/u/12069200?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/shahargl",
                    "html_url": "https://github.com/shahargl",
                    "followers_url": "https://api.github.com/users/shahargl/followers",
                    "following_url": "https://api.github.com/users/shahargl/following{/other_user}",
                    "gists_url": "https://api.github.com/users/shahargl/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/shahargl/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/shahargl/subscriptions",
                    "organizations_url": "https://api.github.com/users/shahargl/orgs",
                    "repos_url": "https://api.github.com/users/shahargl/repos",
                    "events_url": "https://api.github.com/users/shahargl/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/shahargl/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "[âž• Feature]: Add a way to validate Keep workflows from CI",
                  "body": "https://github.com/keephq/keep/pull/5498 https://github.com/keephq/keep/pull/5149 https://github.com/keephq/keep/pull/4517 https://github.com/keephq/keep/pull/5499 https://github.com/keephq/keep/issue",
                  "html_url": "https://github.com/keephq/keep/issues/3376"
                },
                "type": "github"
              },
              "hash": "keephq/keep#3376",
              "body": "https://github.com/keephq/keep/pull/5498 https://github.com/keephq/keep/pull/5149 https://github.com/keephq/keep/pull/4517 https://github.com/keephq/keep/pull/5499 https://github.com/keephq/keep/issue",
              "url": "https://github.com/keephq/keep/issues/3376",
              "tech": [],
              "repo_name": "keep",
              "repo_owner": "keephq",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "keephq#3379",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "keephq",
              "id": "generated-keephq",
              "name": "Keephq",
              "description": "",
              "members": [],
              "display_name": "Keephq",
              "created_at": "2025-12-30T19:50:14.634Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/keephq?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "keephq",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2025-12-30T19:50:14.634Z",
            "created_at": "2025-12-30T19:50:14.634Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-keephq#3379",
              "status": "open",
              "type": "issue",
              "number": 3379,
              "title": "[ðŸ”Œ Provider]: ServiceNow pull activity from incidents into incidents",
              "source": {
                "data": {
                  "id": "source-keephq#3379",
                  "user": {
                    "login": "talboren",
                    "id": 68807791,
                    "node_id": "MDQ6VXNlcjY4ODA3Nzkx",
                    "avatar_url": "https://avatars.githubusercontent.com/u/68807791?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/talboren",
                    "html_url": "https://github.com/talboren",
                    "followers_url": "https://api.github.com/users/talboren/followers",
                    "following_url": "https://api.github.com/users/talboren/following{/other_user}",
                    "gists_url": "https://api.github.com/users/talboren/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/talboren/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/talboren/subscriptions",
                    "organizations_url": "https://api.github.com/users/talboren/orgs",
                    "repos_url": "https://api.github.com/users/talboren/repos",
                    "events_url": "https://api.github.com/users/talboren/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/talboren/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "[ðŸ”Œ Provider]: ServiceNow pull activity from incidents into incidents",
                  "body": "As a user, I would like to pull activity from ServiceNow incident into my Keep incident and the other way around.",
                  "html_url": "https://github.com/keephq/keep/issues/3379"
                },
                "type": "github"
              },
              "hash": "keephq/keep#3379",
              "body": "As a user, I would like to pull activity from ServiceNow incident into my Keep incident and the other way around.",
              "url": "https://github.com/keephq/keep/issues/3379",
              "tech": [],
              "repo_name": "keep",
              "repo_owner": "keephq",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "keephq#2112",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "keephq",
              "id": "generated-keephq",
              "name": "Keephq",
              "description": "",
              "members": [],
              "display_name": "Keephq",
              "created_at": "2025-12-30T19:50:14.936Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/keephq?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "keephq",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2025-12-30T19:50:14.936Z",
            "created_at": "2025-12-30T19:50:14.936Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-keephq#2112",
              "status": "open",
              "type": "issue",
              "number": 2112,
              "title": "[ðŸ”Œ Provider]: SNMP provider",
              "source": {
                "data": {
                  "id": "source-keephq#2112",
                  "user": {
                    "login": "shahargl",
                    "id": 12069200,
                    "node_id": "MDQ6VXNlcjEyMDY5MjAw",
                    "avatar_url": "https://avatars.githubusercontent.com/u/12069200?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/shahargl",
                    "html_url": "https://github.com/shahargl",
                    "followers_url": "https://api.github.com/users/shahargl/followers",
                    "following_url": "https://api.github.com/users/shahargl/following{/other_user}",
                    "gists_url": "https://api.github.com/users/shahargl/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/shahargl/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/shahargl/subscriptions",
                    "organizations_url": "https://api.github.com/users/shahargl/orgs",
                    "repos_url": "https://api.github.com/users/shahargl/repos",
                    "events_url": "https://api.github.com/users/shahargl/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/shahargl/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "[ðŸ”Œ Provider]: SNMP provider",
                  "body": "Send SNMP traps/events into Keep as alerts",
                  "html_url": "https://github.com/keephq/keep/issues/2112"
                },
                "type": "github"
              },
              "hash": "keephq/keep#2112",
              "body": "Send SNMP traps/events into Keep as alerts",
              "url": "https://github.com/keephq/keep/issues/2112",
              "tech": [],
              "repo_name": "keep",
              "repo_owner": "keephq",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "ZIO#584",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "ZIO",
              "id": "generated-ZIO",
              "name": "ZIO",
              "description": "",
              "members": [],
              "display_name": "ZIO",
              "created_at": "2025-12-30T19:50:14.848Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/ZIO?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "zio",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2025-12-30T19:50:14.848Z",
            "created_at": "2025-12-30T19:50:14.848Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-ZIO#584",
              "status": "open",
              "type": "issue",
              "number": 584,
              "title": "Replicate ZIO Chunk (from zio/zio) into here",
              "source": {
                "data": {
                  "id": "source-ZIO#584",
                  "user": {
                    "login": "jdegoes",
                    "id": 156745,
                    "node_id": "MDQ6VXNlcjE1Njc0NQ==",
                    "avatar_url": "https://avatars.githubusercontent.com/u/156745?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/jdegoes",
                    "html_url": "https://github.com/jdegoes",
                    "followers_url": "https://api.github.com/users/jdegoes/followers",
                    "following_url": "https://api.github.com/users/jdegoes/following{/other_user}",
                    "gists_url": "https://api.github.com/users/jdegoes/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/jdegoes/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/jdegoes/subscriptions",
                    "organizations_url": "https://api.github.com/users/jdegoes/orgs",
                    "repos_url": "https://api.github.com/users/jdegoes/repos",
                    "events_url": "https://api.github.com/users/jdegoes/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/jdegoes/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Replicate ZIO Chunk (from zio/zio) into here",
                  "body": "ZIO `Chunk` can be replicated into this repository, in a version that omits all the methods that accept or return ZIO effects. Done properly, this new `Chunk` will be a single-file (`Chunk.scala`) containing the latest, highly optimized version of `Chunk`.\n\nAll unit tests and benchmarks should be ported, and the project created as a new top-level directory in this repository, with new SBT build targets for Scala JVM and Scala JS, across Scala 2.13 and 3.5+. \n\nIt will be in a new package: `zio.blocks.chunk` instead of `zio`, to reflect the new organization under the ZIO Blocks banner.\n\n**NOTE**: While test-time dependencies are fine, the new `zio.blocks.chunk` package should have ZERO runtime dependencies; and, in particular, no dependencies on the ZIO effect system, Izumi type tag, etc.",
                  "html_url": "https://github.com/zio/zio-blocks/issues/584"
                },
                "type": "github"
              },
              "hash": "zio/zio-blocks#584",
              "body": "ZIO `Chunk` can be replicated into this repository, in a version that omits all the methods that accept or return ZIO effects. Done properly, this new `Chunk` will be a single-file (`Chunk.scala`) containing the latest, highly optimized version of `Chunk`.\n\nAll unit tests and benchmarks should be ported, and the project created as a new top-level directory in this repository, with new SBT build targets for Scala JVM and Scala JS, across Scala 2.13 and 3.5+. \n\nIt will be in a new package: `zio.blocks.chunk` instead of `zio`, to reflect the new organization under the ZIO Blocks banner.\n\n**NOTE**: While test-time dependencies are fine, the new `zio.blocks.chunk` package should have ZERO runtime dependencies; and, in particular, no dependencies on the ZIO effect system, Izumi type tag, etc.",
              "url": "https://github.com/zio/zio-blocks/issues/584",
              "tech": [],
              "repo_name": "zio-blocks",
              "repo_owner": "zio",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "ZIO#519",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "ZIO",
              "id": "generated-ZIO",
              "name": "ZIO",
              "description": "",
              "members": [],
              "display_name": "ZIO",
              "created_at": "2025-12-30T19:50:15.001Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/ZIO?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "zio",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2025-12-30T19:50:15.001Z",
            "created_at": "2025-12-30T19:50:15.001Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-ZIO#519",
              "status": "open",
              "type": "issue",
              "number": 519,
              "title": "Schema Migration System for ZIO Schema 2",
              "source": {
                "data": {
                  "id": "source-ZIO#519",
                  "user": {
                    "login": "jdegoes",
                    "id": 156745,
                    "node_id": "MDQ6VXNlcjE1Njc0NQ==",
                    "avatar_url": "https://avatars.githubusercontent.com/u/156745?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/jdegoes",
                    "html_url": "https://github.com/jdegoes",
                    "followers_url": "https://api.github.com/users/jdegoes/followers",
                    "following_url": "https://api.github.com/users/jdegoes/following{/other_user}",
                    "gists_url": "https://api.github.com/users/jdegoes/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/jdegoes/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/jdegoes/subscriptions",
                    "organizations_url": "https://api.github.com/users/jdegoes/orgs",
                    "repos_url": "https://api.github.com/users/jdegoes/repos",
                    "events_url": "https://api.github.com/users/jdegoes/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/jdegoes/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Schema Migration System for ZIO Schema 2",
                  "body": "## Overview\n\nImplement a **pure, algebraic migration system** for ZIO Schema 2 that represents **structural transformations between schema versions** as first-class, serializable data.\n\nA migration describes how to transform data from one schema version to another, enabling:\n\n* schema evolution\n* backward / forward compatibility\n* data versioning\n* offline migrations (JSON, SQL, data lakes, registries, etc.)\n\nThe system provides a **typed, macro-validated user API** (`Migration[A, B]`) built on a **pure, serializable core** (`DynamicMigration`) that operates on `DynamicValue`. \n\nThe ADT is fully introspectable and can be used to generate DDL, etc.\n\n## Motivation & Big Picture\n\n### Why structural types?\n\nWhen evolving schemas over time, **older versions of data types should not require runtime representations**.\n\nIn this design:\n\n* **Current versions** are represented by real case classes / enums\n* **Past versions** are represented using:\n\n  * **structural types** for records\n  * **abstract types + intersection types** for sum types\n\nThese types:\n\n* exist **only at compile time**\n* have **no runtime representation**\n* introduce **zero runtime overhead**\n* do **not require optics or instances to be kept around**\n\nThis allows you to describe arbitrarily old versions of data *without polluting your runtime or codebase*.\n\n#### Typical Workflow\n\nA typical workflow looks like:\n\n1. You have a current type:\n\n   ```scala\n   @schema\n   case class Person(name: String, age: Int)\n   ```\n\n2. You derive and copy its structural shape:\n\n   ```scala\n   type PersonV1 = { def name: String; def age: Int }\n   ```\n\n3. You evolve the real type:\n\n   ```scala\n   @schema\n   case class Person(fullName: String, age: Int, country: String)\n   ```\n\n4. You keep only:\n\n   * the **current** runtime type\n   * the **structural type** for the old version\n   * a **pure migration** between them\n\nNo old case classes. No old optics. No runtime baggage.\n\nNote there is no requirement that the \"current\" type actually be a real case class, enum, etc.--so you can work purely with structural types, allowing you to define migrations for data types that are never materialized as runtime structures.\n\n---\n\n### Why pure data migrations?\n\nMigrations are represented entirely as **pure data**:\n\n* no user functions\n* no closures\n* no reflection\n* no runtime code generation\n\nAs a result:\n\n* migrations can be **serialized**\n* stored in **registries**\n* applied **dynamically**\n* inspected and transformed\n* used to generate:\n\n  * upgraders\n  * downgraders\n  * SQL DDL / DML\n  * offline data transforms\n\nWhile code generation is **out of scope for this ticket**, this explains many design decisions (invertibility, path-based actions, no functions).\n\n---\n\n## Core Architecture\n\n### Type Hierarchy\n\n```scala\n// Typed migration (user-facing API)\ncase class Migration[A, B](\n  dynamicMigration: DynamicMigration,\n  sourceSchema: Schema[A], // These are structural schemas!!!\n  targetSchema: Schema[B] // These are structural schemas!!!\n) {\n  /** Apply migration to transform A to B */\n  def apply(value: A): Either[MigrationError, B]\n\n  /** Compose migrations sequentially */\n  def ++[C](that: Migration[B, C]): Migration[A, C]\n\n  /** Alias for ++ */\n  def andThen[C](that: Migration[B, C]): Migration[A, C] = this ++ that\n\n  /** Reverse migration (structural inverse; runtime is best-effort) */\n  def reverse: Migration[B, A]\n}\n```\n\n```scala\n// Untyped migration (pure data, fully serializable)\ncase class DynamicMigration(\n  actions: Vector[MigrationAction]\n) {\n  def apply(value: DynamicValue): Either[MigrationError, DynamicValue]\n  def ++(that: DynamicMigration): DynamicMigration\n  def reverse: DynamicMigration\n}\n```\n\n* `Migration[A, B]` is introspectable, but not pure data due to bindings inside schemas\n* `DynamicMigration` is **fully serializable**\n\n---\n\n## User-Facing API: Selector Expressions\n\n### Selectors, not optics\n\nThe user-facing API **does not expose optics**.\n\nInstead, all locations are specified using **selector expressions**:\n\n```scala\nS => A\n```\n\nExamples:\n\n```scala\n_.name\n_.address.street\n_.addresses.each.streetNumber\n_.country.when[UK]\n```\n\nTo see the syntax, one can look at the `optic` macro, which utilizes the same selector syntax for optic creation (e.g. `optic(_.address.street)`, etc.).\n\n### Macro extraction\n\nAll builder methods that accept selectors are **implemented via macros** (or via a macro-generated type class such as `ToDynamicOptic`).\n\nThe macro:\n\n1. Inspects the selector expression\n2. Validates it is a supported projection\n3. Converts it into a `DynamicOptic`\n4. Stores that optic in the migration action\n\nSupported projections include:\n\n* field access (`_.foo.bar`)\n* case selection (`_.country.when[UK]`)\n* collection traversal (`_.items.each`)\n* (future) key access, wrappers, etc.\n\n`DynamicOptic` is **never exposed publicly**.\n\n---\n\n## Migration Builder\n\nAll selector-accepting methods are implemented via macros. For simplicity, these are shown as functions (e.g. `A => Any`), but this is NOT the way to implement them. Either all these functions need to be macros, or a macro needs to be used to generate an implicit / given at each call site. Macros may do additional validation to constrain the validity of these different types of transformations.\n\n```scala\nclass MigrationBuilder[A, B](\n  sourceSchema: Schema[A],\n  targetSchema: Schema[B],\n  actions: Vector[MigrationAction]\n) {\n\n  // ----- Record operations -----\n\n  def addField(\n    target: B => Any,\n    default: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  def dropField(\n    source: A => Any,\n    defaultForReverse: SchemaExpr[B, ?] = SchemaExpr.DefaultValue\n  ): MigrationBuilder[A, B]\n\n  def renameField(\n    from: A => Any,\n    to: B => Any\n  ): MigrationBuilder[A, B]\n\n  def transformField(\n    from: A => Any,\n    to: B => Any,\n    transform: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  def mandateField(\n    source: A => Option[?],\n    target: B => Any,\n    default: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  def optionalizeField(\n    source: A => Any,\n    target: B => Option[?]\n  ): MigrationBuilder[A, B]\n\n  def changeFieldType(\n    source: A => Any,\n    target: B => Any,\n    converter: SchemaExpr[A, ?]  // primitive-to-primitive only\n  ): MigrationBuilder[A, B]\n\n  // ----- Enum operations (limited) -----\n\n  def renameCase[SumA, SumB](\n    from: String,\n    to: String\n  ): MigrationBuilder[A, B]\n\n  def transformCase[SumA, CaseA, SumB, CaseB](\n    caseMigration: MigrationBuilder[CaseA, CaseB] => MigrationBuilder[CaseA, CaseB]\n  ): MigrationBuilder[A, B]\n\n  // ----- Collections -----\n\n  def transformElements(\n    at: A => Vector[?],\n    transform: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  // ----- Maps -----\n\n  def transformKeys(\n    at: A => Map[?, ?],\n    transform: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  def transformValues(\n    at: A => Map[?, ?],\n    transform: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  /** Build migration with full macro validation */\n  def build: Migration[A, B]\n\n  /** Build migration without full validation */\n  def buildPartial: Migration[A, B]\n}\n```\n\n---\n\n## Migration Actions (Untyped Core)\n\nAll actions operate at a **path**, represented by `DynamicOptic`.\n\n```scala\nsealed trait MigrationAction {\n  def at: DynamicOptic\n  def reverse: MigrationAction\n}\n```\n\n### Record Actions\n\n```scala\ncase class AddField(\n  at: DynamicOptic,\n  default: SchemaExpr[?]\n) extends MigrationAction\n\ncase class DropField(\n  at: DynamicOptic,\n  defaultForReverse: SchemaExpr[?]\n) extends MigrationAction\n\ncase class Rename(\n  at: DynamicOptic,\n  to: String\n) extends MigrationAction\n\ncase class TransformValue(\n  at: DynamicOptic,\n  transform: SchemaExpr[?]\n) extends MigrationAction\n\ncase class Mandate(\n  at: DynamicOptic,\n  default: SchemaExpr[?]\n) extends MigrationAction\n\ncase class Optionalize(\n  at: DynamicOptic\n) extends MigrationAction\n\ncase class Join(\n  at: DynamicOptic,\n  sourcePaths: Vector[DynamicOptic],\n  combiner: SchemaExpr[?]\n) extends MigrationAction\n\ncase class Split(\n  at: DynamicOptic,\n  targetPaths: Vector[DynamicOptic],\n  splitter: SchemaExpr[?]\n) extends MigrationAction\n\ncase class ChangeType(\n  at: DynamicOptic,\n  converter: SchemaExpr[?]\n) extends MigrationAction\n```\n\n---\n\n### Enum Actions (Supported)\n\n```scala\ncase class RenameCase(\n  at: DynamicOptic,\n  from: String,\n  to: String\n) extends MigrationAction\n\ncase class TransformCase(\n  at: DynamicOptic,\n  actions: Vector[MigrationAction]\n) extends MigrationAction\n```\n\n> Enum case addition / removal is **out of scope** for this ticket\n> (requires composite value construction).\n\n---\n\n### Collection / Map Actions\n\n```scala\ncase class TransformElements(\n  at: DynamicOptic,\n  transform: SchemaExpr[?]\n) extends MigrationAction\n\ncase class TransformKeys(\n  at: DynamicOptic,\n  transform: SchemaExpr[?]\n) extends MigrationAction\n\ncase class TransformValues(\n  at: DynamicOptic,\n  transform: SchemaExpr[?]\n) extends MigrationAction\n```\n\n---\n\n## SchemaExpr Integration\n\n* Used for all value-level transformations\n* **Constraints for this ticket**:\n\n  * primitive â†’ primitive only\n  * joins / splits must produce primitives\n  * no record / enum construction\n\n### `SchemaExpr.DefaultValue`\n\nA special expression that:\n\n1. uses the macro-captured field schema\n2. calls `schema.defaultValue`\n3. converts the value to `DynamicValue`\n4. is stored for reverse migrations\n\n---\n\n## Type Modeling\n\n### Records (Structural Types)\n\n```scala\ntype PersonV0 = { val firstName: String; val lastName: String }\ntype PersonV1 = { val fullName: String; val age: Int }\n\nimplicit val v0Schema: Schema[PersonV0] = Schema.structural[PersonV0]\nimplicit val v1Schema: Schema[PersonV1] = Schema.structural[PersonV1]\n```\n\n---\n\n### Enums (Union of Structural Types with Tags)\n\nEnums are encoded into structural types by using union types, together with singleton types (string literals, which represent the name of the case of the enum).\n\nIn structural types, the names of the type aliases shown below are not relevant, nor are they used.\n\n```scala\ntype OldCreditCard =\n  { type Tag = \"CreditCard\"; def number: String; def exp: String }\ntype OldWireTransfer =\n  { type Tag = \"WireTransfer\"; def account: String; def routing: String }\ntype OldPaymentMethod = OldCreditCard | OldWireTransfer\n```\n\nMacros extract:\n\n* refinement type â†’ structure of the case\n* type `Tag` with singleton type â†’ case tag\n\n---\n\n## Laws\n\n### Identity\n\n```scala\nMigration.identity[A].apply(a) == Right(a)\n```\n\n### Associativity\n\n```scala\n(m1 ++ m2) ++ m3 == m1 ++ (m2 ++ m3)\n```\n\n### Structural Reverse\n\n```scala\nm.reverse.reverse == m\n```\n\n### Best-Effort Semantic Inverse\n\n```scala\nm.apply(a) == Right(b) â‡’ m.reverse.apply(b) == Right(a)\n```\n\n(when sufficient information exists)\n\n---\n\n## Error Handling\n\n* All runtime errors return `MigrationError`\n* Errors must capture **path information** (`DynamicOptic`)\n* Enables diagnostics such as:\n\n> â€œFailed to apply TransformValue at `.addresses.each.streetNumber`â€\n\n---\n\n## Example\n\n```scala\ntype PersonV0 = { val firstName: String; val lastName: String }\n\n@schema\ncase class Person(fullName: String, age: Int)\n\nval migration =\n  Migration.newBuilder[PersonV0, Person]\n    .addField(_.age, 0)\n    .build\n\nval old =\n  new { val firstName = \"John\"; val lastName = \"Doe\" }\n\nmigration(old)\n// Right(Person(\"John Doe\", 0))\n```\n\n---\n\n## Success Criteria\n\n* [ ] `DynamicMigration` fully serializable\n* [ ] `Migration[A, B]` wraps schemas and actions\n* [ ] All actions path-based via `DynamicOptic`\n* [ ] User API uses selector functions (`S => A`) for \"optics\" on old and new types\n* [ ] Macro validation in `.build` to confirm \"old\" has been migrated to \"new\"\n* [ ] `.buildPartial` supported\n* [ ] Structural reverse implemented\n* [ ] Identity & associativity laws hold\n* [ ] Enum rename / transform supported\n* [ ] Errors include path information\n* [ ] Comprehensive tests\n* [ ] Scala 2.13 and Scala 3.5+ supported\n",
                  "html_url": "https://github.com/zio/zio-blocks/issues/519"
                },
                "type": "github"
              },
              "hash": "zio/zio-blocks#519",
              "body": "## Overview\n\nImplement a **pure, algebraic migration system** for ZIO Schema 2 that represents **structural transformations between schema versions** as first-class, serializable data.\n\nA migration describes how to transform data from one schema version to another, enabling:\n\n* schema evolution\n* backward / forward compatibility\n* data versioning\n* offline migrations (JSON, SQL, data lakes, registries, etc.)\n\nThe system provides a **typed, macro-validated user API** (`Migration[A, B]`) built on a **pure, serializable core** (`DynamicMigration`) that operates on `DynamicValue`. \n\nThe ADT is fully introspectable and can be used to generate DDL, etc.\n\n## Motivation & Big Picture\n\n### Why structural types?\n\nWhen evolving schemas over time, **older versions of data types should not require runtime representations**.\n\nIn this design:\n\n* **Current versions** are represented by real case classes / enums\n* **Past versions** are represented using:\n\n  * **structural types** for records\n  * **abstract types + intersection types** for sum types\n\nThese types:\n\n* exist **only at compile time**\n* have **no runtime representation**\n* introduce **zero runtime overhead**\n* do **not require optics or instances to be kept around**\n\nThis allows you to describe arbitrarily old versions of data *without polluting your runtime or codebase*.\n\n#### Typical Workflow\n\nA typical workflow looks like:\n\n1. You have a current type:\n\n   ```scala\n   @schema\n   case class Person(name: String, age: Int)\n   ```\n\n2. You derive and copy its structural shape:\n\n   ```scala\n   type PersonV1 = { def name: String; def age: Int }\n   ```\n\n3. You evolve the real type:\n\n   ```scala\n   @schema\n   case class Person(fullName: String, age: Int, country: String)\n   ```\n\n4. You keep only:\n\n   * the **current** runtime type\n   * the **structural type** for the old version\n   * a **pure migration** between them\n\nNo old case classes. No old optics. No runtime baggage.\n\nNote there is no requirement that the \"current\" type actually be a real case class, enum, etc.--so you can work purely with structural types, allowing you to define migrations for data types that are never materialized as runtime structures.\n\n---\n\n### Why pure data migrations?\n\nMigrations are represented entirely as **pure data**:\n\n* no user functions\n* no closures\n* no reflection\n* no runtime code generation\n\nAs a result:\n\n* migrations can be **serialized**\n* stored in **registries**\n* applied **dynamically**\n* inspected and transformed\n* used to generate:\n\n  * upgraders\n  * downgraders\n  * SQL DDL / DML\n  * offline data transforms\n\nWhile code generation is **out of scope for this ticket**, this explains many design decisions (invertibility, path-based actions, no functions).\n\n---\n\n## Core Architecture\n\n### Type Hierarchy\n\n```scala\n// Typed migration (user-facing API)\ncase class Migration[A, B](\n  dynamicMigration: DynamicMigration,\n  sourceSchema: Schema[A], // These are structural schemas!!!\n  targetSchema: Schema[B] // These are structural schemas!!!\n) {\n  /** Apply migration to transform A to B */\n  def apply(value: A): Either[MigrationError, B]\n\n  /** Compose migrations sequentially */\n  def ++[C](that: Migration[B, C]): Migration[A, C]\n\n  /** Alias for ++ */\n  def andThen[C](that: Migration[B, C]): Migration[A, C] = this ++ that\n\n  /** Reverse migration (structural inverse; runtime is best-effort) */\n  def reverse: Migration[B, A]\n}\n```\n\n```scala\n// Untyped migration (pure data, fully serializable)\ncase class DynamicMigration(\n  actions: Vector[MigrationAction]\n) {\n  def apply(value: DynamicValue): Either[MigrationError, DynamicValue]\n  def ++(that: DynamicMigration): DynamicMigration\n  def reverse: DynamicMigration\n}\n```\n\n* `Migration[A, B]` is introspectable, but not pure data due to bindings inside schemas\n* `DynamicMigration` is **fully serializable**\n\n---\n\n## User-Facing API: Selector Expressions\n\n### Selectors, not optics\n\nThe user-facing API **does not expose optics**.\n\nInstead, all locations are specified using **selector expressions**:\n\n```scala\nS => A\n```\n\nExamples:\n\n```scala\n_.name\n_.address.street\n_.addresses.each.streetNumber\n_.country.when[UK]\n```\n\nTo see the syntax, one can look at the `optic` macro, which utilizes the same selector syntax for optic creation (e.g. `optic(_.address.street)`, etc.).\n\n### Macro extraction\n\nAll builder methods that accept selectors are **implemented via macros** (or via a macro-generated type class such as `ToDynamicOptic`).\n\nThe macro:\n\n1. Inspects the selector expression\n2. Validates it is a supported projection\n3. Converts it into a `DynamicOptic`\n4. Stores that optic in the migration action\n\nSupported projections include:\n\n* field access (`_.foo.bar`)\n* case selection (`_.country.when[UK]`)\n* collection traversal (`_.items.each`)\n* (future) key access, wrappers, etc.\n\n`DynamicOptic` is **never exposed publicly**.\n\n---\n\n## Migration Builder\n\nAll selector-accepting methods are implemented via macros. For simplicity, these are shown as functions (e.g. `A => Any`), but this is NOT the way to implement them. Either all these functions need to be macros, or a macro needs to be used to generate an implicit / given at each call site. Macros may do additional validation to constrain the validity of these different types of transformations.\n\n```scala\nclass MigrationBuilder[A, B](\n  sourceSchema: Schema[A],\n  targetSchema: Schema[B],\n  actions: Vector[MigrationAction]\n) {\n\n  // ----- Record operations -----\n\n  def addField(\n    target: B => Any,\n    default: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  def dropField(\n    source: A => Any,\n    defaultForReverse: SchemaExpr[B, ?] = SchemaExpr.DefaultValue\n  ): MigrationBuilder[A, B]\n\n  def renameField(\n    from: A => Any,\n    to: B => Any\n  ): MigrationBuilder[A, B]\n\n  def transformField(\n    from: A => Any,\n    to: B => Any,\n    transform: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  def mandateField(\n    source: A => Option[?],\n    target: B => Any,\n    default: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  def optionalizeField(\n    source: A => Any,\n    target: B => Option[?]\n  ): MigrationBuilder[A, B]\n\n  def changeFieldType(\n    source: A => Any,\n    target: B => Any,\n    converter: SchemaExpr[A, ?]  // primitive-to-primitive only\n  ): MigrationBuilder[A, B]\n\n  // ----- Enum operations (limited) -----\n\n  def renameCase[SumA, SumB](\n    from: String,\n    to: String\n  ): MigrationBuilder[A, B]\n\n  def transformCase[SumA, CaseA, SumB, CaseB](\n    caseMigration: MigrationBuilder[CaseA, CaseB] => MigrationBuilder[CaseA, CaseB]\n  ): MigrationBuilder[A, B]\n\n  // ----- Collections -----\n\n  def transformElements(\n    at: A => Vector[?],\n    transform: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  // ----- Maps -----\n\n  def transformKeys(\n    at: A => Map[?, ?],\n    transform: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  def transformValues(\n    at: A => Map[?, ?],\n    transform: SchemaExpr[A, ?]\n  ): MigrationBuilder[A, B]\n\n  /** Build migration with full macro validation */\n  def build: Migration[A, B]\n\n  /** Build migration without full validation */\n  def buildPartial: Migration[A, B]\n}\n```\n\n---\n\n## Migration Actions (Untyped Core)\n\nAll actions operate at a **path**, represented by `DynamicOptic`.\n\n```scala\nsealed trait MigrationAction {\n  def at: DynamicOptic\n  def reverse: MigrationAction\n}\n```\n\n### Record Actions\n\n```scala\ncase class AddField(\n  at: DynamicOptic,\n  default: SchemaExpr[?]\n) extends MigrationAction\n\ncase class DropField(\n  at: DynamicOptic,\n  defaultForReverse: SchemaExpr[?]\n) extends MigrationAction\n\ncase class Rename(\n  at: DynamicOptic,\n  to: String\n) extends MigrationAction\n\ncase class TransformValue(\n  at: DynamicOptic,\n  transform: SchemaExpr[?]\n) extends MigrationAction\n\ncase class Mandate(\n  at: DynamicOptic,\n  default: SchemaExpr[?]\n) extends MigrationAction\n\ncase class Optionalize(\n  at: DynamicOptic\n) extends MigrationAction\n\ncase class Join(\n  at: DynamicOptic,\n  sourcePaths: Vector[DynamicOptic],\n  combiner: SchemaExpr[?]\n) extends MigrationAction\n\ncase class Split(\n  at: DynamicOptic,\n  targetPaths: Vector[DynamicOptic],\n  splitter: SchemaExpr[?]\n) extends MigrationAction\n\ncase class ChangeType(\n  at: DynamicOptic,\n  converter: SchemaExpr[?]\n) extends MigrationAction\n```\n\n---\n\n### Enum Actions (Supported)\n\n```scala\ncase class RenameCase(\n  at: DynamicOptic,\n  from: String,\n  to: String\n) extends MigrationAction\n\ncase class TransformCase(\n  at: DynamicOptic,\n  actions: Vector[MigrationAction]\n) extends MigrationAction\n```\n\n> Enum case addition / removal is **out of scope** for this ticket\n> (requires composite value construction).\n\n---\n\n### Collection / Map Actions\n\n```scala\ncase class TransformElements(\n  at: DynamicOptic,\n  transform: SchemaExpr[?]\n) extends MigrationAction\n\ncase class TransformKeys(\n  at: DynamicOptic,\n  transform: SchemaExpr[?]\n) extends MigrationAction\n\ncase class TransformValues(\n  at: DynamicOptic,\n  transform: SchemaExpr[?]\n) extends MigrationAction\n```\n\n---\n\n## SchemaExpr Integration\n\n* Used for all value-level transformations\n* **Constraints for this ticket**:\n\n  * primitive â†’ primitive only\n  * joins / splits must produce primitives\n  * no record / enum construction\n\n### `SchemaExpr.DefaultValue`\n\nA special expression that:\n\n1. uses the macro-captured field schema\n2. calls `schema.defaultValue`\n3. converts the value to `DynamicValue`\n4. is stored for reverse migrations\n\n---\n\n## Type Modeling\n\n### Records (Structural Types)\n\n```scala\ntype PersonV0 = { val firstName: String; val lastName: String }\ntype PersonV1 = { val fullName: String; val age: Int }\n\nimplicit val v0Schema: Schema[PersonV0] = Schema.structural[PersonV0]\nimplicit val v1Schema: Schema[PersonV1] = Schema.structural[PersonV1]\n```\n\n---\n\n### Enums (Union of Structural Types with Tags)\n\nEnums are encoded into structural types by using union types, together with singleton types (string literals, which represent the name of the case of the enum).\n\nIn structural types, the names of the type aliases shown below are not relevant, nor are they used.\n\n```scala\ntype OldCreditCard =\n  { type Tag = \"CreditCard\"; def number: String; def exp: String }\ntype OldWireTransfer =\n  { type Tag = \"WireTransfer\"; def account: String; def routing: String }\ntype OldPaymentMethod = OldCreditCard | OldWireTransfer\n```\n\nMacros extract:\n\n* refinement type â†’ structure of the case\n* type `Tag` with singleton type â†’ case tag\n\n---\n\n## Laws\n\n### Identity\n\n```scala\nMigration.identity[A].apply(a) == Right(a)\n```\n\n### Associativity\n\n```scala\n(m1 ++ m2) ++ m3 == m1 ++ (m2 ++ m3)\n```\n\n### Structural Reverse\n\n```scala\nm.reverse.reverse == m\n```\n\n### Best-Effort Semantic Inverse\n\n```scala\nm.apply(a) == Right(b) â‡’ m.reverse.apply(b) == Right(a)\n```\n\n(when sufficient information exists)\n\n---\n\n## Error Handling\n\n* All runtime errors return `MigrationError`\n* Errors must capture **path information** (`DynamicOptic`)\n* Enables diagnostics such as:\n\n> â€œFailed to apply TransformValue at `.addresses.each.streetNumber`â€\n\n---\n\n## Example\n\n```scala\ntype PersonV0 = { val firstName: String; val lastName: String }\n\n@schema\ncase class Person(fullName: String, age: Int)\n\nval migration =\n  Migration.newBuilder[PersonV0, Person]\n    .addField(_.age, 0)\n    .build\n\nval old =\n  new { val firstName = \"John\"; val lastName = \"Doe\" }\n\nmigration(old)\n// Right(Person(\"John Doe\", 0))\n```\n\n---\n\n## Success Criteria\n\n* [ ] `DynamicMigration` fully serializable\n* [ ] `Migration[A, B]` wraps schemas and actions\n* [ ] All actions path-based via `DynamicOptic`\n* [ ] User API uses selector functions (`S => A`) for \"optics\" on old and new types\n* [ ] Macro validation in `.build` to confirm \"old\" has been migrated to \"new\"\n* [ ] `.buildPartial` supported\n* [ ] Structural reverse implemented\n* [ ] Identity & associativity laws hold\n* [ ] Enum rename / transform supported\n* [ ] Errors include path information\n* [ ] Comprehensive tests\n* [ ] Scala 2.13 and Scala 3.5+ supported\n",
              "url": "https://github.com/zio/zio-blocks/issues/519",
              "tech": [],
              "repo_name": "zio-blocks",
              "repo_owner": "zio",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "ZIO#518",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "ZIO",
              "id": "generated-ZIO",
              "name": "ZIO",
              "description": "",
              "members": [],
              "display_name": "ZIO",
              "created_at": "2025-12-30T19:50:15.168Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/ZIO?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "zio",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2025-12-30T19:50:15.168Z",
            "created_at": "2025-12-30T19:50:15.168Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-ZIO#518",
              "status": "open",
              "type": "issue",
              "number": 518,
              "title": "Add `Into[A, B]` and `As[A, B]` Type Classes with Macro Derivation",
              "source": {
                "data": {
                  "id": "source-ZIO#518",
                  "user": {
                    "login": "jdegoes",
                    "id": 156745,
                    "node_id": "MDQ6VXNlcjE1Njc0NQ==",
                    "avatar_url": "https://avatars.githubusercontent.com/u/156745?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/jdegoes",
                    "html_url": "https://github.com/jdegoes",
                    "followers_url": "https://api.github.com/users/jdegoes/followers",
                    "following_url": "https://api.github.com/users/jdegoes/following{/other_user}",
                    "gists_url": "https://api.github.com/users/jdegoes/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/jdegoes/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/jdegoes/subscriptions",
                    "organizations_url": "https://api.github.com/users/jdegoes/orgs",
                    "repos_url": "https://api.github.com/users/jdegoes/repos",
                    "events_url": "https://api.github.com/users/jdegoes/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/jdegoes/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Add `Into[A, B]` and `As[A, B]` Type Classes with Macro Derivation",
                  "body": "## Overview\n\nAdd two related type classes for type-safe schema evolution:\n\n1. **`Into[A, B]`**: One-way conversion from `A` to `B` with runtime validation\n2. **`As[A, B]`**: Bidirectional conversion establishing a partial equivalence between `A` and `B`\n\nBoth type classes are automatically derived via macros that intelligently map fields using names, positions, and types, with support for validation, coercion, and schema evolution patterns.\n\n---\n\n## Type Class Definitions\n\n### Into[A, B] - One-Way Conversion\n\n```scala\ntrait Into[-A, +B] {\n  def into(input: A): Either[SchemaError, B]\n}\n```\n\n**Purpose**: Convert from source type `A` to target type `B`, potentially failing at runtime when validation constraints cannot be satisfied.\n\n**Use Cases**:\n- Migrating between schema versions\n- Converting between equivalent representations\n- Validating conversions with opaque types\n- Transforming external data into internal models\n\n### As[A, B] - Bidirectional Conversion\n\n```scala\ntrait As[A, B] {\n  def into(input: A): Either[SchemaError, B]\n  def from(input: B): Either[SchemaError, A]\n}\n```\n\n**Purpose**: Establish a partial equivalence between types `A` and `B` where conversion can fail in either direction due to runtime validation.\n\n**Use Cases**:\n- Isomorphic schema versions\n- Equivalent representations (e.g., case class â†” tuple)\n- Reversible transformations with runtime validation\n- Round-trip serialization/deserialization\n\n**Relationship**: `As[A, B]` implies both `Into[A, B]` and `Into[B, A]` exist, but with the additional guarantee that both conversions use compatible mapping logic and can round-trip (subject to runtime validation).\n\n**Note**: `SchemaError` is composable, allowing multiple validation failures to be combined into a single error.\n\n---\n\n## Core Conversion Rules\n\n### Field Mapping Algorithm\n\nThe macro establishes field mappings using three attributes:\n1. **Field name** (identifier in source code)\n2. **Field position** (ordinal position in declaration)\n3. **Field type** (including coercible types)\n\n**Priority for disambiguation:**\n1. **Exact match**: Same name + same type\n2. **Name match with coercion**: Same name + coercible type\n3. **Unique type match**: Type appears only once in both source and target\n4. **Position + unique type**: Positional correspondence with unambiguous type\n5. **Fallback**: If no unambiguous mapping exists, derivation fails at compile-time\n\n### Mapping Examples\n\n#### Unambiguous by Unique Types\n```scala\ncase class Person(name: String, age: Int, active: Boolean)\ncase class User(username: String, yearsOld: Int, enabled: Boolean)\n\n// Success: Each type appears exactly once\n// Mapping: Stringâ†’String, Intâ†’Int, Booleanâ†’Boolean\n```\n\n#### Unambiguous by Names\n```scala\ncase class Point(x: Int, y: Int)\ncase class Coord(y: Int, x: Int)\n\n// Success: Names uniquely identify despite reordering\n// Mapping: xâ†’x, yâ†’y\n```\n\n#### Ambiguous - Compile Failure\n```scala\ncase class Dimensions(width: Int, height: Int)\ncase class Measurements(first: Int, second: Int)\n\n// COMPILE ERROR: Cannot determine mapping\n// Both Int types, different names, ambiguous positional match\n```\n\n#### Disambiguation by Position (Tuples)\n```scala\ncase class RGB(r: Int, g: Int, b: Int)\ntype ColorTuple = (Int, Int, Int)\n\n// Success: Position disambiguates\n// Mapping: râ†’_1, gâ†’_2, bâ†’_3\n```\n\n---\n\n## Supported Conversions\n\n### 1. Product Types (Records)\n\n#### Case Class to Case Class\n```scala\ncase class PersonV1(name: String, age: Int)\ncase class PersonV2(fullName: String, age: Int)\n\n// Success if 'name' is unique String in V1 and 'fullName' is unique String in V2\nInto[PersonV1, PersonV2].into(PersonV1(\"Alice\", 30))\n// => Right(PersonV2(\"Alice\", 30))\n```\n\n#### Case Class to Tuple\n```scala\ncase class Point(x: Double, y: Double)\n\nInto[Point, (Double, Double)].into(Point(1.0, 2.0))\n// => Right((1.0, 2.0))\n```\n\n#### Tuple to Case Class\n```scala\ncase class RGB(red: Int, green: Int, blue: Int)\n\nInto[(Int, Int, Int), RGB].into((255, 128, 64))\n// => Right(RGB(255, 128, 64))\n```\n\n#### Tuple to Tuple\n```scala\nInto[(Int, String), (Long, String)].into((42, \"hello\"))\n// => Right((42L, \"hello\"))\n```\n\n### 2. Coproduct Types (Sum Types)\n\n#### Sealed Trait to Sealed Trait (by name)\n```scala\nsealed trait Color\ncase object Red extends Color\ncase object Blue extends Color\n\nsealed trait Hue\ncase object Red extends Hue\ncase object Blue extends Hue\n\nInto[Color, Hue].into(Red)\n// => Right(Red)\n```\n\n#### Sealed Trait to Sealed Trait (by signature)\n```scala\nsealed trait EventV1\ncase class Created(id: String, ts: Long) extends EventV1\ncase class Deleted(id: String) extends EventV1\n\nsealed trait EventV2\ncase class Spawned(id: String, ts: Long) extends EventV2\ncase class Removed(id: String) extends EventV2\n\nInto[EventV1, EventV2].into(Created(\"abc\", 123L))\n// => Right(Spawned(\"abc\", 123L))\n// Matched by constructor signature (String, Long)\n```\n\n#### Enum to Enum (Scala 3)\n```scala\nenum Status:\n  case Active, Inactive, Suspended\n\nenum State:\n  case Active, Inactive, Suspended\n\nInto[Status, State].into(Status.Active)\n// => Right(State.Active)\n```\n\n#### ADT with Payload Conversion\n```scala\nsealed trait ResultV1\ncase class Success(value: Int) extends ResultV1\ncase class Failure(msg: String) extends ResultV1\n\nsealed trait ResultV2\ncase class Success(value: Long) extends ResultV2\ncase class Failure(msg: String) extends ResultV2\n\nInto[ResultV1, ResultV2].into(Success(42))\n// => Right(Success(42L))\n// Field type coercion within matched case\n```\n\n### 3. Primitive Type Coercions\n\n#### Numeric Widening (Lossless)\n```scala\nInto[Byte, Short].into(42.toByte)    // => Right(42.toShort)\nInto[Short, Int].into(1000.toShort)  // => Right(1000)\nInto[Int, Long].into(100000)         // => Right(100000L)\nInto[Float, Double].into(3.14f)      // => Right(3.14)\n```\n\n#### Numeric Narrowing (with Runtime Validation)\n```scala\nInto[Long, Int].into(42L)\n// => Right(42)\n\nInto[Long, Int].into(3000000000L)\n// => Left(SchemaError(\"Value 3000000000 exceeds Int.MaxValue\"))\n\nInto[Double, Float].into(3.14)\n// => Right(3.14f)\n\nInto[Double, Float].into(1e100)\n// => Left(SchemaError(\"Value 1.0E100 exceeds Float.MaxValue\"))\n```\n\n#### Collection Element Coercion\n```scala\nInto[List[Int], List[Long]].into(List(1, 2, 3))\n// => Right(List(1L, 2L, 3L))\n\nInto[Vector[Float], Vector[Double]].into(Vector(1.5f, 2.5f))\n// => Right(Vector(1.5, 2.5))\n\nInto[Set[Short], Set[Int]].into(Set(10.toShort, 20.toShort))\n// => Right(Set(10, 20))\n\nInto[List[Long], List[Int]].into(List(42L, 3000000000L))\n// => Left(SchemaError(\"Value 3000000000 exceeds Int.MaxValue\"))\n```\n\n#### Nested Collection Coercion\n```scala\nInto[List[List[Int]], List[List[Long]]].into(List(List(1, 2), List(3, 4)))\n// => Right(List(List(1L, 2L), List(3L, 4L)))\n```\n\n#### Map Key/Value Coercion\n```scala\nInto[Map[Int, Float], Map[Long, Double]].into(Map(1 -> 1.5f, 2 -> 2.5f))\n// => Right(Map(1L -> 1.5, 2L -> 2.5))\n\nInto[Map[Long, String], Map[Int, String]].into(Map(42L -> \"a\", 3000000000L -> \"b\"))\n// => Left(SchemaError(\"Key 3000000000 exceeds Int.MaxValue\"))\n```\n\n#### Option Type Coercion\n```scala\nInto[Option[Int], Option[Long]].into(Some(42))\n// => Right(Some(42L))\n\nInto[Option[Int], Option[Long]].into(None)\n// => Right(None)\n\nInto[Option[Long], Option[Int]].into(Some(3000000000L))\n// => Left(SchemaError(\"Value 3000000000 exceeds Int.MaxValue\"))\n```\n\n#### Either Type Coercion\n```scala\nInto[Either[String, Int], Either[String, Long]].into(Right(42))\n// => Right(Right(42L))\n\nInto[Either[Int, String], Either[Long, String]].into(Left(100))\n// => Right(Left(100L))\n```\n\n### 4. Collection Type Conversions\n\n#### Between Standard Collection Types\n```scala\nInto[List[Int], Vector[Int]].into(List(1, 2, 3))\n// => Right(Vector(1, 2, 3))\n\nInto[Vector[String], List[String]].into(Vector(\"a\", \"b\", \"c\"))\n// => Right(List(\"a\", \"b\", \"c\"))\n\nInto[Array[Int], List[Int]].into(Array(1, 2, 3))\n// => Right(List(1, 2, 3))\n\nInto[List[Int], Array[Int]].into(List(1, 2, 3))\n// => Right(Array(1, 2, 3))\n\nInto[Seq[Int], List[Int]].into(Seq(1, 2, 3))\n// => Right(List(1, 2, 3))\n\nInto[List[Int], Seq[Int]].into(List(1, 2, 3))\n// => Right(Seq(1, 2, 3))\n```\n\n#### Set Conversions (Order-Preserving Collections to Set)\n```scala\nInto[List[Int], Set[Int]].into(List(1, 2, 2, 3))\n// => Right(Set(1, 2, 3))\n// Note: Duplicates are removed\n\nInto[Vector[String], Set[String]].into(Vector(\"a\", \"b\", \"a\"))\n// => Right(Set(\"a\", \"b\"))\n```\n\n#### Set to Order-Preserving Collections\n```scala\nInto[Set[Int], List[Int]].into(Set(3, 1, 2))\n// => Right(List(1, 2, 3))\n// Note: Order is determined by Set's iteration order\n\nInto[Set[String], Vector[String]].into(Set(\"c\", \"a\", \"b\"))\n// => Right(Vector(\"a\", \"b\", \"c\"))\n```\n\n#### Combined Element and Collection Type Conversion\n```scala\nInto[List[Int], Vector[Long]].into(List(1, 2, 3))\n// => Right(Vector(1L, 2L, 3L))\n\nInto[Array[Short], List[Int]].into(Array(10.toShort, 20.toShort))\n// => Right(List(10, 20))\n\nInto[Set[Int], List[Long]].into(Set(1, 2, 3))\n// => Right(List(1L, 2L, 3L))\n```\n\n#### Nested Collection Type Conversions\n```scala\nInto[List[Vector[Int]], Vector[List[Long]]].into(List(Vector(1, 2), Vector(3, 4)))\n// => Right(Vector(List(1L, 2L), List(3L, 4L)))\n```\n\n### 5. Structural Types\n\n#### Structural Type Targets (Scala 3 with Selectable)\n```scala\ncase class Point(x: Int, y: Int)\ntype Coord = { def x: Int; def y: Int }\n\nInto[Point, Coord].into(Point(5, 10))\n// => Right(<structural instance with x=5, y=10>)\n```\n\n#### Structural Type Targets (Scala 2 with Dynamic)\n```scala\ncase class Person(name: String, age: Int)\ntype Record = { def name: String; def age: Int }\n\nInto[Person, Record].into(Person(\"Alice\", 30))\n// => Right(<dynamic instance with name=\"Alice\", age=30>)\n```\n\n#### Structural Type Sources\n```scala\ntype PersonLike = { def name: String; def age: Int }\ncase class User(name: String, age: Int)\n\nval personLike: PersonLike = ??? // some structural instance\nInto[PersonLike, User].into(personLike)\n// => Right(User(\"Alice\", 30))\n```\n\n### 6. Schema Evolution Patterns\n\n#### Adding Optional Fields\n```scala\ncase class UserV1(id: String, name: String)\ncase class UserV2(id: String, name: String, email: Option[String])\n\nInto[UserV1, UserV2].into(UserV1(\"123\", \"Alice\"))\n// => Right(UserV2(\"123\", \"Alice\", None))\n```\n\n#### Removing Optional Fields\n```scala\ncase class UserV2(id: String, name: String, email: Option[String])\ncase class UserV1(id: String, name: String)\n\nInto[UserV2, UserV1].into(UserV2(\"123\", \"Alice\", Some(\"alice@example.com\")))\n// => Right(UserV1(\"123\", \"Alice\"))\n// email field is dropped\n```\n\n#### Adding Required Fields with Defaults (Scala 3)\n```scala\ncase class ProductV1(name: String, price: Double)\ncase class ProductV2(name: String, price: Double, available: Boolean = true)\n\nInto[ProductV1, ProductV2].into(ProductV1(\"Widget\", 19.99))\n// => Right(ProductV2(\"Widget\", 19.99, true))\n```\n\n#### Field Reordering\n```scala\ncase class PersonV1(name: String, age: Int, email: String)\ncase class PersonV2(email: String, name: String, age: Int)\n\nInto[PersonV1, PersonV2].into(PersonV1(\"Alice\", 30, \"alice@example.com\"))\n// => Right(PersonV2(\"alice@example.com\", \"Alice\", 30))\n```\n\n#### Field Renaming (with unique types)\n```scala\ncase class PersonV1(fullName: String, yearOfBirth: Int)\ncase class PersonV2(name: String, birthYear: Int)\n\nInto[PersonV1, PersonV2].into(PersonV1(\"Alice Smith\", 1990))\n// => Right(PersonV2(\"Alice Smith\", 1990))\n```\n\n#### Type Refinement\n```scala\ncase class ConfigV1(port: Int, timeout: Int)\ncase class ConfigV2(port: Int, timeout: Long)\n\nInto[ConfigV1, ConfigV2].into(ConfigV1(8080, 30))\n// => Right(ConfigV2(8080, 30L))\n```\n\n### 7. Nested Conversions\n\n#### Nested Products\n```scala\ncase class AddressV1(street: String, zip: Int)\ncase class PersonV1(name: String, address: AddressV1)\n\ncase class AddressV2(street: String, zip: Long)\ncase class PersonV2(name: String, address: AddressV2)\n\nInto[PersonV1, PersonV2].into(\n  PersonV1(\"Alice\", AddressV1(\"Main St\", 12345))\n)\n// => Right(PersonV2(\"Alice\", AddressV2(\"Main St\", 12345L)))\n```\n\n#### Nested Coproducts\n```scala\nsealed trait Inner\ncase class A(x: Int) extends Inner\ncase class B(y: String) extends Inner\n\nsealed trait Outer\ncase class Container(inner: Inner, label: String) extends Outer\n\n// Similar target types with Long instead of Int\nsealed trait InnerV2\ncase class A(x: Long) extends InnerV2\ncase class B(y: String) extends InnerV2\n\nsealed trait OuterV2\ncase class Container(inner: InnerV2, label: String) extends OuterV2\n\nInto[Outer, OuterV2].into(Container(A(42), \"test\"))\n// => Right(Container(A(42L), \"test\"))\n```\n\n#### Collections of Complex Types\n```scala\ncase class PersonV1(name: String, age: Int)\ncase class PersonV2(name: String, age: Long)\n\nInto[List[PersonV1], List[PersonV2]].into(\n  List(PersonV1(\"Alice\", 30), PersonV1(\"Bob\", 25))\n)\n// => Right(List(PersonV2(\"Alice\", 30L), PersonV2(\"Bob\", 25L)))\n```\n\n#### Nested Collections with Type Conversions\n```scala\ncase class DataV1(values: List[Vector[Int]])\ncase class DataV2(values: Vector[List[Long]])\n\nInto[DataV1, DataV2].into(\n  DataV1(List(Vector(1, 2), Vector(3, 4)))\n)\n// => Right(DataV2(Vector(List(1L, 2L), List(3L, 4L))))\n```\n\n---\n\n## Special Type Support\n\n### Opaque Types (Scala 3)\n\nOpaque types with validation are fully supported. The macro generates runtime validation calls.\n\n```scala\n// Definition with validation\nobject Domain:\n  opaque type Age = Int\n  object Age:\n    def apply(value: Int): Either[String, Age] =\n      if value >= 0 && value <= 150 then Right(value)\n      else Left(s\"Invalid age: $value\")\n    \n    def unsafe(value: Int): Age = value\n    \n    extension (age: Age)\n      def toInt: Int = age\n\n  opaque type Email = String\n  object Email:\n    def apply(value: String): Either[String, Email] =\n      if value.contains(\"@\") then Right(value)\n      else Left(s\"Invalid email: $value\")\n    \n    extension (email: Email)\n      def toString: String = email\n\nimport Domain._\n\n// Usage\ncase class PersonV1(name: String, age: Int, email: String)\ncase class PersonV2(name: String, age: Age, email: Email)\n\nInto[PersonV1, PersonV2].into(PersonV1(\"Alice\", 30, \"alice@example.com\"))\n// => Right(PersonV2(\"Alice\", Age.unsafe(30), Email.unsafe(\"alice@example.com\")))\n\nInto[PersonV1, PersonV2].into(PersonV1(\"Alice\", -5, \"alice@example.com\"))\n// => Left(SchemaError(\"Age validation failed: Invalid age: -5\"))\n\nInto[PersonV1, PersonV2].into(PersonV1(\"Alice\", 30, \"invalid\"))\n// => Left(SchemaError(\"Email validation failed: Invalid email: invalid\"))\n```\n\n**Macro Behavior**:\n- Detects opaque type companion objects with `apply(underlying): Either[_, OpaqueType]` method\n- Generates validation calls for each opaque type field\n- Accumulates all validation errors using `SchemaError` composition\n- Falls back to direct conversion if no validation method exists\n\n### Newtype Libraries (Scala 2)\n\n#### ZIO Prelude Newtypes (Built-in Support)\n\nThe macro includes hardcoded support for ZIO Prelude newtypes without requiring a compile-time dependency.\n\n```scala\nimport zio.prelude._\n\n// Definition with validation\nobject Domain {\n  object Age extends Subtype[Int] {\n    override def assertion = assert {\n      Assertion.between(0, 150)\n    }\n  }\n  type Age = Age.Type\n\n  object Email extends Newtype[String] {\n    override def assertion = assert {\n      Assertion.matches(\".*@.*\")\n    }\n  }\n  type Email = Email.Type\n}\n\nimport Domain._\n\n// Usage\ncase class PersonV1(name: String, age: Int, email: String)\ncase class PersonV2(name: String, age: Age, email: Email)\n\nInto[PersonV1, PersonV2].into(PersonV1(\"Alice\", 30, \"alice@example.com\"))\n// => Right(PersonV2(\"Alice\", Age(30), Email(\"alice@example.com\")))\n\nInto[PersonV1, PersonV2].into(PersonV1(\"Alice\", 200, \"invalid\"))\n// => Left(SchemaError(\"Validation failed: age: 200 is not between 0 and 150, email: invalid does not match .*@.*\"))\n```\n\n**Macro Detection** (no ZIO Prelude dependency required):\n```scala\n// The macro detects ZIO Prelude newtypes by checking:\n// 1. Type extends Newtype[A] or Subtype[A]\n// 2. Companion object exists\n// 3. Has apply/wrap method with validation\n\n// Low-level AST matching in Scala 2 macro:\ndef isZIONewtype(tpe: Type): Boolean = {\n  tpe.typeSymbol.fullName.startsWith(\"zio.prelude.Newtype\") ||\n  tpe.typeSymbol.fullName.startsWith(\"zio.prelude.Subtype\")\n}\n```\n\n#### Other Newtype Libraries\n\nFor other newtype libraries, users can provide explicit `Into` instances. The macro will use these instances when available.\n\n```scala\n// User-provided instance for their newtype library\nimplicit val stringToMyNewtype: Into[String, MyNewtype] = \n  new Into[String, MyNewtype] {\n    def into(s: String): Either[SchemaError, MyNewtype] =\n      MyNewtype.make(s).left.map(e => SchemaError(e.toString))\n  }\n\n// The macro will automatically use this instance\ncase class PersonV1(email: String)\ncase class PersonV2(email: MyNewtype)\n\nInto[PersonV1, PersonV2].into(PersonV1(\"test@example.com\"))\n// Uses the user-provided instance automatically\n```\n\n### Validation Error Accumulation\n\nWhen multiple validations fail, all errors are accumulated using `SchemaError` composition:\n\n```scala\ncase class PersonV1(name: String, age: Int, email: String)\ncase class PersonV2(name: String, age: Age, email: Email)\n\nInto[PersonV1, PersonV2].into(PersonV1(\"\", -5, \"invalid\"))\n// => Left(SchemaError(...)) // Combined error containing all validation failures\n```\n\n---\n\n## As[A, B] Additional Requirements\n\nFor `As[A, B]` to be derivable, the bidirectional conversion must be **compatible**:\n\n### Compatibility Rules\n\n1. **Field mappings must be consistent**: The same field correspondence in both directions\n2. **Coercions must be invertible with runtime validation**: \n   - âœ… `Int` â†” `Long` is valid (narrowing validated at runtime)\n   - âœ… `Float` â†” `Double` is valid (narrowing validated at runtime)\n   - âœ… All numeric coercions are valid with runtime checks\n3. **Optional fields**: \n   - âœ… Can add optional fields in one direction (becomes `None` in reverse)\n   - âœ… Can remove optional fields in one direction (value is dropped)\n4. **Default values**:\n   - âŒ Cannot use default arguments (breaks round-trip guarantee)\n5. **Collection types**:\n   - âœ… Can convert between different collection types\n   - âš ï¸  Set â†’ List â†’ Set may not preserve original order\n   - âš ï¸  List â†’ Set â†’ List loses duplicates\n\n### Valid As[A, B] Examples\n\n```scala\n// Valid: Same structure, different names\ncase class PersonV1(name: String, age: Int)\ncase class PersonV2(fullName: String, yearsOld: Int)\n\nAs[PersonV1, PersonV2].into(PersonV1(\"Alice\", 30))\n// => Right(PersonV2(\"Alice\", 30))\n\nAs[PersonV1, PersonV2].from(PersonV2(\"Bob\", 25))\n// => Right(PersonV1(\"Bob\", 25))\n```\n\n```scala\n// Valid: Case class â†” Tuple\ncase class Point(x: Double, y: Double)\n\nAs[Point, (Double, Double)].into(Point(1.0, 2.0))\n// => Right((1.0, 2.0))\n\nAs[Point, (Double, Double)].from((3.0, 4.0))\n// => Right(Point(3.0, 4.0))\n```\n\n```scala\n// Valid: Numeric coercion with runtime validation\ncase class ConfigV1(timeout: Int)\ncase class ConfigV2(timeout: Long)\n\nAs[ConfigV1, ConfigV2].into(ConfigV1(30))\n// => Right(ConfigV2(30L))\n\nAs[ConfigV1, ConfigV2].from(ConfigV2(30L))\n// => Right(ConfigV1(30))\n\nAs[ConfigV1, ConfigV2].from(ConfigV2(3000000000L))\n// => Left(SchemaError(\"Value 3000000000 exceeds Int.MaxValue\"))\n```\n\n```scala\n// Valid: Opaque types (reversible via unwrap)\ncase class PersonRaw(name: String, age: Int)\ncase class PersonValidated(name: String, age: Age)\n\nAs[PersonRaw, PersonValidated].into(PersonRaw(\"Alice\", 30))\n// => Right(PersonValidated(\"Alice\", Age.unsafe(30)))\n\nAs[PersonRaw, PersonValidated].from(PersonValidated(\"Bob\", Age.unsafe(25)))\n// => Right(PersonRaw(\"Bob\", 25))\n\nAs[PersonRaw, PersonValidated].into(PersonRaw(\"Charlie\", -5))\n// => Left(SchemaError(\"Age validation failed: Invalid age: -5\"))\n```\n\n```scala\n// Valid: Collection type conversions\ncase class DataV1(items: List[Int])\ncase class DataV2(items: Vector[Int])\n\nAs[DataV1, DataV2].into(DataV1(List(1, 2, 3)))\n// => Right(DataV2(Vector(1, 2, 3)))\n\nAs[DataV1, DataV2].from(DataV2(Vector(4, 5, 6)))\n// => Right(DataV1(List(4, 5, 6)))\n```\n\n```scala\n// Valid: Optional field in one direction\ncase class UserV1(id: String, name: String)\ncase class UserV2(id: String, name: String, email: Option[String])\n\nAs[UserV1, UserV2].into(UserV1(\"123\", \"Alice\"))\n// => Right(UserV2(\"123\", \"Alice\", None))\n\nAs[UserV1, UserV2].from(UserV2(\"456\", \"Bob\", Some(\"bob@example.com\")))\n// => Right(UserV1(\"456\", \"Bob\"))\n// email is dropped in reverse direction\n```\n\n### Non-Ideal As[A, B] Examples (Valid but Lossy)\n\n```scala\n// Valid but lossy: List with duplicates â†’ Set â†’ List\ncase class DataV1(values: List[Int])\ncase class DataV2(values: Set[Int])\n\nAs[DataV1, DataV2].into(DataV1(List(1, 2, 2, 3)))\n// => Right(DataV2(Set(1, 2, 3)))\n\nAs[DataV1, DataV2].from(DataV2(Set(1, 2, 3)))\n// => Right(DataV1(List(1, 2, 3)))\n// Original duplicates are lost, but conversion is valid\n```\n\n```scala\n// Valid but lossy: Set â†’ List â†’ Set (order may change)\ncase class DataV1(values: Set[Int])\ncase class DataV2(values: List[Int])\n\nval original = DataV1(Set(3, 1, 2))\nval converted = As[DataV1, DataV2].into(original).right.get\n// converted.values might be List(1, 2, 3) depending on Set iteration order\n\nval roundTrip = As[DataV1, DataV2].from(converted).right.get\n// roundTrip.values == Set(1, 2, 3) - same elements, possibly different internal order\n```\n\n### Invalid As[A, B] Examples\n\n```scala\n// Invalid: Default values break round-trip guarantee\ncase class ProductV1(name: String, price: Double)\ncase class ProductV2(name: String, price: Double, taxable: Boolean = true)\n\n// COMPILE ERROR: Cannot derive As[ProductV1, ProductV2]\n// Reason: Default value for 'taxable' cannot be recovered in reverse direction\n// (We can't distinguish between explicitly set 'true' and default 'true')\n```\n\n---\n\n## Testing Requirements\n\n### Test Matrix Dimensions\n\n1. **Type Combinations** (both `Into` and `As`)\n   - Primitive â†’ Primitive (all coercion pairs, including narrowing)\n   - Product â†’ Product (case classes)\n   - Product â†’ Tuple\n   - Tuple â†’ Product\n   - Tuple â†’ Tuple\n   - Coproduct â†’ Coproduct (sealed traits, enums)\n   - Collection[A] â†’ Collection[B] (List, Vector, Set, Map, Option, Either, Array, Seq)\n   - Collection type conversions (List â†” Vector â†” Set â†” Array â†” Seq)\n   - Nested conversions\n   - Structural types\n\n2. **Disambiguation Scenarios**\n   - Unique types (names irrelevant)\n   - Matching names (types irrelevant with coercion)\n   - Duplicate types with name disambiguation\n   - Duplicate types with position disambiguation\n   - Ambiguous cases (must fail at compile-time)\n\n3. **Schema Evolution**\n   - Field reordering\n   - Field renaming (with unique types)\n   - Adding optional fields\n   - Removing optional fields\n   - Type refinement (Int â†’ Long, with narrowing validation)\n   - Adding default values (Scala 3)\n\n4. **Validation** (Scala 3 opaque types)\n   - Valid values pass through\n   - Invalid values produce SchemaError\n   - Multiple validation failures accumulate\n   - Nested validation in products\n   - Validation in coproduct cases\n   - Validation in collections\n   - Narrowing conversions (Long â†’ Int with overflow check)\n\n5. **Validation** (Scala 2 ZIO Prelude newtypes)\n   - Newtype validation success\n   - Newtype validation failure\n   - Subtype validation with assertions\n   - Multiple newtype fields\n\n6. **Collection Type Conversions**\n   - List â†” Vector\n   - List â†” Array\n   - List â†” Set (with duplicate handling)\n   - List â†” Seq\n   - Vector â†” Set\n   - Array â†” Vector\n   - All combinations with element type coercion\n   - Nested collection type conversions\n\n7. **Runtime Validation** (for `As[A, B]`)\n   - Numeric narrowing validation\n   - Round-trip with valid narrowing\n   - Round-trip failure with overflow\n   - Collection conversions with duplicates\n   - Optional field round-trips\n\n8. **Error Cases**\n   - Ambiguous field mapping (compile error)\n   - Ambiguous case mapping (compile error)\n   - Default value in `As` (compile error)\n   - Runtime validation failures\n   - Type mismatch (compile error)\n   - Overflow in narrowing conversions\n\n9. **Edge Cases**\n   - Empty case classes\n   - Single-field case classes\n   - Case objects\n   - Sealed traits with case objects only\n   - Deeply nested structures (5+ levels)\n   - Large products (20+ fields)\n   - Large coproducts (20+ cases)\n   - Recursive types (e.g., `case class Tree(value: Int, children: List[Tree])`)\n   - Mutually recursive types\n\n### Test Organization\n\n```\nsrc/test/scala/\n  into/\n    products/\n      CaseClassToCaseClassSpec.scala\n      CaseClassToTupleSpec.scala\n      TupleToCaseClassSpec.scala\n      TupleToTupleSpec.scala\n      FieldReorderingSpec.scala\n      FieldRenamingSpec.scala\n      NestedProductsSpec.scala\n    coproducts/\n      SealedTraitToSealedTraitSpec.scala\n      EnumToEnumSpec.scala (Scala 3 only)\n      CaseMatchingSpec.scala\n      SignatureMatchingSpec.scala\n      AmbiguousCaseSpec.scala\n      NestedCoproductsSpec.scala\n    primitives/\n      NumericWideningSpec.scala\n      NumericNarrowingSpec.scala\n      CollectionCoercionSpec.scala\n      OptionCoercionSpec.scala\n      EitherCoercionSpec.scala\n      NestedCollectionSpec.scala\n    collections/\n      ListToVectorSpec.scala\n      ListToSetSpec.scala\n      VectorToArraySpec.scala\n      CollectionTypeWithCoercionSpec.scala\n      NestedCollectionTypeSpec.scala\n      SetDuplicateHandlingSpec.scala\n    structural/\n      StructuralTypeTargetSpec.scala (Scala 3 Selectable)\n      DynamicTypeTargetSpec.scala (Scala 2 Dynamic)\n      StructuralTypeSourceSpec.scala\n    validation/\n      OpaqueTypeValidationSpec.scala (Scala 3 only)\n      ZIONewtypeValidationSpec.scala (Scala 2 only)\n      ValidationErrorAccumulationSpec.scala\n      NestedValidationSpec.scala\n      NarrowingValidationSpec.scala\n    evolution/\n      AddOptionalFieldSpec.scala\n      RemoveOptionalFieldSpec.scala\n      TypeRefinementSpec.scala\n      AddDefaultFieldSpec.scala (Scala 3 only)\n    disambiguation/\n      UniqueTypeDisambiguationSpec.scala\n      NameDisambiguationSpec.scala\n      PositionDisambiguationSpec.scala\n      AmbiguousCompileErrorSpec.scala\n    edge/\n      EmptyProductSpec.scala\n      SingleFieldSpec.scala\n      CaseObjectSpec.scala\n      DeepNestingSpec.scala\n      LargeProductSpec.scala\n      LargeCoproductSpec.scala\n      RecursiveTypeSpec.scala\n      MutuallyRecursiveTypeSpec.scala\n  \n  as/\n    reversibility/\n      RoundTripProductSpec.scala\n      RoundTripCoproductSpec.scala\n      RoundTripTupleSpec.scala\n      RoundTripCollectionTypeSpec.scala\n      OpaqueTypeRoundTripSpec.scala\n      NumericNarrowingRoundTripSpec.scala\n      OptionalFieldRoundTripSpec.scala\n    validation/\n      OverflowDetectionSpec.scala\n      NarrowingFailureSpec.scala\n      CollectionLossyConversionSpec.scala\n    compile_errors/\n      DefaultValueSpec.scala\n    (similar structure to into/ for applicable tests)\n```\n\n### Specific Test Cases\n\n#### Disambiguation Tests\n\n```scala\n// Test: Unique types make names irrelevant\ncase class A(x: String, y: Int, z: Boolean)\ncase class B(a: String, b: Int, c: Boolean)\nassert(Into[A, B].into(A(\"test\", 42, true)) == Right(B(\"test\", 42, true)))\n\n// Test: Names disambiguate duplicate types\ncase class Point(x: Int, y: Int)\ncase class Coord(y: Int, x: Int)\nassert(Into[Point, Coord].into(Point(1, 2)) == Right(Coord(2, 1)))\n\n// Test: Ambiguous mapping fails at compile-time\ncase class Dim(width: Int, height: Int)\ncase class Measure(first: Int, second: Int)\n// Must not compile: Into[Dim, Measure]\nassertDoesNotCompile(\"Into[Dim, Measure]\")\n```\n\n#### Numeric Narrowing Validation Tests\n\n```scala\n// Test: Valid narrowing conversion\ncase class V1(value: Long)\ncase class V2(value: Int)\nassert(Into[V1, V2].into(V1(42L)) == Right(V2(42)))\n\n// Test: Invalid narrowing (overflow)\nassert(Into[V1, V2].into(V1(3000000000L)).isLeft)\n\n// Test: Narrowing in collections\ncase class Data1(values: List[Long])\ncase class Data2(values: List[Int])\nassert(Into[Data1, Data2].into(Data1(List(1L, 2L, 3L))) == Right(Data2(List(1, 2, 3))))\nassert(Into[Data1, Data2].into(Data1(List(1L, 3000000000L))).isLeft)\n```\n\n#### Collection Type Conversion Tests\n\n```scala\n// Test: List to Vector\ncase class A(items: List[Int])\ncase class B(items: Vector[Int])\nassert(Into[A, B].into(A(List(1, 2, 3))) == Right(B(Vector(1, 2, 3))))\n\n// Test: List to Set (removes duplicates)\ncase class C(items: List[Int])\ncase class D(items: Set[Int])\nassert(Into[C, D].into(C(List(1, 2, 2, 3))) == Right(D(Set(1, 2, 3))))\n\n// Test: Vector to Array\ncase class E(items: Vector[String])\ncase class F(items: Array[String])\nval result = Into[E, F].into(E(Vector(\"a\", \"b\")))\nassert(result.isRight)\nassert(result.right.get.items.sameElements(Array(\"a\", \"b\")))\n\n// Test: Combined collection and element coercion\ncase class G(items: List[Int])\ncase class H(items: Vector[Long])\nassert(Into[G, H].into(G(List(1, 2, 3))) == Right(H(Vector(1L, 2L, 3L))))\n```\n\n#### Validation Tests (Scala 3)\n\n```scala\n// Test: Valid opaque type conversion\ncase class Raw(age: Int)\ncase class Validated(age: Age)\nassert(Into[Raw, Validated].into(Raw(30)).isRight)\n\n// Test: Invalid opaque type conversion\nassert(Into[Raw, Validated].into(Raw(-5)).isLeft)\n\n// Test: Multiple validation failures accumulate\ncase class RawPerson(age: Int, email: String)\ncase class ValidPerson(age: Age, email: Email)\nval result = Into[RawPerson, ValidPerson].into(RawPerson(-5, \"invalid\"))\nassert(result.isLeft)\n// SchemaError contains both validation failures\n```\n\n#### Round-Trip Tests (As)\n\n```scala\n// Test: Case class round-trip\ncase class PersonV1(name: String, age: Int)\ncase class PersonV2(fullName: String, yearsOld: Int)\n\nval v1 = PersonV1(\"Alice\", 30)\nval v2 = As[PersonV1, PersonV2].into(v1).right.get\nval roundTrip = As[PersonV1, PersonV2].from(v2).right.get\n\nassert(roundTrip == v1)\n\n// Test: Numeric narrowing round-trip (valid)\ncase class ConfigV1(timeout: Int)\ncase class ConfigV2(timeout: Long)\n\nval config1 = ConfigV1(30)\nval config2 = As[ConfigV1, ConfigV2].into(config1).right.get\nval back = As[ConfigV1, ConfigV2].from(config2).right.get\n\nassert(back == config1)\n\n// Test: Numeric narrowing round-trip (overflow failure)\nval config2Overflow = ConfigV2(3000000000L)\nassert(As[ConfigV1, ConfigV2].from(config2Overflow).isLeft)\n\n// Test: Collection type round-trip\ncase class Data1(items: List[Int])\ncase class Data2(items: Vector[Int])\n\nval data1 = Data1(List(1, 2, 3))\nval data2 = As[Data1, Data2].into(data1).right.get\nval backToData1 = As[Data1, Data2].from(data2).right.get\n\nassert(backToData1 == data1)\n\n// Test: Lossy collection round-trip (Set loses duplicates)\ncase class WithDuplicates(items: List[Int])\ncase class NoDuplicates(items: Set[Int])\n\nval original = WithDuplicates(List(1, 2, 2, 3))\nval asSet = As[WithDuplicates, NoDuplicates].into(original).right.get\nval backToList = As[WithDuplicates, NoDuplicates].from(asSet).right.get\n\nassert(asSet.items == Set(1, 2, 3))\nassert(backToList.items.toSet == Set(1, 2, 3)) // Order may differ, duplicates lost\n```\n\n#### Edge Case Tests\n\n```scala\n// Test: Empty case class\ncase class Empty()\nassert(Into[Empty, Empty].into(Empty()) == Right(Empty()))\n\n// Test: Large product (21 fields)\ncase class Large21(f1: Int, f2: Int, /* ... */, f21: Int)\ncase class Large21V2(f1: Long, f2: Long, /* ... */, f21: Long)\n// Must compile and work correctly\n\n// Test: Recursive type\ncase class Tree(value: Int, children: List[Tree])\ncase class TreeV2(value: Long, children: List[TreeV2])\nval tree = Tree(1, List(Tree(2, Nil), Tree(3, Nil)))\nval treeV2 = Into[Tree, TreeV2].into(tree).right.get\nassert(treeV2.value == 1L)\nassert(treeV2.children.head.value == 2L)\n\n// Test: Mutually recursive types\ncase class Node(id: Int, edges: List[Edge])\ncase class Edge(from: Int, to: Node)\ncase class NodeV2(id: Long, edges: List[EdgeV2])\ncase class EdgeV2(from: Long, to: NodeV2)\n// Must compile and handle mutual recursion\n```\n\n---\n\n## Implementation Signatures\n\n### Scala 3.5\n\n```scala\npackage zio.blocks.schema\n\nimport scala.quoted.*\n\n// One-way conversion\ntrait Into[-A, +B] {\n  def into(input: A): Either[SchemaError, B]\n}\n\nobject Into {\n  inline given [A, B]: Into[A, B] = ${intoMacro[A, B]}\n  \n  private def intoMacro[A: Type, B: Type](using Quotes): Expr[Into[A, B]] = {\n    import quotes.reflect.*\n    // Implementation:\n    // 1. Analyze types A and B\n    // 2. Build field mapping using disambiguation algorithm\n    // 3. Detect opaque types and generate validation calls\n    // 4. Generate narrowing validation for numeric coercions\n    // 5. Handle collection type conversions\n    // 6. Generate conversion code\n    // 7. Handle nested conversions recursively\n    ???\n  }\n}\n\n// Bidirectional conversion\ntrait As[A, B] {\n  def into(input: A): Either[SchemaError, B]\n  def from(input: B): Either[SchemaError, A]\n}\n\nobject As {\n  inline given [A, B]: As[A, B] = ${asMacro[A, B]}\n  \n  private def asMacro[A: Type, B: Type](using Quotes): Expr[As[A, B]] = {\n    import quotes.reflect.*\n    // Implementation:\n    // 1. Verify bidirectional compatibility\n    // 2. Check for default values (compile error if found)\n    // 3. Build bidirectional field mapping\n    // 4. Generate both conversion directions with validation\n    // 5. Ensure opaque type wrapping/unwrapping is symmetric\n    // 6. Handle numeric narrowing with runtime validation\n    // 7. Handle collection type conversions bidirectionally\n    ???\n  }\n}\n```\n\n### Scala 2.13\n\n```scala\npackage com.yourorg.schema\n\nimport scala.reflect.macros.blackbox.Context\nimport scala.language.experimental.macros\n\ncase class SchemaError(msg: String) {\n  // SchemaError is composable - can combine multiple errors\n}\n\n// One-way conversion\ntrait Into[-A, +B] {\n  def into(input: A): Either[SchemaError, B]\n}\n\nobject Into {\n  implicit def materializeInto[A, B]: Into[A, B] = macro materializeIntoImpl[A, B]\n  \n  def materializeIntoImpl[A: c.WeakTypeTag, B: c.WeakTypeTag](c: Context): c.Tree = {\n    import c.universe._\n    // Implementation:\n    // 1. Analyze types A and B using reflection\n    // 2. Build field mapping using disambiguation algorithm\n    // 3. Detect ZIO Prelude newtypes via AST pattern matching\n    // 4. Generate narrowing validation for numeric coercions\n    // 5. Handle collection type conversions\n    // 6. Generate conversion code using quasiquotes\n    // 7. Handle nested conversions recursively\n    ???\n  }\n}\n\n// Bidirectional conversion\ntrait As[A, B] {\n  def into(input: A): Either[SchemaError, B]\n  def from(input: B): Either[SchemaError, A]\n}\n\nobject As {\n  implicit def materializeAs[A, B]: As[A, B] = macro materializeAsImpl[A, B]\n  \n  def materializeAsImpl[A: c.WeakTypeTag, B: c.WeakTypeTag](c: Context): c.Tree = {\n    import c.universe._\n    // Implementation:\n    // 1. Verify bidirectional compatibility\n    // 2. Check for default values (compile error if found)\n    // 3. Build bidirectional field mapping\n    // 4. Generate both conversion directions with validation\n    // 5. Ensure newtype wrapping/unwrapping is symmetric\n    // 6. Handle numeric narrowing with runtime validation\n    // 7. Handle collection type conversions bidirectionally\n    ???\n  }\n}\n```\n\n---\n\n## Implementation Notes\n\n### Error Messages\n\nProvide helpful compile-time errors:\n\n```scala\n// Good error message example:\n\"\"\"\nCannot derive Into[PersonV1, PersonV2]: Ambiguous field mapping\n\n  PersonV1(width: Int, height: Int)\n  PersonV2(first: Int, second: Int)\n\nCannot determine unique mapping between fields of type Int.\nConsider:\n  - Using matching field names (width/height)\n  - Making field types unique\n  - Providing an explicit Into instance\n\"\"\"\n```\n\n### Cross-Version Compatibility\n\n- Share test cases between Scala 2 and Scala 3 where possible\n\n---\n\n## Deliverables\n\n1. âœ… `Into[A, B]` trait and macro for Scala 2.13\n2. âœ… `Into[A, B]` trait and macro for Scala 3.5\n3. âœ… `As[A, B]` trait and macro for Scala 2.13\n4. âœ… `As[A, B]` trait and macro for Scala 3.5\n5. âœ… Comprehensive test suite\n6. âœ… Documentation with examples\n",
                  "html_url": "https://github.com/zio/zio-blocks/issues/518"
                },
                "type": "github"
              },
              "hash": "zio/zio-blocks#518",
              "body": "## Overview\n\nAdd two related type classes for type-safe schema evolution:\n\n1. **`Into[A, B]`**: One-way conversion from `A` to `B` with runtime validation\n2. **`As[A, B]`**: Bidirectional conversion establishing a partial equivalence between `A` and `B`\n\nBoth type classes are automatically derived via macros that intelligently map fields using names, positions, and types, with support for validation, coercion, and schema evolution patterns.\n\n---\n\n## Type Class Definitions\n\n### Into[A, B] - One-Way Conversion\n\n```scala\ntrait Into[-A, +B] {\n  def into(input: A): Either[SchemaError, B]\n}\n```\n\n**Purpose**: Convert from source type `A` to target type `B`, potentially failing at runtime when validation constraints cannot be satisfied.\n\n**Use Cases**:\n- Migrating between schema versions\n- Converting between equivalent representations\n- Validating conversions with opaque types\n- Transforming external data into internal models\n\n### As[A, B] - Bidirectional Conversion\n\n```scala\ntrait As[A, B] {\n  def into(input: A): Either[SchemaError, B]\n  def from(input: B): Either[SchemaError, A]\n}\n```\n\n**Purpose**: Establish a partial equivalence between types `A` and `B` where conversion can fail in either direction due to runtime validation.\n\n**Use Cases**:\n- Isomorphic schema versions\n- Equivalent representations (e.g., case class â†” tuple)\n- Reversible transformations with runtime validation\n- Round-trip serialization/deserialization\n\n**Relationship**: `As[A, B]` implies both `Into[A, B]` and `Into[B, A]` exist, but with the additional guarantee that both conversions use compatible mapping logic and can round-trip (subject to runtime validation).\n\n**Note**: `SchemaError` is composable, allowing multiple validation failures to be combined into a single error.\n\n---\n\n## Core Conversion Rules\n\n### Field Mapping Algorithm\n\nThe macro establishes field mappings using three attributes:\n1. **Field name** (identifier in source code)\n2. **Field position** (ordinal position in declaration)\n3. **Field type** (including coercible types)\n\n**Priority for disambiguation:**\n1. **Exact match**: Same name + same type\n2. **Name match with coercion**: Same name + coercible type\n3. **Unique type match**: Type appears only once in both source and target\n4. **Position + unique type**: Positional correspondence with unambiguous type\n5. **Fallback**: If no unambiguous mapping exists, derivation fails at compile-time\n\n### Mapping Examples\n\n#### Unambiguous by Unique Types\n```scala\ncase class Person(name: String, age: Int, active: Boolean)\ncase class User(username: String, yearsOld: Int, enabled: Boolean)\n\n// Success: Each type appears exactly once\n// Mapping: Stringâ†’String, Intâ†’Int, Booleanâ†’Boolean\n```\n\n#### Unambiguous by Names\n```scala\ncase class Point(x: Int, y: Int)\ncase class Coord(y: Int, x: Int)\n\n// Success: Names uniquely identify despite reordering\n// Mapping: xâ†’x, yâ†’y\n```\n\n#### Ambiguous - Compile Failure\n```scala\ncase class Dimensions(width: Int, height: Int)\ncase class Measurements(first: Int, second: Int)\n\n// COMPILE ERROR: Cannot determine mapping\n// Both Int types, different names, ambiguous positional match\n```\n\n#### Disambiguation by Position (Tuples)\n```scala\ncase class RGB(r: Int, g: Int, b: Int)\ntype ColorTuple = (Int, Int, Int)\n\n// Success: Position disambiguates\n// Mapping: râ†’_1, gâ†’_2, bâ†’_3\n```\n\n---\n\n## Supported Conversions\n\n### 1. Product Types (Records)\n\n#### Case Class to Case Class\n```scala\ncase class PersonV1(name: String, age: Int)\ncase class PersonV2(fullName: String, age: Int)\n\n// Success if 'name' is unique String in V1 and 'fullName' is unique String in V2\nInto[PersonV1, PersonV2].into(PersonV1(\"Alice\", 30))\n// => Right(PersonV2(\"Alice\", 30))\n```\n\n#### Case Class to Tuple\n```scala\ncase class Point(x: Double, y: Double)\n\nInto[Point, (Double, Double)].into(Point(1.0, 2.0))\n// => Right((1.0, 2.0))\n```\n\n#### Tuple to Case Class\n```scala\ncase class RGB(red: Int, green: Int, blue: Int)\n\nInto[(Int, Int, Int), RGB].into((255, 128, 64))\n// => Right(RGB(255, 128, 64))\n```\n\n#### Tuple to Tuple\n```scala\nInto[(Int, String), (Long, String)].into((42, \"hello\"))\n// => Right((42L, \"hello\"))\n```\n\n### 2. Coproduct Types (Sum Types)\n\n#### Sealed Trait to Sealed Trait (by name)\n```scala\nsealed trait Color\ncase object Red extends Color\ncase object Blue extends Color\n\nsealed trait Hue\ncase object Red extends Hue\ncase object Blue extends Hue\n\nInto[Color, Hue].into(Red)\n// => Right(Red)\n```\n\n#### Sealed Trait to Sealed Trait (by signature)\n```scala\nsealed trait EventV1\ncase class Created(id: String, ts: Long) extends EventV1\ncase class Deleted(id: String) extends EventV1\n\nsealed trait EventV2\ncase class Spawned(id: String, ts: Long) extends EventV2\ncase class Removed(id: String) extends EventV2\n\nInto[EventV1, EventV2].into(Created(\"abc\", 123L))\n// => Right(Spawned(\"abc\", 123L))\n// Matched by constructor signature (String, Long)\n```\n\n#### Enum to Enum (Scala 3)\n```scala\nenum Status:\n  case Active, Inactive, Suspended\n\nenum State:\n  case Active, Inactive, Suspended\n\nInto[Status, State].into(Status.Active)\n// => Right(State.Active)\n```\n\n#### ADT with Payload Conversion\n```scala\nsealed trait ResultV1\ncase class Success(value: Int) extends ResultV1\ncase class Failure(msg: String) extends ResultV1\n\nsealed trait ResultV2\ncase class Success(value: Long) extends ResultV2\ncase class Failure(msg: String) extends ResultV2\n\nInto[ResultV1, ResultV2].into(Success(42))\n// => Right(Success(42L))\n// Field type coercion within matched case\n```\n\n### 3. Primitive Type Coercions\n\n#### Numeric Widening (Lossless)\n```scala\nInto[Byte, Short].into(42.toByte)    // => Right(42.toShort)\nInto[Short, Int].into(1000.toShort)  // => Right(1000)\nInto[Int, Long].into(100000)         // => Right(100000L)\nInto[Float, Double].into(3.14f)      // => Right(3.14)\n```\n\n#### Numeric Narrowing (with Runtime Validation)\n```scala\nInto[Long, Int].into(42L)\n// => Right(42)\n\nInto[Long, Int].into(3000000000L)\n// => Left(SchemaError(\"Value 3000000000 exceeds Int.MaxValue\"))\n\nInto[Double, Float].into(3.14)\n// => Right(3.14f)\n\nInto[Double, Float].into(1e100)\n// => Left(SchemaError(\"Value 1.0E100 exceeds Float.MaxValue\"))\n```\n\n#### Collection Element Coercion\n```scala\nInto[List[Int], List[Long]].into(List(1, 2, 3))\n// => Right(List(1L, 2L, 3L))\n\nInto[Vector[Float], Vector[Double]].into(Vector(1.5f, 2.5f))\n// => Right(Vector(1.5, 2.5))\n\nInto[Set[Short], Set[Int]].into(Set(10.toShort, 20.toShort))\n// => Right(Set(10, 20))\n\nInto[List[Long], List[Int]].into(List(42L, 3000000000L))\n// => Left(SchemaError(\"Value 3000000000 exceeds Int.MaxValue\"))\n```\n\n#### Nested Collection Coercion\n```scala\nInto[List[List[Int]], List[List[Long]]].into(List(List(1, 2), List(3, 4)))\n// => Right(List(List(1L, 2L), List(3L, 4L)))\n```\n\n#### Map Key/Value Coercion\n```scala\nInto[Map[Int, Float], Map[Long, Double]].into(Map(1 -> 1.5f, 2 -> 2.5f))\n// => Right(Map(1L -> 1.5, 2L -> 2.5))\n\nInto[Map[Long, String], Map[Int, String]].into(Map(42L -> \"a\", 3000000000L -> \"b\"))\n// => Left(SchemaError(\"Key 3000000000 exceeds Int.MaxValue\"))\n```\n\n#### Option Type Coercion\n```scala\nInto[Option[Int], Option[Long]].into(Some(42))\n// => Right(Some(42L))\n\nInto[Option[Int], Option[Long]].into(None)\n// => Right(None)\n\nInto[Option[Long], Option[Int]].into(Some(3000000000L))\n// => Left(SchemaError(\"Value 3000000000 exceeds Int.MaxValue\"))\n```\n\n#### Either Type Coercion\n```scala\nInto[Either[String, Int], Either[String, Long]].into(Right(42))\n// => Right(Right(42L))\n\nInto[Either[Int, String], Either[Long, String]].into(Left(100))\n// => Right(Left(100L))\n```\n\n### 4. Collection Type Conversions\n\n#### Between Standard Collection Types\n```scala\nInto[List[Int], Vector[Int]].into(List(1, 2, 3))\n// => Right(Vector(1, 2, 3))\n\nInto[Vector[String], List[String]].into(Vector(\"a\", \"b\", \"c\"))\n// => Right(List(\"a\", \"b\", \"c\"))\n\nInto[Array[Int], List[Int]].into(Array(1, 2, 3))\n// => Right(List(1, 2, 3))\n\nInto[List[Int], Array[Int]].into(List(1, 2, 3))\n// => Right(Array(1, 2, 3))\n\nInto[Seq[Int], List[Int]].into(Seq(1, 2, 3))\n// => Right(List(1, 2, 3))\n\nInto[List[Int], Seq[Int]].into(List(1, 2, 3))\n// => Right(Seq(1, 2, 3))\n```\n\n#### Set Conversions (Order-Preserving Collections to Set)\n```scala\nInto[List[Int], Set[Int]].into(List(1, 2, 2, 3))\n// => Right(Set(1, 2, 3))\n// Note: Duplicates are removed\n\nInto[Vector[String], Set[String]].into(Vector(\"a\", \"b\", \"a\"))\n// => Right(Set(\"a\", \"b\"))\n```\n\n#### Set to Order-Preserving Collections\n```scala\nInto[Set[Int], List[Int]].into(Set(3, 1, 2))\n// => Right(List(1, 2, 3))\n// Note: Order is determined by Set's iteration order\n\nInto[Set[String], Vector[String]].into(Set(\"c\", \"a\", \"b\"))\n// => Right(Vector(\"a\", \"b\", \"c\"))\n```\n\n#### Combined Element and Collection Type Conversion\n```scala\nInto[List[Int], Vector[Long]].into(List(1, 2, 3))\n// => Right(Vector(1L, 2L, 3L))\n\nInto[Array[Short], List[Int]].into(Array(10.toShort, 20.toShort))\n// => Right(List(10, 20))\n\nInto[Set[Int], List[Long]].into(Set(1, 2, 3))\n// => Right(List(1L, 2L, 3L))\n```\n\n#### Nested Collection Type Conversions\n```scala\nInto[List[Vector[Int]], Vector[List[Long]]].into(List(Vector(1, 2), Vector(3, 4)))\n// => Right(Vector(List(1L, 2L), List(3L, 4L)))\n```\n\n### 5. Structural Types\n\n#### Structural Type Targets (Scala 3 with Selectable)\n```scala\ncase class Point(x: Int, y: Int)\ntype Coord = { def x: Int; def y: Int }\n\nInto[Point, Coord].into(Point(5, 10))\n// => Right(<structural instance with x=5, y=10>)\n```\n\n#### Structural Type Targets (Scala 2 with Dynamic)\n```scala\ncase class Person(name: String, age: Int)\ntype Record = { def name: String; def age: Int }\n\nInto[Person, Record].into(Person(\"Alice\", 30))\n// => Right(<dynamic instance with name=\"Alice\", age=30>)\n```\n\n#### Structural Type Sources\n```scala\ntype PersonLike = { def name: String; def age: Int }\ncase class User(name: String, age: Int)\n\nval personLike: PersonLike = ??? // some structural instance\nInto[PersonLike, User].into(personLike)\n// => Right(User(\"Alice\", 30))\n```\n\n### 6. Schema Evolution Patterns\n\n#### Adding Optional Fields\n```scala\ncase class UserV1(id: String, name: String)\ncase class UserV2(id: String, name: String, email: Option[String])\n\nInto[UserV1, UserV2].into(UserV1(\"123\", \"Alice\"))\n// => Right(UserV2(\"123\", \"Alice\", None))\n```\n\n#### Removing Optional Fields\n```scala\ncase class UserV2(id: String, name: String, email: Option[String])\ncase class UserV1(id: String, name: String)\n\nInto[UserV2, UserV1].into(UserV2(\"123\", \"Alice\", Some(\"alice@example.com\")))\n// => Right(UserV1(\"123\", \"Alice\"))\n// email field is dropped\n```\n\n#### Adding Required Fields with Defaults (Scala 3)\n```scala\ncase class ProductV1(name: String, price: Double)\ncase class ProductV2(name: String, price: Double, available: Boolean = true)\n\nInto[ProductV1, ProductV2].into(ProductV1(\"Widget\", 19.99))\n// => Right(ProductV2(\"Widget\", 19.99, true))\n```\n\n#### Field Reordering\n```scala\ncase class PersonV1(name: String, age: Int, email: String)\ncase class PersonV2(email: String, name: String, age: Int)\n\nInto[PersonV1, PersonV2].into(PersonV1(\"Alice\", 30, \"alice@example.com\"))\n// => Right(PersonV2(\"alice@example.com\", \"Alice\", 30))\n```\n\n#### Field Renaming (with unique types)\n```scala\ncase class PersonV1(fullName: String, yearOfBirth: Int)\ncase class PersonV2(name: String, birthYear: Int)\n\nInto[PersonV1, PersonV2].into(PersonV1(\"Alice Smith\", 1990))\n// => Right(PersonV2(\"Alice Smith\", 1990))\n```\n\n#### Type Refinement\n```scala\ncase class ConfigV1(port: Int, timeout: Int)\ncase class ConfigV2(port: Int, timeout: Long)\n\nInto[ConfigV1, ConfigV2].into(ConfigV1(8080, 30))\n// => Right(ConfigV2(8080, 30L))\n```\n\n### 7. Nested Conversions\n\n#### Nested Products\n```scala\ncase class AddressV1(street: String, zip: Int)\ncase class PersonV1(name: String, address: AddressV1)\n\ncase class AddressV2(street: String, zip: Long)\ncase class PersonV2(name: String, address: AddressV2)\n\nInto[PersonV1, PersonV2].into(\n  PersonV1(\"Alice\", AddressV1(\"Main St\", 12345))\n)\n// => Right(PersonV2(\"Alice\", AddressV2(\"Main St\", 12345L)))\n```\n\n#### Nested Coproducts\n```scala\nsealed trait Inner\ncase class A(x: Int) extends Inner\ncase class B(y: String) extends Inner\n\nsealed trait Outer\ncase class Container(inner: Inner, label: String) extends Outer\n\n// Similar target types with Long instead of Int\nsealed trait InnerV2\ncase class A(x: Long) extends InnerV2\ncase class B(y: String) extends InnerV2\n\nsealed trait OuterV2\ncase class Container(inner: InnerV2, label: String) extends OuterV2\n\nInto[Outer, OuterV2].into(Container(A(42), \"test\"))\n// => Right(Container(A(42L), \"test\"))\n```\n\n#### Collections of Complex Types\n```scala\ncase class PersonV1(name: String, age: Int)\ncase class PersonV2(name: String, age: Long)\n\nInto[List[PersonV1], List[PersonV2]].into(\n  List(PersonV1(\"Alice\", 30), PersonV1(\"Bob\", 25))\n)\n// => Right(List(PersonV2(\"Alice\", 30L), PersonV2(\"Bob\", 25L)))\n```\n\n#### Nested Collections with Type Conversions\n```scala\ncase class DataV1(values: List[Vector[Int]])\ncase class DataV2(values: Vector[List[Long]])\n\nInto[DataV1, DataV2].into(\n  DataV1(List(Vector(1, 2), Vector(3, 4)))\n)\n// => Right(DataV2(Vector(List(1L, 2L), List(3L, 4L))))\n```\n\n---\n\n## Special Type Support\n\n### Opaque Types (Scala 3)\n\nOpaque types with validation are fully supported. The macro generates runtime validation calls.\n\n```scala\n// Definition with validation\nobject Domain:\n  opaque type Age = Int\n  object Age:\n    def apply(value: Int): Either[String, Age] =\n      if value >= 0 && value <= 150 then Right(value)\n      else Left(s\"Invalid age: $value\")\n    \n    def unsafe(value: Int): Age = value\n    \n    extension (age: Age)\n      def toInt: Int = age\n\n  opaque type Email = String\n  object Email:\n    def apply(value: String): Either[String, Email] =\n      if value.contains(\"@\") then Right(value)\n      else Left(s\"Invalid email: $value\")\n    \n    extension (email: Email)\n      def toString: String = email\n\nimport Domain._\n\n// Usage\ncase class PersonV1(name: String, age: Int, email: String)\ncase class PersonV2(name: String, age: Age, email: Email)\n\nInto[PersonV1, PersonV2].into(PersonV1(\"Alice\", 30, \"alice@example.com\"))\n// => Right(PersonV2(\"Alice\", Age.unsafe(30), Email.unsafe(\"alice@example.com\")))\n\nInto[PersonV1, PersonV2].into(PersonV1(\"Alice\", -5, \"alice@example.com\"))\n// => Left(SchemaError(\"Age validation failed: Invalid age: -5\"))\n\nInto[PersonV1, PersonV2].into(PersonV1(\"Alice\", 30, \"invalid\"))\n// => Left(SchemaError(\"Email validation failed: Invalid email: invalid\"))\n```\n\n**Macro Behavior**:\n- Detects opaque type companion objects with `apply(underlying): Either[_, OpaqueType]` method\n- Generates validation calls for each opaque type field\n- Accumulates all validation errors using `SchemaError` composition\n- Falls back to direct conversion if no validation method exists\n\n### Newtype Libraries (Scala 2)\n\n#### ZIO Prelude Newtypes (Built-in Support)\n\nThe macro includes hardcoded support for ZIO Prelude newtypes without requiring a compile-time dependency.\n\n```scala\nimport zio.prelude._\n\n// Definition with validation\nobject Domain {\n  object Age extends Subtype[Int] {\n    override def assertion = assert {\n      Assertion.between(0, 150)\n    }\n  }\n  type Age = Age.Type\n\n  object Email extends Newtype[String] {\n    override def assertion = assert {\n      Assertion.matches(\".*@.*\")\n    }\n  }\n  type Email = Email.Type\n}\n\nimport Domain._\n\n// Usage\ncase class PersonV1(name: String, age: Int, email: String)\ncase class PersonV2(name: String, age: Age, email: Email)\n\nInto[PersonV1, PersonV2].into(PersonV1(\"Alice\", 30, \"alice@example.com\"))\n// => Right(PersonV2(\"Alice\", Age(30), Email(\"alice@example.com\")))\n\nInto[PersonV1, PersonV2].into(PersonV1(\"Alice\", 200, \"invalid\"))\n// => Left(SchemaError(\"Validation failed: age: 200 is not between 0 and 150, email: invalid does not match .*@.*\"))\n```\n\n**Macro Detection** (no ZIO Prelude dependency required):\n```scala\n// The macro detects ZIO Prelude newtypes by checking:\n// 1. Type extends Newtype[A] or Subtype[A]\n// 2. Companion object exists\n// 3. Has apply/wrap method with validation\n\n// Low-level AST matching in Scala 2 macro:\ndef isZIONewtype(tpe: Type): Boolean = {\n  tpe.typeSymbol.fullName.startsWith(\"zio.prelude.Newtype\") ||\n  tpe.typeSymbol.fullName.startsWith(\"zio.prelude.Subtype\")\n}\n```\n\n#### Other Newtype Libraries\n\nFor other newtype libraries, users can provide explicit `Into` instances. The macro will use these instances when available.\n\n```scala\n// User-provided instance for their newtype library\nimplicit val stringToMyNewtype: Into[String, MyNewtype] = \n  new Into[String, MyNewtype] {\n    def into(s: String): Either[SchemaError, MyNewtype] =\n      MyNewtype.make(s).left.map(e => SchemaError(e.toString))\n  }\n\n// The macro will automatically use this instance\ncase class PersonV1(email: String)\ncase class PersonV2(email: MyNewtype)\n\nInto[PersonV1, PersonV2].into(PersonV1(\"test@example.com\"))\n// Uses the user-provided instance automatically\n```\n\n### Validation Error Accumulation\n\nWhen multiple validations fail, all errors are accumulated using `SchemaError` composition:\n\n```scala\ncase class PersonV1(name: String, age: Int, email: String)\ncase class PersonV2(name: String, age: Age, email: Email)\n\nInto[PersonV1, PersonV2].into(PersonV1(\"\", -5, \"invalid\"))\n// => Left(SchemaError(...)) // Combined error containing all validation failures\n```\n\n---\n\n## As[A, B] Additional Requirements\n\nFor `As[A, B]` to be derivable, the bidirectional conversion must be **compatible**:\n\n### Compatibility Rules\n\n1. **Field mappings must be consistent**: The same field correspondence in both directions\n2. **Coercions must be invertible with runtime validation**: \n   - âœ… `Int` â†” `Long` is valid (narrowing validated at runtime)\n   - âœ… `Float` â†” `Double` is valid (narrowing validated at runtime)\n   - âœ… All numeric coercions are valid with runtime checks\n3. **Optional fields**: \n   - âœ… Can add optional fields in one direction (becomes `None` in reverse)\n   - âœ… Can remove optional fields in one direction (value is dropped)\n4. **Default values**:\n   - âŒ Cannot use default arguments (breaks round-trip guarantee)\n5. **Collection types**:\n   - âœ… Can convert between different collection types\n   - âš ï¸  Set â†’ List â†’ Set may not preserve original order\n   - âš ï¸  List â†’ Set â†’ List loses duplicates\n\n### Valid As[A, B] Examples\n\n```scala\n// Valid: Same structure, different names\ncase class PersonV1(name: String, age: Int)\ncase class PersonV2(fullName: String, yearsOld: Int)\n\nAs[PersonV1, PersonV2].into(PersonV1(\"Alice\", 30))\n// => Right(PersonV2(\"Alice\", 30))\n\nAs[PersonV1, PersonV2].from(PersonV2(\"Bob\", 25))\n// => Right(PersonV1(\"Bob\", 25))\n```\n\n```scala\n// Valid: Case class â†” Tuple\ncase class Point(x: Double, y: Double)\n\nAs[Point, (Double, Double)].into(Point(1.0, 2.0))\n// => Right((1.0, 2.0))\n\nAs[Point, (Double, Double)].from((3.0, 4.0))\n// => Right(Point(3.0, 4.0))\n```\n\n```scala\n// Valid: Numeric coercion with runtime validation\ncase class ConfigV1(timeout: Int)\ncase class ConfigV2(timeout: Long)\n\nAs[ConfigV1, ConfigV2].into(ConfigV1(30))\n// => Right(ConfigV2(30L))\n\nAs[ConfigV1, ConfigV2].from(ConfigV2(30L))\n// => Right(ConfigV1(30))\n\nAs[ConfigV1, ConfigV2].from(ConfigV2(3000000000L))\n// => Left(SchemaError(\"Value 3000000000 exceeds Int.MaxValue\"))\n```\n\n```scala\n// Valid: Opaque types (reversible via unwrap)\ncase class PersonRaw(name: String, age: Int)\ncase class PersonValidated(name: String, age: Age)\n\nAs[PersonRaw, PersonValidated].into(PersonRaw(\"Alice\", 30))\n// => Right(PersonValidated(\"Alice\", Age.unsafe(30)))\n\nAs[PersonRaw, PersonValidated].from(PersonValidated(\"Bob\", Age.unsafe(25)))\n// => Right(PersonRaw(\"Bob\", 25))\n\nAs[PersonRaw, PersonValidated].into(PersonRaw(\"Charlie\", -5))\n// => Left(SchemaError(\"Age validation failed: Invalid age: -5\"))\n```\n\n```scala\n// Valid: Collection type conversions\ncase class DataV1(items: List[Int])\ncase class DataV2(items: Vector[Int])\n\nAs[DataV1, DataV2].into(DataV1(List(1, 2, 3)))\n// => Right(DataV2(Vector(1, 2, 3)))\n\nAs[DataV1, DataV2].from(DataV2(Vector(4, 5, 6)))\n// => Right(DataV1(List(4, 5, 6)))\n```\n\n```scala\n// Valid: Optional field in one direction\ncase class UserV1(id: String, name: String)\ncase class UserV2(id: String, name: String, email: Option[String])\n\nAs[UserV1, UserV2].into(UserV1(\"123\", \"Alice\"))\n// => Right(UserV2(\"123\", \"Alice\", None))\n\nAs[UserV1, UserV2].from(UserV2(\"456\", \"Bob\", Some(\"bob@example.com\")))\n// => Right(UserV1(\"456\", \"Bob\"))\n// email is dropped in reverse direction\n```\n\n### Non-Ideal As[A, B] Examples (Valid but Lossy)\n\n```scala\n// Valid but lossy: List with duplicates â†’ Set â†’ List\ncase class DataV1(values: List[Int])\ncase class DataV2(values: Set[Int])\n\nAs[DataV1, DataV2].into(DataV1(List(1, 2, 2, 3)))\n// => Right(DataV2(Set(1, 2, 3)))\n\nAs[DataV1, DataV2].from(DataV2(Set(1, 2, 3)))\n// => Right(DataV1(List(1, 2, 3)))\n// Original duplicates are lost, but conversion is valid\n```\n\n```scala\n// Valid but lossy: Set â†’ List â†’ Set (order may change)\ncase class DataV1(values: Set[Int])\ncase class DataV2(values: List[Int])\n\nval original = DataV1(Set(3, 1, 2))\nval converted = As[DataV1, DataV2].into(original).right.get\n// converted.values might be List(1, 2, 3) depending on Set iteration order\n\nval roundTrip = As[DataV1, DataV2].from(converted).right.get\n// roundTrip.values == Set(1, 2, 3) - same elements, possibly different internal order\n```\n\n### Invalid As[A, B] Examples\n\n```scala\n// Invalid: Default values break round-trip guarantee\ncase class ProductV1(name: String, price: Double)\ncase class ProductV2(name: String, price: Double, taxable: Boolean = true)\n\n// COMPILE ERROR: Cannot derive As[ProductV1, ProductV2]\n// Reason: Default value for 'taxable' cannot be recovered in reverse direction\n// (We can't distinguish between explicitly set 'true' and default 'true')\n```\n\n---\n\n## Testing Requirements\n\n### Test Matrix Dimensions\n\n1. **Type Combinations** (both `Into` and `As`)\n   - Primitive â†’ Primitive (all coercion pairs, including narrowing)\n   - Product â†’ Product (case classes)\n   - Product â†’ Tuple\n   - Tuple â†’ Product\n   - Tuple â†’ Tuple\n   - Coproduct â†’ Coproduct (sealed traits, enums)\n   - Collection[A] â†’ Collection[B] (List, Vector, Set, Map, Option, Either, Array, Seq)\n   - Collection type conversions (List â†” Vector â†” Set â†” Array â†” Seq)\n   - Nested conversions\n   - Structural types\n\n2. **Disambiguation Scenarios**\n   - Unique types (names irrelevant)\n   - Matching names (types irrelevant with coercion)\n   - Duplicate types with name disambiguation\n   - Duplicate types with position disambiguation\n   - Ambiguous cases (must fail at compile-time)\n\n3. **Schema Evolution**\n   - Field reordering\n   - Field renaming (with unique types)\n   - Adding optional fields\n   - Removing optional fields\n   - Type refinement (Int â†’ Long, with narrowing validation)\n   - Adding default values (Scala 3)\n\n4. **Validation** (Scala 3 opaque types)\n   - Valid values pass through\n   - Invalid values produce SchemaError\n   - Multiple validation failures accumulate\n   - Nested validation in products\n   - Validation in coproduct cases\n   - Validation in collections\n   - Narrowing conversions (Long â†’ Int with overflow check)\n\n5. **Validation** (Scala 2 ZIO Prelude newtypes)\n   - Newtype validation success\n   - Newtype validation failure\n   - Subtype validation with assertions\n   - Multiple newtype fields\n\n6. **Collection Type Conversions**\n   - List â†” Vector\n   - List â†” Array\n   - List â†” Set (with duplicate handling)\n   - List â†” Seq\n   - Vector â†” Set\n   - Array â†” Vector\n   - All combinations with element type coercion\n   - Nested collection type conversions\n\n7. **Runtime Validation** (for `As[A, B]`)\n   - Numeric narrowing validation\n   - Round-trip with valid narrowing\n   - Round-trip failure with overflow\n   - Collection conversions with duplicates\n   - Optional field round-trips\n\n8. **Error Cases**\n   - Ambiguous field mapping (compile error)\n   - Ambiguous case mapping (compile error)\n   - Default value in `As` (compile error)\n   - Runtime validation failures\n   - Type mismatch (compile error)\n   - Overflow in narrowing conversions\n\n9. **Edge Cases**\n   - Empty case classes\n   - Single-field case classes\n   - Case objects\n   - Sealed traits with case objects only\n   - Deeply nested structures (5+ levels)\n   - Large products (20+ fields)\n   - Large coproducts (20+ cases)\n   - Recursive types (e.g., `case class Tree(value: Int, children: List[Tree])`)\n   - Mutually recursive types\n\n### Test Organization\n\n```\nsrc/test/scala/\n  into/\n    products/\n      CaseClassToCaseClassSpec.scala\n      CaseClassToTupleSpec.scala\n      TupleToCaseClassSpec.scala\n      TupleToTupleSpec.scala\n      FieldReorderingSpec.scala\n      FieldRenamingSpec.scala\n      NestedProductsSpec.scala\n    coproducts/\n      SealedTraitToSealedTraitSpec.scala\n      EnumToEnumSpec.scala (Scala 3 only)\n      CaseMatchingSpec.scala\n      SignatureMatchingSpec.scala\n      AmbiguousCaseSpec.scala\n      NestedCoproductsSpec.scala\n    primitives/\n      NumericWideningSpec.scala\n      NumericNarrowingSpec.scala\n      CollectionCoercionSpec.scala\n      OptionCoercionSpec.scala\n      EitherCoercionSpec.scala\n      NestedCollectionSpec.scala\n    collections/\n      ListToVectorSpec.scala\n      ListToSetSpec.scala\n      VectorToArraySpec.scala\n      CollectionTypeWithCoercionSpec.scala\n      NestedCollectionTypeSpec.scala\n      SetDuplicateHandlingSpec.scala\n    structural/\n      StructuralTypeTargetSpec.scala (Scala 3 Selectable)\n      DynamicTypeTargetSpec.scala (Scala 2 Dynamic)\n      StructuralTypeSourceSpec.scala\n    validation/\n      OpaqueTypeValidationSpec.scala (Scala 3 only)\n      ZIONewtypeValidationSpec.scala (Scala 2 only)\n      ValidationErrorAccumulationSpec.scala\n      NestedValidationSpec.scala\n      NarrowingValidationSpec.scala\n    evolution/\n      AddOptionalFieldSpec.scala\n      RemoveOptionalFieldSpec.scala\n      TypeRefinementSpec.scala\n      AddDefaultFieldSpec.scala (Scala 3 only)\n    disambiguation/\n      UniqueTypeDisambiguationSpec.scala\n      NameDisambiguationSpec.scala\n      PositionDisambiguationSpec.scala\n      AmbiguousCompileErrorSpec.scala\n    edge/\n      EmptyProductSpec.scala\n      SingleFieldSpec.scala\n      CaseObjectSpec.scala\n      DeepNestingSpec.scala\n      LargeProductSpec.scala\n      LargeCoproductSpec.scala\n      RecursiveTypeSpec.scala\n      MutuallyRecursiveTypeSpec.scala\n  \n  as/\n    reversibility/\n      RoundTripProductSpec.scala\n      RoundTripCoproductSpec.scala\n      RoundTripTupleSpec.scala\n      RoundTripCollectionTypeSpec.scala\n      OpaqueTypeRoundTripSpec.scala\n      NumericNarrowingRoundTripSpec.scala\n      OptionalFieldRoundTripSpec.scala\n    validation/\n      OverflowDetectionSpec.scala\n      NarrowingFailureSpec.scala\n      CollectionLossyConversionSpec.scala\n    compile_errors/\n      DefaultValueSpec.scala\n    (similar structure to into/ for applicable tests)\n```\n\n### Specific Test Cases\n\n#### Disambiguation Tests\n\n```scala\n// Test: Unique types make names irrelevant\ncase class A(x: String, y: Int, z: Boolean)\ncase class B(a: String, b: Int, c: Boolean)\nassert(Into[A, B].into(A(\"test\", 42, true)) == Right(B(\"test\", 42, true)))\n\n// Test: Names disambiguate duplicate types\ncase class Point(x: Int, y: Int)\ncase class Coord(y: Int, x: Int)\nassert(Into[Point, Coord].into(Point(1, 2)) == Right(Coord(2, 1)))\n\n// Test: Ambiguous mapping fails at compile-time\ncase class Dim(width: Int, height: Int)\ncase class Measure(first: Int, second: Int)\n// Must not compile: Into[Dim, Measure]\nassertDoesNotCompile(\"Into[Dim, Measure]\")\n```\n\n#### Numeric Narrowing Validation Tests\n\n```scala\n// Test: Valid narrowing conversion\ncase class V1(value: Long)\ncase class V2(value: Int)\nassert(Into[V1, V2].into(V1(42L)) == Right(V2(42)))\n\n// Test: Invalid narrowing (overflow)\nassert(Into[V1, V2].into(V1(3000000000L)).isLeft)\n\n// Test: Narrowing in collections\ncase class Data1(values: List[Long])\ncase class Data2(values: List[Int])\nassert(Into[Data1, Data2].into(Data1(List(1L, 2L, 3L))) == Right(Data2(List(1, 2, 3))))\nassert(Into[Data1, Data2].into(Data1(List(1L, 3000000000L))).isLeft)\n```\n\n#### Collection Type Conversion Tests\n\n```scala\n// Test: List to Vector\ncase class A(items: List[Int])\ncase class B(items: Vector[Int])\nassert(Into[A, B].into(A(List(1, 2, 3))) == Right(B(Vector(1, 2, 3))))\n\n// Test: List to Set (removes duplicates)\ncase class C(items: List[Int])\ncase class D(items: Set[Int])\nassert(Into[C, D].into(C(List(1, 2, 2, 3))) == Right(D(Set(1, 2, 3))))\n\n// Test: Vector to Array\ncase class E(items: Vector[String])\ncase class F(items: Array[String])\nval result = Into[E, F].into(E(Vector(\"a\", \"b\")))\nassert(result.isRight)\nassert(result.right.get.items.sameElements(Array(\"a\", \"b\")))\n\n// Test: Combined collection and element coercion\ncase class G(items: List[Int])\ncase class H(items: Vector[Long])\nassert(Into[G, H].into(G(List(1, 2, 3))) == Right(H(Vector(1L, 2L, 3L))))\n```\n\n#### Validation Tests (Scala 3)\n\n```scala\n// Test: Valid opaque type conversion\ncase class Raw(age: Int)\ncase class Validated(age: Age)\nassert(Into[Raw, Validated].into(Raw(30)).isRight)\n\n// Test: Invalid opaque type conversion\nassert(Into[Raw, Validated].into(Raw(-5)).isLeft)\n\n// Test: Multiple validation failures accumulate\ncase class RawPerson(age: Int, email: String)\ncase class ValidPerson(age: Age, email: Email)\nval result = Into[RawPerson, ValidPerson].into(RawPerson(-5, \"invalid\"))\nassert(result.isLeft)\n// SchemaError contains both validation failures\n```\n\n#### Round-Trip Tests (As)\n\n```scala\n// Test: Case class round-trip\ncase class PersonV1(name: String, age: Int)\ncase class PersonV2(fullName: String, yearsOld: Int)\n\nval v1 = PersonV1(\"Alice\", 30)\nval v2 = As[PersonV1, PersonV2].into(v1).right.get\nval roundTrip = As[PersonV1, PersonV2].from(v2).right.get\n\nassert(roundTrip == v1)\n\n// Test: Numeric narrowing round-trip (valid)\ncase class ConfigV1(timeout: Int)\ncase class ConfigV2(timeout: Long)\n\nval config1 = ConfigV1(30)\nval config2 = As[ConfigV1, ConfigV2].into(config1).right.get\nval back = As[ConfigV1, ConfigV2].from(config2).right.get\n\nassert(back == config1)\n\n// Test: Numeric narrowing round-trip (overflow failure)\nval config2Overflow = ConfigV2(3000000000L)\nassert(As[ConfigV1, ConfigV2].from(config2Overflow).isLeft)\n\n// Test: Collection type round-trip\ncase class Data1(items: List[Int])\ncase class Data2(items: Vector[Int])\n\nval data1 = Data1(List(1, 2, 3))\nval data2 = As[Data1, Data2].into(data1).right.get\nval backToData1 = As[Data1, Data2].from(data2).right.get\n\nassert(backToData1 == data1)\n\n// Test: Lossy collection round-trip (Set loses duplicates)\ncase class WithDuplicates(items: List[Int])\ncase class NoDuplicates(items: Set[Int])\n\nval original = WithDuplicates(List(1, 2, 2, 3))\nval asSet = As[WithDuplicates, NoDuplicates].into(original).right.get\nval backToList = As[WithDuplicates, NoDuplicates].from(asSet).right.get\n\nassert(asSet.items == Set(1, 2, 3))\nassert(backToList.items.toSet == Set(1, 2, 3)) // Order may differ, duplicates lost\n```\n\n#### Edge Case Tests\n\n```scala\n// Test: Empty case class\ncase class Empty()\nassert(Into[Empty, Empty].into(Empty()) == Right(Empty()))\n\n// Test: Large product (21 fields)\ncase class Large21(f1: Int, f2: Int, /* ... */, f21: Int)\ncase class Large21V2(f1: Long, f2: Long, /* ... */, f21: Long)\n// Must compile and work correctly\n\n// Test: Recursive type\ncase class Tree(value: Int, children: List[Tree])\ncase class TreeV2(value: Long, children: List[TreeV2])\nval tree = Tree(1, List(Tree(2, Nil), Tree(3, Nil)))\nval treeV2 = Into[Tree, TreeV2].into(tree).right.get\nassert(treeV2.value == 1L)\nassert(treeV2.children.head.value == 2L)\n\n// Test: Mutually recursive types\ncase class Node(id: Int, edges: List[Edge])\ncase class Edge(from: Int, to: Node)\ncase class NodeV2(id: Long, edges: List[EdgeV2])\ncase class EdgeV2(from: Long, to: NodeV2)\n// Must compile and handle mutual recursion\n```\n\n---\n\n## Implementation Signatures\n\n### Scala 3.5\n\n```scala\npackage zio.blocks.schema\n\nimport scala.quoted.*\n\n// One-way conversion\ntrait Into[-A, +B] {\n  def into(input: A): Either[SchemaError, B]\n}\n\nobject Into {\n  inline given [A, B]: Into[A, B] = ${intoMacro[A, B]}\n  \n  private def intoMacro[A: Type, B: Type](using Quotes): Expr[Into[A, B]] = {\n    import quotes.reflect.*\n    // Implementation:\n    // 1. Analyze types A and B\n    // 2. Build field mapping using disambiguation algorithm\n    // 3. Detect opaque types and generate validation calls\n    // 4. Generate narrowing validation for numeric coercions\n    // 5. Handle collection type conversions\n    // 6. Generate conversion code\n    // 7. Handle nested conversions recursively\n    ???\n  }\n}\n\n// Bidirectional conversion\ntrait As[A, B] {\n  def into(input: A): Either[SchemaError, B]\n  def from(input: B): Either[SchemaError, A]\n}\n\nobject As {\n  inline given [A, B]: As[A, B] = ${asMacro[A, B]}\n  \n  private def asMacro[A: Type, B: Type](using Quotes): Expr[As[A, B]] = {\n    import quotes.reflect.*\n    // Implementation:\n    // 1. Verify bidirectional compatibility\n    // 2. Check for default values (compile error if found)\n    // 3. Build bidirectional field mapping\n    // 4. Generate both conversion directions with validation\n    // 5. Ensure opaque type wrapping/unwrapping is symmetric\n    // 6. Handle numeric narrowing with runtime validation\n    // 7. Handle collection type conversions bidirectionally\n    ???\n  }\n}\n```\n\n### Scala 2.13\n\n```scala\npackage com.yourorg.schema\n\nimport scala.reflect.macros.blackbox.Context\nimport scala.language.experimental.macros\n\ncase class SchemaError(msg: String) {\n  // SchemaError is composable - can combine multiple errors\n}\n\n// One-way conversion\ntrait Into[-A, +B] {\n  def into(input: A): Either[SchemaError, B]\n}\n\nobject Into {\n  implicit def materializeInto[A, B]: Into[A, B] = macro materializeIntoImpl[A, B]\n  \n  def materializeIntoImpl[A: c.WeakTypeTag, B: c.WeakTypeTag](c: Context): c.Tree = {\n    import c.universe._\n    // Implementation:\n    // 1. Analyze types A and B using reflection\n    // 2. Build field mapping using disambiguation algorithm\n    // 3. Detect ZIO Prelude newtypes via AST pattern matching\n    // 4. Generate narrowing validation for numeric coercions\n    // 5. Handle collection type conversions\n    // 6. Generate conversion code using quasiquotes\n    // 7. Handle nested conversions recursively\n    ???\n  }\n}\n\n// Bidirectional conversion\ntrait As[A, B] {\n  def into(input: A): Either[SchemaError, B]\n  def from(input: B): Either[SchemaError, A]\n}\n\nobject As {\n  implicit def materializeAs[A, B]: As[A, B] = macro materializeAsImpl[A, B]\n  \n  def materializeAsImpl[A: c.WeakTypeTag, B: c.WeakTypeTag](c: Context): c.Tree = {\n    import c.universe._\n    // Implementation:\n    // 1. Verify bidirectional compatibility\n    // 2. Check for default values (compile error if found)\n    // 3. Build bidirectional field mapping\n    // 4. Generate both conversion directions with validation\n    // 5. Ensure newtype wrapping/unwrapping is symmetric\n    // 6. Handle numeric narrowing with runtime validation\n    // 7. Handle collection type conversions bidirectionally\n    ???\n  }\n}\n```\n\n---\n\n## Implementation Notes\n\n### Error Messages\n\nProvide helpful compile-time errors:\n\n```scala\n// Good error message example:\n\"\"\"\nCannot derive Into[PersonV1, PersonV2]: Ambiguous field mapping\n\n  PersonV1(width: Int, height: Int)\n  PersonV2(first: Int, second: Int)\n\nCannot determine unique mapping between fields of type Int.\nConsider:\n  - Using matching field names (width/height)\n  - Making field types unique\n  - Providing an explicit Into instance\n\"\"\"\n```\n\n### Cross-Version Compatibility\n\n- Share test cases between Scala 2 and Scala 3 where possible\n\n---\n\n## Deliverables\n\n1. âœ… `Into[A, B]` trait and macro for Scala 2.13\n2. âœ… `Into[A, B]` trait and macro for Scala 3.5\n3. âœ… `As[A, B]` trait and macro for Scala 2.13\n4. âœ… `As[A, B]` trait and macro for Scala 3.5\n5. âœ… Comprehensive test suite\n6. âœ… Documentation with examples\n",
              "url": "https://github.com/zio/zio-blocks/issues/518",
              "tech": [],
              "repo_name": "zio-blocks",
              "repo_owner": "zio",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "ZIO#517",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "ZIO",
              "id": "generated-ZIO",
              "name": "ZIO",
              "description": "",
              "members": [],
              "display_name": "ZIO",
              "created_at": "2025-12-30T19:50:15.392Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/ZIO?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "zio",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2025-12-30T19:50:15.392Z",
            "created_at": "2025-12-30T19:50:15.392Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-ZIO#517",
              "status": "open",
              "type": "issue",
              "number": 517,
              "title": "Add structural schemas",
              "source": {
                "data": {
                  "id": "source-ZIO#517",
                  "user": {
                    "login": "jdegoes",
                    "id": 156745,
                    "node_id": "MDQ6VXNlcjE1Njc0NQ==",
                    "avatar_url": "https://avatars.githubusercontent.com/u/156745?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/jdegoes",
                    "html_url": "https://github.com/jdegoes",
                    "followers_url": "https://api.github.com/users/jdegoes/followers",
                    "following_url": "https://api.github.com/users/jdegoes/following{/other_user}",
                    "gists_url": "https://api.github.com/users/jdegoes/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/jdegoes/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/jdegoes/subscriptions",
                    "organizations_url": "https://api.github.com/users/jdegoes/orgs",
                    "repos_url": "https://api.github.com/users/jdegoes/repos",
                    "events_url": "https://api.github.com/users/jdegoes/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/jdegoes/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Add structural schemas",
                  "body": "# Structural Type Schema Support\n\n## Overview\n\nExtend `Schema[A]` to support structural types, enabling schema derivation for types defined by their structure rather than their nominal identity. This allows for duck-typed schema validation and conversion between nominal and structural representations.\n\n## Core Concepts\n\n### Direct Structural Schema Derivation\n\nSchemas can be derived directly for structural types:\n\n```scala\n// Scala 3\ntype Person = { def name: String; def age: Int }\nval schema = Schema.derived[Person]\n\n// Scala 2\ntype Person = { def name: String; def age: Int }\nval schema = Schema.derived[Person]\n```\n\n**Note**: Both Scala 2 and Scala 3 use `def` for uniformity, even though Scala 3 supports `val` in structural types.\n\n**Implementation**: Schemas have bindings, which allow construction / deconstruction of values. Values for structural types are backed by:\n- **Scala 3**: `Selectable` \n- **Scala 2**: `Dynamic`\n\n### Nominal to Structural Conversion\n\nConvert nominal type schemas to their structural equivalents:\n\n```scala\ncase class Person(name: String, age: Int)\n\n// Get the structural schema corresponding to Person's shape\nval structuralSchema: Schema[{ def name: String; def age: Int }] = \n  Schema.derived[Person].structural\n```\n\n### Schema API Extension\n\n```scala\ncase class Schema[A](/* existing fields */) {\n  /**\n   * Convert this schema to a structural type schema.\n   * \n   * The structural type represents the \"shape\" of A without its nominal identity.\n   * This enables duck typing and structural validation.\n   * \n   * @param toStructural Macro-generated conversion to structural representation\n   * @return Schema for the structural type corresponding to A\n   */\n  def structural(implicit toStructural: ToStructural[A]): Schema[toStructural.StructuralType] = \n    toStructural.apply(this)\n}\n\n/**\n * Type class for converting nominal schemas to structural schemas.\n * Generated by macro for all supported types. Macro fails if a structural\n * type cannot be generated.\n *\n * NOTE: This approach has to be tested to yield inferrable types, and revised\n * if necessary. Inferrable types (from calling Schema#structural) are a must-have.\n */\ntrait ToStructural[A] {\n  type StructuralType\n  def apply(schema: Schema[A]): Schema[StructuralType]\n}\n\nobject ToStructural {\n  type Aux[A, S] = ToStructural[A] { type StructuralType = S }\n  \n  // Scala 3\n  transparent inline given [A]: ToStructural[A] = ${toStructuralMacro[A]}\n  \n  // Scala 2\n  implicit def materialize[A]: ToStructural[A] = macro toStructuralImpl[A]\n}\n```\n\n---\n\n## Examples\n\n### 1. Simple Product Types\n\n#### Case Class to Structural\n\n```scala\n// Both Scala 2 and Scala 3\ncase class Person(name: String, age: Int)\n\n// Original nominal schema\nval nominalSchema: Schema[Person] = Schema.derived[Person]\n\n// Convert to structural\nval structuralSchema: Schema[{ def name: String; def age: Int }] = \n  nominalSchema.structural\n\n// Direct structural derivation (equivalent)\nval directStructural: Schema[{ def name: String; def age: Int }] = \n  Schema.derived[{ def name: String; def age: Int }]\n```\n\n### 2. Nested Structures\n\n```scala\ncase class Address(street: String, city: String, zip: Int)\ncase class Person(name: String, age: Int, address: Address)\n\nval structuralSchema = Schema.derived[Person].structural\n// Type: Schema[{ \n//   def name: String\n//   def age: Int\n//   def address: { def street: String; def city: String; def zip: Int }\n// }]\n```\n\n### 3. Collections and Options\n\n```scala\ncase class Team(name: String, members: List[String], leader: Option[String])\n\nval structuralSchema = Schema.derived[Team].structural\n// Type: Schema[{\n//   def name: String\n//   def members: List[String]\n//   def leader: Option[String]\n// }]\n```\n\n### 4. Tuples to Structural\n\n```scala\n// Tuples can be converted to structural types\nval tupleSchema: Schema[(String, Int, Boolean)] = Schema.derived[(String, Int, Boolean)]\n\nval structuralSchema = tupleSchema.structural\n// Type: Schema[{ def _1: String; def _2: Int; def _3: Boolean }]\n```\n\n### 5. Sum Types (Sealed Traits) - Scala 3 Only\n\nSealed traits become union types of structural representations, with tag information stored at the type level:\n\n```scala\n// Scala 3 only\nsealed trait Result\ncase class Success(value: Int) extends Result\ncase class Failure(error: String) extends Result\n\nval structuralSchema = Schema.derived[Result].structural\n// Type: Schema[\n//   { type Tag = \"Success\"; def value: Int } | { type Tag = \"Failure\"; def error: String }\n// ]\n```\n\n**Note**: Sum type to structural conversion is **not supported in Scala 2** because it requires union types. Attempting to call `.structural` on a sealed trait schema in Scala 2 will result in a compile-time error.\n\n### 6. Enums (Scala 3 Only)\n\n```scala\nenum Status:\n  case Active, Inactive, Suspended\n\nval structuralSchema = Schema.derived[Status].structural\n// Type: Schema[{type Tag = \"Active\"} | {type Tag = \"Inactive\"} | {type Tag = \"Suspended\"}]\n```\n\n### 7. Opaque Types (Scala 3)\n\n```scala\nopaque type UserId = String\nobject UserId:\n  def apply(value: String): Either[String, UserId] = \n    if value.nonEmpty then Right(value) else Left(\"Empty user ID\")\n\ncase class User(id: UserId, name: String)\n\nval structuralSchema = Schema.derived[User].structural\n// Type: Schema[{ def id: String; def name: String }]\n// Opaque type is unwrapped to its underlying type\n```\n\n### 8. Bidirectional Conversion\n\nStructural schemas work seamlessly with `Into`/`As` (if this ticket is implemented **after** that ticket):\n\n```scala\ncase class Person(name: String, age: Int)\n\nval structuralSchema = Schema.derived[Person].structural\n\n// Create structural value (Scala 3)\nval structuralPerson = new Selectable {\n  def selectDynamic(field: String): Any = field match {\n    case \"name\" => \"Alice\"\n    case \"age\" => 30\n  }\n}\n\n// Convert structural to nominal using Into\nval person: Either[SchemaError, Person] = \n  Into[{ def name: String; def age: Int }, Person].into(structuralPerson)\n// => Right(Person(\"Alice\", 30))\n\n// Convert nominal to structural\nval backToStructural: Either[SchemaError, { def name: String; def age: Int }] = \n  Into[Person, { def name: String; def age: Int }].into(Person(\"Bob\", 25))\n```\n\n### 9. Empty and Single-Field Products\n\n```scala\n// Empty case class\ncase class Empty()\nval emptyStructural = Schema.derived[Empty].structural\n// Type: Schema[{}]\n\n// Single field\ncase class Id(value: String)\nval idStructural = Schema.derived[Id].structural\n// Type: Schema[{ def value: String }]\n```\n\n### 10. Large Products\n\n```scala\ncase class LargeRecord(\n  f1: String, f2: Int, f3: Boolean, f4: Double, f5: Long,\n  f6: String, f7: Int, f8: Boolean, f9: Double, f10: Long,\n  f11: String, f12: Int, f13: Boolean, f14: Double, f15: Long,\n  f16: String, f17: Int, f18: Boolean, f19: Double, f20: Long,\n  f21: String\n)\n\nval structuralSchema = Schema.derived[LargeRecord].structural\n// Type: Schema[{\n//   def f1: String; def f2: Int; def f3: Boolean; ...\n//   def f21: String\n// }]\n```\n\n---\n\n## Type Name Handling\n\n### Current Limitation\n\nSchemas currently use `TypeName[A]` to identify types. Structural types don't have meaningful nominal type names, which creates a mismatch.\n\n### Temporary Solution\n\nUntil `TypeName[A]` is replaced with `TypeId[A]` (see issue #471), structural schemas will use a normalized string representation of the structural type as a fake type name:\n\n```scala\ncase class Person(name: String, age: Int)\n\nval schema = Schema.derived[Person]\nschema.typeName // => TypeName for \"Person\"\n\nval structural = schema.structural\nstructural.typeName // => TypeName for \"{age:Int,name:String}\"\n// Normalized: fields sorted alphabetically, types fully qualified\n```\n\n### Normalization Rules\n\n1. **Field ordering**: Alphabetical by field name\n2. **Type qualification**: Use simple names for primitives and standard library types\n3. **Whitespace**: No whitespace in generated names\n4. **Collections**: Standard notation (e.g., `List[Int]`)\n5. **Options**: Explicit `Option[T]` notation\n6. **Nested structures**: Recursive application of rules\n7. **Deterministic**: Same structure always produces same normalized name\n\n### Examples\n\n```scala\n// Simple product\ncase class Point(x: Int, y: Int)\nSchema.derived[Point].structural.typeName \n// => \"{x:Int,y:Int}\"\n\n// Nested product\ncase class Address(street: String, zip: Int)\ncase class Person(name: String, address: Address)\nSchema.derived[Person].structural.typeName\n// => \"{address:{street:String,zip:Int},name:String}\"\n\n// With collections\ncase class Team(name: String, members: List[String])\nSchema.derived[Team].structural.typeName\n// => \"{members:List[String],name:String}\"\n\n// Union type (Scala 3)\nsealed trait Result\ncase class Success(value: Int) extends Result\ncase class Failure(error: String) extends Result\nSchema.derived[Result].structural.typeName\n// => \"{error:String}|{value:Int}\"\n```\n\n### Future: TypeId[A]\n\nThe upcoming `TypeId[A]` replacement will properly handle structural types by representing them by their structure rather than a string-based hack. See issue #471 for details.\n\n---\n\n## Limitations and Edge Cases\n\n### 1. Generic Types\n\n**Behavior depends on existing Schema derivation support for generic types.**\n\nIf `Schema.derived[Container[Int]]` already works, then structural conversion should work:\n\n```scala\ncase class Container[T](value: T)\n\n// If this works:\nval schema = Schema.derived[Container[Int]]\n\n// Then this should work:\nval structural = schema.structural\n// Type: Schema[{ def value: Int }]\n```\n\nIf generic type derivation is not currently supported, this ticket **does not require implementing it**. The macro should produce a clear compile-time error for unsupported generic types.\n\n### 2. Recursive Types\n\nRecursive types will **fail at compile-time** because Scala does not support infinite types:\n\n```scala\ncase class Tree(value: Int, children: List[Tree])\n\n// This will FAIL at compile-time:\nval structural = Schema.derived[Tree].structural\n// Compile error: Cannot generate infinite structural type\n\n// The structural type would need to be:\n// { def value: Int; def children: List[{ def value: Int; def children: List[...] }] }\n// which is infinite and unsupported\n```\n\nThe macro must detect recursive types and produce a helpful error message:\n\n```\nCompile error: Cannot generate structural type for recursive type Tree.\nStructural types cannot represent recursive structures.\n```\n\n### 3. Mutually Recursive Types\n\nSimilarly, mutually recursive types are unsupported:\n\n```scala\ncase class Node(id: Int, edges: List[Edge])\ncase class Edge(from: Int, to: Node)\n\n// This will FAIL at compile-time:\nval nodeStructural = Schema.derived[Node].structural\n// Compile error: Cannot generate structural type for mutually recursive types\n```\n\n### 4. Sum Types in Scala 2\n\nSealed traits and sum types **cannot be converted to structural types in Scala 2** because they require union types:\n\n```scala\n// Scala 2\nsealed trait Result\ncase class Success(value: Int) extends Result\ncase class Failure(error: String) extends Result\n\n// This will FAIL at compile-time in Scala 2:\nval structural = Schema.derived[Result].structural\n// Compile error: Cannot generate structural type for sum types in Scala 2.\n// Union types are required, which are only available in Scala 3.\n```\n\nThe macro must detect sum types in Scala 2 and produce a clear error.\n\n### 5. Case Objects\n\nCase objects become empty structural types:\n\n```scala\ncase object Singleton\n\nval structural = Schema.derived[Singleton.type].structural\n// Type: Schema[{}]\n```\n\nFor sum types with case objects (Scala 3):\n\n```scala\nsealed trait Status\ncase object Active extends Status\ncase object Inactive extends Status\n\nval structural = Schema.derived[Status].structural\n// Type: Schema[{} | {}]\n// Not particularly useful, but valid\n```\n\n### 6. Structural Types as Source\n\nDeriving schemas directly for structural types is supported:\n\n```scala\ntype PersonStructure = { def name: String; def age: Int }\n\nval schema = Schema.derived[PersonStructure]\n// Should work if structural type derivation is implemented\n```\n\nThe schema's bindings will use `Selectable` (Scala 3) or `Dynamic` (Scala 2) to construct and deconstruct values.\n\n---\n\n## Integration with Into/As\n\nStructural schemas compose naturally with `Into`/`As` conversions.\n\n### Nominal â†’ Structural\n\n```scala\ncase class Person(name: String, age: Int)\n\n// Auto-derived conversion\nval nominalToStructural: Into[Person, { def name: String; def age: Int }] = \n  Into.derived\n\nval person = Person(\"Alice\", 30)\nval structural = nominalToStructural.into(person)\n// => Right(<Selectable/Dynamic instance>)\n```\n\n### Structural â†’ Nominal\n\n```scala\ntype PersonStructure = { def name: String; def age: Int }\ncase class Person(name: String, age: Int)\n\n// Auto-derived conversion\nval structuralToNominal: Into[PersonStructure, Person] = \n  Into.derived\n\nval structural: PersonStructure = new Selectable {\n  def selectDynamic(field: String): Any = field match {\n    case \"name\" => \"Bob\"\n    case \"age\" => 25\n  }\n}\n\nval person = structuralToNominal.into(structural)\n// => Right(Person(\"Bob\", 25))\n```\n\n### Bidirectional (As)\n\n```scala\ncase class Person(name: String, age: Int)\n\n// Bidirectional conversion\nval personAs: As[Person, { def name: String; def age: Int }] = \n  As.derived\n\n// Nominal â†’ Structural\nval structural = personAs.into(Person(\"Alice\", 30))\n\n// Structural â†’ Nominal\nval nominal = structural.flatMap(personAs.from)\n// Round-trip successful\n```\n\n### Schema-Guided Conversion\n\n```scala\ncase class PersonV1(firstName: String, lastName: String, age: Int)\ncase class PersonV2(name: String, age: Int)\n\n// Use structural type as intermediary\ntype PersonStructure = { def name: String; def age: Int }\n\n// Step 1: Transform V1 to structural (custom logic)\nval v1ToStructural: Into[PersonV1, PersonStructure] = \n  new Into[PersonV1, PersonStructure] {\n    def into(v1: PersonV1): Either[SchemaError, PersonStructure] = {\n      Right(new Selectable {\n        def selectDynamic(field: String): Any = field match {\n          case \"name\" => s\"${v1.firstName} ${v1.lastName}\"\n          case \"age\" => v1.age\n        }\n      })\n    }\n  }\n\n// Step 2: Auto-convert structural to V2\nval structuralToV2: Into[PersonStructure, PersonV2] = Into.derived\n\n// Composed migration\ndef migrate(v1: PersonV1): Either[SchemaError, PersonV2] = {\n  v1ToStructural.into(v1).flatMap(structuralToV2.into)\n}\n```\n\n---\n\n## Testing Requirements\n\n### Test Matrix\n\n1. **Direct Structural Derivation**\n   - Simple products (case classes)\n   - Nested products\n   - Collections (List, Vector, Set, Map, Option, Either)\n   - Tuples (2-22 elements)\n   - Empty case classes\n   - Single-field case classes\n   - Large products (20+ fields)\n   - Case objects\n\n2. **Nominal to Structural Conversion**\n   - Case class â†’ structural\n   - Tuple â†’ structural\n   - Nested case classes â†’ nested structural\n   - Case class with collections â†’ structural with collections\n   - Empty case class â†’ empty structural\n\n3. **Sum Types (Scala 3 Only)**\n   - Sealed trait â†’ union type structural\n   - Sealed trait with case objects\n   - Enum â†’ union type structural\n   - Nested sum types\n\n4. **Type Name Generation**\n   - Simple product normalized name\n   - Nested product normalized name\n   - Name determinism (same structure = same name)\n   - Alphabetical field ordering in names\n   - Union type names (Scala 3)\n\n5. **Selectable/Dynamic Implementation**\n   - Scala 3 Selectable field access\n   - Scala 2 Dynamic field access\n   - Field access correctness\n   - Missing field behavior\n   - Extra field behavior\n\n6. **Integration with Into/As**\n   - Nominal â†’ Structural via Into\n   - Structural â†’ Nominal via Into\n   - Round-trip via As\n   - Composed conversions with structural intermediary\n\n7. **Error Cases (Compile-Time)**\n   - Recursive types produce error\n   - Mutually recursive types produce error\n   - Sum types in Scala 2 produce error\n   - Unsupported types produce helpful errors\n\n8. **Generic Types** (if supported by existing Schema derivation)\n   - Fully applied generic â†’ structural\n   - Generic with nested structural fields\n\n### Scala 2 vs Scala 3 Test Separation\n\n```\nsrc/test/scala/\n  structural/\n    common/\n      SimpleProductSpec.scala\n      NestedProductSpec.scala\n      CollectionsSpec.scala\n      TuplesSpec.scala\n      EmptyProductSpec.scala\n      SingleFieldSpec.scala\n      LargeProductSpec.scala\n      TypeNameNormalizationSpec.scala\n      IntoIntegrationSpec.scala\n      AsIntegrationSpec.scala\n      \n    scala3/\n      UnionTypesSpec.scala\n      SealedTraitToUnionSpec.scala\n      EnumToUnionSpec.scala\n      SelectableImplementationSpec.scala\n      \n    scala2/\n      DynamicImplementationSpec.scala\n      SumTypeErrorSpec.scala (verifies compile error)\n      \n    errors/\n      RecursiveTypeErrorSpec.scala\n      MutualRecursionErrorSpec.scala\n      UnsupportedTypeErrorSpec.scala\n```\n\n### Test Examples\n\n```scala\n// Test: Simple product to structural\ntest(\"case class converts to structural schema\") {\n  case class Person(name: String, age: Int)\n  \n  val structural = Schema.derived[Person].structural\n  \n  // Type check (this is a compile-time test)\n  val _: Schema[{ def name: String; def age: Int }] = structural\n  \n  assert(structural.typeName.toString.contains(\"name\"))\n  assert(structural.typeName.toString.contains(\"age\"))\n}\n\n// Test: Nested products\ntest(\"nested case classes convert to nested structural\") {\n  case class Address(street: String, zip: Int)\n  case class Person(name: String, address: Address)\n  \n  val structural = Schema.derived[Person].structural\n  \n  val _: Schema[{ \n    def name: String\n    def address: { def street: String; def zip: Int }\n  }] = structural\n}\n\n// Test: Tuple to structural\ntest(\"tuple converts to structural with _N fields\") {\n  val structural = Schema.derived[(String, Int, Boolean)].structural\n  \n  val _: Schema[{ def _1: String; def _2: Int; def _3: Boolean }] = structural\n}\n\n// Test: Union type (Scala 3 only)\ntest(\"sealed trait converts to union type structural\") {\n  sealed trait Result\n  case class Success(value: Int) extends Result\n  case class Failure(error: String) extends Result\n  \n  val structural = Schema.derived[Result].structural\n  \n  val _: Schema[{ def value: Int } | { def error: String }] = structural\n}\n\n// Test: Type name normalization\ntest(\"structural type names are normalized and deterministic\") {\n  case class Person(name: String, age: Int)\n  case class User(age: Int, name: String) // Different field order\n  \n  val personStructural = Schema.derived[Person].structural\n  val userStructural = Schema.derived[User].structural\n  \n  // Same structure, same normalized name\n  assert(personStructural.typeName == userStructural.typeName)\n  \n  // Alphabetical ordering\n  assert(personStructural.typeName.toString.contains(\"age\"))\n  assert(personStructural.typeName.toString.indexOf(\"age\") < \n         personStructural.typeName.toString.indexOf(\"name\"))\n}\n\n// Test: Integration with Into\ntest(\"structural to nominal conversion via Into\") {\n  case class Person(name: String, age: Int)\n  type PersonStructure = { def name: String; def age: Int }\n  \n  val structural: PersonStructure = new Selectable {\n    def selectDynamic(field: String): Any = field match {\n      case \"name\" => \"Alice\"\n      case \"age\" => 30\n    }\n  }\n  \n  val person = Into[PersonStructure, Person].into(structural)\n  assert(person == Right(Person(\"Alice\", 30)))\n}\n\n// Test: Round-trip via As\ntest(\"nominal to structural and back preserves data\") {\n  case class Person(name: String, age: Int)\n  type PersonStructure = { def name: String; def age: Int }\n  \n  val original = Person(\"Alice\", 30)\n  \n  val toStructural = As[Person, PersonStructure].into(original)\n  val backToNominal = toStructural.flatMap(As[Person, PersonStructure].from)\n  \n  assert(backToNominal == Right(original))\n}\n\n// Test: Recursive type compile error\ntest(\"recursive types produce compile error\") {\n  case class Tree(value: Int, children: List[Tree])\n  \n  assertDoesNotCompile(\"Schema.derived[Tree].structural\")\n}\n\n// Test: Sum type in Scala 2 compile error\ntest(\"sum types in Scala 2 produce compile error\") {\n  sealed trait Result\n  case class Success(value: Int) extends Result\n  \n  // Scala 2 only\n  assertDoesNotCompile(\"Schema.derived[Result].structural\")\n}\n```\n\n---\n\n## Implementation Notes\n\n### Macro Behavior\n\nThe macro must:\n\n1. **Detect product types** (case classes, tuples) and generate structural types with `def` members\n2. **Detect sum types** (sealed traits, enums) and:\n   - In Scala 3: Generate union types of structural representations\n   - In Scala 2: Fail with clear error message\n3. **Detect recursive types** and fail with clear error message\n4. **Normalize structural type representations** for type name generation\n5. **Generate `ToStructural` instance** with:\n   - `StructuralType` type member set to the generated structural type\n   - `apply` method that transforms the schema appropriately\n6. **Preserve field metadata** from original schema where applicable\n7. **Generate appropriate bindings** using `Selectable` (Scala 3) or `Dynamic` (Scala 2)\n\n### Schema Transformation\n\nWhen converting `Schema[A]` to `Schema[StructuralType]`:\n\n1. **Preserve field information**: Field names, types, optional/required status\n2. **Update type name**: Use normalized structural representation\n3. **Transform bindings**: Replace nominal constructors/deconstructors with structural equivalents\n4. **Preserve validation**: Maintain any validation logic that applies to field values\n5. **Handle nested schemas**: Recursively transform nested product types\n\n### Error Messages\n\nProvide clear compile-time errors:\n\n```scala\n// Recursive type\ncase class Tree(value: Int, children: List[Tree])\nSchema.derived[Tree].structural\n\n// Error:\n\"\"\"\nCannot generate structural type for recursive type Tree.\nStructural types cannot represent recursive structures.\nScala's type system does not support infinite types.\n\"\"\"\n\n// Sum type in Scala 2\nsealed trait Result\ncase class Success(value: Int) extends Result\nSchema.derived[Result].structural\n\n// Error (Scala 2 only):\n\"\"\"\nCannot generate structural type for sum type Result.\nStructural representation of sum types requires union types,\nwhich are only available in Scala 3.\nConsider upgrading to Scala 3 or using a different approach.\n\"\"\"\n```\n\n---\n\n## Deliverables\n\n1. âœ… `ToStructural[A]` trait and macro for Scala 2.13\n2. âœ… `ToStructural[A]` trait and macro for Scala 3.5\n3. âœ… `structural` method on `Schema[A]`\n4. âœ… Support for product types (case classes, tuples)\n5. âœ… Support for sum types (sealed traits, enums) in Scala 3 only\n6. âœ… Normalized type name generation\n7. âœ… `Selectable` bindings (Scala 3) and `Dynamic` bindings (Scala 2)\n8. âœ… Integration with `Into`/`As` for structural â†” nominal conversions\n9. âœ… Comprehensive test suite (300+ test cases)\n10. âœ… Clear error messages for unsupported cases\n11. âœ… Documentation with examples",
                  "html_url": "https://github.com/zio/zio-blocks/issues/517"
                },
                "type": "github"
              },
              "hash": "zio/zio-blocks#517",
              "body": "# Structural Type Schema Support\n\n## Overview\n\nExtend `Schema[A]` to support structural types, enabling schema derivation for types defined by their structure rather than their nominal identity. This allows for duck-typed schema validation and conversion between nominal and structural representations.\n\n## Core Concepts\n\n### Direct Structural Schema Derivation\n\nSchemas can be derived directly for structural types:\n\n```scala\n// Scala 3\ntype Person = { def name: String; def age: Int }\nval schema = Schema.derived[Person]\n\n// Scala 2\ntype Person = { def name: String; def age: Int }\nval schema = Schema.derived[Person]\n```\n\n**Note**: Both Scala 2 and Scala 3 use `def` for uniformity, even though Scala 3 supports `val` in structural types.\n\n**Implementation**: Schemas have bindings, which allow construction / deconstruction of values. Values for structural types are backed by:\n- **Scala 3**: `Selectable` \n- **Scala 2**: `Dynamic`\n\n### Nominal to Structural Conversion\n\nConvert nominal type schemas to their structural equivalents:\n\n```scala\ncase class Person(name: String, age: Int)\n\n// Get the structural schema corresponding to Person's shape\nval structuralSchema: Schema[{ def name: String; def age: Int }] = \n  Schema.derived[Person].structural\n```\n\n### Schema API Extension\n\n```scala\ncase class Schema[A](/* existing fields */) {\n  /**\n   * Convert this schema to a structural type schema.\n   * \n   * The structural type represents the \"shape\" of A without its nominal identity.\n   * This enables duck typing and structural validation.\n   * \n   * @param toStructural Macro-generated conversion to structural representation\n   * @return Schema for the structural type corresponding to A\n   */\n  def structural(implicit toStructural: ToStructural[A]): Schema[toStructural.StructuralType] = \n    toStructural.apply(this)\n}\n\n/**\n * Type class for converting nominal schemas to structural schemas.\n * Generated by macro for all supported types. Macro fails if a structural\n * type cannot be generated.\n *\n * NOTE: This approach has to be tested to yield inferrable types, and revised\n * if necessary. Inferrable types (from calling Schema#structural) are a must-have.\n */\ntrait ToStructural[A] {\n  type StructuralType\n  def apply(schema: Schema[A]): Schema[StructuralType]\n}\n\nobject ToStructural {\n  type Aux[A, S] = ToStructural[A] { type StructuralType = S }\n  \n  // Scala 3\n  transparent inline given [A]: ToStructural[A] = ${toStructuralMacro[A]}\n  \n  // Scala 2\n  implicit def materialize[A]: ToStructural[A] = macro toStructuralImpl[A]\n}\n```\n\n---\n\n## Examples\n\n### 1. Simple Product Types\n\n#### Case Class to Structural\n\n```scala\n// Both Scala 2 and Scala 3\ncase class Person(name: String, age: Int)\n\n// Original nominal schema\nval nominalSchema: Schema[Person] = Schema.derived[Person]\n\n// Convert to structural\nval structuralSchema: Schema[{ def name: String; def age: Int }] = \n  nominalSchema.structural\n\n// Direct structural derivation (equivalent)\nval directStructural: Schema[{ def name: String; def age: Int }] = \n  Schema.derived[{ def name: String; def age: Int }]\n```\n\n### 2. Nested Structures\n\n```scala\ncase class Address(street: String, city: String, zip: Int)\ncase class Person(name: String, age: Int, address: Address)\n\nval structuralSchema = Schema.derived[Person].structural\n// Type: Schema[{ \n//   def name: String\n//   def age: Int\n//   def address: { def street: String; def city: String; def zip: Int }\n// }]\n```\n\n### 3. Collections and Options\n\n```scala\ncase class Team(name: String, members: List[String], leader: Option[String])\n\nval structuralSchema = Schema.derived[Team].structural\n// Type: Schema[{\n//   def name: String\n//   def members: List[String]\n//   def leader: Option[String]\n// }]\n```\n\n### 4. Tuples to Structural\n\n```scala\n// Tuples can be converted to structural types\nval tupleSchema: Schema[(String, Int, Boolean)] = Schema.derived[(String, Int, Boolean)]\n\nval structuralSchema = tupleSchema.structural\n// Type: Schema[{ def _1: String; def _2: Int; def _3: Boolean }]\n```\n\n### 5. Sum Types (Sealed Traits) - Scala 3 Only\n\nSealed traits become union types of structural representations, with tag information stored at the type level:\n\n```scala\n// Scala 3 only\nsealed trait Result\ncase class Success(value: Int) extends Result\ncase class Failure(error: String) extends Result\n\nval structuralSchema = Schema.derived[Result].structural\n// Type: Schema[\n//   { type Tag = \"Success\"; def value: Int } | { type Tag = \"Failure\"; def error: String }\n// ]\n```\n\n**Note**: Sum type to structural conversion is **not supported in Scala 2** because it requires union types. Attempting to call `.structural` on a sealed trait schema in Scala 2 will result in a compile-time error.\n\n### 6. Enums (Scala 3 Only)\n\n```scala\nenum Status:\n  case Active, Inactive, Suspended\n\nval structuralSchema = Schema.derived[Status].structural\n// Type: Schema[{type Tag = \"Active\"} | {type Tag = \"Inactive\"} | {type Tag = \"Suspended\"}]\n```\n\n### 7. Opaque Types (Scala 3)\n\n```scala\nopaque type UserId = String\nobject UserId:\n  def apply(value: String): Either[String, UserId] = \n    if value.nonEmpty then Right(value) else Left(\"Empty user ID\")\n\ncase class User(id: UserId, name: String)\n\nval structuralSchema = Schema.derived[User].structural\n// Type: Schema[{ def id: String; def name: String }]\n// Opaque type is unwrapped to its underlying type\n```\n\n### 8. Bidirectional Conversion\n\nStructural schemas work seamlessly with `Into`/`As` (if this ticket is implemented **after** that ticket):\n\n```scala\ncase class Person(name: String, age: Int)\n\nval structuralSchema = Schema.derived[Person].structural\n\n// Create structural value (Scala 3)\nval structuralPerson = new Selectable {\n  def selectDynamic(field: String): Any = field match {\n    case \"name\" => \"Alice\"\n    case \"age\" => 30\n  }\n}\n\n// Convert structural to nominal using Into\nval person: Either[SchemaError, Person] = \n  Into[{ def name: String; def age: Int }, Person].into(structuralPerson)\n// => Right(Person(\"Alice\", 30))\n\n// Convert nominal to structural\nval backToStructural: Either[SchemaError, { def name: String; def age: Int }] = \n  Into[Person, { def name: String; def age: Int }].into(Person(\"Bob\", 25))\n```\n\n### 9. Empty and Single-Field Products\n\n```scala\n// Empty case class\ncase class Empty()\nval emptyStructural = Schema.derived[Empty].structural\n// Type: Schema[{}]\n\n// Single field\ncase class Id(value: String)\nval idStructural = Schema.derived[Id].structural\n// Type: Schema[{ def value: String }]\n```\n\n### 10. Large Products\n\n```scala\ncase class LargeRecord(\n  f1: String, f2: Int, f3: Boolean, f4: Double, f5: Long,\n  f6: String, f7: Int, f8: Boolean, f9: Double, f10: Long,\n  f11: String, f12: Int, f13: Boolean, f14: Double, f15: Long,\n  f16: String, f17: Int, f18: Boolean, f19: Double, f20: Long,\n  f21: String\n)\n\nval structuralSchema = Schema.derived[LargeRecord].structural\n// Type: Schema[{\n//   def f1: String; def f2: Int; def f3: Boolean; ...\n//   def f21: String\n// }]\n```\n\n---\n\n## Type Name Handling\n\n### Current Limitation\n\nSchemas currently use `TypeName[A]` to identify types. Structural types don't have meaningful nominal type names, which creates a mismatch.\n\n### Temporary Solution\n\nUntil `TypeName[A]` is replaced with `TypeId[A]` (see issue #471), structural schemas will use a normalized string representation of the structural type as a fake type name:\n\n```scala\ncase class Person(name: String, age: Int)\n\nval schema = Schema.derived[Person]\nschema.typeName // => TypeName for \"Person\"\n\nval structural = schema.structural\nstructural.typeName // => TypeName for \"{age:Int,name:String}\"\n// Normalized: fields sorted alphabetically, types fully qualified\n```\n\n### Normalization Rules\n\n1. **Field ordering**: Alphabetical by field name\n2. **Type qualification**: Use simple names for primitives and standard library types\n3. **Whitespace**: No whitespace in generated names\n4. **Collections**: Standard notation (e.g., `List[Int]`)\n5. **Options**: Explicit `Option[T]` notation\n6. **Nested structures**: Recursive application of rules\n7. **Deterministic**: Same structure always produces same normalized name\n\n### Examples\n\n```scala\n// Simple product\ncase class Point(x: Int, y: Int)\nSchema.derived[Point].structural.typeName \n// => \"{x:Int,y:Int}\"\n\n// Nested product\ncase class Address(street: String, zip: Int)\ncase class Person(name: String, address: Address)\nSchema.derived[Person].structural.typeName\n// => \"{address:{street:String,zip:Int},name:String}\"\n\n// With collections\ncase class Team(name: String, members: List[String])\nSchema.derived[Team].structural.typeName\n// => \"{members:List[String],name:String}\"\n\n// Union type (Scala 3)\nsealed trait Result\ncase class Success(value: Int) extends Result\ncase class Failure(error: String) extends Result\nSchema.derived[Result].structural.typeName\n// => \"{error:String}|{value:Int}\"\n```\n\n### Future: TypeId[A]\n\nThe upcoming `TypeId[A]` replacement will properly handle structural types by representing them by their structure rather than a string-based hack. See issue #471 for details.\n\n---\n\n## Limitations and Edge Cases\n\n### 1. Generic Types\n\n**Behavior depends on existing Schema derivation support for generic types.**\n\nIf `Schema.derived[Container[Int]]` already works, then structural conversion should work:\n\n```scala\ncase class Container[T](value: T)\n\n// If this works:\nval schema = Schema.derived[Container[Int]]\n\n// Then this should work:\nval structural = schema.structural\n// Type: Schema[{ def value: Int }]\n```\n\nIf generic type derivation is not currently supported, this ticket **does not require implementing it**. The macro should produce a clear compile-time error for unsupported generic types.\n\n### 2. Recursive Types\n\nRecursive types will **fail at compile-time** because Scala does not support infinite types:\n\n```scala\ncase class Tree(value: Int, children: List[Tree])\n\n// This will FAIL at compile-time:\nval structural = Schema.derived[Tree].structural\n// Compile error: Cannot generate infinite structural type\n\n// The structural type would need to be:\n// { def value: Int; def children: List[{ def value: Int; def children: List[...] }] }\n// which is infinite and unsupported\n```\n\nThe macro must detect recursive types and produce a helpful error message:\n\n```\nCompile error: Cannot generate structural type for recursive type Tree.\nStructural types cannot represent recursive structures.\n```\n\n### 3. Mutually Recursive Types\n\nSimilarly, mutually recursive types are unsupported:\n\n```scala\ncase class Node(id: Int, edges: List[Edge])\ncase class Edge(from: Int, to: Node)\n\n// This will FAIL at compile-time:\nval nodeStructural = Schema.derived[Node].structural\n// Compile error: Cannot generate structural type for mutually recursive types\n```\n\n### 4. Sum Types in Scala 2\n\nSealed traits and sum types **cannot be converted to structural types in Scala 2** because they require union types:\n\n```scala\n// Scala 2\nsealed trait Result\ncase class Success(value: Int) extends Result\ncase class Failure(error: String) extends Result\n\n// This will FAIL at compile-time in Scala 2:\nval structural = Schema.derived[Result].structural\n// Compile error: Cannot generate structural type for sum types in Scala 2.\n// Union types are required, which are only available in Scala 3.\n```\n\nThe macro must detect sum types in Scala 2 and produce a clear error.\n\n### 5. Case Objects\n\nCase objects become empty structural types:\n\n```scala\ncase object Singleton\n\nval structural = Schema.derived[Singleton.type].structural\n// Type: Schema[{}]\n```\n\nFor sum types with case objects (Scala 3):\n\n```scala\nsealed trait Status\ncase object Active extends Status\ncase object Inactive extends Status\n\nval structural = Schema.derived[Status].structural\n// Type: Schema[{} | {}]\n// Not particularly useful, but valid\n```\n\n### 6. Structural Types as Source\n\nDeriving schemas directly for structural types is supported:\n\n```scala\ntype PersonStructure = { def name: String; def age: Int }\n\nval schema = Schema.derived[PersonStructure]\n// Should work if structural type derivation is implemented\n```\n\nThe schema's bindings will use `Selectable` (Scala 3) or `Dynamic` (Scala 2) to construct and deconstruct values.\n\n---\n\n## Integration with Into/As\n\nStructural schemas compose naturally with `Into`/`As` conversions.\n\n### Nominal â†’ Structural\n\n```scala\ncase class Person(name: String, age: Int)\n\n// Auto-derived conversion\nval nominalToStructural: Into[Person, { def name: String; def age: Int }] = \n  Into.derived\n\nval person = Person(\"Alice\", 30)\nval structural = nominalToStructural.into(person)\n// => Right(<Selectable/Dynamic instance>)\n```\n\n### Structural â†’ Nominal\n\n```scala\ntype PersonStructure = { def name: String; def age: Int }\ncase class Person(name: String, age: Int)\n\n// Auto-derived conversion\nval structuralToNominal: Into[PersonStructure, Person] = \n  Into.derived\n\nval structural: PersonStructure = new Selectable {\n  def selectDynamic(field: String): Any = field match {\n    case \"name\" => \"Bob\"\n    case \"age\" => 25\n  }\n}\n\nval person = structuralToNominal.into(structural)\n// => Right(Person(\"Bob\", 25))\n```\n\n### Bidirectional (As)\n\n```scala\ncase class Person(name: String, age: Int)\n\n// Bidirectional conversion\nval personAs: As[Person, { def name: String; def age: Int }] = \n  As.derived\n\n// Nominal â†’ Structural\nval structural = personAs.into(Person(\"Alice\", 30))\n\n// Structural â†’ Nominal\nval nominal = structural.flatMap(personAs.from)\n// Round-trip successful\n```\n\n### Schema-Guided Conversion\n\n```scala\ncase class PersonV1(firstName: String, lastName: String, age: Int)\ncase class PersonV2(name: String, age: Int)\n\n// Use structural type as intermediary\ntype PersonStructure = { def name: String; def age: Int }\n\n// Step 1: Transform V1 to structural (custom logic)\nval v1ToStructural: Into[PersonV1, PersonStructure] = \n  new Into[PersonV1, PersonStructure] {\n    def into(v1: PersonV1): Either[SchemaError, PersonStructure] = {\n      Right(new Selectable {\n        def selectDynamic(field: String): Any = field match {\n          case \"name\" => s\"${v1.firstName} ${v1.lastName}\"\n          case \"age\" => v1.age\n        }\n      })\n    }\n  }\n\n// Step 2: Auto-convert structural to V2\nval structuralToV2: Into[PersonStructure, PersonV2] = Into.derived\n\n// Composed migration\ndef migrate(v1: PersonV1): Either[SchemaError, PersonV2] = {\n  v1ToStructural.into(v1).flatMap(structuralToV2.into)\n}\n```\n\n---\n\n## Testing Requirements\n\n### Test Matrix\n\n1. **Direct Structural Derivation**\n   - Simple products (case classes)\n   - Nested products\n   - Collections (List, Vector, Set, Map, Option, Either)\n   - Tuples (2-22 elements)\n   - Empty case classes\n   - Single-field case classes\n   - Large products (20+ fields)\n   - Case objects\n\n2. **Nominal to Structural Conversion**\n   - Case class â†’ structural\n   - Tuple â†’ structural\n   - Nested case classes â†’ nested structural\n   - Case class with collections â†’ structural with collections\n   - Empty case class â†’ empty structural\n\n3. **Sum Types (Scala 3 Only)**\n   - Sealed trait â†’ union type structural\n   - Sealed trait with case objects\n   - Enum â†’ union type structural\n   - Nested sum types\n\n4. **Type Name Generation**\n   - Simple product normalized name\n   - Nested product normalized name\n   - Name determinism (same structure = same name)\n   - Alphabetical field ordering in names\n   - Union type names (Scala 3)\n\n5. **Selectable/Dynamic Implementation**\n   - Scala 3 Selectable field access\n   - Scala 2 Dynamic field access\n   - Field access correctness\n   - Missing field behavior\n   - Extra field behavior\n\n6. **Integration with Into/As**\n   - Nominal â†’ Structural via Into\n   - Structural â†’ Nominal via Into\n   - Round-trip via As\n   - Composed conversions with structural intermediary\n\n7. **Error Cases (Compile-Time)**\n   - Recursive types produce error\n   - Mutually recursive types produce error\n   - Sum types in Scala 2 produce error\n   - Unsupported types produce helpful errors\n\n8. **Generic Types** (if supported by existing Schema derivation)\n   - Fully applied generic â†’ structural\n   - Generic with nested structural fields\n\n### Scala 2 vs Scala 3 Test Separation\n\n```\nsrc/test/scala/\n  structural/\n    common/\n      SimpleProductSpec.scala\n      NestedProductSpec.scala\n      CollectionsSpec.scala\n      TuplesSpec.scala\n      EmptyProductSpec.scala\n      SingleFieldSpec.scala\n      LargeProductSpec.scala\n      TypeNameNormalizationSpec.scala\n      IntoIntegrationSpec.scala\n      AsIntegrationSpec.scala\n      \n    scala3/\n      UnionTypesSpec.scala\n      SealedTraitToUnionSpec.scala\n      EnumToUnionSpec.scala\n      SelectableImplementationSpec.scala\n      \n    scala2/\n      DynamicImplementationSpec.scala\n      SumTypeErrorSpec.scala (verifies compile error)\n      \n    errors/\n      RecursiveTypeErrorSpec.scala\n      MutualRecursionErrorSpec.scala\n      UnsupportedTypeErrorSpec.scala\n```\n\n### Test Examples\n\n```scala\n// Test: Simple product to structural\ntest(\"case class converts to structural schema\") {\n  case class Person(name: String, age: Int)\n  \n  val structural = Schema.derived[Person].structural\n  \n  // Type check (this is a compile-time test)\n  val _: Schema[{ def name: String; def age: Int }] = structural\n  \n  assert(structural.typeName.toString.contains(\"name\"))\n  assert(structural.typeName.toString.contains(\"age\"))\n}\n\n// Test: Nested products\ntest(\"nested case classes convert to nested structural\") {\n  case class Address(street: String, zip: Int)\n  case class Person(name: String, address: Address)\n  \n  val structural = Schema.derived[Person].structural\n  \n  val _: Schema[{ \n    def name: String\n    def address: { def street: String; def zip: Int }\n  }] = structural\n}\n\n// Test: Tuple to structural\ntest(\"tuple converts to structural with _N fields\") {\n  val structural = Schema.derived[(String, Int, Boolean)].structural\n  \n  val _: Schema[{ def _1: String; def _2: Int; def _3: Boolean }] = structural\n}\n\n// Test: Union type (Scala 3 only)\ntest(\"sealed trait converts to union type structural\") {\n  sealed trait Result\n  case class Success(value: Int) extends Result\n  case class Failure(error: String) extends Result\n  \n  val structural = Schema.derived[Result].structural\n  \n  val _: Schema[{ def value: Int } | { def error: String }] = structural\n}\n\n// Test: Type name normalization\ntest(\"structural type names are normalized and deterministic\") {\n  case class Person(name: String, age: Int)\n  case class User(age: Int, name: String) // Different field order\n  \n  val personStructural = Schema.derived[Person].structural\n  val userStructural = Schema.derived[User].structural\n  \n  // Same structure, same normalized name\n  assert(personStructural.typeName == userStructural.typeName)\n  \n  // Alphabetical ordering\n  assert(personStructural.typeName.toString.contains(\"age\"))\n  assert(personStructural.typeName.toString.indexOf(\"age\") < \n         personStructural.typeName.toString.indexOf(\"name\"))\n}\n\n// Test: Integration with Into\ntest(\"structural to nominal conversion via Into\") {\n  case class Person(name: String, age: Int)\n  type PersonStructure = { def name: String; def age: Int }\n  \n  val structural: PersonStructure = new Selectable {\n    def selectDynamic(field: String): Any = field match {\n      case \"name\" => \"Alice\"\n      case \"age\" => 30\n    }\n  }\n  \n  val person = Into[PersonStructure, Person].into(structural)\n  assert(person == Right(Person(\"Alice\", 30)))\n}\n\n// Test: Round-trip via As\ntest(\"nominal to structural and back preserves data\") {\n  case class Person(name: String, age: Int)\n  type PersonStructure = { def name: String; def age: Int }\n  \n  val original = Person(\"Alice\", 30)\n  \n  val toStructural = As[Person, PersonStructure].into(original)\n  val backToNominal = toStructural.flatMap(As[Person, PersonStructure].from)\n  \n  assert(backToNominal == Right(original))\n}\n\n// Test: Recursive type compile error\ntest(\"recursive types produce compile error\") {\n  case class Tree(value: Int, children: List[Tree])\n  \n  assertDoesNotCompile(\"Schema.derived[Tree].structural\")\n}\n\n// Test: Sum type in Scala 2 compile error\ntest(\"sum types in Scala 2 produce compile error\") {\n  sealed trait Result\n  case class Success(value: Int) extends Result\n  \n  // Scala 2 only\n  assertDoesNotCompile(\"Schema.derived[Result].structural\")\n}\n```\n\n---\n\n## Implementation Notes\n\n### Macro Behavior\n\nThe macro must:\n\n1. **Detect product types** (case classes, tuples) and generate structural types with `def` members\n2. **Detect sum types** (sealed traits, enums) and:\n   - In Scala 3: Generate union types of structural representations\n   - In Scala 2: Fail with clear error message\n3. **Detect recursive types** and fail with clear error message\n4. **Normalize structural type representations** for type name generation\n5. **Generate `ToStructural` instance** with:\n   - `StructuralType` type member set to the generated structural type\n   - `apply` method that transforms the schema appropriately\n6. **Preserve field metadata** from original schema where applicable\n7. **Generate appropriate bindings** using `Selectable` (Scala 3) or `Dynamic` (Scala 2)\n\n### Schema Transformation\n\nWhen converting `Schema[A]` to `Schema[StructuralType]`:\n\n1. **Preserve field information**: Field names, types, optional/required status\n2. **Update type name**: Use normalized structural representation\n3. **Transform bindings**: Replace nominal constructors/deconstructors with structural equivalents\n4. **Preserve validation**: Maintain any validation logic that applies to field values\n5. **Handle nested schemas**: Recursively transform nested product types\n\n### Error Messages\n\nProvide clear compile-time errors:\n\n```scala\n// Recursive type\ncase class Tree(value: Int, children: List[Tree])\nSchema.derived[Tree].structural\n\n// Error:\n\"\"\"\nCannot generate structural type for recursive type Tree.\nStructural types cannot represent recursive structures.\nScala's type system does not support infinite types.\n\"\"\"\n\n// Sum type in Scala 2\nsealed trait Result\ncase class Success(value: Int) extends Result\nSchema.derived[Result].structural\n\n// Error (Scala 2 only):\n\"\"\"\nCannot generate structural type for sum type Result.\nStructural representation of sum types requires union types,\nwhich are only available in Scala 3.\nConsider upgrading to Scala 3 or using a different approach.\n\"\"\"\n```\n\n---\n\n## Deliverables\n\n1. âœ… `ToStructural[A]` trait and macro for Scala 2.13\n2. âœ… `ToStructural[A]` trait and macro for Scala 3.5\n3. âœ… `structural` method on `Schema[A]`\n4. âœ… Support for product types (case classes, tuples)\n5. âœ… Support for sum types (sealed traits, enums) in Scala 3 only\n6. âœ… Normalized type name generation\n7. âœ… `Selectable` bindings (Scala 3) and `Dynamic` bindings (Scala 2)\n8. âœ… Integration with `Into`/`As` for structural â†” nominal conversions\n9. âœ… Comprehensive test suite (300+ test cases)\n10. âœ… Clear error messages for unsupported cases\n11. âœ… Documentation with examples",
              "url": "https://github.com/zio/zio-blocks/issues/517",
              "tech": [],
              "repo_name": "zio-blocks",
              "repo_owner": "zio",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "ZIO#516",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "ZIO",
              "id": "generated-ZIO",
              "name": "ZIO",
              "description": "",
              "members": [],
              "display_name": "ZIO",
              "created_at": "2025-12-30T19:50:15.537Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/ZIO?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "zio",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2025-12-30T19:50:15.537Z",
            "created_at": "2025-12-30T19:50:15.537Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-ZIO#516",
              "status": "open",
              "type": "issue",
              "number": 516,
              "title": "Finalize Patch & Diffing",
              "source": {
                "data": {
                  "id": "source-ZIO#516",
                  "user": {
                    "login": "jdegoes",
                    "id": 156745,
                    "node_id": "MDQ6VXNlcjE1Njc0NQ==",
                    "avatar_url": "https://avatars.githubusercontent.com/u/156745?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/jdegoes",
                    "html_url": "https://github.com/jdegoes",
                    "followers_url": "https://api.github.com/users/jdegoes/followers",
                    "following_url": "https://api.github.com/users/jdegoes/following{/other_user}",
                    "gists_url": "https://api.github.com/users/jdegoes/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/jdegoes/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/jdegoes/subscriptions",
                    "organizations_url": "https://api.github.com/users/jdegoes/orgs",
                    "repos_url": "https://api.github.com/users/jdegoes/repos",
                    "events_url": "https://api.github.com/users/jdegoes/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/jdegoes/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Finalize Patch & Diffing",
                  "body": "# Algebraic Patch/Diff System for ZIO Schema 2\n\n## Overview\n\nImplement a pure, algebraic patch/diff system for ZIO Schema 2 that represents structural changes as first-class, serializable data. The system provides a typed API (`Patch[A]`) built on an untyped core (`DynamicPatch`) that operates on `DynamicValue`.\n\nBelow is a rough outline or sketch of the design of patching & diffing, subject to revision by the implementor based on technical feasibility considerations.\n\n## Core Architecture\n\n### Type Hierarchy\n\n```scala\n// Typed patch (user-facing API)\ncase class Patch[A](dynamicPatch: DynamicPatch, schema: Schema[A]) {\n  /** Apply patch with specified mode */\n  def apply(value: A, mode: PatchMode = PatchMode.Strict): Either[SchemaError, A]\n  \n  /** Compose patches sequentially (monoid operation) */\n  def ++(that: Patch[A]): Patch[A]\n}\n\n// Untyped patch (operates on DynamicValue)\ncase class DynamicPatch(ops: Vector[DynamicPatchOp]) {\n  /** Apply to dynamic value */\n  def apply(value: DynamicValue, mode: PatchMode): Either[SchemaError, DynamicValue]\n  \n  /** Compose patches */\n  def ++(that: DynamicPatch): DynamicPatch\n}\n```\n\n### Operations\n\n```scala\ncase class DynamicPatchOp(optic: DynamicOptic, operation: Operation)\n\nsealed trait Operation\nobject Operation {\n  case class Set(value: DynamicValue) extends Operation\n  case class PrimitiveDelta(op: PrimitiveOp) extends Operation\n  case class SequenceEdit(ops: Vector[SeqOp]) extends Operation\n  case class MapEdit(ops: Vector[MapOp]) extends Operation\n}\n```\n\n## Typed API\n\nAll typed operations live in `Patch` companion object:\n\n```scala\nobject Patch {\n  /** Empty patch (monoid identity) */\n  def empty[A](implicit schema: Schema[A]): Patch[A]\n  \n  /** Set a field/element to a value (clobber semantics) */\n  def set[S, A](optic: Optic[S, A], value: A)(implicit schema: Schema[S]): Patch[S]\n  \n  /** Increment numeric field */\n  def increment[S](optic: Optic[S, Int], delta: Int)(implicit schema: Schema[S]): Patch[S]\n  def incrementLong[S](optic: Optic[S, Long], delta: Long)(implicit schema: Schema[S]): Patch[S]\n  def incrementDouble[S](optic: Optic[S, Double], delta: Double)(implicit schema: Schema[S]): Patch[S]\n  \n  /** Edit string field */\n  def editString[S](optic: Optic[S, String], edits: Vector[StringOp])(implicit schema: Schema[S]): Patch[S]\n  \n  /** Sequence operations */\n  def append[S, A](optic: Optic[S, Vector[A]], elements: Vector[A])(implicit schema: Schema[S]): Patch[S]\n  def insertAt[S, A](optic: Optic[S, Vector[A]], index: Int, elements: Vector[A])(implicit schema: Schema[S]): Patch[S]\n  def deleteAt[S, A](optic: Optic[S, Vector[A]], index: Int, count: Int)(implicit schema: Schema[S]): Patch[S]\n  \n  /** Map operations */\n  def addKey[S, K, V](optic: Optic[S, Map[K, V]], key: K, value: V)(implicit schema: Schema[S]): Patch[S]\n  def removeKey[S, K, V](optic: Optic[S, Map[K, V]], key: K)(implicit schema: Schema[S]): Patch[S]\n  def modifyKey[S, K, V](optic: Optic[S, Map[K, V]], key: K, valuePatch: Patch[V])(implicit schema: Schema[S]): Patch[S]\n}\n```\n\n## Primitive Operations\n\n```scala\nsealed trait PrimitiveOp\nobject PrimitiveOp {\n  // Numeric deltas\n  case class IntDelta(delta: Int) extends PrimitiveOp\n  case class LongDelta(delta: Long) extends PrimitiveOp\n  case class DoubleDelta(delta: Double) extends PrimitiveOp\n  case class FloatDelta(delta: Float) extends PrimitiveOp\n  case class ShortDelta(delta: Short) extends PrimitiveOp\n  case class ByteDelta(delta: Byte) extends PrimitiveOp\n  case class BigIntDelta(delta: BigInt) extends PrimitiveOp\n  case class BigDecimalDelta(delta: BigDecimal) extends PrimitiveOp\n  \n  // String edits (LCS-based)\n  case class StringEdit(ops: Vector[StringOp]) extends PrimitiveOp\n  \n  // Temporal deltas\n  case class InstantDelta(duration: java.time.Duration) extends PrimitiveOp\n  case class DurationDelta(duration: java.time.Duration) extends PrimitiveOp\n  case class LocalDateDelta(period: java.time.Period) extends PrimitiveOp\n  case class LocalDateTimeDelta(period: java.time.Period, duration: java.time.Duration) extends PrimitiveOp\n  case class PeriodDelta(period: java.time.Period) extends PrimitiveOp\n  // ... other temporal types\n}\n\nsealed trait StringOp\nobject StringOp {\n  case class Insert(index: Int, text: String) extends StringOp\n  case class Delete(index: Int, length: Int) extends StringOp\n}\n```\n\n## Collection Operations\n\n```scala\nsealed trait SeqOp\nobject SeqOp {\n  /** Insert at index (fails if index occupied in Strict mode) */\n  case class Insert(index: Int, values: Vector[DynamicValue]) extends SeqOp\n  \n  /** Append to end (always succeeds) */\n  case class Append(values: Vector[DynamicValue]) extends SeqOp\n  \n  /** Delete count elements starting at index */\n  case class Delete(index: Int, count: Int) extends SeqOp\n  \n  /** Modify element at index with nested operation */\n  case class Modify(index: Int, op: Operation) extends SeqOp\n}\n\nsealed trait MapOp\nobject MapOp {\n  /** Add key-value (fails if key exists in Strict mode) */\n  case class Add(key: DynamicValue, value: DynamicValue) extends MapOp\n  \n  /** Remove key (fails if key missing in Strict mode) */\n  case class Remove(key: DynamicValue) extends MapOp\n  \n  /** Modify value at key with nested operation */\n  case class Modify(key: DynamicValue, op: Operation) extends MapOp\n}\n```\n\n## Patch Application Modes\n\n```scala\nsealed trait PatchMode\nobject PatchMode {\n  /** Fail on precondition violations (e.g. modifying non-existent key) */\n  case object Strict extends PatchMode\n  \n  /** Skip operations that fail preconditions */\n  case object Lenient extends PatchMode\n  \n  /** Replace/overwrite on conflicts */\n  case object Clobber extends PatchMode\n}\n```\n\n## Schema Integration\n\n```scala\ntrait Schema[A] {\n  /** \n   * Compute smart patch from oldValue to newValue.\n   * Uses heuristics to choose between delta/edit vs set operations.\n   */\n  def diff(oldValue: A, newValue: A): Patch[A]\n  \n  /** Convenience method - apply patch with Strict mode */\n  def patch(value: A, patch: Patch[A]): Either[SchemaError, A] =\n    patch.apply(value, PatchMode.Strict)\n}\n```\n\n## Diffing Strategy\n\nThe `Schema#diff` implementation uses smart heuristics:\n\n1. **New elements/keys**: Use `Operation.Set` \n   - Sequence insertions at new indices\n   - Map additions for new keys\n   - Sum type switches to different cases\n\n2. **String modifications**: Use `StringEdit` if edit sequence is shorter than new string, otherwise use `Set`\n\n3. **Numeric modifications**: Use delta operations (`IntDelta`, etc.)\n\n4. **Structural modifications**: Recursively diff nested structures, using field-level patches for records\n\n5. **Temporal modifications**: Use temporal delta operations for date/time types\n\n## Laws\n\n### Roundtrip Law\nFor all values, the following must hold:\n```scala\nâˆ€ (schema: Schema[A], old: A, new: A).\n  schema.diff(old, new).apply(old) == Right(new)\n```\n\n### Monoid Laws\n```scala\n// Identity (empty patch)\nâˆ€ (p: Patch[A]). \n  p ++ Patch.empty == p\n  Patch.empty ++ p == p\n\n// Associativity\nâˆ€ (p1: Patch[A], p2: Patch[A], p3: Patch[A]).\n  (p1 ++ p2) ++ p3 == p1 ++ (p2 ++ p3)\n```\n\n### Serializability\nAll patch types are pure data (DynamicValue, DynamicOptic, primitives) and must be serializable:\n```scala\nâˆ€ (p: Patch[A]). \n  jsonCodec.decode(jsonCodec.encode(p)) == Right(p)\n```\n\n## Implementation Notes\n\n- `Operation.Set` uses `DynamicValue` to represent whole values for materialization cases\n- `Patch[A]` converts typed values to `DynamicValue` via `Schema[A]` before applying `DynamicPatch` constructor\n- String edits use LCS (Longest Common Subsequence) algorithm\n- Sequence edits also use LCS for computing minimal insert/delete sequences\n\n## Success Criteria\n\n- [ ] `DynamicPatch` defined with all operation types, capable of transforming one DynamicValue to another in the most minimal possible way\n- [ ] `Patch[A]` wraps `DynamicPatch` with an additional `Schema[A]`\n- [ ] Typed API in `Patch` companion object for all common operations\n- [ ] `Schema#diff` implements smart diffing strategy\n- [ ] `PatchMode` controls patch application behavior\n- [ ] All fallible operations return `Either[SchemaError, A]` so error information is preserved\n- [ ] Roundtrip law holds for all schema types\n- [ ] Monoid laws hold for patch composition\n- [ ] All patch types serialize/deserialize correctly (except `Patch` itself, which cannot be serialized unless `Schema` is serialized, which in the general case requires a `TypeRegistry`)\n- [ ] String diffs use LCS algorithm\n- [ ] Sequence diffs use LCS algorithm\n- [ ] Comprehensive tests for all operation types, and for serialization of non-`Patch` types such as DynamicPatch and everything it contains\n\n## Example Usage\n\n```scala\n@schema \n@optics\ncase class Person(name: String, age: Int, address: Address)\n\n@schema \n@optics\ncase class Address(street: String, city: String, country: String)\n\nval old = Person(\"Alice\", 30, Address(\"123 Main St\", \"NYC\", \"USA\"))\nval new1 = Person(\"Alice\", 31, Address(\"456 Elm St\", \"NYC\", \"USA\"))\n\n// Automatic diffing\nval patch1: Patch[Person] = Person.schema.diff(old, new1)\npatch1(old) // Right(new1)\n\n// Manual patch construction\nval patch2: Patch[Person] = Patch.increment(Person.age, 1) ++ \n             Patch.set(Person.address(Address.street), \"456 Elm St\")\npatch2(old) // Right(new1)\n\n// Patch composition\nval patch3 = patch1 ++ patch2\npatch3(old) // Applies both patches sequentially\n\n// Different application modes\npatch2(old, PatchMode.Strict)   // Fails if preconditions violated\npatch2(old, PatchMode.Lenient)  // Skips failed operations\npatch2(old, PatchMode.Clobber)  // Replaces on conflicts\n\n// Serialization (via @schema on DynamicPatch)\nval json = jsonCodec.encode(patch1.dynamicPatch)\nval recovered = jsonCodec.decode[DynamicPatch](json)\n```",
                  "html_url": "https://github.com/zio/zio-blocks/issues/516"
                },
                "type": "github"
              },
              "hash": "zio/zio-blocks#516",
              "body": "# Algebraic Patch/Diff System for ZIO Schema 2\n\n## Overview\n\nImplement a pure, algebraic patch/diff system for ZIO Schema 2 that represents structural changes as first-class, serializable data. The system provides a typed API (`Patch[A]`) built on an untyped core (`DynamicPatch`) that operates on `DynamicValue`.\n\nBelow is a rough outline or sketch of the design of patching & diffing, subject to revision by the implementor based on technical feasibility considerations.\n\n## Core Architecture\n\n### Type Hierarchy\n\n```scala\n// Typed patch (user-facing API)\ncase class Patch[A](dynamicPatch: DynamicPatch, schema: Schema[A]) {\n  /** Apply patch with specified mode */\n  def apply(value: A, mode: PatchMode = PatchMode.Strict): Either[SchemaError, A]\n  \n  /** Compose patches sequentially (monoid operation) */\n  def ++(that: Patch[A]): Patch[A]\n}\n\n// Untyped patch (operates on DynamicValue)\ncase class DynamicPatch(ops: Vector[DynamicPatchOp]) {\n  /** Apply to dynamic value */\n  def apply(value: DynamicValue, mode: PatchMode): Either[SchemaError, DynamicValue]\n  \n  /** Compose patches */\n  def ++(that: DynamicPatch): DynamicPatch\n}\n```\n\n### Operations\n\n```scala\ncase class DynamicPatchOp(optic: DynamicOptic, operation: Operation)\n\nsealed trait Operation\nobject Operation {\n  case class Set(value: DynamicValue) extends Operation\n  case class PrimitiveDelta(op: PrimitiveOp) extends Operation\n  case class SequenceEdit(ops: Vector[SeqOp]) extends Operation\n  case class MapEdit(ops: Vector[MapOp]) extends Operation\n}\n```\n\n## Typed API\n\nAll typed operations live in `Patch` companion object:\n\n```scala\nobject Patch {\n  /** Empty patch (monoid identity) */\n  def empty[A](implicit schema: Schema[A]): Patch[A]\n  \n  /** Set a field/element to a value (clobber semantics) */\n  def set[S, A](optic: Optic[S, A], value: A)(implicit schema: Schema[S]): Patch[S]\n  \n  /** Increment numeric field */\n  def increment[S](optic: Optic[S, Int], delta: Int)(implicit schema: Schema[S]): Patch[S]\n  def incrementLong[S](optic: Optic[S, Long], delta: Long)(implicit schema: Schema[S]): Patch[S]\n  def incrementDouble[S](optic: Optic[S, Double], delta: Double)(implicit schema: Schema[S]): Patch[S]\n  \n  /** Edit string field */\n  def editString[S](optic: Optic[S, String], edits: Vector[StringOp])(implicit schema: Schema[S]): Patch[S]\n  \n  /** Sequence operations */\n  def append[S, A](optic: Optic[S, Vector[A]], elements: Vector[A])(implicit schema: Schema[S]): Patch[S]\n  def insertAt[S, A](optic: Optic[S, Vector[A]], index: Int, elements: Vector[A])(implicit schema: Schema[S]): Patch[S]\n  def deleteAt[S, A](optic: Optic[S, Vector[A]], index: Int, count: Int)(implicit schema: Schema[S]): Patch[S]\n  \n  /** Map operations */\n  def addKey[S, K, V](optic: Optic[S, Map[K, V]], key: K, value: V)(implicit schema: Schema[S]): Patch[S]\n  def removeKey[S, K, V](optic: Optic[S, Map[K, V]], key: K)(implicit schema: Schema[S]): Patch[S]\n  def modifyKey[S, K, V](optic: Optic[S, Map[K, V]], key: K, valuePatch: Patch[V])(implicit schema: Schema[S]): Patch[S]\n}\n```\n\n## Primitive Operations\n\n```scala\nsealed trait PrimitiveOp\nobject PrimitiveOp {\n  // Numeric deltas\n  case class IntDelta(delta: Int) extends PrimitiveOp\n  case class LongDelta(delta: Long) extends PrimitiveOp\n  case class DoubleDelta(delta: Double) extends PrimitiveOp\n  case class FloatDelta(delta: Float) extends PrimitiveOp\n  case class ShortDelta(delta: Short) extends PrimitiveOp\n  case class ByteDelta(delta: Byte) extends PrimitiveOp\n  case class BigIntDelta(delta: BigInt) extends PrimitiveOp\n  case class BigDecimalDelta(delta: BigDecimal) extends PrimitiveOp\n  \n  // String edits (LCS-based)\n  case class StringEdit(ops: Vector[StringOp]) extends PrimitiveOp\n  \n  // Temporal deltas\n  case class InstantDelta(duration: java.time.Duration) extends PrimitiveOp\n  case class DurationDelta(duration: java.time.Duration) extends PrimitiveOp\n  case class LocalDateDelta(period: java.time.Period) extends PrimitiveOp\n  case class LocalDateTimeDelta(period: java.time.Period, duration: java.time.Duration) extends PrimitiveOp\n  case class PeriodDelta(period: java.time.Period) extends PrimitiveOp\n  // ... other temporal types\n}\n\nsealed trait StringOp\nobject StringOp {\n  case class Insert(index: Int, text: String) extends StringOp\n  case class Delete(index: Int, length: Int) extends StringOp\n}\n```\n\n## Collection Operations\n\n```scala\nsealed trait SeqOp\nobject SeqOp {\n  /** Insert at index (fails if index occupied in Strict mode) */\n  case class Insert(index: Int, values: Vector[DynamicValue]) extends SeqOp\n  \n  /** Append to end (always succeeds) */\n  case class Append(values: Vector[DynamicValue]) extends SeqOp\n  \n  /** Delete count elements starting at index */\n  case class Delete(index: Int, count: Int) extends SeqOp\n  \n  /** Modify element at index with nested operation */\n  case class Modify(index: Int, op: Operation) extends SeqOp\n}\n\nsealed trait MapOp\nobject MapOp {\n  /** Add key-value (fails if key exists in Strict mode) */\n  case class Add(key: DynamicValue, value: DynamicValue) extends MapOp\n  \n  /** Remove key (fails if key missing in Strict mode) */\n  case class Remove(key: DynamicValue) extends MapOp\n  \n  /** Modify value at key with nested operation */\n  case class Modify(key: DynamicValue, op: Operation) extends MapOp\n}\n```\n\n## Patch Application Modes\n\n```scala\nsealed trait PatchMode\nobject PatchMode {\n  /** Fail on precondition violations (e.g. modifying non-existent key) */\n  case object Strict extends PatchMode\n  \n  /** Skip operations that fail preconditions */\n  case object Lenient extends PatchMode\n  \n  /** Replace/overwrite on conflicts */\n  case object Clobber extends PatchMode\n}\n```\n\n## Schema Integration\n\n```scala\ntrait Schema[A] {\n  /** \n   * Compute smart patch from oldValue to newValue.\n   * Uses heuristics to choose between delta/edit vs set operations.\n   */\n  def diff(oldValue: A, newValue: A): Patch[A]\n  \n  /** Convenience method - apply patch with Strict mode */\n  def patch(value: A, patch: Patch[A]): Either[SchemaError, A] =\n    patch.apply(value, PatchMode.Strict)\n}\n```\n\n## Diffing Strategy\n\nThe `Schema#diff` implementation uses smart heuristics:\n\n1. **New elements/keys**: Use `Operation.Set` \n   - Sequence insertions at new indices\n   - Map additions for new keys\n   - Sum type switches to different cases\n\n2. **String modifications**: Use `StringEdit` if edit sequence is shorter than new string, otherwise use `Set`\n\n3. **Numeric modifications**: Use delta operations (`IntDelta`, etc.)\n\n4. **Structural modifications**: Recursively diff nested structures, using field-level patches for records\n\n5. **Temporal modifications**: Use temporal delta operations for date/time types\n\n## Laws\n\n### Roundtrip Law\nFor all values, the following must hold:\n```scala\nâˆ€ (schema: Schema[A], old: A, new: A).\n  schema.diff(old, new).apply(old) == Right(new)\n```\n\n### Monoid Laws\n```scala\n// Identity (empty patch)\nâˆ€ (p: Patch[A]). \n  p ++ Patch.empty == p\n  Patch.empty ++ p == p\n\n// Associativity\nâˆ€ (p1: Patch[A], p2: Patch[A], p3: Patch[A]).\n  (p1 ++ p2) ++ p3 == p1 ++ (p2 ++ p3)\n```\n\n### Serializability\nAll patch types are pure data (DynamicValue, DynamicOptic, primitives) and must be serializable:\n```scala\nâˆ€ (p: Patch[A]). \n  jsonCodec.decode(jsonCodec.encode(p)) == Right(p)\n```\n\n## Implementation Notes\n\n- `Operation.Set` uses `DynamicValue` to represent whole values for materialization cases\n- `Patch[A]` converts typed values to `DynamicValue` via `Schema[A]` before applying `DynamicPatch` constructor\n- String edits use LCS (Longest Common Subsequence) algorithm\n- Sequence edits also use LCS for computing minimal insert/delete sequences\n\n## Success Criteria\n\n- [ ] `DynamicPatch` defined with all operation types, capable of transforming one DynamicValue to another in the most minimal possible way\n- [ ] `Patch[A]` wraps `DynamicPatch` with an additional `Schema[A]`\n- [ ] Typed API in `Patch` companion object for all common operations\n- [ ] `Schema#diff` implements smart diffing strategy\n- [ ] `PatchMode` controls patch application behavior\n- [ ] All fallible operations return `Either[SchemaError, A]` so error information is preserved\n- [ ] Roundtrip law holds for all schema types\n- [ ] Monoid laws hold for patch composition\n- [ ] All patch types serialize/deserialize correctly (except `Patch` itself, which cannot be serialized unless `Schema` is serialized, which in the general case requires a `TypeRegistry`)\n- [ ] String diffs use LCS algorithm\n- [ ] Sequence diffs use LCS algorithm\n- [ ] Comprehensive tests for all operation types, and for serialization of non-`Patch` types such as DynamicPatch and everything it contains\n\n## Example Usage\n\n```scala\n@schema \n@optics\ncase class Person(name: String, age: Int, address: Address)\n\n@schema \n@optics\ncase class Address(street: String, city: String, country: String)\n\nval old = Person(\"Alice\", 30, Address(\"123 Main St\", \"NYC\", \"USA\"))\nval new1 = Person(\"Alice\", 31, Address(\"456 Elm St\", \"NYC\", \"USA\"))\n\n// Automatic diffing\nval patch1: Patch[Person] = Person.schema.diff(old, new1)\npatch1(old) // Right(new1)\n\n// Manual patch construction\nval patch2: Patch[Person] = Patch.increment(Person.age, 1) ++ \n             Patch.set(Person.address(Address.street), \"456 Elm St\")\npatch2(old) // Right(new1)\n\n// Patch composition\nval patch3 = patch1 ++ patch2\npatch3(old) // Applies both patches sequentially\n\n// Different application modes\npatch2(old, PatchMode.Strict)   // Fails if preconditions violated\npatch2(old, PatchMode.Lenient)  // Skips failed operations\npatch2(old, PatchMode.Clobber)  // Replaces on conflicts\n\n// Serialization (via @schema on DynamicPatch)\nval json = jsonCodec.encode(patch1.dynamicPatch)\nval recovered = jsonCodec.decode[DynamicPatch](json)\n```",
              "url": "https://github.com/zio/zio-blocks/issues/516",
              "tech": [],
              "repo_name": "zio-blocks",
              "repo_owner": "zio",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "ZIO#471",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "ZIO",
              "id": "generated-ZIO",
              "name": "ZIO",
              "description": "",
              "members": [],
              "display_name": "ZIO",
              "created_at": "2025-12-30T19:50:15.677Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/ZIO?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "zio",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2025-12-30T19:50:15.677Z",
            "created_at": "2025-12-30T19:50:15.677Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-ZIO#471",
              "status": "open",
              "type": "issue",
              "number": 471,
              "title": "Replace TypeName by TypeId & Macro Derivation",
              "source": {
                "data": {
                  "id": "source-ZIO#471",
                  "user": {
                    "login": "jdegoes",
                    "id": 156745,
                    "node_id": "MDQ6VXNlcjE1Njc0NQ==",
                    "avatar_url": "https://avatars.githubusercontent.com/u/156745?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/jdegoes",
                    "html_url": "https://github.com/jdegoes",
                    "followers_url": "https://api.github.com/users/jdegoes/followers",
                    "following_url": "https://api.github.com/users/jdegoes/following{/other_user}",
                    "gists_url": "https://api.github.com/users/jdegoes/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/jdegoes/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/jdegoes/subscriptions",
                    "organizations_url": "https://api.github.com/users/jdegoes/orgs",
                    "repos_url": "https://api.github.com/users/jdegoes/repos",
                    "events_url": "https://api.github.com/users/jdegoes/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/jdegoes/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Replace TypeName by TypeId & Macro Derivation",
                  "body": "```scala\n// ============================================================================\n// Owner: Where a type is defined\n// ============================================================================\n\nfinal case class Owner(segments: List[Owner.Segment]) {\n  def asString: String = segments.map(_.name).mkString(\".\")\n}\n\nobject Owner {\n  sealed trait Segment { def name: String }\n\n  final case class Package(name: String) extends Segment\n  final case class Term(name: String)    extends Segment\n  final case class Type(name: String)    extends Segment\n\n  val Root: Owner = Owner(Nil)\n}\n\n// ============================================================================\n// TypeParam: Type parameter specification\n// ============================================================================\n\nfinal case class TypeParam(\n  name: String,\n  index: Int\n  // Can extend with: variance, bounds, kind\n)\n\n// ============================================================================\n// TypeId: Identity of a type or type constructor (phantom-typed by A)\n// ============================================================================\n\nsealed trait TypeId[A <: AnyKind] {\n  def name: String\n  def owner: Owner\n  def typeParams: List[TypeParam]\n\n  final def arity: Int = typeParams.size\n\n  final def fullName: String =\n    if (owner.segments.isEmpty) name\n    else owner.asString + \".\" + name\n}\n\nobject TypeId {\n  private final case class NominalImpl(\n    name: String,\n    owner: Owner,\n    typeParams: List[TypeParam]\n  ) extends TypeId[Nothing]\n\n  private final case class AliasImpl(\n    name: String,\n    owner: Owner,\n    typeParams: List[TypeParam],\n    aliased: TypeRepr\n  ) extends TypeId[Nothing]\n\n  private final case class OpaqueImpl(\n    name: String,\n    owner: Owner,\n    typeParams: List[TypeParam],\n    representation: TypeRepr\n  ) extends TypeId[Nothing]\n\n  /** Macro-derived TypeId for any type or type constructor */\n  def derive[A <: AnyKind]: TypeId[A] =\n    macro TypeIdMacros.deriveMacro[A]\n\n  /** Manual construction: nominal type */\n  def nominal[A <: AnyKind](\n    name: String,\n    owner: Owner,\n    typeParams: List[TypeParam]\n  ): TypeId[A] =\n    NominalImpl(name, owner, typeParams).asInstanceOf[TypeId[A]]\n\n  /** Manual construction: type alias */\n  def alias[A <: AnyKind](\n    name: String,\n    owner: Owner,\n    typeParams: List[TypeParam],\n    aliased: TypeRepr\n  ): TypeId[A] =\n    AliasImpl(name, owner, typeParams, aliased).asInstanceOf[TypeId[A]]\n\n  /** Manual construction: opaque type */\n  def opaque[A <: AnyKind](\n    name: String,\n    owner: Owner,\n    typeParams: List[TypeParam],\n    representation: TypeRepr\n  ): TypeId[A] =\n    OpaqueImpl(name, owner, typeParams, representation).asInstanceOf[TypeId[A]]\n\n  /** Pattern matching support */\n  object Nominal {\n    def unapply(id: TypeId[_]): Option[(String, Owner, List[TypeParam])] = id match {\n      case impl: NominalImpl => Some((impl.name, impl.owner, impl.typeParams))\n      case _                 => None\n    }\n  }\n\n  object Alias {\n    def unapply(id: TypeId[_]): Option[(String, Owner, List[TypeParam], TypeRepr)] = id match {\n      case impl: AliasImpl => Some((impl.name, impl.owner, impl.typeParams, impl.aliased))\n      case _               => None\n    }\n  }\n\n  object Opaque {\n    def unapply(id: TypeId[_]): Option[(String, Owner, List[TypeParam], TypeRepr)] = id match {\n      case impl: OpaqueImpl => Some((impl.name, impl.owner, impl.typeParams, impl.representation))\n      case _                => None\n    }\n  }\n}\n\n// ============================================================================\n// TypeRepr: Type expressions\n// ============================================================================\n\nsealed trait TypeRepr\n\nobject TypeRepr {\n  /** Reference to a named type constructor (unapplied).\n    * - If id.arity == 0, this is already a proper type\n    * - If id.arity > 0, this is a type constructor\n    */\n  final case class Ref(id: TypeId[_ <: AnyKind]) extends TypeRepr\n\n  /** Reference to a type parameter (can itself be a constructor) */\n  final case class ParamRef(param: TypeParam) extends TypeRepr\n\n  /** Application of a type constructor to arguments.\n    * Examples:\n    *   List[Int]   â†’ Applied(Ref(listId), List(Ref(intId)))\n    *   F[A]        â†’ Applied(ParamRef(F), List(ParamRef(A)))\n    */\n  final case class Applied(\n    tycon: TypeRepr,\n    args: List[TypeRepr]\n  ) extends TypeRepr\n\n  /** Structural/refinement type: { def foo: Int; type T; ... } */\n  final case class Structural(\n    parents: List[TypeRepr],\n    members: List[Member]\n  ) extends TypeRepr\n\n  /** Intersection type: A & B */\n  final case class Intersection(left: TypeRepr, right: TypeRepr) extends TypeRepr\n\n  /** Union type: A | B */\n  final case class Union(left: TypeRepr, right: TypeRepr) extends TypeRepr\n\n  /** Tuple type: (A, B, C) */\n  final case class Tuple(elems: List[TypeRepr]) extends TypeRepr\n\n  /** Function type: (A, B) => C */\n  final case class Function(params: List[TypeRepr], result: TypeRepr) extends TypeRepr\n\n  /** Singleton type: x.type */\n  final case class Singleton(path: TermPath) extends TypeRepr\n\n  /** Constant/literal type: 42, \"foo\", true */\n  final case class Constant(value: Any) extends TypeRepr\n\n  /** Top type */\n  case object AnyType extends TypeRepr\n\n  /** Bottom type */\n  case object NothingType extends TypeRepr\n}\n\n// ============================================================================\n// Member: Structural type members\n// ============================================================================\n\nsealed trait Member\n\nobject Member {\n  final case class Val(\n    name: String,\n    tpe: TypeRepr,\n    isVar: Boolean = false\n  ) extends Member\n\n  final case class Def(\n    name: String,\n    paramLists: List[List[Param]],\n    result: TypeRepr\n  ) extends Member\n\n  final case class TypeMember(\n    name: String,\n    typeParams: List[TypeParam],\n    lowerBound: Option[TypeRepr],\n    upperBound: Option[TypeRepr]\n  ) extends Member\n}\n\nfinal case class Param(name: String, tpe: TypeRepr)\n\n// ============================================================================\n// TermPath: For singleton types\n// ============================================================================\n\nfinal case class TermPath(segments: List[TermPath.Segment])\n\nobject TermPath {\n  sealed trait Segment { def name: String }\n\n  final case class Package(name: String) extends Segment\n  final case class Term(name: String)    extends Segment\n}\n\n// ============================================================================\n// Examples\n// ============================================================================\n\nobject Examples {\n  import TypeId.{nominal, alias, opaque}\n  import TypeRepr._\n  import Member._\n\n  private val pkgScala          = Owner(List(Owner.Package(\"scala\")))\n  private val pkgScalaCollection =\n    Owner(List(Owner.Package(\"scala\"), Owner.Package(\"collection\"), Owner.Package(\"immutable\")))\n  private val pkgJavaLang       = Owner(List(Owner.Package(\"java\"), Owner.Package(\"lang\")))\n  private val pkgMyApp          = Owner(List(Owner.Package(\"myapp\")))\n\n  // ===== Basic nominal types =====\n\n  val intId: TypeId[Int]       = nominal[Int](\"Int\", pkgScala, Nil)\n  val stringId: TypeId[String] = nominal[String](\"String\", pkgJavaLang, Nil)\n  val booleanId: TypeId[Boolean] = nominal[Boolean](\"Boolean\", pkgScala, Nil)\n\n  val intType: TypeRepr     = Ref(intId)\n  val stringType: TypeRepr  = Ref(stringId)\n  val booleanType: TypeRepr = Ref(booleanId)\n\n  // ===== Type constructors =====\n\n  val A = TypeParam(\"A\", 0)\n  val B = TypeParam(\"B\", 1)\n  val K = TypeParam(\"K\", 0)\n  val V = TypeParam(\"V\", 1)\n\n  val listId: TypeId[List]   = nominal[List](\"List\", pkgScalaCollection, List(A))\n  val optionId: TypeId[Option] = nominal[Option](\"Option\", pkgScala, List(A))\n  val mapId: TypeId[Map]     = nominal[Map](\"Map\", pkgScalaCollection, List(K, V))\n  val eitherId: TypeId[Either] = nominal[Either](\"Either\", pkgScala, List(A, B))\n\n  // Type constructors (unapplied)\n  val listConstructor: TypeRepr   = Ref(listId)\n  val optionConstructor: TypeRepr = Ref(optionId)\n\n  // Applied types\n  val listIntType: TypeRepr       = Applied(Ref(listId), List(intType))\n  val optionStringType: TypeRepr  = Applied(Ref(optionId), List(stringType))\n  val mapStringIntType: TypeRepr  = Applied(Ref(mapId), List(stringType, intType))\n\n  // ===== Type aliases =====\n\n  // type Age = Int\n  val ageId: TypeId[Int] = alias[Int](\n    name       = \"Age\",\n    owner      = pkgMyApp,\n    typeParams = Nil,\n    aliased    = intType\n  )\n  val ageType: TypeRepr = Ref(ageId)\n\n  // type MyList[A] = List[A]\n  val myListId: TypeId[List] = alias[List](\n    name       = \"MyList\",\n    owner      = pkgMyApp,\n    typeParams = List(A),\n    aliased    = Applied(Ref(listId), List(ParamRef(A)))\n  )\n\n  // type StringMap[V] = Map[String, V]\n  val stringMapId: TypeId[Map[String, *]] = alias[Map[String, *]](\n    name       = \"StringMap\",\n    owner      = pkgMyApp,\n    typeParams = List(V),\n    aliased    = Applied(Ref(mapId), List(stringType, ParamRef(V)))\n  )\n\n  // type Id[A] = A\n  val idId: TypeId[AnyKind] = alias[AnyKind](\n    name       = \"Id\",\n    owner      = pkgMyApp,\n    typeParams = List(A),\n    aliased    = ParamRef(A)\n  )\n\n  // ===== Opaque types =====\n\n  // opaque type Email = String\n  val emailId: TypeId[String] = opaque[String](\n    name           = \"Email\",\n    owner          = pkgMyApp,\n    typeParams     = Nil,\n    representation = stringType\n  )\n  val emailType: TypeRepr = Ref(emailId)\n\n  // opaque type SafeList[A] = List[A]\n  val safeListId: TypeId[List] = opaque[List](\n    name           = \"SafeList\",\n    owner          = pkgMyApp,\n    typeParams     = List(A),\n    representation = Applied(Ref(listId), List(ParamRef(A)))\n  )\n\n  // ===== Structural types =====\n\n  // { def size: Int; val isEmpty: Boolean }\n  val sizedType: TypeRepr = Structural(\n    parents = Nil,\n    members = List(\n      Def(\"size\", Nil, intType),\n      Val(\"isEmpty\", booleanType, isVar = false)\n    )\n  )\n\n  // type Record[A] = { def value: A }\n  val recordId: TypeId[AnyKind] = alias[AnyKind](\n    name       = \"Record\",\n    owner      = pkgMyApp,\n    typeParams = List(A),\n    aliased    = Structural(\n      parents = Nil,\n      members = List(\n        Def(\"value\", Nil, ParamRef(A))\n      )\n    )\n  )\n\n  // { type T; def get: T }\n  val T = TypeParam(\"T\", 0)\n  val genericGetterType: TypeRepr = Structural(\n    parents = Nil,\n    members = List(\n      TypeMember(\"T\", Nil, None, None),\n      // Note: ParamRef(T) here is a shorthand for \"the type member T\";\n      // if you want precise scoping you can extend the model, but for\n      // most uses you'll just inspect the name.\n      Def(\"get\", Nil, ParamRef(T))\n    )\n  )\n\n  // ===== Higher-kinded example =====\n\n  // type F[G[_], A] = G[A]\n  val G = TypeParam(\"G\", 0)\n  val fId: TypeId[AnyKind] = alias[AnyKind](\n    name       = \"F\",\n    owner      = pkgMyApp,\n    typeParams = List(G, A),\n    aliased    = Applied(\n      tycon = ParamRef(G),  // G is itself a type constructor\n      args  = List(ParamRef(A))\n    )\n  )\n\n  // ===== Singleton and constant types =====\n\n  // 42 (literal type)\n  val fortyTwoType: TypeRepr = Constant(42)\n\n  // \"hello\" (literal type)\n  val helloType: TypeRepr = Constant(\"hello\")\n\n  // myObject.type\n  val myObjectSingleton: TypeRepr = Singleton(\n    TermPath(List(TermPath.Package(\"myapp\"), TermPath.Term(\"myObject\")))\n  )\n\n  // ===== Complex types =====\n\n  // Option[List[String]]\n  val optionListStringType: TypeRepr =\n    Applied(Ref(optionId), List(Applied(Ref(listId), List(stringType))))\n\n  // Map[Email, List[Age]]\n  val emailToAgesType: TypeRepr =\n    Applied(\n      Ref(mapId),\n      List(\n        Ref(emailId),\n        Applied(Ref(listId), List(Ref(ageId)))\n      )\n    )\n\n  // (Int, String) => Boolean\n  val intStringToBoolType: TypeRepr =\n    Function(List(intType, stringType), booleanType)\n\n  // String & { def length: Int }\n  val stringWithLengthType: TypeRepr =\n    Intersection(\n      stringType,\n      Structural(Nil, List(Def(\"length\", Nil, intType)))\n    )\n\n  // ===== Utility: substitute type parameters =====\n\n  def substitute(\n    repr: TypeRepr,\n    substitutions: Map[TypeParam, TypeRepr]\n  ): TypeRepr =\n    repr match {\n      case ParamRef(param) =>\n        substitutions.getOrElse(param, repr)\n\n      case Ref(_) =>\n        repr\n\n      case Applied(tycon, args) =>\n        Applied(\n          substitute(tycon, substitutions),\n          args.map(substitute(_, substitutions))\n        )\n\n      case Structural(parents, members) =>\n        Structural(\n          parents.map(substitute(_, substitutions)),\n          members.map(substituteMember(_, substitutions))\n        )\n\n      case Intersection(l, r) =>\n        Intersection(\n          substitute(l, substitutions),\n          substitute(r, substitutions)\n        )\n\n      case Union(l, r) =>\n        Union(\n          substitute(l, substitutions),\n          substitute(r, substitutions)\n        )\n\n      case Tuple(elems) =>\n        Tuple(elems.map(substitute(_, substitutions)))\n\n      case Function(params, result) =>\n        Function(\n          params.map(substitute(_, substitutions)),\n          substitute(result, substitutions)\n        )\n\n      case Singleton(_) | Constant(_) | AnyType | NothingType =>\n        repr\n    }\n\n  private def substituteMember(\n    m: Member,\n    substitutions: Map[TypeParam, TypeRepr]\n  ): Member =\n    m match {\n      case Val(name, tpe, isVar) =>\n        Val(name, substitute(tpe, substitutions), isVar)\n\n      case Def(name, paramLists, result) =>\n        Def(\n          name,\n          paramLists.map(_.map { p => Param(p.name, substitute(p.tpe, substitutions)) }),\n          substitute(result, substitutions)\n        )\n\n      case TypeMember(name, typeParams, lower, upper) =>\n        TypeMember(\n          name,\n          typeParams,\n          lower.map(substitute(_, substitutions)),\n          upper.map(substitute(_, substitutions))\n        )\n    }\n\n  // Get underlying type for alias/opaque with substitution\n  def underlyingType(\n    id: TypeId[_],\n    args: List[TypeRepr]\n  ): Option[TypeRepr] = id match {\n    case TypeId.Alias(_, _, typeParams, aliased) =>\n      val subs = typeParams.zip(args).toMap\n      Some(substitute(aliased, subs))\n\n    case TypeId.Opaque(_, _, typeParams, representation) =>\n      val subs = typeParams.zip(args).toMap\n      Some(substitute(representation, subs))\n\n    case _ =>\n      None\n  }\n\n  // Examples:\n  // underlyingType(ageId, Nil)                  => Some(Int)\n  // underlyingType(myListId, List(intType))     => Some(List[Int])\n  // underlyingType(stringMapId, List(intType))  => Some(Map[String, Int])\n  // underlyingType(emailId, Nil)                => Some(String)\n\n  // ===== Type safety via phantom types =====\n\n  def processList(id: TypeId[List]): String =\n    s\"Processing list type constructor: ${id.fullName}\"\n\n  def processScalar[A](id: TypeId[A]): String =\n    s\"Processing scalar type: ${id.fullName}\"\n\n  // These compile:\n  val _x: String = processList(listId)\n  val _y: String = processList(myListId)     // MyList is an alias for List\n  val _z: String = processList(safeListId)   // SafeList is opaque over List\n\n  val _s1: String = processScalar(intId)\n  val _s2: String = processScalar(ageId)     // Age is an alias for Int\n  val _s3: String = processScalar(emailId)   // Email is opaque over String\n\n  // These would NOT compile:\n  // processList(intId)     // Type mismatch\n  // processScalar(listId)  // Type mismatch\n}\n```",
                  "html_url": "https://github.com/zio/zio-blocks/issues/471"
                },
                "type": "github"
              },
              "hash": "zio/zio-blocks#471",
              "body": "```scala\n// ============================================================================\n// Owner: Where a type is defined\n// ============================================================================\n\nfinal case class Owner(segments: List[Owner.Segment]) {\n  def asString: String = segments.map(_.name).mkString(\".\")\n}\n\nobject Owner {\n  sealed trait Segment { def name: String }\n\n  final case class Package(name: String) extends Segment\n  final case class Term(name: String)    extends Segment\n  final case class Type(name: String)    extends Segment\n\n  val Root: Owner = Owner(Nil)\n}\n\n// ============================================================================\n// TypeParam: Type parameter specification\n// ============================================================================\n\nfinal case class TypeParam(\n  name: String,\n  index: Int\n  // Can extend with: variance, bounds, kind\n)\n\n// ============================================================================\n// TypeId: Identity of a type or type constructor (phantom-typed by A)\n// ============================================================================\n\nsealed trait TypeId[A <: AnyKind] {\n  def name: String\n  def owner: Owner\n  def typeParams: List[TypeParam]\n\n  final def arity: Int = typeParams.size\n\n  final def fullName: String =\n    if (owner.segments.isEmpty) name\n    else owner.asString + \".\" + name\n}\n\nobject TypeId {\n  private final case class NominalImpl(\n    name: String,\n    owner: Owner,\n    typeParams: List[TypeParam]\n  ) extends TypeId[Nothing]\n\n  private final case class AliasImpl(\n    name: String,\n    owner: Owner,\n    typeParams: List[TypeParam],\n    aliased: TypeRepr\n  ) extends TypeId[Nothing]\n\n  private final case class OpaqueImpl(\n    name: String,\n    owner: Owner,\n    typeParams: List[TypeParam],\n    representation: TypeRepr\n  ) extends TypeId[Nothing]\n\n  /** Macro-derived TypeId for any type or type constructor */\n  def derive[A <: AnyKind]: TypeId[A] =\n    macro TypeIdMacros.deriveMacro[A]\n\n  /** Manual construction: nominal type */\n  def nominal[A <: AnyKind](\n    name: String,\n    owner: Owner,\n    typeParams: List[TypeParam]\n  ): TypeId[A] =\n    NominalImpl(name, owner, typeParams).asInstanceOf[TypeId[A]]\n\n  /** Manual construction: type alias */\n  def alias[A <: AnyKind](\n    name: String,\n    owner: Owner,\n    typeParams: List[TypeParam],\n    aliased: TypeRepr\n  ): TypeId[A] =\n    AliasImpl(name, owner, typeParams, aliased).asInstanceOf[TypeId[A]]\n\n  /** Manual construction: opaque type */\n  def opaque[A <: AnyKind](\n    name: String,\n    owner: Owner,\n    typeParams: List[TypeParam],\n    representation: TypeRepr\n  ): TypeId[A] =\n    OpaqueImpl(name, owner, typeParams, representation).asInstanceOf[TypeId[A]]\n\n  /** Pattern matching support */\n  object Nominal {\n    def unapply(id: TypeId[_]): Option[(String, Owner, List[TypeParam])] = id match {\n      case impl: NominalImpl => Some((impl.name, impl.owner, impl.typeParams))\n      case _                 => None\n    }\n  }\n\n  object Alias {\n    def unapply(id: TypeId[_]): Option[(String, Owner, List[TypeParam], TypeRepr)] = id match {\n      case impl: AliasImpl => Some((impl.name, impl.owner, impl.typeParams, impl.aliased))\n      case _               => None\n    }\n  }\n\n  object Opaque {\n    def unapply(id: TypeId[_]): Option[(String, Owner, List[TypeParam], TypeRepr)] = id match {\n      case impl: OpaqueImpl => Some((impl.name, impl.owner, impl.typeParams, impl.representation))\n      case _                => None\n    }\n  }\n}\n\n// ============================================================================\n// TypeRepr: Type expressions\n// ============================================================================\n\nsealed trait TypeRepr\n\nobject TypeRepr {\n  /** Reference to a named type constructor (unapplied).\n    * - If id.arity == 0, this is already a proper type\n    * - If id.arity > 0, this is a type constructor\n    */\n  final case class Ref(id: TypeId[_ <: AnyKind]) extends TypeRepr\n\n  /** Reference to a type parameter (can itself be a constructor) */\n  final case class ParamRef(param: TypeParam) extends TypeRepr\n\n  /** Application of a type constructor to arguments.\n    * Examples:\n    *   List[Int]   â†’ Applied(Ref(listId), List(Ref(intId)))\n    *   F[A]        â†’ Applied(ParamRef(F), List(ParamRef(A)))\n    */\n  final case class Applied(\n    tycon: TypeRepr,\n    args: List[TypeRepr]\n  ) extends TypeRepr\n\n  /** Structural/refinement type: { def foo: Int; type T; ... } */\n  final case class Structural(\n    parents: List[TypeRepr],\n    members: List[Member]\n  ) extends TypeRepr\n\n  /** Intersection type: A & B */\n  final case class Intersection(left: TypeRepr, right: TypeRepr) extends TypeRepr\n\n  /** Union type: A | B */\n  final case class Union(left: TypeRepr, right: TypeRepr) extends TypeRepr\n\n  /** Tuple type: (A, B, C) */\n  final case class Tuple(elems: List[TypeRepr]) extends TypeRepr\n\n  /** Function type: (A, B) => C */\n  final case class Function(params: List[TypeRepr], result: TypeRepr) extends TypeRepr\n\n  /** Singleton type: x.type */\n  final case class Singleton(path: TermPath) extends TypeRepr\n\n  /** Constant/literal type: 42, \"foo\", true */\n  final case class Constant(value: Any) extends TypeRepr\n\n  /** Top type */\n  case object AnyType extends TypeRepr\n\n  /** Bottom type */\n  case object NothingType extends TypeRepr\n}\n\n// ============================================================================\n// Member: Structural type members\n// ============================================================================\n\nsealed trait Member\n\nobject Member {\n  final case class Val(\n    name: String,\n    tpe: TypeRepr,\n    isVar: Boolean = false\n  ) extends Member\n\n  final case class Def(\n    name: String,\n    paramLists: List[List[Param]],\n    result: TypeRepr\n  ) extends Member\n\n  final case class TypeMember(\n    name: String,\n    typeParams: List[TypeParam],\n    lowerBound: Option[TypeRepr],\n    upperBound: Option[TypeRepr]\n  ) extends Member\n}\n\nfinal case class Param(name: String, tpe: TypeRepr)\n\n// ============================================================================\n// TermPath: For singleton types\n// ============================================================================\n\nfinal case class TermPath(segments: List[TermPath.Segment])\n\nobject TermPath {\n  sealed trait Segment { def name: String }\n\n  final case class Package(name: String) extends Segment\n  final case class Term(name: String)    extends Segment\n}\n\n// ============================================================================\n// Examples\n// ============================================================================\n\nobject Examples {\n  import TypeId.{nominal, alias, opaque}\n  import TypeRepr._\n  import Member._\n\n  private val pkgScala          = Owner(List(Owner.Package(\"scala\")))\n  private val pkgScalaCollection =\n    Owner(List(Owner.Package(\"scala\"), Owner.Package(\"collection\"), Owner.Package(\"immutable\")))\n  private val pkgJavaLang       = Owner(List(Owner.Package(\"java\"), Owner.Package(\"lang\")))\n  private val pkgMyApp          = Owner(List(Owner.Package(\"myapp\")))\n\n  // ===== Basic nominal types =====\n\n  val intId: TypeId[Int]       = nominal[Int](\"Int\", pkgScala, Nil)\n  val stringId: TypeId[String] = nominal[String](\"String\", pkgJavaLang, Nil)\n  val booleanId: TypeId[Boolean] = nominal[Boolean](\"Boolean\", pkgScala, Nil)\n\n  val intType: TypeRepr     = Ref(intId)\n  val stringType: TypeRepr  = Ref(stringId)\n  val booleanType: TypeRepr = Ref(booleanId)\n\n  // ===== Type constructors =====\n\n  val A = TypeParam(\"A\", 0)\n  val B = TypeParam(\"B\", 1)\n  val K = TypeParam(\"K\", 0)\n  val V = TypeParam(\"V\", 1)\n\n  val listId: TypeId[List]   = nominal[List](\"List\", pkgScalaCollection, List(A))\n  val optionId: TypeId[Option] = nominal[Option](\"Option\", pkgScala, List(A))\n  val mapId: TypeId[Map]     = nominal[Map](\"Map\", pkgScalaCollection, List(K, V))\n  val eitherId: TypeId[Either] = nominal[Either](\"Either\", pkgScala, List(A, B))\n\n  // Type constructors (unapplied)\n  val listConstructor: TypeRepr   = Ref(listId)\n  val optionConstructor: TypeRepr = Ref(optionId)\n\n  // Applied types\n  val listIntType: TypeRepr       = Applied(Ref(listId), List(intType))\n  val optionStringType: TypeRepr  = Applied(Ref(optionId), List(stringType))\n  val mapStringIntType: TypeRepr  = Applied(Ref(mapId), List(stringType, intType))\n\n  // ===== Type aliases =====\n\n  // type Age = Int\n  val ageId: TypeId[Int] = alias[Int](\n    name       = \"Age\",\n    owner      = pkgMyApp,\n    typeParams = Nil,\n    aliased    = intType\n  )\n  val ageType: TypeRepr = Ref(ageId)\n\n  // type MyList[A] = List[A]\n  val myListId: TypeId[List] = alias[List](\n    name       = \"MyList\",\n    owner      = pkgMyApp,\n    typeParams = List(A),\n    aliased    = Applied(Ref(listId), List(ParamRef(A)))\n  )\n\n  // type StringMap[V] = Map[String, V]\n  val stringMapId: TypeId[Map[String, *]] = alias[Map[String, *]](\n    name       = \"StringMap\",\n    owner      = pkgMyApp,\n    typeParams = List(V),\n    aliased    = Applied(Ref(mapId), List(stringType, ParamRef(V)))\n  )\n\n  // type Id[A] = A\n  val idId: TypeId[AnyKind] = alias[AnyKind](\n    name       = \"Id\",\n    owner      = pkgMyApp,\n    typeParams = List(A),\n    aliased    = ParamRef(A)\n  )\n\n  // ===== Opaque types =====\n\n  // opaque type Email = String\n  val emailId: TypeId[String] = opaque[String](\n    name           = \"Email\",\n    owner          = pkgMyApp,\n    typeParams     = Nil,\n    representation = stringType\n  )\n  val emailType: TypeRepr = Ref(emailId)\n\n  // opaque type SafeList[A] = List[A]\n  val safeListId: TypeId[List] = opaque[List](\n    name           = \"SafeList\",\n    owner          = pkgMyApp,\n    typeParams     = List(A),\n    representation = Applied(Ref(listId), List(ParamRef(A)))\n  )\n\n  // ===== Structural types =====\n\n  // { def size: Int; val isEmpty: Boolean }\n  val sizedType: TypeRepr = Structural(\n    parents = Nil,\n    members = List(\n      Def(\"size\", Nil, intType),\n      Val(\"isEmpty\", booleanType, isVar = false)\n    )\n  )\n\n  // type Record[A] = { def value: A }\n  val recordId: TypeId[AnyKind] = alias[AnyKind](\n    name       = \"Record\",\n    owner      = pkgMyApp,\n    typeParams = List(A),\n    aliased    = Structural(\n      parents = Nil,\n      members = List(\n        Def(\"value\", Nil, ParamRef(A))\n      )\n    )\n  )\n\n  // { type T; def get: T }\n  val T = TypeParam(\"T\", 0)\n  val genericGetterType: TypeRepr = Structural(\n    parents = Nil,\n    members = List(\n      TypeMember(\"T\", Nil, None, None),\n      // Note: ParamRef(T) here is a shorthand for \"the type member T\";\n      // if you want precise scoping you can extend the model, but for\n      // most uses you'll just inspect the name.\n      Def(\"get\", Nil, ParamRef(T))\n    )\n  )\n\n  // ===== Higher-kinded example =====\n\n  // type F[G[_], A] = G[A]\n  val G = TypeParam(\"G\", 0)\n  val fId: TypeId[AnyKind] = alias[AnyKind](\n    name       = \"F\",\n    owner      = pkgMyApp,\n    typeParams = List(G, A),\n    aliased    = Applied(\n      tycon = ParamRef(G),  // G is itself a type constructor\n      args  = List(ParamRef(A))\n    )\n  )\n\n  // ===== Singleton and constant types =====\n\n  // 42 (literal type)\n  val fortyTwoType: TypeRepr = Constant(42)\n\n  // \"hello\" (literal type)\n  val helloType: TypeRepr = Constant(\"hello\")\n\n  // myObject.type\n  val myObjectSingleton: TypeRepr = Singleton(\n    TermPath(List(TermPath.Package(\"myapp\"), TermPath.Term(\"myObject\")))\n  )\n\n  // ===== Complex types =====\n\n  // Option[List[String]]\n  val optionListStringType: TypeRepr =\n    Applied(Ref(optionId), List(Applied(Ref(listId), List(stringType))))\n\n  // Map[Email, List[Age]]\n  val emailToAgesType: TypeRepr =\n    Applied(\n      Ref(mapId),\n      List(\n        Ref(emailId),\n        Applied(Ref(listId), List(Ref(ageId)))\n      )\n    )\n\n  // (Int, String) => Boolean\n  val intStringToBoolType: TypeRepr =\n    Function(List(intType, stringType), booleanType)\n\n  // String & { def length: Int }\n  val stringWithLengthType: TypeRepr =\n    Intersection(\n      stringType,\n      Structural(Nil, List(Def(\"length\", Nil, intType)))\n    )\n\n  // ===== Utility: substitute type parameters =====\n\n  def substitute(\n    repr: TypeRepr,\n    substitutions: Map[TypeParam, TypeRepr]\n  ): TypeRepr =\n    repr match {\n      case ParamRef(param) =>\n        substitutions.getOrElse(param, repr)\n\n      case Ref(_) =>\n        repr\n\n      case Applied(tycon, args) =>\n        Applied(\n          substitute(tycon, substitutions),\n          args.map(substitute(_, substitutions))\n        )\n\n      case Structural(parents, members) =>\n        Structural(\n          parents.map(substitute(_, substitutions)),\n          members.map(substituteMember(_, substitutions))\n        )\n\n      case Intersection(l, r) =>\n        Intersection(\n          substitute(l, substitutions),\n          substitute(r, substitutions)\n        )\n\n      case Union(l, r) =>\n        Union(\n          substitute(l, substitutions),\n          substitute(r, substitutions)\n        )\n\n      case Tuple(elems) =>\n        Tuple(elems.map(substitute(_, substitutions)))\n\n      case Function(params, result) =>\n        Function(\n          params.map(substitute(_, substitutions)),\n          substitute(result, substitutions)\n        )\n\n      case Singleton(_) | Constant(_) | AnyType | NothingType =>\n        repr\n    }\n\n  private def substituteMember(\n    m: Member,\n    substitutions: Map[TypeParam, TypeRepr]\n  ): Member =\n    m match {\n      case Val(name, tpe, isVar) =>\n        Val(name, substitute(tpe, substitutions), isVar)\n\n      case Def(name, paramLists, result) =>\n        Def(\n          name,\n          paramLists.map(_.map { p => Param(p.name, substitute(p.tpe, substitutions)) }),\n          substitute(result, substitutions)\n        )\n\n      case TypeMember(name, typeParams, lower, upper) =>\n        TypeMember(\n          name,\n          typeParams,\n          lower.map(substitute(_, substitutions)),\n          upper.map(substitute(_, substitutions))\n        )\n    }\n\n  // Get underlying type for alias/opaque with substitution\n  def underlyingType(\n    id: TypeId[_],\n    args: List[TypeRepr]\n  ): Option[TypeRepr] = id match {\n    case TypeId.Alias(_, _, typeParams, aliased) =>\n      val subs = typeParams.zip(args).toMap\n      Some(substitute(aliased, subs))\n\n    case TypeId.Opaque(_, _, typeParams, representation) =>\n      val subs = typeParams.zip(args).toMap\n      Some(substitute(representation, subs))\n\n    case _ =>\n      None\n  }\n\n  // Examples:\n  // underlyingType(ageId, Nil)                  => Some(Int)\n  // underlyingType(myListId, List(intType))     => Some(List[Int])\n  // underlyingType(stringMapId, List(intType))  => Some(Map[String, Int])\n  // underlyingType(emailId, Nil)                => Some(String)\n\n  // ===== Type safety via phantom types =====\n\n  def processList(id: TypeId[List]): String =\n    s\"Processing list type constructor: ${id.fullName}\"\n\n  def processScalar[A](id: TypeId[A]): String =\n    s\"Processing scalar type: ${id.fullName}\"\n\n  // These compile:\n  val _x: String = processList(listId)\n  val _y: String = processList(myListId)     // MyList is an alias for List\n  val _z: String = processList(safeListId)   // SafeList is opaque over List\n\n  val _s1: String = processScalar(intId)\n  val _s2: String = processScalar(ageId)     // Age is an alias for Int\n  val _s3: String = processScalar(emailId)   // Email is opaque over String\n\n  // These would NOT compile:\n  // processList(intId)     // Type mismatch\n  // processScalar(listId)  // Type mismatch\n}\n```",
              "url": "https://github.com/zio/zio-blocks/issues/471",
              "tech": [],
              "repo_name": "zio-blocks",
              "repo_owner": "zio",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "ZIO#514",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "ZIO",
              "id": "generated-ZIO",
              "name": "ZIO",
              "description": "",
              "members": [],
              "display_name": "ZIO",
              "created_at": "2025-12-30T19:50:15.817Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/ZIO?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "zio",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2025-12-30T19:50:15.817Z",
            "created_at": "2025-12-30T19:50:15.817Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-ZIO#514",
              "status": "open",
              "type": "issue",
              "number": 514,
              "title": "Add annotation macros for Scala 2.13 and Scala 3.5+",
              "source": {
                "data": {
                  "id": "source-ZIO#514",
                  "user": {
                    "login": "jdegoes",
                    "id": 156745,
                    "node_id": "MDQ6VXNlcjE1Njc0NQ==",
                    "avatar_url": "https://avatars.githubusercontent.com/u/156745?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/jdegoes",
                    "html_url": "https://github.com/jdegoes",
                    "followers_url": "https://api.github.com/users/jdegoes/followers",
                    "following_url": "https://api.github.com/users/jdegoes/following{/other_user}",
                    "gists_url": "https://api.github.com/users/jdegoes/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/jdegoes/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/jdegoes/subscriptions",
                    "organizations_url": "https://api.github.com/users/jdegoes/orgs",
                    "repos_url": "https://api.github.com/users/jdegoes/repos",
                    "events_url": "https://api.github.com/users/jdegoes/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/jdegoes/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Add annotation macros for Scala 2.13 and Scala 3.5+",
                  "body": "# Overview\n\nThis ticket involves adding derived optics support for Scala 2.13 and Scala 3.5+. Users will extend `DerivedOptics[T]` in their companion object to gain access to automatically-generated lenses and prisms via a typed `optics` accessor.\n\nThe mechanism is as follows:\n\n- `DerivedOptics[T]`: Extend this trait in the companion object of a case class, sealed trait, or enum. Access optics via `Companion.optics.fieldName` which returns appropriately-typed `Lens` or `Prism` instances. An optional variant, `DerivedOptics_[T]`, prefixes all optic accessors with an underscore character (`_`) to avoid name collisions.\n\n**Implementation Notes**:\n\n1. The `optics` method returns a structurally-typed object. For case classes, each field becomes a `Lens` accessor. For sealed traits/enums, each variant becomes a `Prism` accessor (with the first letter lower-cased to avoid colliding with the type name).\n\n2. The optics object **must be cached** to avoid repeated allocation. Users should not need to manually cache `val myOptics = Person.optics`â€”calling `Person.optics` multiple times must return the same cached instance.\n\n3. For Scala 3, use `transparent inline def` to expose the structural refinement type at compile time. For Scala 2, use whitebox macros to achieve the same effect.\n\n---\n\n## Optics\n\n### Case Class\n\n#### User Code\n\n```scala\nfinal case class Person(name: String, age: Int)\nobject Person extends DerivedOptics[Person]\n```\n\n#### Usage\n\n```scala\nval nameLens: Lens[Person, String] = Person.optics.name\nval ageLens: Lens[Person, Int] = Person.optics.age\n\nval person = Person(\"Alice\", 30)\nnameLens.get(person)              // \"Alice\"\nageLens.replace(person, 31)       // Person(\"Alice\", 31)\n```\n\n#### Structural Type\n\n```scala\nPerson.optics  // : { def name: Lens[Person, String]; def age: Lens[Person, Int] }\n```\n\n---\n\n### Sealed Trait\n\n#### User Code\n\n```scala\nsealed trait Result[+A]\nobject Result extends DerivedOptics[Result[_]] {\n  final case class Success[A](value: A) extends Result[A]\n  object Success extends DerivedOptics[Success[_]]\n  \n  final case class Failure(error: String) extends Result[Nothing]\n  object Failure extends DerivedOptics[Failure]\n  \n  case object Pending extends Result[Nothing]\n}\n```\n\n#### Usage\n\n```scala\n// Prisms for the sealed trait variants\nval successPrism: Prism[Result[Int], Success[Int]] = Result.optics.success\nval failurePrism: Prism[Result[Nothing], Failure] = Result.optics.failure\nval pendingPrism: Prism[Result[Nothing], Pending.type] = Result.optics.pending\n\n// Lenses for case class fields\nval valueLens: Lens[Success[Int], Int] = Success.optics.value\nval errorLens: Lens[Failure, String] = Failure.optics.error\n\nval result: Result[Int] = Success(42)\nsuccessPrism.getOption(result)    // Some(Success(42))\nfailurePrism.getOption(result)    // None\n```\n\n#### Structural Types\n\n```scala\nResult.optics   // : { def success[A]: Prism[Result[A], Success[A]]; def failure: Prism[Result[Nothing], Failure]; def pending: Prism[Result[Nothing], Pending.type] }\nSuccess.optics  // : { def value: Lens[Success[A], A] }\nFailure.optics  // : { def error: Lens[Failure, String] }\n```\n\n---\n\n### Enum (Scala 3 only)\n\n#### User Code\n\n```scala\nenum Status {\n  case Active(since: Long)\n  case Inactive\n  case Suspended(reason: String, until: Long)\n}\nobject Status extends DerivedOptics[Status]\n```\n\n#### Usage\n\n```scala\n// Prisms for enum cases\nval activePrism: Prism[Status, Status.Active] = Status.optics.active\nval inactivePrism: Prism[Status, Status.Inactive.type] = Status.optics.inactive\nval suspendedPrism: Prism[Status, Status.Suspended] = Status.optics.suspended\n\nval status: Status = Status.Active(1234567890L)\nactivePrism.getOption(status)     // Some(Active(1234567890L))\ninactivePrism.getOption(status)   // None\n```\n\n#### Structural Type\n\n```scala\nStatus.optics  // : { def active: Prism[Status, Active]; def inactive: Prism[Status, Inactive.type]; def suspended: Prism[Status, Suspended] }\n```\n\n---\n\n## Definition of Done\n\nThis ticket is **not complete** until the following comprehensive test suites pass on both Scala 2.13 and Scala 3.5+.\n\n### Lens Tests (Case Classes)\n\n| Test Case | Description |\n|-----------|-------------|\n| `get field value` | `Person.optics.name.get(Person(\"Alice\", 30))` returns `\"Alice\"` |\n| `replace field value` | `Person.optics.name.replace(person, \"Bob\")` returns `Person(\"Bob\", 30)` |\n| `modify field value` | `Person.optics.age.modify(person, _ + 1)` returns `Person(\"Alice\", 31)` |\n| `compose lenses for nested access` | `Employee.optics.address.andThen(Address.optics.city)` works correctly |\n| `lens for generic case class` | `Box[Int].optics.value` has type `Lens[Box[Int], Int]` |\n| `lens for case class with many fields (10+)` | All fields accessible |\n| `lens for fields with keyword names` | Fields named `` `type` ``, `` `class` ``, `` `val` `` work correctly |\n| `lens for optional fields` | `Lens[T, Option[A]]` works correctly |\n| `lens for collection fields` | `Lens[T, List[A]]` works correctly |\n| `empty case class` | `Empty.optics` compiles (no accessors) |\n| `single-field case class` | `Wrapper.optics.value` works |\n| `case class with private constructor` | Optics still work |\n| `case class extending trait` | Only case class fields become lenses |\n\n### Prism Tests (Sealed Traits / Enums)\n\n| Test Case | Description |\n|-----------|-------------|\n| `getOption returns Some for matching variant` | `Shape.optics.circle.getOption(Circle(5.0))` returns `Some(Circle(5.0))` |\n| `getOption returns None for non-matching variant` | `Shape.optics.circle.getOption(Rectangle(3, 4))` returns `None` |\n| `reverseGet constructs the variant` | `Shape.optics.circle.reverseGet(Circle(5.0))` returns `Circle(5.0)` typed as `Shape` |\n| `prism for case object` | `Shape.optics.point.getOption(Point)` returns `Some(Point)` |\n| `prism names are lower-cased` | Accessor is `circle`, not `Circle` |\n| `nested sealed traits` | Prisms compose correctly |\n| `enum simple cases` (Scala 3) | Parameterless enum cases work |\n| `enum parameterized cases` (Scala 3) | Enum cases with fields work |\n| `sealed trait with type parameters` | `Result.optics.success[Int]` returns `Prism[Result[Int], Success[Int]]` |\n\n### Composition Tests\n\n| Test Case | Description |\n|-----------|-------------|\n| `lens andThen lens` | Nested field access works |\n| `prism andThen lens` | Access field inside a variant |\n| `lens andThen prism` | Access variant inside a field |\n| `prism andThen prism` | Nested variant access |\n\n### Traversal Tests\n\n| Test Case | Description |\n|-----------|-------------|\n| `traverse list field` | Combine lens with list traversal |\n| `traverse option field` | Combine lens with optional |\n| `traverse nested collections` | `List[Option[A]]` traversal |\n\n### Caching Tests\n\n| Test Case | Description |\n|-----------|-------------|\n| `optics object is cached (referential equality)` | `Person.optics eq Person.optics` is `true` |\n| `lens from cached optics is stable` | `Person.optics.name eq Person.optics.name` is `true` |\n| `concurrent access returns same instance` | 100 concurrent calls all return same object |\n| `no allocation on repeated access` | Benchmark or allocation tracking |\n\n### Type Safety Tests\n\n| Test Case | Description |\n|-----------|-------------|\n| `lens has correct static type` | `val x: Lens[Person, String] = Person.optics.name` compiles |\n| `prism has correct static type` | `val x: Prism[Shape, Circle] = Shape.optics.circle` compiles |\n| `nonexistent field does not compile` | `Person.optics.nonexistent` fails at compile time |\n| `wrong type annotation does not compile` | `val x: Lens[Person, Int] = Person.optics.name` fails |\n| `IDE completion works` | (Manual verification) Structural type provides completion |\n\n### Edge Cases\n\n| Test Case | Description |\n|-----------|-------------|\n| `underscore variant avoids collision` | `DerivedOptics_` prefixes with `_` |\n| `field named \"optics\"` | Does not conflict with `optics` method |\n| `deeply nested structures (5+ levels)` | Performance is acceptable |\n| `recursive types` | `case class Tree(children: List[Tree])` works |\n| `mutually recursive types` | `A` references `B`, `B` references `A` |\n| `case class with default parameters` | Optics work correctly |\n| `case class with lazy val` | Only constructor params become lenses |\n| `case class with var` | Only val params become lenses |\n\n### Cross-Platform Tests\n\n| Platform | Requirement |\n|----------|-------------|\n| JVM | All tests pass |\n| Scala.js | All tests pass |\n| Scala Native | All tests pass (if supported) |\n\n---\n\n## Implementation Checklist\n\n- [ ] `DerivedOptics[T]` trait implemented for Scala 2.13\n- [ ] `DerivedOptics[T]` trait implemented for Scala 3.5+\n- [ ] `DerivedOptics_[T]` underscore variant for both versions\n- [ ] Caching mechanism implemented and tested\n- [ ] All Lens tests passing\n- [ ] All Prism tests passing  \n- [ ] All Composition tests passing\n- [ ] All Traversal tests passing\n- [ ] All Caching tests passing\n- [ ] All Type Safety tests passing\n- [ ] All Edge Case tests passing\n- [ ] JVM tests passing\n- [ ] Scala.js tests passing\n- [ ] Documentation updated with usage examples",
                  "html_url": "https://github.com/zio/zio-blocks/issues/514"
                },
                "type": "github"
              },
              "hash": "zio/zio-blocks#514",
              "body": "# Overview\n\nThis ticket involves adding derived optics support for Scala 2.13 and Scala 3.5+. Users will extend `DerivedOptics[T]` in their companion object to gain access to automatically-generated lenses and prisms via a typed `optics` accessor.\n\nThe mechanism is as follows:\n\n- `DerivedOptics[T]`: Extend this trait in the companion object of a case class, sealed trait, or enum. Access optics via `Companion.optics.fieldName` which returns appropriately-typed `Lens` or `Prism` instances. An optional variant, `DerivedOptics_[T]`, prefixes all optic accessors with an underscore character (`_`) to avoid name collisions.\n\n**Implementation Notes**:\n\n1. The `optics` method returns a structurally-typed object. For case classes, each field becomes a `Lens` accessor. For sealed traits/enums, each variant becomes a `Prism` accessor (with the first letter lower-cased to avoid colliding with the type name).\n\n2. The optics object **must be cached** to avoid repeated allocation. Users should not need to manually cache `val myOptics = Person.optics`â€”calling `Person.optics` multiple times must return the same cached instance.\n\n3. For Scala 3, use `transparent inline def` to expose the structural refinement type at compile time. For Scala 2, use whitebox macros to achieve the same effect.\n\n---\n\n## Optics\n\n### Case Class\n\n#### User Code\n\n```scala\nfinal case class Person(name: String, age: Int)\nobject Person extends DerivedOptics[Person]\n```\n\n#### Usage\n\n```scala\nval nameLens: Lens[Person, String] = Person.optics.name\nval ageLens: Lens[Person, Int] = Person.optics.age\n\nval person = Person(\"Alice\", 30)\nnameLens.get(person)              // \"Alice\"\nageLens.replace(person, 31)       // Person(\"Alice\", 31)\n```\n\n#### Structural Type\n\n```scala\nPerson.optics  // : { def name: Lens[Person, String]; def age: Lens[Person, Int] }\n```\n\n---\n\n### Sealed Trait\n\n#### User Code\n\n```scala\nsealed trait Result[+A]\nobject Result extends DerivedOptics[Result[_]] {\n  final case class Success[A](value: A) extends Result[A]\n  object Success extends DerivedOptics[Success[_]]\n  \n  final case class Failure(error: String) extends Result[Nothing]\n  object Failure extends DerivedOptics[Failure]\n  \n  case object Pending extends Result[Nothing]\n}\n```\n\n#### Usage\n\n```scala\n// Prisms for the sealed trait variants\nval successPrism: Prism[Result[Int], Success[Int]] = Result.optics.success\nval failurePrism: Prism[Result[Nothing], Failure] = Result.optics.failure\nval pendingPrism: Prism[Result[Nothing], Pending.type] = Result.optics.pending\n\n// Lenses for case class fields\nval valueLens: Lens[Success[Int], Int] = Success.optics.value\nval errorLens: Lens[Failure, String] = Failure.optics.error\n\nval result: Result[Int] = Success(42)\nsuccessPrism.getOption(result)    // Some(Success(42))\nfailurePrism.getOption(result)    // None\n```\n\n#### Structural Types\n\n```scala\nResult.optics   // : { def success[A]: Prism[Result[A], Success[A]]; def failure: Prism[Result[Nothing], Failure]; def pending: Prism[Result[Nothing], Pending.type] }\nSuccess.optics  // : { def value: Lens[Success[A], A] }\nFailure.optics  // : { def error: Lens[Failure, String] }\n```\n\n---\n\n### Enum (Scala 3 only)\n\n#### User Code\n\n```scala\nenum Status {\n  case Active(since: Long)\n  case Inactive\n  case Suspended(reason: String, until: Long)\n}\nobject Status extends DerivedOptics[Status]\n```\n\n#### Usage\n\n```scala\n// Prisms for enum cases\nval activePrism: Prism[Status, Status.Active] = Status.optics.active\nval inactivePrism: Prism[Status, Status.Inactive.type] = Status.optics.inactive\nval suspendedPrism: Prism[Status, Status.Suspended] = Status.optics.suspended\n\nval status: Status = Status.Active(1234567890L)\nactivePrism.getOption(status)     // Some(Active(1234567890L))\ninactivePrism.getOption(status)   // None\n```\n\n#### Structural Type\n\n```scala\nStatus.optics  // : { def active: Prism[Status, Active]; def inactive: Prism[Status, Inactive.type]; def suspended: Prism[Status, Suspended] }\n```\n\n---\n\n## Definition of Done\n\nThis ticket is **not complete** until the following comprehensive test suites pass on both Scala 2.13 and Scala 3.5+.\n\n### Lens Tests (Case Classes)\n\n| Test Case | Description |\n|-----------|-------------|\n| `get field value` | `Person.optics.name.get(Person(\"Alice\", 30))` returns `\"Alice\"` |\n| `replace field value` | `Person.optics.name.replace(person, \"Bob\")` returns `Person(\"Bob\", 30)` |\n| `modify field value` | `Person.optics.age.modify(person, _ + 1)` returns `Person(\"Alice\", 31)` |\n| `compose lenses for nested access` | `Employee.optics.address.andThen(Address.optics.city)` works correctly |\n| `lens for generic case class` | `Box[Int].optics.value` has type `Lens[Box[Int], Int]` |\n| `lens for case class with many fields (10+)` | All fields accessible |\n| `lens for fields with keyword names` | Fields named `` `type` ``, `` `class` ``, `` `val` `` work correctly |\n| `lens for optional fields` | `Lens[T, Option[A]]` works correctly |\n| `lens for collection fields` | `Lens[T, List[A]]` works correctly |\n| `empty case class` | `Empty.optics` compiles (no accessors) |\n| `single-field case class` | `Wrapper.optics.value` works |\n| `case class with private constructor` | Optics still work |\n| `case class extending trait` | Only case class fields become lenses |\n\n### Prism Tests (Sealed Traits / Enums)\n\n| Test Case | Description |\n|-----------|-------------|\n| `getOption returns Some for matching variant` | `Shape.optics.circle.getOption(Circle(5.0))` returns `Some(Circle(5.0))` |\n| `getOption returns None for non-matching variant` | `Shape.optics.circle.getOption(Rectangle(3, 4))` returns `None` |\n| `reverseGet constructs the variant` | `Shape.optics.circle.reverseGet(Circle(5.0))` returns `Circle(5.0)` typed as `Shape` |\n| `prism for case object` | `Shape.optics.point.getOption(Point)` returns `Some(Point)` |\n| `prism names are lower-cased` | Accessor is `circle`, not `Circle` |\n| `nested sealed traits` | Prisms compose correctly |\n| `enum simple cases` (Scala 3) | Parameterless enum cases work |\n| `enum parameterized cases` (Scala 3) | Enum cases with fields work |\n| `sealed trait with type parameters` | `Result.optics.success[Int]` returns `Prism[Result[Int], Success[Int]]` |\n\n### Composition Tests\n\n| Test Case | Description |\n|-----------|-------------|\n| `lens andThen lens` | Nested field access works |\n| `prism andThen lens` | Access field inside a variant |\n| `lens andThen prism` | Access variant inside a field |\n| `prism andThen prism` | Nested variant access |\n\n### Traversal Tests\n\n| Test Case | Description |\n|-----------|-------------|\n| `traverse list field` | Combine lens with list traversal |\n| `traverse option field` | Combine lens with optional |\n| `traverse nested collections` | `List[Option[A]]` traversal |\n\n### Caching Tests\n\n| Test Case | Description |\n|-----------|-------------|\n| `optics object is cached (referential equality)` | `Person.optics eq Person.optics` is `true` |\n| `lens from cached optics is stable` | `Person.optics.name eq Person.optics.name` is `true` |\n| `concurrent access returns same instance` | 100 concurrent calls all return same object |\n| `no allocation on repeated access` | Benchmark or allocation tracking |\n\n### Type Safety Tests\n\n| Test Case | Description |\n|-----------|-------------|\n| `lens has correct static type` | `val x: Lens[Person, String] = Person.optics.name` compiles |\n| `prism has correct static type` | `val x: Prism[Shape, Circle] = Shape.optics.circle` compiles |\n| `nonexistent field does not compile` | `Person.optics.nonexistent` fails at compile time |\n| `wrong type annotation does not compile` | `val x: Lens[Person, Int] = Person.optics.name` fails |\n| `IDE completion works` | (Manual verification) Structural type provides completion |\n\n### Edge Cases\n\n| Test Case | Description |\n|-----------|-------------|\n| `underscore variant avoids collision` | `DerivedOptics_` prefixes with `_` |\n| `field named \"optics\"` | Does not conflict with `optics` method |\n| `deeply nested structures (5+ levels)` | Performance is acceptable |\n| `recursive types` | `case class Tree(children: List[Tree])` works |\n| `mutually recursive types` | `A` references `B`, `B` references `A` |\n| `case class with default parameters` | Optics work correctly |\n| `case class with lazy val` | Only constructor params become lenses |\n| `case class with var` | Only val params become lenses |\n\n### Cross-Platform Tests\n\n| Platform | Requirement |\n|----------|-------------|\n| JVM | All tests pass |\n| Scala.js | All tests pass |\n| Scala Native | All tests pass (if supported) |\n\n---\n\n## Implementation Checklist\n\n- [ ] `DerivedOptics[T]` trait implemented for Scala 2.13\n- [ ] `DerivedOptics[T]` trait implemented for Scala 3.5+\n- [ ] `DerivedOptics_[T]` underscore variant for both versions\n- [ ] Caching mechanism implemented and tested\n- [ ] All Lens tests passing\n- [ ] All Prism tests passing  \n- [ ] All Composition tests passing\n- [ ] All Traversal tests passing\n- [ ] All Caching tests passing\n- [ ] All Type Safety tests passing\n- [ ] All Edge Case tests passing\n- [ ] JVM tests passing\n- [ ] Scala.js tests passing\n- [ ] Documentation updated with usage examples",
              "url": "https://github.com/zio/zio-blocks/issues/514",
              "tech": [],
              "repo_name": "zio-blocks",
              "repo_owner": "zio",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "ZIO#3697",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "ZIO",
              "id": "generated-ZIO",
              "name": "ZIO",
              "description": "",
              "members": [],
              "display_name": "ZIO",
              "created_at": "2025-12-30T19:50:15.970Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/ZIO?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "zio",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2025-12-30T19:50:15.971Z",
            "created_at": "2025-12-30T19:50:15.971Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-ZIO#3697",
              "status": "open",
              "type": "issue",
              "number": 3697,
              "title": "Datastar requests from Endpoint",
              "source": {
                "data": {
                  "id": "source-ZIO#3697",
                  "user": {
                    "login": "987Nabil",
                    "id": 7283535,
                    "node_id": "MDQ6VXNlcjcyODM1MzU=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/7283535?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/987Nabil",
                    "html_url": "https://github.com/987Nabil",
                    "followers_url": "https://api.github.com/users/987Nabil/followers",
                    "following_url": "https://api.github.com/users/987Nabil/following{/other_user}",
                    "gists_url": "https://api.github.com/users/987Nabil/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/987Nabil/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/987Nabil/subscriptions",
                    "organizations_url": "https://api.github.com/users/987Nabil/orgs",
                    "repos_url": "https://api.github.com/users/987Nabil/repos",
                    "events_url": "https://api.github.com/users/987Nabil/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/987Nabil/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Datastar requests from Endpoint",
                  "body": "Build Datastar expressions for request against an Endpoint from its definition\n",
                  "html_url": "https://github.com/zio/zio-http/issues/3697"
                },
                "type": "github"
              },
              "hash": "zio/zio-http#3697",
              "body": "Build Datastar expressions for request against an Endpoint from its definition\n",
              "url": "https://github.com/zio/zio-http/issues/3697",
              "tech": [],
              "repo_name": "zio-http",
              "repo_owner": "zio",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "ZIO#709",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "ZIO",
              "id": "generated-ZIO",
              "name": "ZIO",
              "description": "",
              "members": [],
              "display_name": "ZIO",
              "created_at": "2025-12-30T19:50:16.508Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/ZIO?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "zio",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2025-12-30T19:50:16.508Z",
            "created_at": "2025-12-30T19:50:16.508Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-ZIO#709",
              "status": "open",
              "type": "issue",
              "number": 709,
              "title": "Support Http Range header on request for Files",
              "source": {
                "data": {
                  "id": "source-ZIO#709",
                  "user": {
                    "login": "ashprakasan",
                    "id": 8946971,
                    "node_id": "MDQ6VXNlcjg5NDY5NzE=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/8946971?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/ashprakasan",
                    "html_url": "https://github.com/ashprakasan",
                    "followers_url": "https://api.github.com/users/ashprakasan/followers",
                    "following_url": "https://api.github.com/users/ashprakasan/following{/other_user}",
                    "gists_url": "https://api.github.com/users/ashprakasan/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/ashprakasan/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/ashprakasan/subscriptions",
                    "organizations_url": "https://api.github.com/users/ashprakasan/orgs",
                    "repos_url": "https://api.github.com/users/ashprakasan/repos",
                    "events_url": "https://api.github.com/users/ashprakasan/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/ashprakasan/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Support Http Range header on request for Files",
                  "body": "**Is your feature request related to a problem? Please describe.**\r\n\r\nThe Range HTTP request header indicates the part of a document that the server should return. Several parts can be requested with one Range header at once, and the server may send back these ranges in a multipart document.\r\n\r\n**Describe the solution you'd like**\r\n\r\nExample requesting 3 ranges from files -\r\n`Range: bytes=200-1000, 2000-6576, 19000-`\r\n\r\nSend only those parts of the document in Response.\r\n\r\n**Describe alternatives you've considered**\r\n\r\nCurrently, the range is hardcoded as follows - \r\n` ctx.write(new DefaultFileRegion(raf.getChannel, 0, fileLength))`\r\nManipulate the positions as per request headers instead.\r\n\r\n**Additional context**\r\n\r\nhttps://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Range\r\n",
                  "html_url": "https://github.com/zio/zio-http/issues/709"
                },
                "type": "github"
              },
              "hash": "zio/zio-http#709",
              "body": "**Is your feature request related to a problem? Please describe.**\r\n\r\nThe Range HTTP request header indicates the part of a document that the server should return. Several parts can be requested with one Range header at once, and the server may send back these ranges in a multipart document.\r\n\r\n**Describe the solution you'd like**\r\n\r\nExample requesting 3 ranges from files -\r\n`Range: bytes=200-1000, 2000-6576, 19000-`\r\n\r\nSend only those parts of the document in Response.\r\n\r\n**Describe alternatives you've considered**\r\n\r\nCurrently, the range is hardcoded as follows - \r\n` ctx.write(new DefaultFileRegion(raf.getChannel, 0, fileLength))`\r\nManipulate the positions as per request headers instead.\r\n\r\n**Additional context**\r\n\r\nhttps://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Range\r\n",
              "url": "https://github.com/zio/zio-http/issues/709",
              "tech": [],
              "repo_name": "zio-http",
              "repo_owner": "zio",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "ZIO#3472",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "ZIO",
              "id": "generated-ZIO",
              "name": "ZIO",
              "description": "",
              "members": [],
              "display_name": "ZIO",
              "created_at": "2025-12-30T19:50:17.753Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/ZIO?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "zio",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2025-12-30T19:50:17.753Z",
            "created_at": "2025-12-30T19:50:17.753Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-ZIO#3472",
              "status": "open",
              "type": "issue",
              "number": 3472,
              "title": "Split into multiple modules",
              "source": {
                "data": {
                  "id": "source-ZIO#3472",
                  "user": {
                    "login": "987Nabil",
                    "id": 7283535,
                    "node_id": "MDQ6VXNlcjcyODM1MzU=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/7283535?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/987Nabil",
                    "html_url": "https://github.com/987Nabil",
                    "followers_url": "https://api.github.com/users/987Nabil/followers",
                    "following_url": "https://api.github.com/users/987Nabil/following{/other_user}",
                    "gists_url": "https://api.github.com/users/987Nabil/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/987Nabil/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/987Nabil/subscriptions",
                    "organizations_url": "https://api.github.com/users/987Nabil/orgs",
                    "repos_url": "https://api.github.com/users/987Nabil/repos",
                    "events_url": "https://api.github.com/users/987Nabil/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/987Nabil/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Split into multiple modules",
                  "body": "Currently, the zio-http artifact contains a lot of different parts of zio-http exclusively. They are not separate maven artifacts.\n\nWe want to change this, to support future changes/features.\n\nThere should be at least these modules that are published into maven. \n\n1. core\n2. endpoint\n3. netty\n\nShould we have client and server in different modules?",
                  "html_url": "https://github.com/zio/zio-http/issues/3472"
                },
                "type": "github"
              },
              "hash": "zio/zio-http#3472",
              "body": "Currently, the zio-http artifact contains a lot of different parts of zio-http exclusively. They are not separate maven artifacts.\n\nWe want to change this, to support future changes/features.\n\nThere should be at least these modules that are published into maven. \n\n1. core\n2. endpoint\n3. netty\n\nShould we have client and server in different modules?",
              "url": "https://github.com/zio/zio-http/issues/3472",
              "tech": [],
              "repo_name": "zio-http",
              "repo_owner": "zio",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "activepieces#10618",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "activepieces",
              "id": "generated-activepieces",
              "name": "Activepieces",
              "description": "",
              "members": [],
              "display_name": "Activepieces",
              "created_at": "2025-12-30T19:50:39.107Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/activepieces?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "activepieces",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2025-12-30T19:50:39.107Z",
            "created_at": "2025-12-30T19:50:39.107Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-activepieces#10618",
              "status": "open",
              "type": "issue",
              "number": 10618,
              "title": "Native AI Selector",
              "source": {
                "data": {
                  "id": "source-activepieces#10618",
                  "user": {
                    "login": "abuaboud",
                    "id": 1812998,
                    "node_id": "MDQ6VXNlcjE4MTI5OTg=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1812998?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/abuaboud",
                    "html_url": "https://github.com/abuaboud",
                    "followers_url": "https://api.github.com/users/abuaboud/followers",
                    "following_url": "https://api.github.com/users/abuaboud/following{/other_user}",
                    "gists_url": "https://api.github.com/users/abuaboud/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/abuaboud/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/abuaboud/subscriptions",
                    "organizations_url": "https://api.github.com/users/abuaboud/orgs",
                    "repos_url": "https://api.github.com/users/abuaboud/repos",
                    "events_url": "https://api.github.com/users/abuaboud/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/abuaboud/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "Native AI Selector",
                  "body": "<br>In the Flow Builder, the current shape design looks very basic. We would like to revamp it to improve the visual quality and match the new design.<br>\n\n## Current State\n\nThe shape is simple and lacks visual polish.\n\n<img src=\"https://uploads.linear.app/31a22bcc-cf6d-4d14-99c3-7f5b856dd10f/c2c9f1ef-1aa1-4c5d-a502-aec7fc20f5f1/d547bade-f286-4591-9d65-3fcd3f3d8420?signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJwYXRoIjoiLzMxYTIyYmNjLWNmNmQtNGQxNC05OWMzLTdmNWI4NTZkZDEwZi9jMmM5ZjFlZi0xYWExLTRjNWQtYTUwMi1hZWM3ZmMyMGY1ZjEvZDU0N2JhZGUtZjI4Ni00NTkxLTlkNjUtM2ZjZDNmM2Q4NDIwIiwiaWF0IjoxNzY2NjUzMTgxLCJleHAiOjE3OTgyMjM3NDF9.bn08HPH8t8hcuSIG-23eYe0zvBG3MLifX8Bh3eUSZYc \" alt=\"image.png\" width=\"725\" data-linear-height=\"556\" />\n\n## New State\n\n<br>Update the shape to match the new design shown in the Figma prototype:<br><br>[https://www.figma.com/proto/MvGDWYULNEs3c3UVwhg9G5/AI-Pieces-Selector?page-id=102%3A11175&node-id=176-548&p=f&t=OT6EYu3U3akLXB1z-1&scaling=min-zoom&content-scaling=fixed&starting-point-node-id=176%3A548](https://www.figma.com/proto/MvGDWYULNEs3c3UVwhg9G5/AI-Pieces-Selector?page-id=102%3A11175&node-id=176-548&p=f&t=OT6EYu3U3akLXB1z-1&scaling=min-zoom&content-scaling=fixed&starting-point-node-id=176%3A548)<br>\n\n## **Implementation Details**\n\n* **Code location:**<br>`packages/react-ui/src/app/builder/pieces-selector/ai-tab-content`\n* Ensure the **height stays the same for both tabs**.\n* Only the visual design should change; behavior should remain unchanged.\n* The text for each action is inside the action metadata (description field)\n* Here is videos link\n  * [https://cdn.activepieces.com/pieces/ai/native/ai-agents.mp4](https://cdn.activepieces.com/pieces/ai/native/ai-agents.mp4)\n  * [https://cdn.activepieces.com/pieces/ai/native/ask-ai.mp4](https://cdn.activepieces.com/pieces/ai/native/ask-ai.mp4)\n  * [https://cdn.activepieces.com/pieces/ai/native/classify-text.mp4](https://cdn.activepieces.com/pieces/ai/native/classify-text.mp4)\n  * [https://cdn.activepieces.com/pieces/ai/native/generate-images.mp4](https://cdn.activepieces.com/pieces/ai/native/generate-images.mp4)\n  * [https://cdn.activepieces.com/pieces/ai/native/ocr.mp4](https://cdn.activepieces.com/pieces/ai/native/ocr.mp4)\n  * [https://cdn.activepieces.com/pieces/ai/native/summarize-text.mp4](https://cdn.activepieces.com/pieces/ai/native/summarize-text.mp4)",
                  "html_url": "https://github.com/activepieces/activepieces/issues/10618"
                },
                "type": "github"
              },
              "hash": "activepieces/activepieces#10618",
              "body": "<br>In the Flow Builder, the current shape design looks very basic. We would like to revamp it to improve the visual quality and match the new design.<br>\n\n## Current State\n\nThe shape is simple and lacks visual polish.\n\n<img src=\"https://uploads.linear.app/31a22bcc-cf6d-4d14-99c3-7f5b856dd10f/c2c9f1ef-1aa1-4c5d-a502-aec7fc20f5f1/d547bade-f286-4591-9d65-3fcd3f3d8420?signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJwYXRoIjoiLzMxYTIyYmNjLWNmNmQtNGQxNC05OWMzLTdmNWI4NTZkZDEwZi9jMmM5ZjFlZi0xYWExLTRjNWQtYTUwMi1hZWM3ZmMyMGY1ZjEvZDU0N2JhZGUtZjI4Ni00NTkxLTlkNjUtM2ZjZDNmM2Q4NDIwIiwiaWF0IjoxNzY2NjUzMTgxLCJleHAiOjE3OTgyMjM3NDF9.bn08HPH8t8hcuSIG-23eYe0zvBG3MLifX8Bh3eUSZYc \" alt=\"image.png\" width=\"725\" data-linear-height=\"556\" />\n\n## New State\n\n<br>Update the shape to match the new design shown in the Figma prototype:<br><br>[https://www.figma.com/proto/MvGDWYULNEs3c3UVwhg9G5/AI-Pieces-Selector?page-id=102%3A11175&node-id=176-548&p=f&t=OT6EYu3U3akLXB1z-1&scaling=min-zoom&content-scaling=fixed&starting-point-node-id=176%3A548](https://www.figma.com/proto/MvGDWYULNEs3c3UVwhg9G5/AI-Pieces-Selector?page-id=102%3A11175&node-id=176-548&p=f&t=OT6EYu3U3akLXB1z-1&scaling=min-zoom&content-scaling=fixed&starting-point-node-id=176%3A548)<br>\n\n## **Implementation Details**\n\n* **Code location:**<br>`packages/react-ui/src/app/builder/pieces-selector/ai-tab-content`\n* Ensure the **height stays the same for both tabs**.\n* Only the visual design should change; behavior should remain unchanged.\n* The text for each action is inside the action metadata (description field)\n* Here is videos link\n  * [https://cdn.activepieces.com/pieces/ai/native/ai-agents.mp4](https://cdn.activepieces.com/pieces/ai/native/ai-agents.mp4)\n  * [https://cdn.activepieces.com/pieces/ai/native/ask-ai.mp4](https://cdn.activepieces.com/pieces/ai/native/ask-ai.mp4)\n  * [https://cdn.activepieces.com/pieces/ai/native/classify-text.mp4](https://cdn.activepieces.com/pieces/ai/native/classify-text.mp4)\n  * [https://cdn.activepieces.com/pieces/ai/native/generate-images.mp4](https://cdn.activepieces.com/pieces/ai/native/generate-images.mp4)\n  * [https://cdn.activepieces.com/pieces/ai/native/ocr.mp4](https://cdn.activepieces.com/pieces/ai/native/ocr.mp4)\n  * [https://cdn.activepieces.com/pieces/ai/native/summarize-text.mp4](https://cdn.activepieces.com/pieces/ai/native/summarize-text.mp4)",
              "url": "https://github.com/activepieces/activepieces/issues/10618",
              "tech": [],
              "repo_name": "activepieces",
              "repo_owner": "activepieces",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "activepieces#9703",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "activepieces",
              "id": "generated-activepieces",
              "name": "Activepieces",
              "description": "",
              "members": [],
              "display_name": "Activepieces",
              "created_at": "2025-12-30T19:50:39.278Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/activepieces?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "activepieces",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2025-12-30T19:50:39.278Z",
            "created_at": "2025-12-30T19:50:39.278Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-activepieces#9703",
              "status": "open",
              "type": "issue",
              "number": 9703,
              "title": "[MCP] Oracle Fusion Cloud ERP",
              "source": {
                "data": {
                  "id": "source-activepieces#9703",
                  "user": {
                    "login": "kishanprmr",
                    "id": 135701940,
                    "node_id": "U_kgDOCBaltA",
                    "avatar_url": "https://avatars.githubusercontent.com/u/135701940?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/kishanprmr",
                    "html_url": "https://github.com/kishanprmr",
                    "followers_url": "https://api.github.com/users/kishanprmr/followers",
                    "following_url": "https://api.github.com/users/kishanprmr/following{/other_user}",
                    "gists_url": "https://api.github.com/users/kishanprmr/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/kishanprmr/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/kishanprmr/subscriptions",
                    "organizations_url": "https://api.github.com/users/kishanprmr/orgs",
                    "repos_url": "https://api.github.com/users/kishanprmr/repos",
                    "events_url": "https://api.github.com/users/kishanprmr/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/kishanprmr/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "[MCP] Oracle Fusion Cloud ERP",
                  "body": "## â€‹ ðŸ§© Product Overview\n\nOracle Fusion Cloud ERP is an enterprise resource planning suite covering financials, procurement, project accounting, supply chain, and more. This integration supports generic record operations (CRUD + search + watch) across business objects in Fusion ERP, enabling automation and data synchronization. \n\n---\n\n## â€‹â€‹ âš ï¸ Important Note for Contributors\n\nThis feature must be submitted as a [Piece](https://www.activepieces.com/docs/developers/building-pieces/piece-definition) following the Activepieces architecture. Submissions not following this format will not be accepted. Please make sure to review the [Piece Development Guidelines](https://www.activepieces.com/docs/developers/building-pieces/overview) before starting development.\n\n---\n\n## ðŸš¨ Triggers\n\n| **Trigger** | **Description** | \n|:--|:--|\n| **New Record** | Fires when new records are created in a specified business object (e.g. Invoice, Purchase Order, Customer) in Oracle ERP. | \n\n\n---\n\n## â€‹â€‹ ðŸ› ï¸ Write Actions\n\n| **Action** | **Description** | **Use Case Example** |\n|:--|:--|:--|\n| **Create Record**     | Create a new record in a specified object (e.g. Invoice, PO, Customer). | Automate creating purchase orders from purchase requests.  |\n| **Update Record**     | Update fields of an existing record (by object + ID).                      | Update invoice status, adjust amounts, modify due dates. |\n| **Delete a Record**    | Delete (or mark for deletion) a record by ID.                             | Remove test or obsolete records.  |\n| **Get a Record**     | Retrieve the details of a specific record (by object type and ID). | Fetch detailed invoice or supplier info when needed.  |\n\n\n\n---\n\n## ðŸ” Search Actions\n\n| Action Name       | Description                                                                 | \n|--------------------|-----------------------------------------------------------------------------|\n| **Search Records**   | Retrieve a list of records matching filter criteria (object + query). |\n\n---\n\n## â€‹ ðŸ“š API Reference\n\n- [Oracle Fusion Cloud ERP API Documentation](https://docs.oracle.com/en/cloud/saas/financials/25d/farfa/index.html)\n\n---\n\n## â€‹ ðŸ§ª Test Account Access\n\n- You can create free trial at https://www.oracle.com/in/erp/financials/.\n\n---\n\n## â€‹â€‹â€‹ðŸ§‘â€ðŸ’» New to Activepieces?\n\nActivepieces is the leading open source AI automation platform. We have many apps (we call them Pieces), that are available within the builder and as MCPs. These apps are build with our TypeScript framework and are easy to build. Once they're merged to our repo, they will available as pieces in our automation builder and as MCPs to be used with AI agents and MCP clients.\n\nWe welcome contributions and in fact, we get excited over them. Start your journey here: https://www.activepieces.com/docs/developers/building-pieces/overview\n",
                  "html_url": "https://github.com/activepieces/activepieces/issues/9703"
                },
                "type": "github"
              },
              "hash": "activepieces/activepieces#9703",
              "body": "## â€‹ ðŸ§© Product Overview\n\nOracle Fusion Cloud ERP is an enterprise resource planning suite covering financials, procurement, project accounting, supply chain, and more. This integration supports generic record operations (CRUD + search + watch) across business objects in Fusion ERP, enabling automation and data synchronization. \n\n---\n\n## â€‹â€‹ âš ï¸ Important Note for Contributors\n\nThis feature must be submitted as a [Piece](https://www.activepieces.com/docs/developers/building-pieces/piece-definition) following the Activepieces architecture. Submissions not following this format will not be accepted. Please make sure to review the [Piece Development Guidelines](https://www.activepieces.com/docs/developers/building-pieces/overview) before starting development.\n\n---\n\n## ðŸš¨ Triggers\n\n| **Trigger** | **Description** | \n|:--|:--|\n| **New Record** | Fires when new records are created in a specified business object (e.g. Invoice, Purchase Order, Customer) in Oracle ERP. | \n\n\n---\n\n## â€‹â€‹ ðŸ› ï¸ Write Actions\n\n| **Action** | **Description** | **Use Case Example** |\n|:--|:--|:--|\n| **Create Record**     | Create a new record in a specified object (e.g. Invoice, PO, Customer). | Automate creating purchase orders from purchase requests.  |\n| **Update Record**     | Update fields of an existing record (by object + ID).                      | Update invoice status, adjust amounts, modify due dates. |\n| **Delete a Record**    | Delete (or mark for deletion) a record by ID.                             | Remove test or obsolete records.  |\n| **Get a Record**     | Retrieve the details of a specific record (by object type and ID). | Fetch detailed invoice or supplier info when needed.  |\n\n\n\n---\n\n## ðŸ” Search Actions\n\n| Action Name       | Description                                                                 | \n|--------------------|-----------------------------------------------------------------------------|\n| **Search Records**   | Retrieve a list of records matching filter criteria (object + query). |\n\n---\n\n## â€‹ ðŸ“š API Reference\n\n- [Oracle Fusion Cloud ERP API Documentation](https://docs.oracle.com/en/cloud/saas/financials/25d/farfa/index.html)\n\n---\n\n## â€‹ ðŸ§ª Test Account Access\n\n- You can create free trial at https://www.oracle.com/in/erp/financials/.\n\n---\n\n## â€‹â€‹â€‹ðŸ§‘â€ðŸ’» New to Activepieces?\n\nActivepieces is the leading open source AI automation platform. We have many apps (we call them Pieces), that are available within the builder and as MCPs. These apps are build with our TypeScript framework and are easy to build. Once they're merged to our repo, they will available as pieces in our automation builder and as MCPs to be used with AI agents and MCP clients.\n\nWe welcome contributions and in fact, we get excited over them. Start your journey here: https://www.activepieces.com/docs/developers/building-pieces/overview\n",
              "url": "https://github.com/activepieces/activepieces/issues/9703",
              "tech": [],
              "repo_name": "activepieces",
              "repo_owner": "activepieces",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "activepieces#8284",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "activepieces",
              "id": "generated-activepieces",
              "name": "Activepieces",
              "description": "",
              "members": [],
              "display_name": "Activepieces",
              "created_at": "2025-12-30T19:50:39.463Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/activepieces?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "activepieces",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2025-12-30T19:50:39.463Z",
            "created_at": "2025-12-30T19:50:39.463Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-activepieces#8284",
              "status": "open",
              "type": "issue",
              "number": 8284,
              "title": "[MCP] Klaviyo",
              "source": {
                "data": {
                  "id": "source-activepieces#8284",
                  "user": {
                    "login": "kishanprmr",
                    "id": 135701940,
                    "node_id": "U_kgDOCBaltA",
                    "avatar_url": "https://avatars.githubusercontent.com/u/135701940?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/kishanprmr",
                    "html_url": "https://github.com/kishanprmr",
                    "followers_url": "https://api.github.com/users/kishanprmr/followers",
                    "following_url": "https://api.github.com/users/kishanprmr/following{/other_user}",
                    "gists_url": "https://api.github.com/users/kishanprmr/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/kishanprmr/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/kishanprmr/subscriptions",
                    "organizations_url": "https://api.github.com/users/kishanprmr/orgs",
                    "repos_url": "https://api.github.com/users/kishanprmr/repos",
                    "events_url": "https://api.github.com/users/kishanprmr/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/kishanprmr/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "[MCP] Klaviyo",
                  "body": "## ðŸ§© Product Overview\n\nKlaviyo is a marketing automation platform for email, SMS, and customer data.  \nThis integration enables AI agents and workflows to create, manage, and interact with profiles, lists, events, campaigns, and segments, automating customer engagement and analytics.\n\n---\n\n## âš ï¸ Important Note for Contributors\n\nTo ensure consistency and maintainability, this feature must be submitted as a [Piece](https://www.activepieces.com/docs/developers/building-pieces/piece-definition) following the Activepieces architecture. Submissions that do not follow this format will not be accepted. Please make sure to review the [Piece Development Guidelines](https://www.activepieces.com/docs/developers/building-pieces/overview) before starting development.\n\n---\n\n## ðŸš¨ Triggers\n\n| **Trigger** | **Use Case** |\n|-------------|---------------|\n| **New Profile** | Triggers when a new profile is created in the account. |\n| **Profile Added to List/Segment** | Fires when a profile is added to a specific list or segment. |\n\n---\n\n## ðŸ› ï¸ Write Actions\n\n| **Action Item** | **Use Case** |\n|-----------------|---------------|\n| **Create Profile** | Add a new user profile to Klaviyo, optionally subscribing to email/SMS. |\n| **Update Profile** | Update existing profile data and preferences. |\n| **Subscribe Profile** | Subscribe a profile to email or SMS lists. |\n| **Unsubscribe Profile** | Remove a profile from email or SMS lists. |\n| **Add Profile to List** | Add a profile to a specific list. |\n| **Remove Profile from List** | Remove a profile from a specific list. |\n| **Create List** | Create a new subscriber list. |\n\n---\n\n## ðŸ” Search Actions\n\n| **Action Item** | **Use Case** |\n|-----------------|---------------|\n| **Find Profile by Email/Phone** | Locate a profile using email or phone number. |\n| **Find List by Name** | Look up a list by name to get its ID. |\n| **Find Tag by Name** | Locate a tag to manage tagging workflows. |\n\n---\n\n## ðŸ“š API Reference\n\n- [Official Klaviyo API Documentation](https://developers.klaviyo.com/en/reference)\n\n---\n\n## ðŸ§ª Test Account Access\n\nYou can test Klaviyo APIs by creating a free account on [Klaviyo](https://www.klaviyo.com/) and generating a private API key from your account settings.\n\n---\n\n## ðŸ§‘â€ðŸ’» New to Activepieces?\n\nActivepieces is the leading open source AI automation platform. We have many apps (we call them Pieces), that are available within the builder and as MCPs. These apps are built with our TypeScript framework and are easy to develop. Once merged into our repository, they become available as pieces in our automation builder and as MCPs usable by AI agents and MCP clients.\n\nStart building here: [Piece Development Docs](https://www.activepieces.com/docs/developers/building-pieces/overview)\n",
                  "html_url": "https://github.com/activepieces/activepieces/issues/8284"
                },
                "type": "github"
              },
              "hash": "activepieces/activepieces#8284",
              "body": "## ðŸ§© Product Overview\n\nKlaviyo is a marketing automation platform for email, SMS, and customer data.  \nThis integration enables AI agents and workflows to create, manage, and interact with profiles, lists, events, campaigns, and segments, automating customer engagement and analytics.\n\n---\n\n## âš ï¸ Important Note for Contributors\n\nTo ensure consistency and maintainability, this feature must be submitted as a [Piece](https://www.activepieces.com/docs/developers/building-pieces/piece-definition) following the Activepieces architecture. Submissions that do not follow this format will not be accepted. Please make sure to review the [Piece Development Guidelines](https://www.activepieces.com/docs/developers/building-pieces/overview) before starting development.\n\n---\n\n## ðŸš¨ Triggers\n\n| **Trigger** | **Use Case** |\n|-------------|---------------|\n| **New Profile** | Triggers when a new profile is created in the account. |\n| **Profile Added to List/Segment** | Fires when a profile is added to a specific list or segment. |\n\n---\n\n## ðŸ› ï¸ Write Actions\n\n| **Action Item** | **Use Case** |\n|-----------------|---------------|\n| **Create Profile** | Add a new user profile to Klaviyo, optionally subscribing to email/SMS. |\n| **Update Profile** | Update existing profile data and preferences. |\n| **Subscribe Profile** | Subscribe a profile to email or SMS lists. |\n| **Unsubscribe Profile** | Remove a profile from email or SMS lists. |\n| **Add Profile to List** | Add a profile to a specific list. |\n| **Remove Profile from List** | Remove a profile from a specific list. |\n| **Create List** | Create a new subscriber list. |\n\n---\n\n## ðŸ” Search Actions\n\n| **Action Item** | **Use Case** |\n|-----------------|---------------|\n| **Find Profile by Email/Phone** | Locate a profile using email or phone number. |\n| **Find List by Name** | Look up a list by name to get its ID. |\n| **Find Tag by Name** | Locate a tag to manage tagging workflows. |\n\n---\n\n## ðŸ“š API Reference\n\n- [Official Klaviyo API Documentation](https://developers.klaviyo.com/en/reference)\n\n---\n\n## ðŸ§ª Test Account Access\n\nYou can test Klaviyo APIs by creating a free account on [Klaviyo](https://www.klaviyo.com/) and generating a private API key from your account settings.\n\n---\n\n## ðŸ§‘â€ðŸ’» New to Activepieces?\n\nActivepieces is the leading open source AI automation platform. We have many apps (we call them Pieces), that are available within the builder and as MCPs. These apps are built with our TypeScript framework and are easy to develop. Once merged into our repository, they become available as pieces in our automation builder and as MCPs usable by AI agents and MCP clients.\n\nStart building here: [Piece Development Docs](https://www.activepieces.com/docs/developers/building-pieces/overview)\n",
              "url": "https://github.com/activepieces/activepieces/issues/8284",
              "tech": [],
              "repo_name": "activepieces",
              "repo_owner": "activepieces",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "activepieces#8135",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "activepieces",
              "id": "generated-activepieces",
              "name": "Activepieces",
              "description": "",
              "members": [],
              "display_name": "Activepieces",
              "created_at": "2025-12-30T19:50:39.632Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/activepieces?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "activepieces",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2025-12-30T19:50:39.632Z",
            "created_at": "2025-12-30T19:50:39.632Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-activepieces#8135",
              "status": "open",
              "type": "issue",
              "number": 8135,
              "title": "[MCP] Canva",
              "source": {
                "data": {
                  "id": "source-activepieces#8135",
                  "user": {
                    "login": "kishanprmr",
                    "id": 135701940,
                    "node_id": "U_kgDOCBaltA",
                    "avatar_url": "https://avatars.githubusercontent.com/u/135701940?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/kishanprmr",
                    "html_url": "https://github.com/kishanprmr",
                    "followers_url": "https://api.github.com/users/kishanprmr/followers",
                    "following_url": "https://api.github.com/users/kishanprmr/following{/other_user}",
                    "gists_url": "https://api.github.com/users/kishanprmr/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/kishanprmr/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/kishanprmr/subscriptions",
                    "organizations_url": "https://api.github.com/users/kishanprmr/orgs",
                    "repos_url": "https://api.github.com/users/kishanprmr/repos",
                    "events_url": "https://api.github.com/users/kishanprmr/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/kishanprmr/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "[MCP] Canva",
                  "body": "## ðŸ§© Product Overview  \n\nCanva is an online design platform that enables users to create visual content like social graphics, presentations, and posters. This integration empowers automation builders and AI agents to streamline tasks such as design creation, asset uploads, exports, folder organization, and more.\n\n---\n\n## âš ï¸ Important Note for Contributors  \n\nTo ensure consistency and maintainability, this feature must be submitted as a [Piece](https://www.activepieces.com/docs/developers/building-pieces/piece-definition) following the Activepieces architecture. Submissions that do not follow this format will not be accepted. Please make sure to review the [Piece Development Guidelines](https://www.activepieces.com/docs/developers/building-pieces/overview) before starting development.\n\n---\n\n## ðŸ› ï¸ Write Actions  \n\n| **Action Item**               | **Use Case** |\n|:--------------------------|:---------------------------------------|\n| **Upload Asset** | Auto-upload brand assets when a campaign starts. |\n| **Create Design** | Automatically generate Instagram templates on new blog posts.|\n| **Import Design** | Convert user-submitted PDFs into editable Canva designs. |\n|**Export Design**| Export a brochure as a PDF and save it.|\n|**Move Folder Item**| Organize completed designs into an â€œArchiveâ€ folder.|\n\n---\n\n## ðŸ” Search Actions  \n\n| **Action Item**               | **Use Case**                                                                                                                                     |\n|:------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------|\n| **Find Design** | Ensure a design doesnâ€™t already exist before creation.|\n\n---\n\n## ðŸ“– Read Actions\n\n| **Action Item**               | **Use Case**                                                                                                                                     |\n|:------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------|\n| **Get a Folder** | Retrieves details about an existing folder.|\n|**Get an Image**| Retrieves details about an existing image.|\n\n---\n\n## ðŸ“š API Reference  \n- [Official Canva API Documentation](https://www.canva.dev/docs/connect/api-reference/designs/create-design/)\n\n---\n\n## ðŸ§ª Test Account Access  \nYou can sign up for a free account at https://www.canva.com/en_in/.\n\n---\n\n## ðŸ§‘â€ðŸ’» New to Activepieces?\n\nActivepieces is the leading open source AI automation platform. We have many apps (we call them Pieces), that are available within the builder and as MCPs. These apps are built with our TypeScript framework and are easy to develop. Once merged into our repository, they become available as pieces in our automation builder and as MCPs usable by AI agents and MCP clients.\n\nStart building here: [Piece Development Docs](https://www.activepieces.com/docs/developers/building-pieces/overview)\n",
                  "html_url": "https://github.com/activepieces/activepieces/issues/8135"
                },
                "type": "github"
              },
              "hash": "activepieces/activepieces#8135",
              "body": "## ðŸ§© Product Overview  \n\nCanva is an online design platform that enables users to create visual content like social graphics, presentations, and posters. This integration empowers automation builders and AI agents to streamline tasks such as design creation, asset uploads, exports, folder organization, and more.\n\n---\n\n## âš ï¸ Important Note for Contributors  \n\nTo ensure consistency and maintainability, this feature must be submitted as a [Piece](https://www.activepieces.com/docs/developers/building-pieces/piece-definition) following the Activepieces architecture. Submissions that do not follow this format will not be accepted. Please make sure to review the [Piece Development Guidelines](https://www.activepieces.com/docs/developers/building-pieces/overview) before starting development.\n\n---\n\n## ðŸ› ï¸ Write Actions  \n\n| **Action Item**               | **Use Case** |\n|:--------------------------|:---------------------------------------|\n| **Upload Asset** | Auto-upload brand assets when a campaign starts. |\n| **Create Design** | Automatically generate Instagram templates on new blog posts.|\n| **Import Design** | Convert user-submitted PDFs into editable Canva designs. |\n|**Export Design**| Export a brochure as a PDF and save it.|\n|**Move Folder Item**| Organize completed designs into an â€œArchiveâ€ folder.|\n\n---\n\n## ðŸ” Search Actions  \n\n| **Action Item**               | **Use Case**                                                                                                                                     |\n|:------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------|\n| **Find Design** | Ensure a design doesnâ€™t already exist before creation.|\n\n---\n\n## ðŸ“– Read Actions\n\n| **Action Item**               | **Use Case**                                                                                                                                     |\n|:------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------|\n| **Get a Folder** | Retrieves details about an existing folder.|\n|**Get an Image**| Retrieves details about an existing image.|\n\n---\n\n## ðŸ“š API Reference  \n- [Official Canva API Documentation](https://www.canva.dev/docs/connect/api-reference/designs/create-design/)\n\n---\n\n## ðŸ§ª Test Account Access  \nYou can sign up for a free account at https://www.canva.com/en_in/.\n\n---\n\n## ðŸ§‘â€ðŸ’» New to Activepieces?\n\nActivepieces is the leading open source AI automation platform. We have many apps (we call them Pieces), that are available within the builder and as MCPs. These apps are built with our TypeScript framework and are easy to develop. Once merged into our repository, they become available as pieces in our automation builder and as MCPs usable by AI agents and MCP clients.\n\nStart building here: [Piece Development Docs](https://www.activepieces.com/docs/developers/building-pieces/overview)\n",
              "url": "https://github.com/activepieces/activepieces/issues/8135",
              "tech": [],
              "repo_name": "activepieces",
              "repo_owner": "activepieces",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "activepieces#8135",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "activepieces",
              "id": "generated-activepieces",
              "name": "Activepieces",
              "description": "",
              "members": [],
              "display_name": "Activepieces",
              "created_at": "2025-12-30T19:50:39.650Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/activepieces?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "activepieces",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2025-12-30T19:50:39.650Z",
            "created_at": "2025-12-30T19:50:39.650Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-activepieces#8135",
              "status": "open",
              "type": "issue",
              "number": 8135,
              "title": "[MCP] Canva",
              "source": {
                "data": {
                  "id": "source-activepieces#8135",
                  "user": {
                    "login": "kishanprmr",
                    "id": 135701940,
                    "node_id": "U_kgDOCBaltA",
                    "avatar_url": "https://avatars.githubusercontent.com/u/135701940?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/kishanprmr",
                    "html_url": "https://github.com/kishanprmr",
                    "followers_url": "https://api.github.com/users/kishanprmr/followers",
                    "following_url": "https://api.github.com/users/kishanprmr/following{/other_user}",
                    "gists_url": "https://api.github.com/users/kishanprmr/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/kishanprmr/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/kishanprmr/subscriptions",
                    "organizations_url": "https://api.github.com/users/kishanprmr/orgs",
                    "repos_url": "https://api.github.com/users/kishanprmr/repos",
                    "events_url": "https://api.github.com/users/kishanprmr/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/kishanprmr/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "[MCP] Canva",
                  "body": "## ðŸ§© Product Overview  \n\nCanva is an online design platform that enables users to create visual content like social graphics, presentations, and posters. This integration empowers automation builders and AI agents to streamline tasks such as design creation, asset uploads, exports, folder organization, and more.\n\n---\n\n## âš ï¸ Important Note for Contributors  \n\nTo ensure consistency and maintainability, this feature must be submitted as a [Piece](https://www.activepieces.com/docs/developers/building-pieces/piece-definition) following the Activepieces architecture. Submissions that do not follow this format will not be accepted. Please make sure to review the [Piece Development Guidelines](https://www.activepieces.com/docs/developers/building-pieces/overview) before starting development.\n\n---\n\n## ðŸ› ï¸ Write Actions  \n\n| **Action Item**               | **Use Case** |\n|:--------------------------|:---------------------------------------|\n| **Upload Asset** | Auto-upload brand assets when a campaign starts. |\n| **Create Design** | Automatically generate Instagram templates on new blog posts.|\n| **Import Design** | Convert user-submitted PDFs into editable Canva designs. |\n|**Export Design**| Export a brochure as a PDF and save it.|\n|**Move Folder Item**| Organize completed designs into an â€œArchiveâ€ folder.|\n\n---\n\n## ðŸ” Search Actions  \n\n| **Action Item**               | **Use Case**                                                                                                                                     |\n|:------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------|\n| **Find Design** | Ensure a design doesnâ€™t already exist before creation.|\n\n---\n\n## ðŸ“– Read Actions\n\n| **Action Item**               | **Use Case**                                                                                                                                     |\n|:------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------|\n| **Get a Folder** | Retrieves details about an existing folder.|\n|**Get an Image**| Retrieves details about an existing image.|\n\n---\n\n## ðŸ“š API Reference  \n- [Official Canva API Documentation](https://www.canva.dev/docs/connect/api-reference/designs/create-design/)\n\n---\n\n## ðŸ§ª Test Account Access  \nYou can sign up for a free account at https://www.canva.com/en_in/.\n\n---\n\n## ðŸ§‘â€ðŸ’» New to Activepieces?\n\nActivepieces is the leading open source AI automation platform. We have many apps (we call them Pieces), that are available within the builder and as MCPs. These apps are built with our TypeScript framework and are easy to develop. Once merged into our repository, they become available as pieces in our automation builder and as MCPs usable by AI agents and MCP clients.\n\nStart building here: [Piece Development Docs](https://www.activepieces.com/docs/developers/building-pieces/overview)\n",
                  "html_url": "https://github.com/activepieces/activepieces/issues/8135"
                },
                "type": "github"
              },
              "hash": "activepieces/activepieces#8135",
              "body": "## ðŸ§© Product Overview  \n\nCanva is an online design platform that enables users to create visual content like social graphics, presentations, and posters. This integration empowers automation builders and AI agents to streamline tasks such as design creation, asset uploads, exports, folder organization, and more.\n\n---\n\n## âš ï¸ Important Note for Contributors  \n\nTo ensure consistency and maintainability, this feature must be submitted as a [Piece](https://www.activepieces.com/docs/developers/building-pieces/piece-definition) following the Activepieces architecture. Submissions that do not follow this format will not be accepted. Please make sure to review the [Piece Development Guidelines](https://www.activepieces.com/docs/developers/building-pieces/overview) before starting development.\n\n---\n\n## ðŸ› ï¸ Write Actions  \n\n| **Action Item**               | **Use Case** |\n|:--------------------------|:---------------------------------------|\n| **Upload Asset** | Auto-upload brand assets when a campaign starts. |\n| **Create Design** | Automatically generate Instagram templates on new blog posts.|\n| **Import Design** | Convert user-submitted PDFs into editable Canva designs. |\n|**Export Design**| Export a brochure as a PDF and save it.|\n|**Move Folder Item**| Organize completed designs into an â€œArchiveâ€ folder.|\n\n---\n\n## ðŸ” Search Actions  \n\n| **Action Item**               | **Use Case**                                                                                                                                     |\n|:------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------|\n| **Find Design** | Ensure a design doesnâ€™t already exist before creation.|\n\n---\n\n## ðŸ“– Read Actions\n\n| **Action Item**               | **Use Case**                                                                                                                                     |\n|:------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------|\n| **Get a Folder** | Retrieves details about an existing folder.|\n|**Get an Image**| Retrieves details about an existing image.|\n\n---\n\n## ðŸ“š API Reference  \n- [Official Canva API Documentation](https://www.canva.dev/docs/connect/api-reference/designs/create-design/)\n\n---\n\n## ðŸ§ª Test Account Access  \nYou can sign up for a free account at https://www.canva.com/en_in/.\n\n---\n\n## ðŸ§‘â€ðŸ’» New to Activepieces?\n\nActivepieces is the leading open source AI automation platform. We have many apps (we call them Pieces), that are available within the builder and as MCPs. These apps are built with our TypeScript framework and are easy to develop. Once merged into our repository, they become available as pieces in our automation builder and as MCPs usable by AI agents and MCP clients.\n\nStart building here: [Piece Development Docs](https://www.activepieces.com/docs/developers/building-pieces/overview)\n",
              "url": "https://github.com/activepieces/activepieces/issues/8135",
              "tech": [],
              "repo_name": "activepieces",
              "repo_owner": "activepieces",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "activepieces#8072",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "activepieces",
              "id": "generated-activepieces",
              "name": "Activepieces",
              "description": "",
              "members": [],
              "display_name": "Activepieces",
              "created_at": "2025-12-30T19:50:39.821Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/activepieces?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "activepieces",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2025-12-30T19:50:39.821Z",
            "created_at": "2025-12-30T19:50:39.821Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-activepieces#8072",
              "status": "open",
              "type": "issue",
              "number": 8072,
              "title": "[MCP] Gmail",
              "source": {
                "data": {
                  "id": "source-activepieces#8072",
                  "user": {
                    "login": "kishanprmr",
                    "id": 135701940,
                    "node_id": "U_kgDOCBaltA",
                    "avatar_url": "https://avatars.githubusercontent.com/u/135701940?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/kishanprmr",
                    "html_url": "https://github.com/kishanprmr",
                    "followers_url": "https://api.github.com/users/kishanprmr/followers",
                    "following_url": "https://api.github.com/users/kishanprmr/following{/other_user}",
                    "gists_url": "https://api.github.com/users/kishanprmr/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/kishanprmr/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/kishanprmr/subscriptions",
                    "organizations_url": "https://api.github.com/users/kishanprmr/orgs",
                    "repos_url": "https://api.github.com/users/kishanprmr/repos",
                    "events_url": "https://api.github.com/users/kishanprmr/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/kishanprmr/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "[MCP] Gmail",
                  "body": "## ðŸ§© Product Overview  \n\nGmail is Googleâ€™s email platform for sending, receiving, labeling, archiving, and organizing messages.\nThis integration empowers AI agents and workflows to automate email-based processes, from detection to response, labeling, and thread management.\n\n\n---\n\n## âš ï¸ Important Note for Contributors  \n\nThis Gmail piece already exists in Activepieces. Your task is to extend the current piece by adding additional actions and triggers as outlined in the documentation and reference materials.\nPlease avoid duplicating existing functionality. Review the current implementation before making changes, and ensure that all new features follow existing coding patterns and standards.\n\n---\n\n## ðŸš¨ Triggers  \n\n| **Trigger** | **Use Case** |\n|:--------------------------|:---------------------------------------|\n| **New Starred Email** | Fires when an email is starred (within 2 days).|\n| **New Conversation** | Fires when a new conversation (thread) begins.|\n|**New Attachment**|Fires when an email with an attachment arrives (with optional filters).|\n|**New Label**|Triggers when a new label is created.|\n---\n\n## ðŸ› ï¸ Write Actions  \n\n| **Action Item**               | **Use Case** |\n|:--------------------------|:---------------------------------------|\n| **Reply to Email** | Reply within an existing thread, maintaining context. |\n| **Create Draft Reply** | Generate a reply draft within an existing thread.|\n| **Add Label to Email** | Attach a label to an individual email.|\n|**Remove Label from Email**|Remove a specific label from an email.Remove a specific label from an email.|\n|**Create Label**|Create a new user label in Gmail.|\n|**Archive Email**|Archive (move to â€œAll Mailâ€) rather than deleting.|\n|**Delete Email**|Permanently move an email to Trash.|\n|**Remove Label from Thread**|Strip a label from all emails in a thread.|\n---\n\n## ðŸ” Search Actions  \n\n| **Action Item**               | **Use Case**                                                                                                                                     |\n|:------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------|\n| **Find Email** | Locate a specific email using search keywords like subject, sender, or content.|\n\n---\n\n\n## ðŸ“š API Reference  \n- [Official Gmail API Documentation](https://developers.google.com/workspace/gmail/api/guides)\n\n---\n\n## ðŸ§ª Test Account Access  \nYou can test Gmail APIs using a Google account with enabled Gmail API in a [Google Cloud Project Console](https://console.cloud.google.com/).\n\n---\n\n## ðŸ§‘â€ðŸ’» New to Activepieces?\n\nActivepieces is the leading open source AI automation platform. We have many apps (we call them Pieces), that are available within the builder and as MCPs. These apps are built with our TypeScript framework and are easy to develop. Once merged into our repository, they become available as pieces in our automation builder and as MCPs usable by AI agents and MCP clients.\n\nStart building here: [Piece Development Docs](https://www.activepieces.com/docs/developers/building-pieces/overview)\n",
                  "html_url": "https://github.com/activepieces/activepieces/issues/8072"
                },
                "type": "github"
              },
              "hash": "activepieces/activepieces#8072",
              "body": "## ðŸ§© Product Overview  \n\nGmail is Googleâ€™s email platform for sending, receiving, labeling, archiving, and organizing messages.\nThis integration empowers AI agents and workflows to automate email-based processes, from detection to response, labeling, and thread management.\n\n\n---\n\n## âš ï¸ Important Note for Contributors  \n\nThis Gmail piece already exists in Activepieces. Your task is to extend the current piece by adding additional actions and triggers as outlined in the documentation and reference materials.\nPlease avoid duplicating existing functionality. Review the current implementation before making changes, and ensure that all new features follow existing coding patterns and standards.\n\n---\n\n## ðŸš¨ Triggers  \n\n| **Trigger** | **Use Case** |\n|:--------------------------|:---------------------------------------|\n| **New Starred Email** | Fires when an email is starred (within 2 days).|\n| **New Conversation** | Fires when a new conversation (thread) begins.|\n|**New Attachment**|Fires when an email with an attachment arrives (with optional filters).|\n|**New Label**|Triggers when a new label is created.|\n---\n\n## ðŸ› ï¸ Write Actions  \n\n| **Action Item**               | **Use Case** |\n|:--------------------------|:---------------------------------------|\n| **Reply to Email** | Reply within an existing thread, maintaining context. |\n| **Create Draft Reply** | Generate a reply draft within an existing thread.|\n| **Add Label to Email** | Attach a label to an individual email.|\n|**Remove Label from Email**|Remove a specific label from an email.Remove a specific label from an email.|\n|**Create Label**|Create a new user label in Gmail.|\n|**Archive Email**|Archive (move to â€œAll Mailâ€) rather than deleting.|\n|**Delete Email**|Permanently move an email to Trash.|\n|**Remove Label from Thread**|Strip a label from all emails in a thread.|\n---\n\n## ðŸ” Search Actions  \n\n| **Action Item**               | **Use Case**                                                                                                                                     |\n|:------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------|\n| **Find Email** | Locate a specific email using search keywords like subject, sender, or content.|\n\n---\n\n\n## ðŸ“š API Reference  \n- [Official Gmail API Documentation](https://developers.google.com/workspace/gmail/api/guides)\n\n---\n\n## ðŸ§ª Test Account Access  \nYou can test Gmail APIs using a Google account with enabled Gmail API in a [Google Cloud Project Console](https://console.cloud.google.com/).\n\n---\n\n## ðŸ§‘â€ðŸ’» New to Activepieces?\n\nActivepieces is the leading open source AI automation platform. We have many apps (we call them Pieces), that are available within the builder and as MCPs. These apps are built with our TypeScript framework and are easy to develop. Once merged into our repository, they become available as pieces in our automation builder and as MCPs usable by AI agents and MCP clients.\n\nStart building here: [Piece Development Docs](https://www.activepieces.com/docs/developers/building-pieces/overview)\n",
              "url": "https://github.com/activepieces/activepieces/issues/8072",
              "tech": [],
              "repo_name": "activepieces",
              "repo_owner": "activepieces",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "projectdiscovery#14623",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "projectdiscovery",
              "id": "generated-projectdiscovery",
              "name": "Projectdiscovery",
              "description": "",
              "members": [],
              "display_name": "Projectdiscovery",
              "created_at": "2025-12-30T19:50:39.108Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/projectdiscovery?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "projectdiscovery",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2025-12-30T19:50:39.108Z",
            "created_at": "2025-12-30T19:50:39.108Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-projectdiscovery#14623",
              "status": "open",
              "type": "issue",
              "number": 14623,
              "title": "CVE-2018-6961 - VMware NSX SD-WAN Edge - Command Injection ðŸ’°",
              "source": {
                "data": {
                  "id": "source-projectdiscovery#14623",
                  "user": {
                    "login": "princechaddha",
                    "id": 16654365,
                    "node_id": "MDQ6VXNlcjE2NjU0MzY1",
                    "avatar_url": "https://avatars.githubusercontent.com/u/16654365?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/princechaddha",
                    "html_url": "https://github.com/princechaddha",
                    "followers_url": "https://api.github.com/users/princechaddha/followers",
                    "following_url": "https://api.github.com/users/princechaddha/following{/other_user}",
                    "gists_url": "https://api.github.com/users/princechaddha/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/princechaddha/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/princechaddha/subscriptions",
                    "organizations_url": "https://api.github.com/users/princechaddha/orgs",
                    "repos_url": "https://api.github.com/users/princechaddha/repos",
                    "events_url": "https://api.github.com/users/princechaddha/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/princechaddha/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "CVE-2018-6961 - VMware NSX SD-WAN Edge - Command Injection ðŸ’°",
                  "body": "\n### Description: \n> VMware NSX SD-WAN Edge prior to 3.1.0 contains a command injection caused by vulnerable local web UI component, letting attackers execute arbitrary commands remotely, exploit requires the web UI to be enabled on untrusted networks.\n\n#### Severity: `High`\n\n#### POC: \n- https://www.exploit-db.com/exploits/44959/\n- https://vulncheck.com/xdb/eeb1766c5086\n- https://github.com/r3dxpl0it/CVE-2018-6961\n- https///github.com:r3dxpl0it/CVE-2018-6961.git\n- https://vulncheck.com/xdb/f3adc82ac1f7\n- https://github.com/bokanrb/CVE-2018-6961\n- https///github.com:bokanrb/CVE-2018-6961.git\n\n### KEV: True\n\n### Shodan Query: `NA`\n\n> Acceptance Criteria: The template must include a complete POC and should not rely solely on version-based detection. Contributors are required to provide debug data(`-debug`) along with the template to help the triage team with validation or can also share a vulnerable environment like docker file. \n\n> Rewards will only be given once the template is fully validated by the team. Templates that are incomplete or invalid will not be accepted. Avoid adding code templates for CVEs that can be achieved using HTTP, TCP, or JavaScript. Such templates are blocked by default and wonâ€™t produce results, so we prioritize creating templates with other protocols unless exceptions are made.\n\nYou can check the FAQ for the Nuclei Templates Community Rewards Program [here](https://github.com/projectdiscovery/nuclei-templates/blob/main/Community-Rewards-FAQ.md).\n",
                  "html_url": "https://github.com/projectdiscovery/nuclei-templates/issues/14623"
                },
                "type": "github"
              },
              "hash": "projectdiscovery/nuclei-templates#14623",
              "body": "\n### Description: \n> VMware NSX SD-WAN Edge prior to 3.1.0 contains a command injection caused by vulnerable local web UI component, letting attackers execute arbitrary commands remotely, exploit requires the web UI to be enabled on untrusted networks.\n\n#### Severity: `High`\n\n#### POC: \n- https://www.exploit-db.com/exploits/44959/\n- https://vulncheck.com/xdb/eeb1766c5086\n- https://github.com/r3dxpl0it/CVE-2018-6961\n- https///github.com:r3dxpl0it/CVE-2018-6961.git\n- https://vulncheck.com/xdb/f3adc82ac1f7\n- https://github.com/bokanrb/CVE-2018-6961\n- https///github.com:bokanrb/CVE-2018-6961.git\n\n### KEV: True\n\n### Shodan Query: `NA`\n\n> Acceptance Criteria: The template must include a complete POC and should not rely solely on version-based detection. Contributors are required to provide debug data(`-debug`) along with the template to help the triage team with validation or can also share a vulnerable environment like docker file. \n\n> Rewards will only be given once the template is fully validated by the team. Templates that are incomplete or invalid will not be accepted. Avoid adding code templates for CVEs that can be achieved using HTTP, TCP, or JavaScript. Such templates are blocked by default and wonâ€™t produce results, so we prioritize creating templates with other protocols unless exceptions are made.\n\nYou can check the FAQ for the Nuclei Templates Community Rewards Program [here](https://github.com/projectdiscovery/nuclei-templates/blob/main/Community-Rewards-FAQ.md).\n",
              "url": "https://github.com/projectdiscovery/nuclei-templates/issues/14623",
              "tech": [],
              "repo_name": "nuclei-templates",
              "repo_owner": "projectdiscovery",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "projectdiscovery#14598",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "projectdiscovery",
              "id": "generated-projectdiscovery",
              "name": "Projectdiscovery",
              "description": "",
              "members": [],
              "display_name": "Projectdiscovery",
              "created_at": "2025-12-30T19:50:39.257Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/projectdiscovery?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "projectdiscovery",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2025-12-30T19:50:39.257Z",
            "created_at": "2025-12-30T19:50:39.257Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-projectdiscovery#14598",
              "status": "open",
              "type": "issue",
              "number": 14598,
              "title": "CVE-2018-15133 - Laravel Framework - Remote Code Execution ðŸ’°",
              "source": {
                "data": {
                  "id": "source-projectdiscovery#14598",
                  "user": {
                    "login": "princechaddha",
                    "id": 16654365,
                    "node_id": "MDQ6VXNlcjE2NjU0MzY1",
                    "avatar_url": "https://avatars.githubusercontent.com/u/16654365?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/princechaddha",
                    "html_url": "https://github.com/princechaddha",
                    "followers_url": "https://api.github.com/users/princechaddha/followers",
                    "following_url": "https://api.github.com/users/princechaddha/following{/other_user}",
                    "gists_url": "https://api.github.com/users/princechaddha/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/princechaddha/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/princechaddha/subscriptions",
                    "organizations_url": "https://api.github.com/users/princechaddha/orgs",
                    "repos_url": "https://api.github.com/users/princechaddha/repos",
                    "events_url": "https://api.github.com/users/princechaddha/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/princechaddha/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "CVE-2018-15133 - Laravel Framework - Remote Code Execution ðŸ’°",
                  "body": "\n### Description: \n> Laravel Framework versions 5.5.40 and 5.6.x through 5.6.29 contain a remote code execution caused by unserialize call on untrusted X-XSRF-TOKEN value in Encrypter.php and phpggc gadgetchains, letting attackers with prior access execute arbitrary code, exploit requires attacker to know the application key.\n\n#### Severity: `High`\n\n#### POC: \n- http://packetstormsecurity.com/files/153641/PHP-Laravel-Framework-Token-Unserialize-Remote-Command-Execution.html\n- https://github.com/rapid7/metasploit-framework/blob/master/modules/exploits/unix/http/laravel_token_unserialize_exec.rb\n- https://github.com/Loaxert/CVE-2018-15133-PoC\n- https///github.com:Loaxert/CVE-2018-15133-PoC.git\n- https://vulncheck.com/xdb/7fa45a25cb32\n- https://github.com/yeahhbean/Laravel-CVE-2018-15133\n- https///github.com:yeahhbean/Laravel-CVE-2018-15133.git\n- https://vulncheck.com/xdb/45e7d1957c7f\n- https://github.com/0xSalle/cve-2018-15133\n- https///github.com:0xSalle/cve-2018-15133.git\n- https://vulncheck.com/xdb/b31ca993356f\n- https://github.com/Cr4zyD14m0nd137/Lab-for-cve-2018-15133\n- https///github.com:Cr4zyD14m0nd137/Lab-for-cve-2018-15133.git\n- https://vulncheck.com/xdb/3004cb8714e9\n- https://github.com/NatteeSetobol/CVE-2018-15133-Lavel-Expliot\n- https///github.com:NatteeSetobol/CVE-2018-15133-Lavel-Expliot.git\n- https://github.com/AzhariKun/CVE-2018-15133\n- https://vulncheck.com/xdb/be7a45b53d16\n- https://github.com/pwnedshell/Larascript\n- https///github.com:pwnedshell/Larascript.git\n- https://vulncheck.com/xdb/2c6de6585be5\n- https://github.com/aljavier/exploit_laravel_cve-2018-15133\n- https///github.com:aljavier/exploit_laravel_cve-2018-15133.git\n- https://vulncheck.com/xdb/0a29cfc05e95\n- https://github.com/AlienX2001/better-poc-for-CVE-2018-15133\n- https///github.com:AlienX2001/better-poc-for-CVE-2018-15133.git\n- https://github.com/bukitbarisan/laravel-rce-cve-2018-15133\n- https://vulncheck.com/xdb/b1064b8f348a\n- https://github.com/Prabesh01/Laravel-PHP-Unit-RCE-Auto-shell-uploader\n- https///github.com:Prabesh01/Laravel-PHP-Unit-RCE-Auto-shell-uploader.git\n- https://vulncheck.com/xdb/8027eabdd92d\n- https://github.com/Bilelxdz/Laravel-CVE-2018-15133\n- https///github.com:Bilelxdz/Laravel-CVE-2018-15133.git\n- https://vulncheck.com/xdb/bb622dfa8b57\n- https://github.com/kozmic/laravel-poc-CVE-2018-15133\n- https///github.com:kozmic/laravel-poc-CVE-2018-15133.git\n\n### KEV: True\n\n### Shodan Query: `cpe:\"cpe:2.3:a:laravel:laravel\"`\n\n> Acceptance Criteria: The template must include a complete POC and should not rely solely on version-based detection. Contributors are required to provide debug data(`-debug`) along with the template to help the triage team with validation or can also share a vulnerable environment like docker file. \n\n> Rewards will only be given once the template is fully validated by the team. Templates that are incomplete or invalid will not be accepted. Avoid adding code templates for CVEs that can be achieved using HTTP, TCP, or JavaScript. Such templates are blocked by default and wonâ€™t produce results, so we prioritize creating templates with other protocols unless exceptions are made.\n\nYou can check the FAQ for the Nuclei Templates Community Rewards Program [here](https://github.com/projectdiscovery/nuclei-templates/blob/main/Community-Rewards-FAQ.md).\n",
                  "html_url": "https://github.com/projectdiscovery/nuclei-templates/issues/14598"
                },
                "type": "github"
              },
              "hash": "projectdiscovery/nuclei-templates#14598",
              "body": "\n### Description: \n> Laravel Framework versions 5.5.40 and 5.6.x through 5.6.29 contain a remote code execution caused by unserialize call on untrusted X-XSRF-TOKEN value in Encrypter.php and phpggc gadgetchains, letting attackers with prior access execute arbitrary code, exploit requires attacker to know the application key.\n\n#### Severity: `High`\n\n#### POC: \n- http://packetstormsecurity.com/files/153641/PHP-Laravel-Framework-Token-Unserialize-Remote-Command-Execution.html\n- https://github.com/rapid7/metasploit-framework/blob/master/modules/exploits/unix/http/laravel_token_unserialize_exec.rb\n- https://github.com/Loaxert/CVE-2018-15133-PoC\n- https///github.com:Loaxert/CVE-2018-15133-PoC.git\n- https://vulncheck.com/xdb/7fa45a25cb32\n- https://github.com/yeahhbean/Laravel-CVE-2018-15133\n- https///github.com:yeahhbean/Laravel-CVE-2018-15133.git\n- https://vulncheck.com/xdb/45e7d1957c7f\n- https://github.com/0xSalle/cve-2018-15133\n- https///github.com:0xSalle/cve-2018-15133.git\n- https://vulncheck.com/xdb/b31ca993356f\n- https://github.com/Cr4zyD14m0nd137/Lab-for-cve-2018-15133\n- https///github.com:Cr4zyD14m0nd137/Lab-for-cve-2018-15133.git\n- https://vulncheck.com/xdb/3004cb8714e9\n- https://github.com/NatteeSetobol/CVE-2018-15133-Lavel-Expliot\n- https///github.com:NatteeSetobol/CVE-2018-15133-Lavel-Expliot.git\n- https://github.com/AzhariKun/CVE-2018-15133\n- https://vulncheck.com/xdb/be7a45b53d16\n- https://github.com/pwnedshell/Larascript\n- https///github.com:pwnedshell/Larascript.git\n- https://vulncheck.com/xdb/2c6de6585be5\n- https://github.com/aljavier/exploit_laravel_cve-2018-15133\n- https///github.com:aljavier/exploit_laravel_cve-2018-15133.git\n- https://vulncheck.com/xdb/0a29cfc05e95\n- https://github.com/AlienX2001/better-poc-for-CVE-2018-15133\n- https///github.com:AlienX2001/better-poc-for-CVE-2018-15133.git\n- https://github.com/bukitbarisan/laravel-rce-cve-2018-15133\n- https://vulncheck.com/xdb/b1064b8f348a\n- https://github.com/Prabesh01/Laravel-PHP-Unit-RCE-Auto-shell-uploader\n- https///github.com:Prabesh01/Laravel-PHP-Unit-RCE-Auto-shell-uploader.git\n- https://vulncheck.com/xdb/8027eabdd92d\n- https://github.com/Bilelxdz/Laravel-CVE-2018-15133\n- https///github.com:Bilelxdz/Laravel-CVE-2018-15133.git\n- https://vulncheck.com/xdb/bb622dfa8b57\n- https://github.com/kozmic/laravel-poc-CVE-2018-15133\n- https///github.com:kozmic/laravel-poc-CVE-2018-15133.git\n\n### KEV: True\n\n### Shodan Query: `cpe:\"cpe:2.3:a:laravel:laravel\"`\n\n> Acceptance Criteria: The template must include a complete POC and should not rely solely on version-based detection. Contributors are required to provide debug data(`-debug`) along with the template to help the triage team with validation or can also share a vulnerable environment like docker file. \n\n> Rewards will only be given once the template is fully validated by the team. Templates that are incomplete or invalid will not be accepted. Avoid adding code templates for CVEs that can be achieved using HTTP, TCP, or JavaScript. Such templates are blocked by default and wonâ€™t produce results, so we prioritize creating templates with other protocols unless exceptions are made.\n\nYou can check the FAQ for the Nuclei Templates Community Rewards Program [here](https://github.com/projectdiscovery/nuclei-templates/blob/main/Community-Rewards-FAQ.md).\n",
              "url": "https://github.com/projectdiscovery/nuclei-templates/issues/14598",
              "tech": [],
              "repo_name": "nuclei-templates",
              "repo_owner": "projectdiscovery",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "projectdiscovery#14587",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "projectdiscovery",
              "id": "generated-projectdiscovery",
              "name": "Projectdiscovery",
              "description": "",
              "members": [],
              "display_name": "Projectdiscovery",
              "created_at": "2025-12-30T19:50:39.385Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/projectdiscovery?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "projectdiscovery",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2025-12-30T19:50:39.385Z",
            "created_at": "2025-12-30T19:50:39.385Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-projectdiscovery#14587",
              "status": "open",
              "type": "issue",
              "number": 14587,
              "title": "CVE-2018-9206 - Blueimp jQuery-File-Upload - Unrestricted File Upload ðŸ’°",
              "source": {
                "data": {
                  "id": "source-projectdiscovery#14587",
                  "user": {
                    "login": "princechaddha",
                    "id": 16654365,
                    "node_id": "MDQ6VXNlcjE2NjU0MzY1",
                    "avatar_url": "https://avatars.githubusercontent.com/u/16654365?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/princechaddha",
                    "html_url": "https://github.com/princechaddha",
                    "followers_url": "https://api.github.com/users/princechaddha/followers",
                    "following_url": "https://api.github.com/users/princechaddha/following{/other_user}",
                    "gists_url": "https://api.github.com/users/princechaddha/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/princechaddha/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/princechaddha/subscriptions",
                    "organizations_url": "https://api.github.com/users/princechaddha/orgs",
                    "repos_url": "https://api.github.com/users/princechaddha/repos",
                    "events_url": "https://api.github.com/users/princechaddha/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/princechaddha/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "CVE-2018-9206 - Blueimp jQuery-File-Upload - Unrestricted File Upload ðŸ’°",
                  "body": "\n### Description: \n> Blueimp jQuery-File-Upload <= v9.22.0 contains an unauthenticated arbitrary file upload caused by insufficient validation in the upload component, letting remote attackers upload malicious files, exploit requires no authentication.\n\n#### Severity: `Critical`\n\n#### POC: \n- http://www.vapidlabs.com/advisory.php?v=204\n- https://wpvulndb.com/vulnerabilities/9136\n- https://www.exploit-db.com/exploits/45790/\n- https://www.exploit-db.com/exploits/46182/\n- https://github.com/rapid7/metasploit-framework/blob/master/modules/exploits/unix/webapp/jquery_file_upload.rb\n- https://github.com/liemkaka/CVE-2018-9206\n- https://vulncheck.com/xdb/157694709091\n- https://github.com/MikeyPPPPPPPP/CVE-2018-9206\n- https///github.com:MikeyPPPPPPPP/CVE-2018-9206.git\n- https://github.com/mi-hood/CVE-2018-9206\n- https://github.com/cved-sources/cve-2018-9206\n- https://vulncheck.com/xdb/686936ca9734\n- https://github.com/Stahlz/JQShell\n- https///github.com:Stahlz/JQShell.git\n- https://github.com/Den1al/CVE-2018-9206\n\n### KEV: True\n\n### Shodan Query: `NA`\n\n> Acceptance Criteria: The template must include a complete POC and should not rely solely on version-based detection. Contributors are required to provide debug data(`-debug`) along with the template to help the triage team with validation or can also share a vulnerable environment like docker file. \n\n> Rewards will only be given once the template is fully validated by the team. Templates that are incomplete or invalid will not be accepted. Avoid adding code templates for CVEs that can be achieved using HTTP, TCP, or JavaScript. Such templates are blocked by default and wonâ€™t produce results, so we prioritize creating templates with other protocols unless exceptions are made.\n\nYou can check the FAQ for the Nuclei Templates Community Rewards Program [here](https://github.com/projectdiscovery/nuclei-templates/blob/main/Community-Rewards-FAQ.md).\n",
                  "html_url": "https://github.com/projectdiscovery/nuclei-templates/issues/14587"
                },
                "type": "github"
              },
              "hash": "projectdiscovery/nuclei-templates#14587",
              "body": "\n### Description: \n> Blueimp jQuery-File-Upload <= v9.22.0 contains an unauthenticated arbitrary file upload caused by insufficient validation in the upload component, letting remote attackers upload malicious files, exploit requires no authentication.\n\n#### Severity: `Critical`\n\n#### POC: \n- http://www.vapidlabs.com/advisory.php?v=204\n- https://wpvulndb.com/vulnerabilities/9136\n- https://www.exploit-db.com/exploits/45790/\n- https://www.exploit-db.com/exploits/46182/\n- https://github.com/rapid7/metasploit-framework/blob/master/modules/exploits/unix/webapp/jquery_file_upload.rb\n- https://github.com/liemkaka/CVE-2018-9206\n- https://vulncheck.com/xdb/157694709091\n- https://github.com/MikeyPPPPPPPP/CVE-2018-9206\n- https///github.com:MikeyPPPPPPPP/CVE-2018-9206.git\n- https://github.com/mi-hood/CVE-2018-9206\n- https://github.com/cved-sources/cve-2018-9206\n- https://vulncheck.com/xdb/686936ca9734\n- https://github.com/Stahlz/JQShell\n- https///github.com:Stahlz/JQShell.git\n- https://github.com/Den1al/CVE-2018-9206\n\n### KEV: True\n\n### Shodan Query: `NA`\n\n> Acceptance Criteria: The template must include a complete POC and should not rely solely on version-based detection. Contributors are required to provide debug data(`-debug`) along with the template to help the triage team with validation or can also share a vulnerable environment like docker file. \n\n> Rewards will only be given once the template is fully validated by the team. Templates that are incomplete or invalid will not be accepted. Avoid adding code templates for CVEs that can be achieved using HTTP, TCP, or JavaScript. Such templates are blocked by default and wonâ€™t produce results, so we prioritize creating templates with other protocols unless exceptions are made.\n\nYou can check the FAQ for the Nuclei Templates Community Rewards Program [here](https://github.com/projectdiscovery/nuclei-templates/blob/main/Community-Rewards-FAQ.md).\n",
              "url": "https://github.com/projectdiscovery/nuclei-templates/issues/14587",
              "tech": [],
              "repo_name": "nuclei-templates",
              "repo_owner": "projectdiscovery",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "projectdiscovery#14576",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "projectdiscovery",
              "id": "generated-projectdiscovery",
              "name": "Projectdiscovery",
              "description": "",
              "members": [],
              "display_name": "Projectdiscovery",
              "created_at": "2025-12-30T19:50:39.503Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/projectdiscovery?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "projectdiscovery",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2025-12-30T19:50:39.503Z",
            "created_at": "2025-12-30T19:50:39.503Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-projectdiscovery#14576",
              "status": "open",
              "type": "issue",
              "number": 14576,
              "title": "CVE-2018-8581 - Microsoft Exchange Server - Elevation of Privilege ðŸ’°",
              "source": {
                "data": {
                  "id": "source-projectdiscovery#14576",
                  "user": {
                    "login": "princechaddha",
                    "id": 16654365,
                    "node_id": "MDQ6VXNlcjE2NjU0MzY1",
                    "avatar_url": "https://avatars.githubusercontent.com/u/16654365?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/princechaddha",
                    "html_url": "https://github.com/princechaddha",
                    "followers_url": "https://api.github.com/users/princechaddha/followers",
                    "following_url": "https://api.github.com/users/princechaddha/following{/other_user}",
                    "gists_url": "https://api.github.com/users/princechaddha/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/princechaddha/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/princechaddha/subscriptions",
                    "organizations_url": "https://api.github.com/users/princechaddha/orgs",
                    "repos_url": "https://api.github.com/users/princechaddha/repos",
                    "events_url": "https://api.github.com/users/princechaddha/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/princechaddha/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "CVE-2018-8581 - Microsoft Exchange Server - Elevation of Privilege ðŸ’°",
                  "body": "\n### Description: \n> Microsoft Exchange Server contains an elevation of privilege caused by a vulnerability in the system, letting attackers escalate their privileges, exploit requires specific conditions not specified.\n\n#### Severity: `High`\n\n#### POC: \n- https://vulncheck.com/xdb/276c34c7f74f\n- https///gitee.com:mirrors_WyAtu/CVE-2018-8581.git\n- https://vulncheck.com/xdb/7730cd30a582\n- https://github.com/Ridter/Exchange2domain\n- https///github.com:Ridter/Exchange2domain.git\n- https://vulncheck.com/xdb/d7f23b749ff9\n- https://github.com/qiantu88/CVE-2018-8581\n- https///github.com:qiantu88/CVE-2018-8581.git\n- https://vulncheck.com/xdb/dba145cf3cba\n- https://github.com/WyAtu/CVE-2018-8581\n- https///github.com:WyAtu/CVE-2018-8581.git\n- https://vulncheck.com/xdb/3d3434d62f82\n- https///github.com:thezdi/PoC.git\n\n### KEV: True\n\n### Shodan Query: `cpe:\"cpe:2.3:a:microsoft:exchange_server\"`\n\n> Acceptance Criteria: The template must include a complete POC and should not rely solely on version-based detection. Contributors are required to provide debug data(`-debug`) along with the template to help the triage team with validation or can also share a vulnerable environment like docker file. \n\n> Rewards will only be given once the template is fully validated by the team. Templates that are incomplete or invalid will not be accepted. Avoid adding code templates for CVEs that can be achieved using HTTP, TCP, or JavaScript. Such templates are blocked by default and wonâ€™t produce results, so we prioritize creating templates with other protocols unless exceptions are made.\n\nYou can check the FAQ for the Nuclei Templates Community Rewards Program [here](https://github.com/projectdiscovery/nuclei-templates/blob/main/Community-Rewards-FAQ.md).\n",
                  "html_url": "https://github.com/projectdiscovery/nuclei-templates/issues/14576"
                },
                "type": "github"
              },
              "hash": "projectdiscovery/nuclei-templates#14576",
              "body": "\n### Description: \n> Microsoft Exchange Server contains an elevation of privilege caused by a vulnerability in the system, letting attackers escalate their privileges, exploit requires specific conditions not specified.\n\n#### Severity: `High`\n\n#### POC: \n- https://vulncheck.com/xdb/276c34c7f74f\n- https///gitee.com:mirrors_WyAtu/CVE-2018-8581.git\n- https://vulncheck.com/xdb/7730cd30a582\n- https://github.com/Ridter/Exchange2domain\n- https///github.com:Ridter/Exchange2domain.git\n- https://vulncheck.com/xdb/d7f23b749ff9\n- https://github.com/qiantu88/CVE-2018-8581\n- https///github.com:qiantu88/CVE-2018-8581.git\n- https://vulncheck.com/xdb/dba145cf3cba\n- https://github.com/WyAtu/CVE-2018-8581\n- https///github.com:WyAtu/CVE-2018-8581.git\n- https://vulncheck.com/xdb/3d3434d62f82\n- https///github.com:thezdi/PoC.git\n\n### KEV: True\n\n### Shodan Query: `cpe:\"cpe:2.3:a:microsoft:exchange_server\"`\n\n> Acceptance Criteria: The template must include a complete POC and should not rely solely on version-based detection. Contributors are required to provide debug data(`-debug`) along with the template to help the triage team with validation or can also share a vulnerable environment like docker file. \n\n> Rewards will only be given once the template is fully validated by the team. Templates that are incomplete or invalid will not be accepted. Avoid adding code templates for CVEs that can be achieved using HTTP, TCP, or JavaScript. Such templates are blocked by default and wonâ€™t produce results, so we prioritize creating templates with other protocols unless exceptions are made.\n\nYou can check the FAQ for the Nuclei Templates Community Rewards Program [here](https://github.com/projectdiscovery/nuclei-templates/blob/main/Community-Rewards-FAQ.md).\n",
              "url": "https://github.com/projectdiscovery/nuclei-templates/issues/14576",
              "tech": [],
              "repo_name": "nuclei-templates",
              "repo_owner": "projectdiscovery",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "projectdiscovery#14559",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "projectdiscovery",
              "id": "generated-projectdiscovery",
              "name": "Projectdiscovery",
              "description": "",
              "members": [],
              "display_name": "Projectdiscovery",
              "created_at": "2025-12-30T19:50:39.676Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/projectdiscovery?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "projectdiscovery",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2025-12-30T19:50:39.676Z",
            "created_at": "2025-12-30T19:50:39.676Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-projectdiscovery#14559",
              "status": "open",
              "type": "issue",
              "number": 14559,
              "title": "CVE-2016-15041 - MainWP Dashboard - Stored XSS ðŸ’°",
              "source": {
                "data": {
                  "id": "source-projectdiscovery#14559",
                  "user": {
                    "login": "princechaddha",
                    "id": 16654365,
                    "node_id": "MDQ6VXNlcjE2NjU0MzY1",
                    "avatar_url": "https://avatars.githubusercontent.com/u/16654365?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/princechaddha",
                    "html_url": "https://github.com/princechaddha",
                    "followers_url": "https://api.github.com/users/princechaddha/followers",
                    "following_url": "https://api.github.com/users/princechaddha/following{/other_user}",
                    "gists_url": "https://api.github.com/users/princechaddha/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/princechaddha/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/princechaddha/subscriptions",
                    "organizations_url": "https://api.github.com/users/princechaddha/orgs",
                    "repos_url": "https://api.github.com/users/princechaddha/repos",
                    "events_url": "https://api.github.com/users/princechaddha/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/princechaddha/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "CVE-2016-15041 - MainWP Dashboard - Stored XSS ðŸ’°",
                  "body": "\n### Description: \n> MainWP Dashboard â€“ The Private WordPress Manager for Multiple Website Maintenance plugin for WordPress versions up to 3.1.2 contains a stored cross-site scripting caused by insufficient input sanitization and output escaping in 'mwp_setup_purchase_username' parameter, letting unauthenticated attackers inject and execute arbitrary scripts when users access affected pages.\n\n#### Severity: `High`\n\n#### POC: \n- https://klikki.fi/adv/mainwp.html\n\n### KEV: True\n\n### Shodan Query: `NA`\n\n> Acceptance Criteria: The template must include a complete POC and should not rely solely on version-based detection. Contributors are required to provide debug data(`-debug`) along with the template to help the triage team with validation or can also share a vulnerable environment like docker file. \n\n> Rewards will only be given once the template is fully validated by the team. Templates that are incomplete or invalid will not be accepted. Avoid adding code templates for CVEs that can be achieved using HTTP, TCP, or JavaScript. Such templates are blocked by default and wonâ€™t produce results, so we prioritize creating templates with other protocols unless exceptions are made.\n\nYou can check the FAQ for the Nuclei Templates Community Rewards Program [here](https://github.com/projectdiscovery/nuclei-templates/blob/main/Community-Rewards-FAQ.md).\n",
                  "html_url": "https://github.com/projectdiscovery/nuclei-templates/issues/14559"
                },
                "type": "github"
              },
              "hash": "projectdiscovery/nuclei-templates#14559",
              "body": "\n### Description: \n> MainWP Dashboard â€“ The Private WordPress Manager for Multiple Website Maintenance plugin for WordPress versions up to 3.1.2 contains a stored cross-site scripting caused by insufficient input sanitization and output escaping in 'mwp_setup_purchase_username' parameter, letting unauthenticated attackers inject and execute arbitrary scripts when users access affected pages.\n\n#### Severity: `High`\n\n#### POC: \n- https://klikki.fi/adv/mainwp.html\n\n### KEV: True\n\n### Shodan Query: `NA`\n\n> Acceptance Criteria: The template must include a complete POC and should not rely solely on version-based detection. Contributors are required to provide debug data(`-debug`) along with the template to help the triage team with validation or can also share a vulnerable environment like docker file. \n\n> Rewards will only be given once the template is fully validated by the team. Templates that are incomplete or invalid will not be accepted. Avoid adding code templates for CVEs that can be achieved using HTTP, TCP, or JavaScript. Such templates are blocked by default and wonâ€™t produce results, so we prioritize creating templates with other protocols unless exceptions are made.\n\nYou can check the FAQ for the Nuclei Templates Community Rewards Program [here](https://github.com/projectdiscovery/nuclei-templates/blob/main/Community-Rewards-FAQ.md).\n",
              "url": "https://github.com/projectdiscovery/nuclei-templates/issues/14559",
              "tech": [],
              "repo_name": "nuclei-templates",
              "repo_owner": "projectdiscovery",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "projectdiscovery#14535",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "projectdiscovery",
              "id": "generated-projectdiscovery",
              "name": "Projectdiscovery",
              "description": "",
              "members": [],
              "display_name": "Projectdiscovery",
              "created_at": "2025-12-30T19:50:39.833Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/projectdiscovery?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "projectdiscovery",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2025-12-30T19:50:39.833Z",
            "created_at": "2025-12-30T19:50:39.833Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-projectdiscovery#14535",
              "status": "open",
              "type": "issue",
              "number": 14535,
              "title": "CVE-2018-20753 - Kaseya VSA - Command Injection ðŸ’°",
              "source": {
                "data": {
                  "id": "source-projectdiscovery#14535",
                  "user": {
                    "login": "princechaddha",
                    "id": 16654365,
                    "node_id": "MDQ6VXNlcjE2NjU0MzY1",
                    "avatar_url": "https://avatars.githubusercontent.com/u/16654365?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/princechaddha",
                    "html_url": "https://github.com/princechaddha",
                    "followers_url": "https://api.github.com/users/princechaddha/followers",
                    "following_url": "https://api.github.com/users/princechaddha/following{/other_user}",
                    "gists_url": "https://api.github.com/users/princechaddha/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/princechaddha/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/princechaddha/subscriptions",
                    "organizations_url": "https://api.github.com/users/princechaddha/orgs",
                    "repos_url": "https://api.github.com/users/princechaddha/repos",
                    "events_url": "https://api.github.com/users/princechaddha/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/princechaddha/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "CVE-2018-20753 - Kaseya VSA - Command Injection ðŸ’°",
                  "body": "\n### Description: \n> Kaseya VSA RMM before R9.3 9.3.0.35, R9.4 before 9.4.0.36, and R9.5 before 9.5.0.5 contain a command injection caused by insufficient input validation in PowerShell execution, letting unprivileged remote attackers execute arbitrary PowerShell payloads on all managed devices, exploit requires network access to the system.\n\n#### Severity: `Critical`\n\n#### POC: \n- https://blog.huntresslabs.com/deep-dive-kaseya-vsa-mining-payload-c0ac839a0e88\n\n### KEV: True\n\n### Shodan Query: `http.favicon.hash:-1445519482`\n\n> Acceptance Criteria: The template must include a complete POC and should not rely solely on version-based detection. Contributors are required to provide debug data(`-debug`) along with the template to help the triage team with validation or can also share a vulnerable environment like docker file. \n\n> Rewards will only be given once the template is fully validated by the team. Templates that are incomplete or invalid will not be accepted. Avoid adding code templates for CVEs that can be achieved using HTTP, TCP, or JavaScript. Such templates are blocked by default and wonâ€™t produce results, so we prioritize creating templates with other protocols unless exceptions are made.\n\nYou can check the FAQ for the Nuclei Templates Community Rewards Program [here](https://github.com/projectdiscovery/nuclei-templates/blob/main/Community-Rewards-FAQ.md).\n",
                  "html_url": "https://github.com/projectdiscovery/nuclei-templates/issues/14535"
                },
                "type": "github"
              },
              "hash": "projectdiscovery/nuclei-templates#14535",
              "body": "\n### Description: \n> Kaseya VSA RMM before R9.3 9.3.0.35, R9.4 before 9.4.0.36, and R9.5 before 9.5.0.5 contain a command injection caused by insufficient input validation in PowerShell execution, letting unprivileged remote attackers execute arbitrary PowerShell payloads on all managed devices, exploit requires network access to the system.\n\n#### Severity: `Critical`\n\n#### POC: \n- https://blog.huntresslabs.com/deep-dive-kaseya-vsa-mining-payload-c0ac839a0e88\n\n### KEV: True\n\n### Shodan Query: `http.favicon.hash:-1445519482`\n\n> Acceptance Criteria: The template must include a complete POC and should not rely solely on version-based detection. Contributors are required to provide debug data(`-debug`) along with the template to help the triage team with validation or can also share a vulnerable environment like docker file. \n\n> Rewards will only be given once the template is fully validated by the team. Templates that are incomplete or invalid will not be accepted. Avoid adding code templates for CVEs that can be achieved using HTTP, TCP, or JavaScript. Such templates are blocked by default and wonâ€™t produce results, so we prioritize creating templates with other protocols unless exceptions are made.\n\nYou can check the FAQ for the Nuclei Templates Community Rewards Program [here](https://github.com/projectdiscovery/nuclei-templates/blob/main/Community-Rewards-FAQ.md).\n",
              "url": "https://github.com/projectdiscovery/nuclei-templates/issues/14535",
              "tech": [],
              "repo_name": "nuclei-templates",
              "repo_owner": "projectdiscovery",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "projectdiscovery#14488",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "projectdiscovery",
              "id": "generated-projectdiscovery",
              "name": "Projectdiscovery",
              "description": "",
              "members": [],
              "display_name": "Projectdiscovery",
              "created_at": "2025-12-30T19:50:39.990Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/projectdiscovery?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "projectdiscovery",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2025-12-30T19:50:39.990Z",
            "created_at": "2025-12-30T19:50:39.990Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-projectdiscovery#14488",
              "status": "open",
              "type": "issue",
              "number": 14488,
              "title": "CVE-2024-3408 - man-group/dtale - Authentication Bypass & Remote Code Execution ðŸ’°",
              "source": {
                "data": {
                  "id": "source-projectdiscovery#14488",
                  "user": {
                    "login": "princechaddha",
                    "id": 16654365,
                    "node_id": "MDQ6VXNlcjE2NjU0MzY1",
                    "avatar_url": "https://avatars.githubusercontent.com/u/16654365?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/princechaddha",
                    "html_url": "https://github.com/princechaddha",
                    "followers_url": "https://api.github.com/users/princechaddha/followers",
                    "following_url": "https://api.github.com/users/princechaddha/following{/other_user}",
                    "gists_url": "https://api.github.com/users/princechaddha/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/princechaddha/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/princechaddha/subscriptions",
                    "organizations_url": "https://api.github.com/users/princechaddha/orgs",
                    "repos_url": "https://api.github.com/users/princechaddha/repos",
                    "events_url": "https://api.github.com/users/princechaddha/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/princechaddha/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "CVE-2024-3408 - man-group/dtale - Authentication Bypass & Remote Code Execution ðŸ’°",
                  "body": "\n### Description: \n> man-group/dtale 3.10.0 contains an authentication bypass and remote code execution caused by improper input validation and a hardcoded SECRET_KEY in Flask configuration, letting attackers forge session cookies and execute arbitrary code, exploit requires attacker to access the application.\n\n#### Severity: `Critical`\n\n#### POC: \n- https://huntr.com/bounties/57a06666-ff85-4577-af19-f3dfb7b02f91\n- https://github.com/rapid7/metasploit-framework/blob/master/modules/exploits/linux/http/dtale_rce_cve_2025_0655.rb\n\n### KEV: True\n\n### Shodan Query: `NA`\n\n> Acceptance Criteria: The template must include a complete POC and should not rely solely on version-based detection. Contributors are required to provide debug data(`-debug`) along with the template to help the triage team with validation or can also share a vulnerable environment like docker file. \n\n> Rewards will only be given once the template is fully validated by the team. Templates that are incomplete or invalid will not be accepted. Avoid adding code templates for CVEs that can be achieved using HTTP, TCP, or JavaScript. Such templates are blocked by default and wonâ€™t produce results, so we prioritize creating templates with other protocols unless exceptions are made.\n\nYou can check the FAQ for the Nuclei Templates Community Rewards Program [here](https://github.com/projectdiscovery/nuclei-templates/blob/main/Community-Rewards-FAQ.md).\n",
                  "html_url": "https://github.com/projectdiscovery/nuclei-templates/issues/14488"
                },
                "type": "github"
              },
              "hash": "projectdiscovery/nuclei-templates#14488",
              "body": "\n### Description: \n> man-group/dtale 3.10.0 contains an authentication bypass and remote code execution caused by improper input validation and a hardcoded SECRET_KEY in Flask configuration, letting attackers forge session cookies and execute arbitrary code, exploit requires attacker to access the application.\n\n#### Severity: `Critical`\n\n#### POC: \n- https://huntr.com/bounties/57a06666-ff85-4577-af19-f3dfb7b02f91\n- https://github.com/rapid7/metasploit-framework/blob/master/modules/exploits/linux/http/dtale_rce_cve_2025_0655.rb\n\n### KEV: True\n\n### Shodan Query: `NA`\n\n> Acceptance Criteria: The template must include a complete POC and should not rely solely on version-based detection. Contributors are required to provide debug data(`-debug`) along with the template to help the triage team with validation or can also share a vulnerable environment like docker file. \n\n> Rewards will only be given once the template is fully validated by the team. Templates that are incomplete or invalid will not be accepted. Avoid adding code templates for CVEs that can be achieved using HTTP, TCP, or JavaScript. Such templates are blocked by default and wonâ€™t produce results, so we prioritize creating templates with other protocols unless exceptions are made.\n\nYou can check the FAQ for the Nuclei Templates Community Rewards Program [here](https://github.com/projectdiscovery/nuclei-templates/blob/main/Community-Rewards-FAQ.md).\n",
              "url": "https://github.com/projectdiscovery/nuclei-templates/issues/14488",
              "tech": [],
              "repo_name": "nuclei-templates",
              "repo_owner": "projectdiscovery",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "projectdiscovery#14488",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "projectdiscovery",
              "id": "generated-projectdiscovery",
              "name": "Projectdiscovery",
              "description": "",
              "members": [],
              "display_name": "Projectdiscovery",
              "created_at": "2025-12-30T19:50:40.008Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/projectdiscovery?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "projectdiscovery",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2025-12-30T19:50:40.008Z",
            "created_at": "2025-12-30T19:50:40.008Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-projectdiscovery#14488",
              "status": "open",
              "type": "issue",
              "number": 14488,
              "title": "CVE-2024-3408 - man-group/dtale - Authentication Bypass & Remote Code Execution ðŸ’°",
              "source": {
                "data": {
                  "id": "source-projectdiscovery#14488",
                  "user": {
                    "login": "princechaddha",
                    "id": 16654365,
                    "node_id": "MDQ6VXNlcjE2NjU0MzY1",
                    "avatar_url": "https://avatars.githubusercontent.com/u/16654365?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/princechaddha",
                    "html_url": "https://github.com/princechaddha",
                    "followers_url": "https://api.github.com/users/princechaddha/followers",
                    "following_url": "https://api.github.com/users/princechaddha/following{/other_user}",
                    "gists_url": "https://api.github.com/users/princechaddha/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/princechaddha/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/princechaddha/subscriptions",
                    "organizations_url": "https://api.github.com/users/princechaddha/orgs",
                    "repos_url": "https://api.github.com/users/princechaddha/repos",
                    "events_url": "https://api.github.com/users/princechaddha/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/princechaddha/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "CVE-2024-3408 - man-group/dtale - Authentication Bypass & Remote Code Execution ðŸ’°",
                  "body": "\n### Description: \n> man-group/dtale 3.10.0 contains an authentication bypass and remote code execution caused by improper input validation and a hardcoded SECRET_KEY in Flask configuration, letting attackers forge session cookies and execute arbitrary code, exploit requires attacker to access the application.\n\n#### Severity: `Critical`\n\n#### POC: \n- https://huntr.com/bounties/57a06666-ff85-4577-af19-f3dfb7b02f91\n- https://github.com/rapid7/metasploit-framework/blob/master/modules/exploits/linux/http/dtale_rce_cve_2025_0655.rb\n\n### KEV: True\n\n### Shodan Query: `NA`\n\n> Acceptance Criteria: The template must include a complete POC and should not rely solely on version-based detection. Contributors are required to provide debug data(`-debug`) along with the template to help the triage team with validation or can also share a vulnerable environment like docker file. \n\n> Rewards will only be given once the template is fully validated by the team. Templates that are incomplete or invalid will not be accepted. Avoid adding code templates for CVEs that can be achieved using HTTP, TCP, or JavaScript. Such templates are blocked by default and wonâ€™t produce results, so we prioritize creating templates with other protocols unless exceptions are made.\n\nYou can check the FAQ for the Nuclei Templates Community Rewards Program [here](https://github.com/projectdiscovery/nuclei-templates/blob/main/Community-Rewards-FAQ.md).\n",
                  "html_url": "https://github.com/projectdiscovery/nuclei-templates/issues/14488"
                },
                "type": "github"
              },
              "hash": "projectdiscovery/nuclei-templates#14488",
              "body": "\n### Description: \n> man-group/dtale 3.10.0 contains an authentication bypass and remote code execution caused by improper input validation and a hardcoded SECRET_KEY in Flask configuration, letting attackers forge session cookies and execute arbitrary code, exploit requires attacker to access the application.\n\n#### Severity: `Critical`\n\n#### POC: \n- https://huntr.com/bounties/57a06666-ff85-4577-af19-f3dfb7b02f91\n- https://github.com/rapid7/metasploit-framework/blob/master/modules/exploits/linux/http/dtale_rce_cve_2025_0655.rb\n\n### KEV: True\n\n### Shodan Query: `NA`\n\n> Acceptance Criteria: The template must include a complete POC and should not rely solely on version-based detection. Contributors are required to provide debug data(`-debug`) along with the template to help the triage team with validation or can also share a vulnerable environment like docker file. \n\n> Rewards will only be given once the template is fully validated by the team. Templates that are incomplete or invalid will not be accepted. Avoid adding code templates for CVEs that can be achieved using HTTP, TCP, or JavaScript. Such templates are blocked by default and wonâ€™t produce results, so we prioritize creating templates with other protocols unless exceptions are made.\n\nYou can check the FAQ for the Nuclei Templates Community Rewards Program [here](https://github.com/projectdiscovery/nuclei-templates/blob/main/Community-Rewards-FAQ.md).\n",
              "url": "https://github.com/projectdiscovery/nuclei-templates/issues/14488",
              "tech": [],
              "repo_name": "nuclei-templates",
              "repo_owner": "projectdiscovery",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "projectdiscovery#14478",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "projectdiscovery",
              "id": "generated-projectdiscovery",
              "name": "Projectdiscovery",
              "description": "",
              "members": [],
              "display_name": "Projectdiscovery",
              "created_at": "2025-12-30T19:50:40.169Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/projectdiscovery?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "projectdiscovery",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2025-12-30T19:50:40.169Z",
            "created_at": "2025-12-30T19:50:40.169Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-projectdiscovery#14478",
              "status": "open",
              "type": "issue",
              "number": 14478,
              "title": "CVE-2012-10018 - Mapplic & Mapplic Lite - Server Side Request Forgery & Stored XSS ðŸ’°",
              "source": {
                "data": {
                  "id": "source-projectdiscovery#14478",
                  "user": {
                    "login": "princechaddha",
                    "id": 16654365,
                    "node_id": "MDQ6VXNlcjE2NjU0MzY1",
                    "avatar_url": "https://avatars.githubusercontent.com/u/16654365?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/princechaddha",
                    "html_url": "https://github.com/princechaddha",
                    "followers_url": "https://api.github.com/users/princechaddha/followers",
                    "following_url": "https://api.github.com/users/princechaddha/following{/other_user}",
                    "gists_url": "https://api.github.com/users/princechaddha/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/princechaddha/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/princechaddha/subscriptions",
                    "organizations_url": "https://api.github.com/users/princechaddha/orgs",
                    "repos_url": "https://api.github.com/users/princechaddha/repos",
                    "events_url": "https://api.github.com/users/princechaddha/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/princechaddha/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "CVE-2012-10018 - Mapplic & Mapplic Lite - Server Side Request Forgery & Stored XSS ðŸ’°",
                  "body": "\n### Description: \n> Mapplic and Mapplic Lite WordPress plugins versions up to 6.1 and 1.0 contain a server-side request forgery caused by insufficient validation, letting attackers forge requests from the server and perform an XSS attack if requesting an SVG file.\n\n#### Severity: `High`\n\n#### POC: \n- https://packetstormsecurity.com/files/161919/\n- https://packetstormsecurity.com/files/161920/\n\n### KEV: True\n\n### Shodan Query: `NA`\n\n> Acceptance Criteria: The template must include a complete POC and should not rely solely on version-based detection. Contributors are required to provide debug data(`-debug`) along with the template to help the triage team with validation or can also share a vulnerable environment like docker file. \n\n> Rewards will only be given once the template is fully validated by the team. Templates that are incomplete or invalid will not be accepted. Avoid adding code templates for CVEs that can be achieved using HTTP, TCP, or JavaScript. Such templates are blocked by default and wonâ€™t produce results, so we prioritize creating templates with other protocols unless exceptions are made.\n\nYou can check the FAQ for the Nuclei Templates Community Rewards Program [here](https://github.com/projectdiscovery/nuclei-templates/blob/main/Community-Rewards-FAQ.md).\n",
                  "html_url": "https://github.com/projectdiscovery/nuclei-templates/issues/14478"
                },
                "type": "github"
              },
              "hash": "projectdiscovery/nuclei-templates#14478",
              "body": "\n### Description: \n> Mapplic and Mapplic Lite WordPress plugins versions up to 6.1 and 1.0 contain a server-side request forgery caused by insufficient validation, letting attackers forge requests from the server and perform an XSS attack if requesting an SVG file.\n\n#### Severity: `High`\n\n#### POC: \n- https://packetstormsecurity.com/files/161919/\n- https://packetstormsecurity.com/files/161920/\n\n### KEV: True\n\n### Shodan Query: `NA`\n\n> Acceptance Criteria: The template must include a complete POC and should not rely solely on version-based detection. Contributors are required to provide debug data(`-debug`) along with the template to help the triage team with validation or can also share a vulnerable environment like docker file. \n\n> Rewards will only be given once the template is fully validated by the team. Templates that are incomplete or invalid will not be accepted. Avoid adding code templates for CVEs that can be achieved using HTTP, TCP, or JavaScript. Such templates are blocked by default and wonâ€™t produce results, so we prioritize creating templates with other protocols unless exceptions are made.\n\nYou can check the FAQ for the Nuclei Templates Community Rewards Program [here](https://github.com/projectdiscovery/nuclei-templates/blob/main/Community-Rewards-FAQ.md).\n",
              "url": "https://github.com/projectdiscovery/nuclei-templates/issues/14478",
              "tech": [],
              "repo_name": "nuclei-templates",
              "repo_owner": "projectdiscovery",
              "forge": "github"
            },
            "timeouts_disabled": false
          },
          {
            "id": "projectdiscovery#14451",
            "status": "open",
            "type": "standard",
            "kind": "dev",
            "org": {
              "handle": "projectdiscovery",
              "id": "generated-projectdiscovery",
              "name": "Projectdiscovery",
              "description": "",
              "members": [],
              "display_name": "Projectdiscovery",
              "created_at": "2025-12-30T19:50:40.295Z",
              "website_url": "",
              "avatar_url": "https://avatars.githubusercontent.com/u/projectdiscovery?v=4",
              "discord_url": "",
              "slack_url": "",
              "stargazers_count": 0,
              "twitter_url": "",
              "youtube_url": "",
              "tech": [],
              "github_handle": "projectdiscovery",
              "accepts_sponsorships": false,
              "days_until_timeout": null,
              "enabled_expert_recs": false,
              "enabled_private_bounties": false
            },
            "updated_at": "2025-12-30T19:50:40.295Z",
            "created_at": "2025-12-30T19:50:40.295Z",
            "visibility": "public",
            "autopay_disabled": false,
            "tech": [],
            "bids": [],
            "is_external": false,
            "manual_assignments": false,
            "point_reward": null,
            "reward": {
              "currency": "USD",
              "amount": 10000
            },
            "reward_formatted": "$100",
            "reward_tiers": [],
            "reward_type": "cash",
            "task": {
              "id": "task-projectdiscovery#14451",
              "status": "open",
              "type": "issue",
              "number": 14451,
              "title": "CVE-2017-18365 - GitHub Enterprise - Insecure Deserialization ðŸ’°",
              "source": {
                "data": {
                  "id": "source-projectdiscovery#14451",
                  "user": {
                    "login": "princechaddha",
                    "id": 16654365,
                    "node_id": "MDQ6VXNlcjE2NjU0MzY1",
                    "avatar_url": "https://avatars.githubusercontent.com/u/16654365?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/princechaddha",
                    "html_url": "https://github.com/princechaddha",
                    "followers_url": "https://api.github.com/users/princechaddha/followers",
                    "following_url": "https://api.github.com/users/princechaddha/following{/other_user}",
                    "gists_url": "https://api.github.com/users/princechaddha/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/princechaddha/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/princechaddha/subscriptions",
                    "organizations_url": "https://api.github.com/users/princechaddha/orgs",
                    "repos_url": "https://api.github.com/users/princechaddha/repos",
                    "events_url": "https://api.github.com/users/princechaddha/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/princechaddha/received_events",
                    "type": "User",
                    "user_view_type": "public",
                    "site_admin": false
                  },
                  "title": "CVE-2017-18365 - GitHub Enterprise - Insecure Deserialization ðŸ’°",
                  "body": "\n### Description: \n> GitHub Enterprise 2.8.x before 2.8.7 contains a deserialization caused by a static enterprise session secret in the Management Console, letting unauthenticated attackers execute arbitrary code, exploit requires crafting a signed cookie with the secret.\n\n#### Severity: `Critical`\n\n#### POC: \n- https://www.exablue.de/blog/2017-03-15-github-enterprise-remote-code-execution.html\n- https://github.com/rapid7/metasploit-framework/blob/master/modules/exploits/linux/http/github_enterprise_secret.rb\n\n### KEV: True\n\n### Shodan Query: `http.title:\"github debug\"`\n\n> Acceptance Criteria: The template must include a complete POC and should not rely solely on version-based detection. Contributors are required to provide debug data(`-debug`) along with the template to help the triage team with validation or can also share a vulnerable environment like docker file. \n\n> Rewards will only be given once the template is fully validated by the team. Templates that are incomplete or invalid will not be accepted. Avoid adding code templates for CVEs that can be achieved using HTTP, TCP, or JavaScript. Such templates are blocked by default and wonâ€™t produce results, so we prioritize creating templates with other protocols unless exceptions are made.\n\nYou can check the FAQ for the Nuclei Templates Community Rewards Program [here](https://github.com/projectdiscovery/nuclei-templates/blob/main/Community-Rewards-FAQ.md).\n",
                  "html_url": "https://github.com/projectdiscovery/nuclei-templates/issues/14451"
                },
                "type": "github"
              },
              "hash": "projectdiscovery/nuclei-templates#14451",
              "body": "\n### Description: \n> GitHub Enterprise 2.8.x before 2.8.7 contains a deserialization caused by a static enterprise session secret in the Management Console, letting unauthenticated attackers execute arbitrary code, exploit requires crafting a signed cookie with the secret.\n\n#### Severity: `Critical`\n\n#### POC: \n- https://www.exablue.de/blog/2017-03-15-github-enterprise-remote-code-execution.html\n- https://github.com/rapid7/metasploit-framework/blob/master/modules/exploits/linux/http/github_enterprise_secret.rb\n\n### KEV: True\n\n### Shodan Query: `http.title:\"github debug\"`\n\n> Acceptance Criteria: The template must include a complete POC and should not rely solely on version-based detection. Contributors are required to provide debug data(`-debug`) along with the template to help the triage team with validation or can also share a vulnerable environment like docker file. \n\n> Rewards will only be given once the template is fully validated by the team. Templates that are incomplete or invalid will not be accepted. Avoid adding code templates for CVEs that can be achieved using HTTP, TCP, or JavaScript. Such templates are blocked by default and wonâ€™t produce results, so we prioritize creating templates with other protocols unless exceptions are made.\n\nYou can check the FAQ for the Nuclei Templates Community Rewards Program [here](https://github.com/projectdiscovery/nuclei-templates/blob/main/Community-Rewards-FAQ.md).\n",
              "url": "https://github.com/projectdiscovery/nuclei-templates/issues/14451",
              "tech": [],
              "repo_name": "nuclei-templates",
              "repo_owner": "projectdiscovery",
              "forge": "github"
            },
            "timeouts_disabled": false
          }
        ],
        "next_cursor": null
      }
    }
  }
}